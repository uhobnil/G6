"use strict";(self.webpackChunk_antv_g6_site=self.webpackChunk_antv_g6_site||[]).push([[9600],{95110:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},46447:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},22859:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},26546:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},9406:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},27398:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},18763:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},26945:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},76467:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},31577:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},2887:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},68339:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},3770:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},2003:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},20586:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},62995:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},38145:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},81331:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},64515:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},72151:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},55221:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},47785:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},27333:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},73074:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},28598:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},21864:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},28894:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},56349:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},38759:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},35785:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},54271:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},30214:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},67547:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},14002:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},847:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},5448:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},7413:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},32447:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},51442:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},77896:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34645:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},88865:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},97961:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},91127:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},36740:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},43093:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},33711:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},44118:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},45787:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},91136:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},61538:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},97810:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},87433:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},19505:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},91557:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},325:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},47437:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},2982:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},23339:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},52861:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},55049:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},117:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},89956:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},80961:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},97138:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},4762:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},37849:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},45538:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},15500:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},81486:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},79269:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},37840:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},55339:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},3168:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},57609:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},33347:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},29417:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},85369:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},49001:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},23625:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},87096:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},65085:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},2908:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},77118:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},32894:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},26553:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},97346:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},29748:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},13718:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},85e3:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},84336:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},86928:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},65329:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},759:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},11590:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},29547:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34075:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},14157:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},85165:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},97487:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},46452:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},36118:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},63977:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},13634:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34314:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},88221:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},18666:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},59384:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},43125:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},47172:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},84008:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},11812:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},42515:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},5109:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},83113:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},71726:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},58778:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34151:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},43236:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},51557:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},18798:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},63814:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},59280:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34795:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},29698:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},7654:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},35633:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},65593:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},87321:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},39997:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},27142:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},70068:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},57199:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},40749:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},88645:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},56144:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},45476:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},36423:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},72800:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},54960:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},46091:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},25062:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},41546:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},38885:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},3690:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},17582:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},99569:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},41328:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},58546:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},66043:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},17673:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},28023:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},34716:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},26761:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},28381:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},1303:function(a,e,d){d.r(e),d.d(e,{demos:function(){return n}});d(58757);var n={}},61745:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图算法提供了一种最有效的分析关联数据的方法，它们描述了如何处理图以发现一些定性或者定量的结论。图算法基于图论，利用节点之间的关系来推断复杂系统的结构和变化。我们可以使用这些算法来发现隐藏的信息，验证业务假设，并对行为进行预测。",paraId:0},{value:"如果你对数据结构及算法感兴趣，可以通过 ",paraId:1},{value:"javascript-algorithms",paraId:1},{value:" 来进一步学习。",paraId:1},{value:"G6 从 V3.5 版本开始加入了图算法，在以后版本更新中，我们会不断丰富内置的算法。",paraId:2},{value:"「v4.2.2」新特性",paraId:3,tocIndex:0},{value:"GADDI 图模式匹配",paraId:4,tocIndex:0},{value:"算法是一种支持结构和语义的图模式匹配算法，给定一个模式，可通过在算法在原数据上查找结果和语义相同、相似的结构。",paraId:5,tocIndex:0},{value:"DEMO",paraId:6,tocIndex:0},{value:"。",paraId:5,tocIndex:0},{value:"参数",paraId:7,tocIndex:0},{value:"名称",paraId:8,tocIndex:0},{value:"类型",paraId:8,tocIndex:0},{value:"是否必选",paraId:8,tocIndex:0},{value:"描述",paraId:8,tocIndex:0},{value:"graphData",paraId:8,tocIndex:0},{value:"GraphData",paraId:8,tocIndex:0},{value:"true",paraId:8,tocIndex:0},{value:"原图数据",paraId:8,tocIndex:0},{value:"pattern",paraId:8,tocIndex:0},{value:"GraphData",paraId:8,tocIndex:0},{value:"true",paraId:8,tocIndex:0},{value:"需要查找的模式图数据",paraId:8,tocIndex:0},{value:"k",paraId:8,tocIndex:0},{value:"number",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"匹配算法的参数，设置为 ",paraId:8,tocIndex:0},{value:"undefined",paraId:8,tocIndex:0},{value:" 则自动设置",paraId:8,tocIndex:0},{value:"length",paraId:8,tocIndex:0},{value:"number",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"匹配算法的参数，设置为 ",paraId:8,tocIndex:0},{value:"undefined",paraId:8,tocIndex:0},{value:" 则自动设置",paraId:8,tocIndex:0},{value:"nodeLabelProp",paraId:8,tocIndex:0},{value:"number",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"节点聚类信息的属性名，默认为 ",paraId:8,tocIndex:0},{value:"'cluster'",paraId:8,tocIndex:0},{value:"edgeLabelProp",paraId:8,tocIndex:0},{value:"number",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"边聚类信息的属性名，默认为 ",paraId:8,tocIndex:0},{value:"'cluster'",paraId:8,tocIndex:0},{value:"用法",paraId:9,tocIndex:0},{value:"import G6, { Algorithm } from '@antv/g6'\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500\n})\n\nconst graphData = {\n  nodes: [\n    { id: 'A', cluster: 'nc1' },\n    { id: 'B', cluster: 'nc1' },\n    { id: 'C', cluster: 'nc2' },\n    { id: 'D', cluster: 'nc1' },\n    { id: 'E', cluster: 'nc3' },\n  ],\n  edges: [\n    { source: 'A', target: 'B', cluster: 'ec1' },\n    { source: 'B', target: 'C', cluster: 'ec2' },\n    { source: 'A', target: 'D', cluster: 'ec1' },\n    { source: 'A', target: 'E', cluster: 'ec2' },\n  ]\n}\n\ngraph.data(data)\ngraph.render()\n\nconst { GADDI } = Algorithm;\nconst patternData = {\n  nodes: [\n    { id: 'pn1', cluster: 'nc1' },\n    { id: 'pn2', cluster: 'nc1' },\n    { id: 'pn3', cluster: 'nc3' },\n  ],\n  edges: [\n    { source: 'pn1', target: 'pn2', cluster: 'ec1' },\n    { source: 'pn1', target: 'pn3', cluster: 'ec2' },\n  ]\n}\nconst resultMatches = GADDI(graphData, patternData, true, undefined, undefined, 'cluster', 'cluster');\n\nconsole.log(resultMatches);\n  // output:\n  // [{\n  //   nodes: [\n  //     { id: 'A', cluster: 'nc1' },\n  //     { id: 'B', cluster: 'nc1' },\n  //     { id: 'E', cluster: 'nc3' },],\n  //   edges: [\n  //     { source: 'A', target: 'B', cluster: 'ec1' },\n  //     { source: 'A', target: 'E', cluster: 'ec2' }\n  //   ]\n  // }]\n",paraId:10,tocIndex:0},{value:"深度优先搜索",paraId:11,tocIndex:1},{value:"（Depth First Search，简称 DFS）算法是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。",paraId:11,tocIndex:1},{value:"图片来源",paraId:12,tocIndex:1},{value:"参数",paraId:13,tocIndex:1},{value:"名称",paraId:14,tocIndex:1},{value:"类型",paraId:14,tocIndex:1},{value:"是否必选",paraId:14,tocIndex:1},{value:"描述",paraId:14,tocIndex:1},{value:"graphData",paraId:14,tocIndex:1},{value:"GraphData",paraId:14,tocIndex:1},{value:"true",paraId:14,tocIndex:1},{value:"图数据，满足 G6 ",paraId:14,tocIndex:1},{value:"数据格式",paraId:15,tocIndex:1},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:14,tocIndex:1},{value:"startNodeId",paraId:14,tocIndex:1},{value:"string",paraId:14,tocIndex:1},{value:"true",paraId:14,tocIndex:1},{value:"开始访问的节点的 ID",paraId:14,tocIndex:1},{value:"callbacks",paraId:14,tocIndex:1},{value:"IAlgorithmCallbacks",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"遍历的回调函数",paraId:14,tocIndex:1},{value:"用法",paraId:16,tocIndex:1},{value:"import G6, { Algorithm } from '@antv/g6'\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500\n})\n\nconst data = {\n  nodes: [\n    {\n      id: 'A'\n    },\n    {\n      id: 'B'\n    },\n    {\n      id: 'C'\n    },\n    {\n      id: 'D'\n    },\n    {\n      id: 'E'\n    },\n    {\n      id: 'F'\n    },\n    {\n      id: 'G'\n    },\n  ],\n  edges: [\n    {\n      source: 'A',\n      target: 'B'\n    },\n    {\n      source: 'B',\n      target: 'C'\n    },\n    {\n      source: 'C',\n      target: 'G'\n    },\n    {\n      source: 'A',\n      target: 'D'\n    },\n    {\n      source: 'A',\n      target: 'E'\n    },\n    {\n      source: 'E',\n      target: 'F'\n    },\n    {\n      source: 'F',\n      target: 'D'\n    },\n    {\n      source: 'D',\n      target: 'G'\n    },\n  ]\n}\n\ngraph.data(data)\ngraph.render()\n\nconst { depthFirstSearch } = Algorithm\ndepthFirstSearch(data, 'A', {\n  enter: ({ current, previous }) => {\n    // 开始遍历点的回调\n  },\n  leave: ({ current, previous }) => {\n    // 遍历完节点的回调\n  },\n})\n",paraId:17,tocIndex:1},{value:"广度优先搜索",paraId:18,tocIndex:2},{value:"算法（Breadth First Search，简称 BFS），又译作宽度优先搜索，或横向优先搜索，是一种图搜索算法。简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用 open-closed 表。",paraId:18,tocIndex:2},{value:"图片来源",paraId:19,tocIndex:2},{value:"参数",paraId:20,tocIndex:2},{value:"名称",paraId:21,tocIndex:2},{value:"类型",paraId:21,tocIndex:2},{value:"是否必选",paraId:21,tocIndex:2},{value:"描述",paraId:21,tocIndex:2},{value:"graphData",paraId:21,tocIndex:2},{value:"GraphData",paraId:21,tocIndex:2},{value:"true",paraId:21,tocIndex:2},{value:"图数据，满足 G6 ",paraId:21,tocIndex:2},{value:"数据格式",paraId:22,tocIndex:2},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:21,tocIndex:2},{value:"startNodeId",paraId:21,tocIndex:2},{value:"string",paraId:21,tocIndex:2},{value:"true",paraId:21,tocIndex:2},{value:"开始访问的节点的 ID",paraId:21,tocIndex:2},{value:"originalCallbacks",paraId:21,tocIndex:2},{value:"IAlgorithmCallbacks",paraId:21,tocIndex:2},{value:"false",paraId:21,tocIndex:2},{value:"遍历的回调函数",paraId:21,tocIndex:2},{value:"用法",paraId:23,tocIndex:2},{value:"import G6, { Algorithm } from '@antv/g6'\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500\n})\n\nconst data = {\n  nodes: [\n    {\n      id: 'A'\n    },\n    {\n      id: 'B'\n    },\n    {\n      id: 'C'\n    },\n    {\n      id: 'D'\n    },\n    {\n      id: 'E'\n    },\n    {\n      id: 'F'\n    },\n    {\n      id: 'G'\n    },\n  ],\n  edges: [\n    {\n      source: 'A',\n      target: 'B'\n    },\n    {\n      source: 'B',\n      target: 'C'\n    },\n    {\n      source: 'C',\n      target: 'G'\n    },\n    {\n      source: 'A',\n      target: 'D'\n    },\n    {\n      source: 'A',\n      target: 'E'\n    },\n    {\n      source: 'E',\n      target: 'F'\n    },\n    {\n      source: 'F',\n      target: 'D'\n    },\n    {\n      source: 'D',\n      target: 'G'\n    },\n  ]\n}\n\ngraph.data(data)\ngraph.render()\n\nconst { breadthFirstSearch } = Algorithm\nbreadthFirstSearch(data, 'A', {\n  enter: ({ current, previous }) => {\n    // 开始遍历点的回调\n  },\n  leave: ({ current, previous }) => {\n    // 遍历完节点的回调\n  },\n})\n",paraId:24,tocIndex:2},{value:"G6 4.0 起支持",paraId:25,tocIndex:3},{value:" 标签传播算法，自动为数据聚类。优势：速度较 LOUVAIN 快。",paraId:25,tocIndex:3},{value:"参考资料：",paraId:26,tocIndex:3},{value:"https://en.wikipedia.org/wiki/Label_propagation_algorithm",paraId:26,tocIndex:3},{value:"参数",paraId:27,tocIndex:3},{value:"名称",paraId:28,tocIndex:3},{value:"类型",paraId:28,tocIndex:3},{value:"是否必选",paraId:28,tocIndex:3},{value:"描述",paraId:28,tocIndex:3},{value:"data",paraId:28,tocIndex:3},{value:"GraphData",paraId:28,tocIndex:3},{value:"true",paraId:28,tocIndex:3},{value:"图数据",paraId:28,tocIndex:3},{value:"directed",paraId:28,tocIndex:3},{value:"Boolean",paraId:28,tocIndex:3},{value:"false",paraId:28,tocIndex:3},{value:"是否是有向图，默认为 false",paraId:28,tocIndex:3},{value:"weightPropertyName",paraId:28,tocIndex:3},{value:"String",paraId:28,tocIndex:3},{value:"false",paraId:28,tocIndex:3},{value:"边权重的属名称，默认为 `'weight'，若数据中没有权重，则默认每条边权重为 1",paraId:28,tocIndex:3},{value:"maxIteration",paraId:28,tocIndex:3},{value:"Number",paraId:28,tocIndex:3},{value:"false",paraId:28,tocIndex:3},{value:"最大迭代次数，默认为 1000",paraId:28,tocIndex:3},{value:"返回值",paraId:29,tocIndex:3},{value:"返回聚合数据，并为输入的 ",paraId:30,tocIndex:3},{value:"data",paraId:30,tocIndex:3},{value:" 中的每个节点数据加上 ",paraId:30,tocIndex:3},{value:"clusterId",paraId:30,tocIndex:3},{value:" 字段。聚合数据 ",paraId:30,tocIndex:3},{value:"ClusterData",paraId:30,tocIndex:3},{value:" 类型如下：",paraId:30,tocIndex:3},{value:"interface ClusterData {\n  clusters: {\n    // 聚类数组\n    id: string; // 聚类 Id\n    nodes: NodeConfig[]; // 该聚类包含的节点\n  }[];\n  clusterEdges: {\n    // 聚类与聚类之间的边数组\n    source: string; // 起点聚类 id\n    target: string; // 终点聚类 id\n    count: number; // 该边所包含的真实边个数\n  }[];\n}\n",paraId:31,tocIndex:3},{value:"返回值示例：",paraId:32,tocIndex:3},{value:"{\n  clusters: [\n    {id: 'cluster1', nodes: [ {id: 'node1', clusterId: 'cluster1'}, {id: 'node2', clusterId: 'cluster1'} ]},\n    {id: 'cluster2', nodes: [ {id: 'node3', clusterId: 'cluster2'} ]},\n  ],\n  clusterEdges: [\n    {source: 'cluster1', target: 'cluster2', count: 10},\n    {source: 'cluster1', target: 'cluster1', count: 3},\n  ]\n}\n",paraId:33,tocIndex:3},{value:"用法",paraId:34,tocIndex:3},{value:"import G6, { Algorithm } from '@antv/g6';\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500,\n});\n\nconst data = {\n  nodes: [\n    { id: 'A' },\n    { id: 'B' },\n    { id: 'C' },\n    { id: 'D' },\n    { id: 'E' },\n    { id: 'F' },\n    { id: 'G' },\n  ],\n  edges: [\n    { source: 'A', target: 'B' },\n    { source: 'B', target: 'C' },\n    { source: 'A', target: 'C' },\n    { source: 'D', arget: 'A' },\n    { source: 'D', target: 'E' },\n    { source: 'E', target: 'F' },\n  ],\n};\n\ngraph.data(data);\ngraph.render();\n\nconst { labelPropagation } = Algorithm;\n\n// result 中包含 clusters 与 clusterEdges 数组。data 中的每个节点数据将带有 clusterId 字段\nlet result = labelPropagation(data);\n",paraId:35,tocIndex:3},{value:"G6 4.0 起支持",paraId:36,tocIndex:4},{value:" LOUVAIN 自动聚类算法。优势：根据节点间的紧密程度计算，较之于 Label Propagation 更准确。",paraId:36,tocIndex:4},{value:"参考资料：",paraId:37,tocIndex:4},{value:"https://en.wikipedia.org/wiki/Louvain_method",paraId:37,tocIndex:4},{value:"参数",paraId:38,tocIndex:4},{value:"名称",paraId:39,tocIndex:4},{value:"类型",paraId:39,tocIndex:4},{value:"是否必选",paraId:39,tocIndex:4},{value:"描述",paraId:39,tocIndex:4},{value:"data",paraId:39,tocIndex:4},{value:"GraphData",paraId:39,tocIndex:4},{value:"true",paraId:39,tocIndex:4},{value:"图数据",paraId:39,tocIndex:4},{value:"directed",paraId:39,tocIndex:4},{value:"Boolean",paraId:39,tocIndex:4},{value:"false",paraId:39,tocIndex:4},{value:"是否是有向图，默认为 false",paraId:39,tocIndex:4},{value:"weightPropertyName",paraId:39,tocIndex:4},{value:"String",paraId:39,tocIndex:4},{value:"false",paraId:39,tocIndex:4},{value:"边权重的属名称，默认为 `'weight'，若数据中没有权重，则默认每条边权重为 1",paraId:39,tocIndex:4},{value:"threshold",paraId:39,tocIndex:4},{value:"Number",paraId:39,tocIndex:4},{value:"false",paraId:39,tocIndex:4},{value:"停止迭代的阈值，默认为 0.0001",paraId:39,tocIndex:4},{value:"返回值",paraId:40,tocIndex:4},{value:"返回聚合数据，并为输入的 ",paraId:41,tocIndex:4},{value:"data",paraId:41,tocIndex:4},{value:" 中的每个节点数据加上 ",paraId:41,tocIndex:4},{value:"clusterId",paraId:41,tocIndex:4},{value:" 字段。聚合数据 ",paraId:41,tocIndex:4},{value:"ClusterData",paraId:41,tocIndex:4},{value:" 类型如下：",paraId:41,tocIndex:4},{value:"interface ClusterData {\n  clusters: {\n    // 聚类数组\n    id: string; // 聚类 Id\n    nodes: NodeConfig[]; // 该聚类包含的节点\n    sumTot?: number; // 该聚类内部边总数\n  }[];\n  clusterEdges: {\n    // 聚类与聚类之间的边数组\n    source: string; // 起点聚类 id\n    target: string; // 终点聚类 id\n    count: number; // 该边所包含的真实边个数\n  }[];\n}\n",paraId:42,tocIndex:4},{value:"返回值示例：",paraId:43,tocIndex:4},{value:"{\n  clusters: [\n    {id: 'cluster1', sumTot: 8, nodes: [ {id: 'node1', clusterId: 'cluster1'}, {id: 'node2', clusterId: 'cluster1'} ]},\n    {id: 'cluster2', sumTot: 15, nodes: [ {id: 'node3', clusterId: 'cluster2'} ]},\n  ],\n  clusterEdges: [\n    {source: 'cluster1', target: 'cluster2', count: 10},\n    {source: 'cluster1', target: 'cluster1', count: 3},\n  ]\n}\n",paraId:44,tocIndex:4},{value:"用法",paraId:45,tocIndex:4},{value:"import G6, { Algorithm } from '@antv/g6';\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500,\n});\n\nconst data = {\n  nodes: [\n    { id: 'A' },\n    { id: 'B' },\n    { id: 'C' },\n    { id: 'D' },\n    { id: 'E' },\n    { id: 'F' },\n    { id: 'G' },\n  ],\n  edges: [\n    { source: 'A', target: 'B' },\n    { source: 'B', target: 'C' },\n    { source: 'A', target: 'C' },\n    { source: 'D', arget: 'A' },\n    { source: 'D', target: 'E' },\n    { source: 'E', target: 'F' },\n  ],\n};\n\ngraph.data(data);\ngraph.render();\n\nconst { louvain } = Algorithm;\n\n// result 中包含 clusters 与 clusterEdges 数组。data 中的每个节点数据将带有 clusterId 字段\nlet result = louvain(data);\n",paraId:46,tocIndex:4},{value:"在给定的有向图中，检查是否包括圈。如果给定的图中至少包括一个圈，则返回包括的第一个圈，否则返回 null。",paraId:47,tocIndex:5},{value:"参考资料：",paraId:48,tocIndex:5},{value:"detect-cycle-in-a-graph",paraId:49,tocIndex:5},{value:"detect-cycle",paraId:50,tocIndex:5},{value:"参数",paraId:51,tocIndex:5},{value:"名称",paraId:52,tocIndex:5},{value:"类型",paraId:52,tocIndex:5},{value:"是否必选",paraId:52,tocIndex:5},{value:"描述",paraId:52,tocIndex:5},{value:"graphData",paraId:52,tocIndex:5},{value:"GraphData",paraId:52,tocIndex:5},{value:"true",paraId:52,tocIndex:5},{value:"图数据，满足 G6 ",paraId:52,tocIndex:5},{value:"数据格式",paraId:53,tocIndex:5},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:52,tocIndex:5},{value:"返回值",paraId:54,tocIndex:5},{value:"返回检测到的圈，否则返回 null。",paraId:55,tocIndex:5},{value:"用法",paraId:56,tocIndex:5},{value:"import G6, { Algorithm } from '@antv/g6';\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500,\n});\n\nconst data = {\n  nodes: [\n    { id: 'A' },\n    { id: 'B' },\n    { id: 'C' },\n    { id: 'D' },\n    { id: 'E' },\n    { id: 'F' },\n    { id: 'G' },\n  ],\n  edges: [\n    { source: 'A', target: 'B' },\n    { source: 'B', target: 'C' },\n    { source: 'A', target: 'C' },\n    { source: 'D', arget: 'A' },\n    { source: 'D', target: 'E' },\n    { source: 'E', target: 'F' },\n  ],\n};\n\ngraph.data(data);\ngraph.render();\n\nconst { detectDirectedCycle } = Algorithm;\n\n// 此时图中没有环，result 为 null\nlet result = detectDirectedCycle(data);\n\n// 当数据中加入 F->D 这条边后，图中有一个环\ndata.edges.push({\n  source: 'F',\n  target: 'D',\n});\n\ngraph.changeData(data);\n\n// 返回数据\n/**\n* {\n    D: Node,\n    F: Node,\n    E: Node,\n  }\n*/\nresult = detectDirectedCycle(data);\n",paraId:57,tocIndex:5},{value:"提供支持寻找图中所有环路的函数。对有向图来说返回所有简单环，简单环是指路径上的节点都只出现一次的闭合路径；对于无向图来说，返回一组完备的",paraId:58,tocIndex:6},{value:"基本环",paraId:58,tocIndex:6},{value:"。",paraId:58,tocIndex:6},{value:"参考资料：",paraId:59,tocIndex:6},{value:"检测无向图中的所有环",paraId:60,tocIndex:6},{value:"检测所有有向图中的简单环: ",paraId:61,tocIndex:6},{value:"Johnson's algorithm ",paraId:61,tocIndex:6},{value:"参数",paraId:62,tocIndex:6},{value:"名称",paraId:63,tocIndex:6},{value:"类型",paraId:63,tocIndex:6},{value:"是否必选",paraId:63,tocIndex:6},{value:"描述",paraId:63,tocIndex:6},{value:"graphData",paraId:63,tocIndex:6},{value:"GraphData",paraId:63,tocIndex:6},{value:"true",paraId:63,tocIndex:6},{value:"图数据，满足 G6 ",paraId:63,tocIndex:6},{value:"数据格式",paraId:64,tocIndex:6},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:63,tocIndex:6},{value:"directed",paraId:63,tocIndex:6},{value:"boolean",paraId:63,tocIndex:6},{value:"false",paraId:63,tocIndex:6},{value:"是否考虑边的方向性，若不指定，则取图的 ",paraId:63,tocIndex:6},{value:"directed",paraId:63,tocIndex:6},{value:" 属性 ｜",paraId:63,tocIndex:6},{value:"nodeIds",paraId:63,tocIndex:6},{value:"string[]",paraId:63,tocIndex:6},{value:"false",paraId:63,tocIndex:6},{value:"需包含或排除的节点 ID 的数组，若不指定，则返回图中所有的圈 ｜",paraId:63,tocIndex:6},{value:"include",paraId:63,tocIndex:6},{value:"boolean",paraId:63,tocIndex:6},{value:"false",paraId:63,tocIndex:6},{value:"若为 ",paraId:63,tocIndex:6},{value:"true",paraId:63,tocIndex:6},{value:", 则返回包含参数 ",paraId:63,tocIndex:6},{value:"nodeIds",paraId:63,tocIndex:6},{value:" 中指定的节点的圈，否则，返回所有不包含 ",paraId:63,tocIndex:6},{value:"nodeIds",paraId:63,tocIndex:6},{value:" 中指定的节点的圈。默认为 ",paraId:63,tocIndex:6},{value:"true",paraId:63,tocIndex:6},{value:" ｜",paraId:63,tocIndex:6},{value:"返回值",paraId:65,tocIndex:6},{value:"返回值类型：[{[key: string]: Node}]",paraId:66,tocIndex:6},{value:"返回一个数组表示检测到的所有符合条件的圈，每个环用一个 Object 表示，其中 key 为节点 id，value 为该节点在环中指向的下一个节点。",paraId:66,tocIndex:6},{value:"用法",paraId:67,tocIndex:6},{value:"const { detectAllCycles } = Algorithm;\n\n// 检测有向图中的所有简单环\nconst allCycles = detectAllCycles(data, true);\n\n// 检测有向图中包含节点 B 的所有简单环\nconst allCycleIncludeB = detectAllCycles(data, true, ['B']);\n\n// 检测无向图中所有不包含节点 B 的所有基本环\nconst allCycleExcludeB = detectAllCycles(data, false, ['B'], false);\n",paraId:68,tocIndex:6},{value:"查找两点之间的最短路径。",paraId:69,tocIndex:7},{value:"参数",paraId:70,tocIndex:7},{value:"名称",paraId:71,tocIndex:7},{value:"类型",paraId:71,tocIndex:7},{value:"是否必选",paraId:71,tocIndex:7},{value:"描述",paraId:71,tocIndex:7},{value:"graphData",paraId:71,tocIndex:7},{value:"GraphData",paraId:71,tocIndex:7},{value:"true",paraId:71,tocIndex:7},{value:"图数据，满足 G6 ",paraId:71,tocIndex:7},{value:"数据格式",paraId:72,tocIndex:7},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:71,tocIndex:7},{value:"start",paraId:71,tocIndex:7},{value:"INode / string",paraId:71,tocIndex:7},{value:"true",paraId:71,tocIndex:7},{value:"G6 Node 实例或 ID，路径起始点 ｜",paraId:71,tocIndex:7},{value:"end",paraId:71,tocIndex:7},{value:"INode / string",paraId:71,tocIndex:7},{value:"true",paraId:71,tocIndex:7},{value:"G6 Node 实例或 ID，路径终点 ｜",paraId:71,tocIndex:7},{value:"directed",paraId:71,tocIndex:7},{value:"boolean",paraId:71,tocIndex:7},{value:"false",paraId:71,tocIndex:7},{value:"是否考虑边的方向性，若不指定，则取图的 ",paraId:71,tocIndex:7},{value:"directed",paraId:71,tocIndex:7},{value:" 属性 ｜",paraId:71,tocIndex:7},{value:"weightPropertyName",paraId:71,tocIndex:7},{value:"string",paraId:71,tocIndex:7},{value:"false",paraId:71,tocIndex:7},{value:"边的权重属性字段名，若不指定，则认为所有边权重相同 ｜",paraId:71,tocIndex:7},{value:"返回值",paraId:73,tocIndex:7},{value:"返回值类型：Object，",paraId:74,tocIndex:7},{value:" {\n  length: number, // 最短路径长度\n  path: string[],\n  allPath: string[][] // start 到 end 的所有的最短路径\n}\n",paraId:75,tocIndex:7},{value:"返回的对象中，length 属性代表最短路径的长度，path 属性为构成一条最短路径的节点数组。",paraId:76,tocIndex:7},{value:"用法",paraId:77,tocIndex:7},{value:"const data = {\n  nodes: [\n    {\n      id: 'A',\n      label: 'A',\n    },\n    {\n      id: 'B',\n      label: 'B',\n    },\n    {\n      id: 'C',\n      label: 'C',\n    },\n    {\n      id: 'D',\n      label: 'D',\n    },\n    {\n      id: 'E',\n      label: 'E',\n    },\n    {\n      id: 'F',\n      label: 'F',\n    },\n    {\n      id: 'G',\n      label: 'G',\n    },\n    {\n      id: 'H',\n      label: 'H',\n    },\n  ],\n  edges: [\n    {\n      source: 'A',\n      target: 'B',\n    },\n    {\n      source: 'B',\n      target: 'C',\n    },\n    {\n      source: 'C',\n      target: 'G',\n    },\n    {\n      source: 'A',\n      target: 'D',\n    },\n    {\n      source: 'A',\n      target: 'E',\n    },\n    {\n      source: 'E',\n      target: 'F',\n    },\n    {\n      source: 'F',\n      target: 'D',\n    },\n    {\n      source: 'D',\n      target: 'E',\n    },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500,\n});\ngraph.data(data);\ngraph.render();\n\nconst { findShortestPath } = Algorithm;\n// 不考虑边的方向性，查找节点 A 和 节点 C 之间的最短路径\nconst { length, path, allPath } = findShortestPath(data, 'A', 'C');\nconsole.log(length, path);\n// 期望输出：2, ['A', 'B', 'C']\n",paraId:78,tocIndex:7},{value:"查找两点之间的所有路径。",paraId:79,tocIndex:8},{value:"参数",paraId:80,tocIndex:8},{value:"名称",paraId:81,tocIndex:8},{value:"类型",paraId:81,tocIndex:8},{value:"是否必选",paraId:81,tocIndex:8},{value:"描述",paraId:81,tocIndex:8},{value:"graphData",paraId:81,tocIndex:8},{value:"GraphData",paraId:81,tocIndex:8},{value:"true",paraId:81,tocIndex:8},{value:"图数据，满足 G6 ",paraId:81,tocIndex:8},{value:"数据格式",paraId:82,tocIndex:8},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:81,tocIndex:8},{value:"start",paraId:81,tocIndex:8},{value:"INode / string",paraId:81,tocIndex:8},{value:"true",paraId:81,tocIndex:8},{value:"G6 Node 实例或 ID，路径起始点 ｜",paraId:81,tocIndex:8},{value:"end",paraId:81,tocIndex:8},{value:"INode / string",paraId:81,tocIndex:8},{value:"true",paraId:81,tocIndex:8},{value:"G6 Node 实例或 ID，路径终点 ｜",paraId:81,tocIndex:8},{value:"directed",paraId:81,tocIndex:8},{value:"boolean",paraId:81,tocIndex:8},{value:"false",paraId:81,tocIndex:8},{value:"是否考虑边的方向性，若不指定，则取图的 ",paraId:81,tocIndex:8},{value:"directed",paraId:81,tocIndex:8},{value:" 属性 ｜",paraId:81,tocIndex:8},{value:"返回值",paraId:83,tocIndex:8},{value:"返回值类型：string[][]",paraId:84,tocIndex:8},{value:"返回包含两个节点之间所有路径的数组，每条路径由节点 ID 数组表示",paraId:84,tocIndex:8},{value:"用法",paraId:85,tocIndex:8},{value:"const data = {\n  nodes: [\n    {\n      id: 'A',\n      label: 'A',\n    },\n    {\n      id: 'B',\n      label: 'B',\n    },\n    {\n      id: 'C',\n      label: 'C',\n    },\n    {\n      id: 'D',\n      label: 'D',\n    },\n    {\n      id: 'E',\n      label: 'E',\n    },\n    {\n      id: 'F',\n      label: 'F',\n    },\n    {\n      id: 'G',\n      label: 'G',\n    },\n    {\n      id: 'H',\n      label: 'H',\n    },\n  ],\n  edges: [\n    {\n      source: 'A',\n      target: 'B',\n    },\n    {\n      source: 'B',\n      target: 'C',\n    },\n    {\n      source: 'C',\n      target: 'G',\n    },\n    {\n      source: 'A',\n      target: 'D',\n    },\n    {\n      source: 'A',\n      target: 'E',\n    },\n    {\n      source: 'E',\n      target: 'F',\n    },\n    {\n      source: 'F',\n      target: 'D',\n    },\n    {\n      source: 'D',\n      target: 'E',\n    },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 500,\n});\ngraph.data(data);\ngraph.render();\n\nconst { findAllPath } = Algorithm;\nconst allPath = findAllPath(data, 'A', 'E');\nconsole.log(allPath);\n// 期望输出值：[['A', 'D', 'F', 'E'], ['A', 'D', 'E'], ['A', 'E']]\n",paraId:86,tocIndex:8},{value:"返回图中的连通分量。若为无向图，连通分量指图中的极大连通子图，连通子图中任何两个顶点之间通过路径相互连接；若为有向图，则返回所有强连通分量，强连通分量指有向图中的极大强连通子图，强连通子图中任何两个节点之间都存在一条可达到彼此的有向路径。",paraId:87,tocIndex:9},{value:"参考资料：",paraId:88,tocIndex:9},{value:"检测有向图中的强连通分量：",paraId:89,tocIndex:9},{value:"Tarjan's Algorithm",paraId:89,tocIndex:9},{value:"参数",paraId:90,tocIndex:9},{value:"名称",paraId:91,tocIndex:9},{value:"类型",paraId:91,tocIndex:9},{value:"是否必选",paraId:91,tocIndex:9},{value:"描述",paraId:91,tocIndex:9},{value:"graphData",paraId:91,tocIndex:9},{value:"GraphData",paraId:91,tocIndex:9},{value:"true",paraId:91,tocIndex:9},{value:"图数据，满足 G6 ",paraId:91,tocIndex:9},{value:"数据格式",paraId:92,tocIndex:9},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:91,tocIndex:9},{value:"directed",paraId:91,tocIndex:9},{value:"boolean",paraId:91,tocIndex:9},{value:"false",paraId:91,tocIndex:9},{value:"是否考虑边的方向性，若不指定，则取图的 ",paraId:91,tocIndex:9},{value:"directed",paraId:91,tocIndex:9},{value:" 属性 ｜",paraId:91,tocIndex:9},{value:"返回值",paraId:93,tocIndex:9},{value:"返回值类型：INode[][]",paraId:94,tocIndex:9},{value:"返回一个数组表示检测到的所有连通分量，每个连通分量为节点数组。",paraId:94,tocIndex:9},{value:"用法",paraId:95,tocIndex:9},{value:"const data = {\n  nodes: [\n    {\n      id: 'A',\n    },\n    {\n      id: 'B',\n    },\n    {\n      id: 'C',\n    },\n    {\n      id: 'D',\n    },\n    {\n      id: 'E',\n    },\n    {\n      id: 'F',\n    },\n    {\n      id: 'G',\n    },\n    {\n      id: 'H',\n    },\n  ],\n  edges: [\n    {\n      source: 'A',\n      target: 'B',\n    },\n    {\n      source: 'B',\n      target: 'C',\n    },\n    {\n      source: 'A',\n      target: 'C',\n    },\n    {\n      source: 'D',\n      target: 'A',\n    },\n    {\n      source: 'D',\n      target: 'E',\n    },\n    {\n      source: 'E',\n      target: 'F',\n    },\n    {\n      source: 'F',\n      target: 'D',\n    },\n    {\n      source: 'G',\n      target: 'H',\n    },\n    {\n      source: 'H',\n      target: 'G',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'container',\n  width: 500,\n  height: 400,\n});\ngraph.data(data);\ngraph.render();\n\n// 图中的连通分量\nconst components = connectedComponent(data, false);\ncomponents.forEach((component) => {\n  console.log(component.map((node) => node.get('id')));\n});\n// 期望输出结果：['A', 'B', 'C', 'D', 'E', 'F'], ['G', 'H']\n\n// 有向图中的强连通分量\nconst components2 = connectedComponent(data, true);\ncomponents2.forEach((component) => {\n  console.log(component.map((node) => node.get('id')));\n});\n// 期望输出结果：['A'], ['B'], ['C'], ['D', 'E', 'F'], ['G', 'H']\n",paraId:96,tocIndex:9},{value:"PageRank 可以用来度量网络中节点的重要性，最初用于标识网页的重要性，对网页进行排序。PageRank 算法假设当前节点的重要性是由指向它的其他节点的重要性决定的，一个节点接收到的来自其他节点的入链 (inbound) 越多，则越重要，每个入链的权重由提供入链的节点的重要性决定。 因此 PageRank 除了考虑到入链数量，还参考了入链“质量”。PageRank 通过迭代递归计算来更新每个节点的得分，直到得分稳定为止。",paraId:97,tocIndex:10},{value:"参考资料：",paraId:98,tocIndex:10},{value:"PageRank",paraId:99,tocIndex:10},{value:"参数",paraId:100,tocIndex:10},{value:"名称",paraId:101,tocIndex:10},{value:"类型",paraId:101,tocIndex:10},{value:"是否必选",paraId:101,tocIndex:10},{value:"描述",paraId:101,tocIndex:10},{value:"graphData",paraId:101,tocIndex:10},{value:"GraphData",paraId:101,tocIndex:10},{value:"true",paraId:101,tocIndex:10},{value:"图数据，满足 G6 ",paraId:101,tocIndex:10},{value:"数据格式",paraId:102,tocIndex:10},{value:"。注意，4.1 以前的版本该参数请传入图实例",paraId:101,tocIndex:10},{value:"epsilon",paraId:101,tocIndex:10},{value:"number",paraId:101,tocIndex:10},{value:"false",paraId:101,tocIndex:10},{value:"判断 PageRank 得分是否稳定的精度值，默认 0.000001 ｜",paraId:101,tocIndex:10},{value:"linkProb",paraId:101,tocIndex:10},{value:"number",paraId:101,tocIndex:10},{value:"false",paraId:101,tocIndex:10},{value:"阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点指向的节点的概率，默认 0.85。 ｜",paraId:101,tocIndex:10},{value:"返回值",paraId:103,tocIndex:10},{value:"返回值类型：Object, {[key: string]: number}",paraId:104,tocIndex:10},{value:"返回一个对象，表示节点 ID 对应的该节点的 PageRank 值。",paraId:104,tocIndex:10}]},60250:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Behavior 指 G6 中的复合交互，一般 Behavior 包含一个或多个事件的监听与处理以及一系列对图中元素的操作。",paraId:0},{value:"Behavior 默认包含 ",paraId:1},{value:"shouldBegin",paraId:1},{value:"，",paraId:1},{value:"shouldUpdate",paraId:1},{value:"，",paraId:1},{value:"shouldEnd",paraId:1},{value:" 三个回调，代表是否开始行为，是否更新元素，是否进行结束行为，当返回值为 ",paraId:1},{value:"false",paraId:1},{value:" 时阻止默认行为。",paraId:1},{value:"所有内置 Behavior 及其参数参见 ",paraId:2},{value:"内置的 Behavior 教程",paraId:3},{value:"。当 ",paraId:2},{value:"内置 Behavior",paraId:4},{value:" 不能满足需求时，使用 ",paraId:2},{value:"registerBehavior(behaviorName, behavior)",paraId:2},{value:" 方法注册自定义的交互行为。详见 ",paraId:2},{value:"Behavior API",paraId:5},{value:"。本文将介绍如何自定义 Behavior。",paraId:2},{value:"// highlight-start\nG6.registerBehavior(behaviorName: string, behavior: BehaviorOption)\n// highlight-end\n\n// Custom a type of Behavior\nG6.registerBehavior('behaviorName', {\n  // Bind the event and its callback\n  getEvents() {\n    return {\n      'node:click': 'onClick',\n      mousemove: 'onMousemove',\n      'edge:click': 'onEdgeClick',\n    };\n  },\n  /**\n   * Handle the callback for node:click\n   * @override\n   * @param  {Object} evt The handler\n   */\n  onClick(evt) {\n    const node = evt.item;\n    const graph = this.graph;\n    const point = { x: evt.x, y: evt.y };\n    const model = node.getModel();\n    // TODO\n  },\n  /**\n   * Handle the callback for mousemove\n   * @override\n   * @param  {Object} evt The handler\n   */\n  onMousemove(evt) {\n    // TODO\n  },\n  /**\n   * Handle the callback for :click\n   * @override\n   * @param  {Object} evt The handler\n   */\n  onEdgeClick(evt) {\n    // TODO\n  },\n});\n",paraId:6},{value:"名称",paraId:7,tocIndex:0},{value:"类型",paraId:7,tocIndex:0},{value:"是否必选",paraId:7,tocIndex:0},{value:"描述",paraId:7,tocIndex:0},{value:"behaviorName",paraId:7,tocIndex:0},{value:"String",paraId:7,tocIndex:0},{value:"true",paraId:7,tocIndex:0},{value:"自定义 Behavior 的名称。",paraId:7,tocIndex:0},{value:"behavior",paraId:7,tocIndex:0},{value:"BehaviorOption",paraId:7,tocIndex:0},{value:"true",paraId:7,tocIndex:0},{value:"自定义 behavior 时的配置项，配置项中包括的方法及作用具体请参考：",paraId:7,tocIndex:0},{value:"Behavior API",paraId:8,tocIndex:0},{value:"。",paraId:7,tocIndex:0},{value:"自定义 Behavior 时，定义事件及处理事件的方法。",paraId:9,tocIndex:1},{value:"getEvents()",paraId:10,tocIndex:1},{value:" 方法中可以使用的事件请参考",paraId:10,tocIndex:1},{value:"Event 文档",paraId:11,tocIndex:1},{value:"。",paraId:10,tocIndex:1},{value:"用法",paraId:12,tocIndex:1},{value:"G6.registerBehavior('behaviorName', {\n  getEvents() {\n    return {\n      'node:click': 'onNodeClick',\n      'edge:click': 'onEdgeClick',\n      'mousemove': 'onMouseMove'\n    }\n  }\n}\n",paraId:13,tocIndex:1},{value:"onNodeClick",paraId:14,tocIndex:2},{value:"、",paraId:14,tocIndex:2},{value:"onEdgeClick",paraId:14,tocIndex:2},{value:" 和 ",paraId:14,tocIndex:2},{value:"onMouseMove",paraId:14,tocIndex:2},{value:" 都属于自定义方法，用于处理 ",paraId:14,tocIndex:2},{value:"node:click",paraId:14,tocIndex:2},{value:"、",paraId:14,tocIndex:2},{value:"edge:click",paraId:14,tocIndex:2},{value:"、",paraId:14,tocIndex:2},{value:"mousemove",paraId:14,tocIndex:2},{value:" 事件。",paraId:14,tocIndex:2},{value:"参数",paraId:15,tocIndex:2},{value:"名称",paraId:16,tocIndex:2},{value:"类型",paraId:16,tocIndex:2},{value:"是否必选",paraId:16,tocIndex:2},{value:"描述",paraId:16,tocIndex:2},{value:"evt",paraId:16,tocIndex:2},{value:"Event",paraId:16,tocIndex:2},{value:"否",paraId:16,tocIndex:2},{value:"包含事件句柄、当前操作对象及各坐标值等",paraId:16,tocIndex:2},{value:"参数 ",paraId:17,tocIndex:2},{value:"evt",paraId:17,tocIndex:2},{value:" 包括以下属性：",paraId:17,tocIndex:2},{value:"名称",paraId:18,tocIndex:2},{value:"类型",paraId:18,tocIndex:2},{value:"描述",paraId:18,tocIndex:2},{value:"x",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"元素视口 x 坐标",paraId:18,tocIndex:2},{value:"y",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"元素视口 y 坐标",paraId:18,tocIndex:2},{value:"canvasX",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"元素 Canvas x 坐标",paraId:18,tocIndex:2},{value:"canvasY",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"元素 Canvas y 坐标",paraId:18,tocIndex:2},{value:"clientX",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"屏幕/页面 x 坐标",paraId:18,tocIndex:2},{value:"clientY",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"屏幕/页面 y 坐标",paraId:18,tocIndex:2},{value:"event",paraId:18,tocIndex:2},{value:"MouseEvent",paraId:18,tocIndex:2},{value:"事件句柄",paraId:18,tocIndex:2},{value:"target",paraId:18,tocIndex:2},{value:"Shape",paraId:18,tocIndex:2},{value:"当前对象",paraId:18,tocIndex:2},{value:"type",paraId:18,tocIndex:2},{value:"String",paraId:18,tocIndex:2},{value:"操作类型",paraId:18,tocIndex:2},{value:"currentTarget",paraId:18,tocIndex:2},{value:"Object",paraId:18,tocIndex:2},{value:"item",paraId:18,tocIndex:2},{value:"Shape",paraId:18,tocIndex:2},{value:"操作的目标元素",paraId:18,tocIndex:2},{value:"removed",paraId:18,tocIndex:2},{value:"Boolean",paraId:18,tocIndex:2},{value:"是否删除/销毁",paraId:18,tocIndex:2},{value:"timeStamp",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"时间戳",paraId:18,tocIndex:2},{value:"bubbles",paraId:18,tocIndex:2},{value:"Boolean",paraId:18,tocIndex:2},{value:"是否支持事件冒泡",paraId:18,tocIndex:2},{value:"defaultPrevented",paraId:18,tocIndex:2},{value:"Boolean",paraId:18,tocIndex:2},{value:"是否阻止默认事件",paraId:18,tocIndex:2},{value:"cancelable",paraId:18,tocIndex:2},{value:"Boolean",paraId:18,tocIndex:2},{value:"是否取消",paraId:18,tocIndex:2},{value:"用法",paraId:19,tocIndex:2},{value:"G6.registerBehavior('behaviorName', {\n  getEvents() {\n    return {\n      'node:click': 'onNodeClick',\n      'edge:click': 'onEdgeClick',\n      mousemove: 'onMouseMove',\n    };\n  },\n  onNodeClick(evt) {\n    // TODO\n  },\n  onEdgeClick(evt) {\n    // TODO\n  },\n  onMouseMove(evt) {\n    // TODO\n  },\n});\n",paraId:20,tocIndex:2},{value:"定义自定义 Behavior 时的默认参数，会与用户传入的参数进行合并。",paraId:21,tocIndex:3},{value:"提示：该方法是可选的",paraId:22,tocIndex:3},{value:"。",paraId:22,tocIndex:3},{value:"用法",paraId:23,tocIndex:3},{value:"G6.registerBehavior('behaviorName', {\n  getDefaultCfg() {\n    return {\n      trigger: 'click' // mouseneter or click\n    }\n  }\n}\n",paraId:24,tocIndex:3},{value:"是否阻止行为发生，默认返回 ",paraId:25,tocIndex:4},{value:"true",paraId:25,tocIndex:4},{value:"，不阻止行为，需要在处理逻辑中自行调用。",paraId:25,tocIndex:4},{value:"v4.7.16 起支持",paraId:25,tocIndex:4},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:25,tocIndex:4},{value:"shouldBegin",paraId:25,tocIndex:4},{value:" 中访问该实例。",paraId:25,tocIndex:4},{value:"用法",paraId:26,tocIndex:4},{value:"G6.registerBehavior('behaviorName', {\n  shouldBegin(evt, self) {\n    // 这里可以根据业务自定义\n    return true\n  }\n}\n",paraId:27,tocIndex:4},{value:"是否更新数据及更改视图，默认返回 ",paraId:28,tocIndex:5},{value:"true",paraId:28,tocIndex:5},{value:"，允许更新，如果返回 ",paraId:28,tocIndex:5},{value:"false",paraId:28,tocIndex:5},{value:"，则不更新数据和视图。",paraId:28,tocIndex:5},{value:"v4.7.16 起支持",paraId:28,tocIndex:5},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:28,tocIndex:5},{value:"shouldUpdate",paraId:28,tocIndex:5},{value:" 中访问该实例。",paraId:28,tocIndex:5},{value:"用法",paraId:29,tocIndex:5},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  modes: {\n    default: [\n      'drag-canvas',\n      {\n        type: 'self-behavior',\n        shouldUpdate: (e, self) => {\n          if (e.target.type !== 'text') {\n            return false;\n          }\n          return true;\n        },\n      },\n    ],\n  },\n});\n",paraId:30,tocIndex:5},{value:"是否结束行为，默认返回 ",paraId:31,tocIndex:6},{value:"true",paraId:31,tocIndex:6},{value:"。",paraId:31,tocIndex:6},{value:"v4.7.16 起支持",paraId:31,tocIndex:6},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:31,tocIndex:6},{value:"shouldEnd",paraId:31,tocIndex:6},{value:" 中访问该实例。",paraId:31,tocIndex:6}]},22089:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本章介绍的事件可以通过 ",paraId:0},{value:"graph.on",paraId:1},{value:" 与 ",paraId:0},{value:"graph.off",paraId:2},{value:" 进行绑定/解绑监听函数。",paraId:0},{value:"通用事件、Node 事件、Edge 事件及 Canvas 事件回调的参数请参考 ",paraId:3},{value:"Behavior API",paraId:4},{value:"。",paraId:3},{value:"使用如下形式进行交互事件的监听：",paraId:5,tocIndex:0},{value:"graph.on(eventName, evt => {\n  // 一些操作\n})\n",paraId:6,tocIndex:0},{value:"其中，事件对象 ",paraId:7,tocIndex:0},{value:"evt",paraId:7,tocIndex:0},{value:" 的属性值有：",paraId:7,tocIndex:0},{value:"type",paraId:8,tocIndex:0},{value:": 事件类型",paraId:8,tocIndex:0},{value:"name",paraId:8,tocIndex:0},{value:": 事件名称",paraId:8,tocIndex:0},{value:"x",paraId:8,tocIndex:0},{value:": 画布上的 x 坐标",paraId:8,tocIndex:0},{value:"y",paraId:8,tocIndex:0},{value:": 画布上的 y 坐标",paraId:8,tocIndex:0},{value:"clientX",paraId:8,tocIndex:0},{value:": 浏览器窗口上的 x 坐标",paraId:8,tocIndex:0},{value:"clientY",paraId:8,tocIndex:0},{value:": 浏览器窗口上的 y 坐标",paraId:8,tocIndex:0},{value:"canvasX",paraId:8,tocIndex:0},{value:": 画布父容器视口上的 x 坐标",paraId:8,tocIndex:0},{value:"canvasY",paraId:8,tocIndex:0},{value:": 画布父容器视口上的 y 坐标",paraId:8,tocIndex:0},{value:"（x/y，clientX/clientY，canvasX/canvasY 三套坐标系详解见 ",paraId:9,tocIndex:0},{value:"G6 坐标系深度解析",paraId:10,tocIndex:0},{value:"）",paraId:9,tocIndex:0},{value:"item",paraId:11,tocIndex:0},{value:": 事件的触发元素（节点/边/ Combo）",paraId:11,tocIndex:0},{value:"target",paraId:11,tocIndex:0},{value:": 事件的触发图形 ",paraId:11,tocIndex:0},{value:"Shape",paraId:12,tocIndex:0},{value:" 或画布对象",paraId:11,tocIndex:0},{value:"bubbles",paraId:11,tocIndex:0},{value:": 是否允许冒泡",paraId:11,tocIndex:0},{value:"defaultPrevented",paraId:11,tocIndex:0},{value:": 是否阻止了原生事件",paraId:11,tocIndex:0},{value:"originalEvent",paraId:11,tocIndex:0},{value:": 原始浏览器事件对象，其中的 ",paraId:11,tocIndex:0},{value:"button",paraId:11,tocIndex:0},{value:" 可以用于区分 ",paraId:11,tocIndex:0},{value:"click",paraId:11,tocIndex:0},{value:" 事件的左/中/右键",paraId:11,tocIndex:0},{value:"timeStamp",paraId:11,tocIndex:0},{value:": 触发事件的时间",paraId:11,tocIndex:0},{value:"propagationStopped",paraId:11,tocIndex:0},{value:": 是否阻止传播（向上冒泡）",paraId:11,tocIndex:0},{value:"propagationPath",paraId:11,tocIndex:0},{value:": 触发事件的路径",paraId:11,tocIndex:0},{value:"eventName",paraId:13,tocIndex:0},{value:" 见下方内容。",paraId:13,tocIndex:0},{value:"事件名称",paraId:14,tocIndex:1},{value:"描述",paraId:14,tocIndex:1},{value:"click",paraId:14,tocIndex:1},{value:"单击鼠标",paraId:14,tocIndex:1},{value:"左键",paraId:14,tocIndex:1},{value:"或者按下回车键时触发",paraId:14,tocIndex:1},{value:"dblclick",paraId:14,tocIndex:1},{value:"双击鼠标",paraId:14,tocIndex:1},{value:"左键",paraId:14,tocIndex:1},{value:"时触发，同时会触发两次 click",paraId:14,tocIndex:1},{value:"mouseenter",paraId:14,tocIndex:1},{value:"鼠标移入元素范围内触发，",paraId:14,tocIndex:1},{value:"该事件不冒泡",paraId:14,tocIndex:1},{value:"，即鼠标移到其后代元素上时不会触发",paraId:14,tocIndex:1},{value:"mousemove",paraId:14,tocIndex:1},{value:"鼠标在元素内部移动时不断触发，不能通过键盘触发",paraId:14,tocIndex:1},{value:"mouseout",paraId:14,tocIndex:1},{value:"鼠标移出目标元素后触发",paraId:14,tocIndex:1},{value:"mouseover",paraId:14,tocIndex:1},{value:"鼠标移入目标元素上方，鼠标移到其后代元素上时会触发",paraId:14,tocIndex:1},{value:"mouseleave",paraId:14,tocIndex:1},{value:"鼠标移出元素范围时触发，",paraId:14,tocIndex:1},{value:"该事件不冒泡",paraId:14,tocIndex:1},{value:"，即鼠标移到其后代元素时不会触发",paraId:14,tocIndex:1},{value:"mousedown",paraId:14,tocIndex:1},{value:"鼠标按钮被按下（左键或者右键）时触发，不能通过键盘触发",paraId:14,tocIndex:1},{value:"mouseup",paraId:14,tocIndex:1},{value:"鼠标按钮被释放弹起时触发，不能通过键盘触发",paraId:14,tocIndex:1},{value:"contextmenu",paraId:14,tocIndex:1},{value:"用户右击鼠标时触发并打开上下文菜单，见 ",paraId:14,tocIndex:1},{value:"Demo",paraId:15,tocIndex:1},{value:"dragstart",paraId:14,tocIndex:1},{value:"当拖拽元素开始被拖拽的时候触发的事件，此事件作用在被拖曳元素上",paraId:14,tocIndex:1},{value:"drag",paraId:14,tocIndex:1},{value:"当拖拽元素在拖动过程中时触发的事件，此事件作用于被拖拽元素上",paraId:14,tocIndex:1},{value:"dragend",paraId:14,tocIndex:1},{value:"当拖拽完成后触发的事件，此事件作用在被拖曳元素上",paraId:14,tocIndex:1},{value:"dragenter",paraId:14,tocIndex:1},{value:"当拖曳元素进入目标元素的时候触发的事件，此事件作用在目标元素上",paraId:14,tocIndex:1},{value:"dragleave",paraId:14,tocIndex:1},{value:"当拖曳元素离开目标元素的时候触发的事件，此事件作用在目标元素上",paraId:14,tocIndex:1},{value:"drop",paraId:14,tocIndex:1},{value:"被拖拽的元素在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上",paraId:14,tocIndex:1},{value:"keydown",paraId:14,tocIndex:1},{value:"按下键盘键触发该事件",paraId:14,tocIndex:1},{value:"keyup",paraId:14,tocIndex:1},{value:"释放键盘键触发该事件",paraId:14,tocIndex:1},{value:"wheel",paraId:14,tocIndex:1},{value:"鼠标滚轮滚动时触发该事件",paraId:14,tocIndex:1},{value:"touchstart",paraId:14,tocIndex:1},{value:"当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发",paraId:14,tocIndex:1},{value:"touchmove",paraId:14,tocIndex:1},{value:"当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用 ",paraId:14,tocIndex:1},{value:"preventDefault()",paraId:14,tocIndex:1},{value:" 事件可以阻止滚动。",paraId:14,tocIndex:1},{value:"touchend",paraId:14,tocIndex:1},{value:"当手指从屏幕上离开的时候触发",paraId:14,tocIndex:1},{value:"事件名称",paraId:16,tocIndex:2},{value:"描述",paraId:16,tocIndex:2},{value:"node:click",paraId:16,tocIndex:2},{value:"鼠标",paraId:16,tocIndex:2},{value:"左键",paraId:16,tocIndex:2},{value:"单击节点时触发",paraId:16,tocIndex:2},{value:"node:dblclick",paraId:16,tocIndex:2},{value:"鼠标双击",paraId:16,tocIndex:2},{value:"左键",paraId:16,tocIndex:2},{value:"节点时触发，同时会触发两次 node:click",paraId:16,tocIndex:2},{value:"node:mouseenter",paraId:16,tocIndex:2},{value:"鼠标移入节点时触发",paraId:16,tocIndex:2},{value:"node:mousemove",paraId:16,tocIndex:2},{value:"鼠标在节点内部移动时不断触发，不能通过键盘触发",paraId:16,tocIndex:2},{value:"node:mouseout",paraId:16,tocIndex:2},{value:"鼠标移出节点后触发",paraId:16,tocIndex:2},{value:"node:mouseover",paraId:16,tocIndex:2},{value:"鼠标移入节点上方时触发",paraId:16,tocIndex:2},{value:"node:mouseleave",paraId:16,tocIndex:2},{value:"鼠标移出节点时触发",paraId:16,tocIndex:2},{value:"node:mousedown",paraId:16,tocIndex:2},{value:"鼠标按钮在节点上按下（左键或者右键）时触发，不能通过键盘触发",paraId:16,tocIndex:2},{value:"node:mouseup",paraId:16,tocIndex:2},{value:"节点上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发",paraId:16,tocIndex:2},{value:"node:dragstart",paraId:16,tocIndex:2},{value:"当节点开始被拖拽的时候触发的事件，此事件作用在被拖曳节点上",paraId:16,tocIndex:2},{value:"node:drag",paraId:16,tocIndex:2},{value:"当节点在拖动过程中时触发的事件，此事件作用于被拖拽节点上",paraId:16,tocIndex:2},{value:"node:dragend",paraId:16,tocIndex:2},{value:"当拖拽完成后触发的事件，此事件作用在被拖曳节点上",paraId:16,tocIndex:2},{value:"node:dragenter",paraId:16,tocIndex:2},{value:"当拖曳节点进入目标元素的时候触发的事件，此事件作用在目标元素上",paraId:16,tocIndex:2},{value:"node:dragleave",paraId:16,tocIndex:2},{value:"当拖曳节点离开目标元素的时候触发的事件，此事件作用在目标元素上",paraId:16,tocIndex:2},{value:"node:dragover",paraId:16,tocIndex:2},{value:"当拖曳节点在另一目标元素上移动时触发此事件，此事件作用在目标元素上",paraId:16,tocIndex:2},{value:"node:drop",paraId:16,tocIndex:2},{value:"被拖拽的节点在目标元素上同时鼠标放开触发的事件，此事件作用在目标元素上",paraId:16,tocIndex:2},{value:"node:touchstart",paraId:16,tocIndex:2},{value:"在触控屏上，当节点开始被触碰的时候触发的事件",paraId:16,tocIndex:2},{value:"node:touchmove",paraId:16,tocIndex:2},{value:"在触控屏上，当节点开始被触碰过程中触发的事件",paraId:16,tocIndex:2},{value:"node:touchend",paraId:16,tocIndex:2},{value:"在触控屏上，当节点开始被触碰结束的时候触发的事件",paraId:16,tocIndex:2},{value:"node:contextmenu",paraId:16,tocIndex:2},{value:"用户在节点上右击鼠标时触发并打开右键菜单，见 ",paraId:16,tocIndex:2},{value:"Demo",paraId:17,tocIndex:2},{value:"事件名称",paraId:18,tocIndex:3},{value:"描述",paraId:18,tocIndex:3},{value:"edge:click",paraId:18,tocIndex:3},{value:"鼠标",paraId:18,tocIndex:3},{value:"左键",paraId:18,tocIndex:3},{value:"单击边时触发",paraId:18,tocIndex:3},{value:"edge:dblclick",paraId:18,tocIndex:3},{value:"鼠标双击",paraId:18,tocIndex:3},{value:"左键",paraId:18,tocIndex:3},{value:"边时触发，同时会触发两次 edge:click",paraId:18,tocIndex:3},{value:"edge:mouseenter",paraId:18,tocIndex:3},{value:"鼠标移入边时触发",paraId:18,tocIndex:3},{value:"edge:mousemove",paraId:18,tocIndex:3},{value:"鼠标在边上移动时不断触发，不能通过键盘触发",paraId:18,tocIndex:3},{value:"edge:mouseout",paraId:18,tocIndex:3},{value:"鼠标移出边后触发",paraId:18,tocIndex:3},{value:"edge:mouseover",paraId:18,tocIndex:3},{value:"鼠标移入边上方时触发",paraId:18,tocIndex:3},{value:"edge:mouseleave",paraId:18,tocIndex:3},{value:"鼠标移出边时触发",paraId:18,tocIndex:3},{value:"edge:mousedown",paraId:18,tocIndex:3},{value:"鼠标按钮在边上按下（左键或者右键）时触发，不能通过键盘触发",paraId:18,tocIndex:3},{value:"edge:mouseup",paraId:18,tocIndex:3},{value:"边上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发",paraId:18,tocIndex:3},{value:"edge:dragenter",paraId:18,tocIndex:3},{value:"当拖曳元素进入目标边元素的时候触发的事件，此事件作用在目标边元素上",paraId:18,tocIndex:3},{value:"edge:dragleave",paraId:18,tocIndex:3},{value:"当拖曳元素离开目标边元素的时候触发的事件，此事件作用在目标边元素上",paraId:18,tocIndex:3},{value:"edge:dragover",paraId:18,tocIndex:3},{value:"当拖曳元素在另一目标边上移动时触发此事件，此事件作用在目标边元素上",paraId:18,tocIndex:3},{value:"edge:drop",paraId:18,tocIndex:3},{value:"被拖拽的元素在目标边元素上同时鼠标放开触发的事件，此事件作用在目标边元素上",paraId:18,tocIndex:3},{value:"edge:contextmenu",paraId:18,tocIndex:3},{value:"用户在边上右击鼠标时触发并打开右键菜单，见 ",paraId:18,tocIndex:3},{value:"Demo",paraId:19,tocIndex:3},{value:"Combo 继承所有 Node 事件。",paraId:20,tocIndex:4},{value:"事件名称",paraId:21,tocIndex:5},{value:"描述",paraId:21,tocIndex:5},{value:"canvas:click",paraId:21,tocIndex:5},{value:"鼠标",paraId:21,tocIndex:5},{value:"左键",paraId:21,tocIndex:5},{value:"单击画布时触发",paraId:21,tocIndex:5},{value:"canvas:dblclick",paraId:21,tocIndex:5},{value:"鼠标双击",paraId:21,tocIndex:5},{value:"左键",paraId:21,tocIndex:5},{value:"画布时触发",paraId:21,tocIndex:5},{value:"canvas:mouseenter",paraId:21,tocIndex:5},{value:"鼠标移入画布时触发",paraId:21,tocIndex:5},{value:"canvas:mousemove",paraId:21,tocIndex:5},{value:"鼠标在画布内部移动时不断触发，不能通过键盘触发",paraId:21,tocIndex:5},{value:"canvas:mouseout",paraId:21,tocIndex:5},{value:"鼠标移出画布后触发",paraId:21,tocIndex:5},{value:"canvas:mouseover",paraId:21,tocIndex:5},{value:"鼠标移入画布上方时触发",paraId:21,tocIndex:5},{value:"canvas:mouseleave",paraId:21,tocIndex:5},{value:"鼠标移出画布时触发",paraId:21,tocIndex:5},{value:"canvas:mousedown",paraId:21,tocIndex:5},{value:"鼠标按钮在画布上按下（左键或者右键）时触发，不能通过键盘触发",paraId:21,tocIndex:5},{value:"canvas:mouseup",paraId:21,tocIndex:5},{value:"画布上按下的鼠标按钮被释放弹起时触发，不能通过键盘触发",paraId:21,tocIndex:5},{value:"canvas:contextmenu",paraId:21,tocIndex:5},{value:"用户在画布上右击鼠标时触发并打开右键菜单，见 ",paraId:21,tocIndex:5},{value:"Demo",paraId:22,tocIndex:5},{value:"canvas:dragstart",paraId:21,tocIndex:5},{value:"当画布开始被拖拽的时候触发的事件，此事件作用在被拖曳画布上",paraId:21,tocIndex:5},{value:"canvas:drag",paraId:21,tocIndex:5},{value:"当画布在拖动过程中时触发的事件，此事件作用于被拖拽画布上",paraId:21,tocIndex:5},{value:"canvas:dragend",paraId:21,tocIndex:5},{value:"当拖拽完成后触发的事件，此事件作用在被拖曳画布上",paraId:21,tocIndex:5},{value:"canvas:dragenter",paraId:21,tocIndex:5},{value:"当拖曳画布进入目标元素的时候触发的事件，此事件作用在目标画布上",paraId:21,tocIndex:5},{value:"canvas:dragleave",paraId:21,tocIndex:5},{value:"当拖曳画布离开目标元素的时候触发的事件，此事件作用在目标画布上",paraId:21,tocIndex:5},{value:"canvas:drop",paraId:21,tocIndex:5},{value:"被拖拽的元素在空白画布上同时鼠标放开触发的事件，此事件作用在目标画布上",paraId:21,tocIndex:5},{value:"canvas:touchstart",paraId:21,tocIndex:5},{value:"在触控屏上，当画布开始被触碰的时候触发的事件",paraId:21,tocIndex:5},{value:"canvas:touchmove",paraId:21,tocIndex:5},{value:"在触控屏上，当画布开始被触碰过程中触发的事件",paraId:21,tocIndex:5},{value:"canvas:touchend",paraId:21,tocIndex:5},{value:"在触控屏上，当画布开始被触碰结束的时候触发的事件",paraId:21,tocIndex:5},{value:"用于监听图的某方法调用前后的时机。使用如下形式进行交互事件的监听：",paraId:23,tocIndex:6},{value:"graph.on(timingEventName, evt => {\n  // 一些操作\n})\n",paraId:24,tocIndex:6},{value:"timingEventName",paraId:25,tocIndex:6},{value:" 见下方内容。",paraId:25,tocIndex:6},{value:"事件名称",paraId:26,tocIndex:6},{value:"描述",paraId:26,tocIndex:6},{value:"beforerender",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.render",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.read",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afterrender",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.render",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.read",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforedestroy",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.destroy",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afterdestroy",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.destroy",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforechangedata",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.changeData",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afterchangedata",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.changeData",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeadditem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.add",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.addItem",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afteradditem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.add",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.addItem",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeremoveitem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.remove",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.removeItem",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afterremoveitem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.remove",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.removeItem",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeupdateitem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.update",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.updateItem",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afterupdateitem",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.update",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.updateItem",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeitemvisibilitychange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.showItem",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.hideItem",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afteritemvisibilitychange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.showItem",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.hideItem",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeitemstatechange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.setItemState",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afteritemstatechange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.setItemState",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeitemrefresh",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.refreshItem",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afteritemrefresh",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.refreshItem",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforeitemstatesclear",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.clearItemStates",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"afteritemstatesclear",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.clearItemStates",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforemodechange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.setMode",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.addBehaviors",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.removeBehaviors",paraId:26,tocIndex:6},{value:" 方法之前触发",paraId:26,tocIndex:6},{value:"aftermodechange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.setMode",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.addBehaviors",paraId:26,tocIndex:6},{value:" / ",paraId:26,tocIndex:6},{value:"graph.removeBehaviors",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"beforelayout",paraId:26,tocIndex:6},{value:"布局前触发。调用 ",paraId:26,tocIndex:6},{value:"graph.render",paraId:26,tocIndex:6},{value:" 时会进行布局，因此 ",paraId:26,tocIndex:6},{value:"render",paraId:26,tocIndex:6},{value:" 时会触发。或用户主动调用图的 ",paraId:26,tocIndex:6},{value:"graph.layout",paraId:26,tocIndex:6},{value:" 时触发。",paraId:26,tocIndex:6},{value:"afterlayout",paraId:26,tocIndex:6},{value:"布局完成后触发。调用 ",paraId:26,tocIndex:6},{value:"graph.render",paraId:26,tocIndex:6},{value:" 时会进行布局，因此 ",paraId:26,tocIndex:6},{value:"render",paraId:26,tocIndex:6},{value:" 时布局完成后会触发。或用户主动调用图的 ",paraId:26,tocIndex:6},{value:"graph.layout",paraId:26,tocIndex:6},{value:" 时布局完成后触发。",paraId:26,tocIndex:6},{value:"beforegraphrefreshposition",paraId:26,tocIndex:6},{value:"graph.refreshPositions",paraId:26,tocIndex:6},{value:" 被调用前触发",paraId:26,tocIndex:6},{value:"aftergraphrefreshposition",paraId:26,tocIndex:6},{value:"graph.refreshPositions",paraId:26,tocIndex:6},{value:" 被调用后触发",paraId:26,tocIndex:6},{value:"beforegraphrefresh",paraId:26,tocIndex:6},{value:"graph.refresh",paraId:26,tocIndex:6},{value:" 被调用前触发",paraId:26,tocIndex:6},{value:"aftergraphrefresh",paraId:26,tocIndex:6},{value:"graph.refresh",paraId:26,tocIndex:6},{value:" 被调用后触发",paraId:26,tocIndex:6},{value:"beforeanimate",paraId:26,tocIndex:6},{value:"全局动画发生前触发",paraId:26,tocIndex:6},{value:"afteranimate",paraId:26,tocIndex:6},{value:"全局动画发生后触发",paraId:26,tocIndex:6},{value:"beforecreateedge",paraId:26,tocIndex:6},{value:"使用内置交互 ",paraId:26,tocIndex:6},{value:"create-edge",paraId:26,tocIndex:6},{value:"，创建边之前触发",paraId:26,tocIndex:6},{value:"aftercreateedge",paraId:26,tocIndex:6},{value:"使用内置交互 ",paraId:26,tocIndex:6},{value:"create-edge",paraId:26,tocIndex:6},{value:"，创建边之后触发",paraId:26,tocIndex:6},{value:"beforecollapseexpandcombo",paraId:26,tocIndex:6},{value:"当一个 combo 被收起或展开之前被触发，参数 ",paraId:26,tocIndex:6},{value:"action",paraId:26,tocIndex:6},{value:" 指明了是收起还是展开",paraId:26,tocIndex:6},{value:"aftercollapseexpandcombo",paraId:26,tocIndex:6},{value:"当一个 combo 被收起或展开之后被触发，参数 ",paraId:26,tocIndex:6},{value:"action",paraId:26,tocIndex:6},{value:" 指明了是收起还是展开",paraId:26,tocIndex:6},{value:"graphstatechange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.updateItemState",paraId:26,tocIndex:6},{value:" 方法之后触发",paraId:26,tocIndex:6},{value:"afteractivaterelations",paraId:26,tocIndex:6},{value:"使用了 ",paraId:26,tocIndex:6},{value:"'activate-relations'",paraId:26,tocIndex:6},{value:" Behavior 并触发了该行为后，该事件被触发",paraId:26,tocIndex:6},{value:"nodeselectchange",paraId:26,tocIndex:6},{value:"使用了 ",paraId:26,tocIndex:6},{value:"'brush-select'",paraId:26,tocIndex:6},{value:" , ",paraId:26,tocIndex:6},{value:"'click-select'",paraId:26,tocIndex:6},{value:" 或 ",paraId:26,tocIndex:6},{value:"'lasso-select'",paraId:26,tocIndex:6},{value:" Behavior 且选中元素发生变化时，该事件被触发",paraId:26,tocIndex:6},{value:"itemcollapsed",paraId:26,tocIndex:6},{value:"在 TreeGraph 上使用了 ",paraId:26,tocIndex:6},{value:"'collapse-expand'",paraId:26,tocIndex:6},{value:" Behavior 并触发了该行为后，该事件被触发",paraId:26,tocIndex:6},{value:"tooltipchange",paraId:26,tocIndex:6},{value:"使用了 ",paraId:26,tocIndex:6},{value:"'tooltip'",paraId:26,tocIndex:6},{value:" 或 ",paraId:26,tocIndex:6},{value:"'edge-tooltip'",paraId:26,tocIndex:6},{value:" Behavior 且 tooltip 的显示/隐藏被改变后，该事件被触发",paraId:26,tocIndex:6},{value:"wheelzoom",paraId:26,tocIndex:6},{value:"使用了 ",paraId:26,tocIndex:6},{value:"'zoom-canvas'",paraId:26,tocIndex:6},{value:" Behavior 并用滚轮对图进行缩放后，该事件被触发",paraId:26,tocIndex:6},{value:"viewportchange",paraId:26,tocIndex:6},{value:"调用 ",paraId:26,tocIndex:6},{value:"graph.moveTo",paraId:26,tocIndex:6},{value:"，",paraId:26,tocIndex:6},{value:"graph.translate",paraId:26,tocIndex:6},{value:"，或 ",paraId:26,tocIndex:6},{value:"graph.zoom",paraId:26,tocIndex:6},{value:" 均会触发该事件",paraId:26,tocIndex:6},{value:"dragnodeend",paraId:26,tocIndex:6},{value:"使用了 ",paraId:26,tocIndex:6},{value:"'drag-node'",paraId:26,tocIndex:6},{value:" Behavior，当拖动结束时，该事件被触发",paraId:26,tocIndex:6},{value:"stackchange",paraId:26,tocIndex:6},{value:"撤销/重做栈发生变化时，该事件触发",paraId:26,tocIndex:6},{value:"插件中的时机事件",paraId:27,tocIndex:6},{value:"TimeBar 插件：",paraId:28,tocIndex:6},{value:"事件名称",paraId:29,tocIndex:6},{value:"描述",paraId:29,tocIndex:6},{value:"valuechange",paraId:29,tocIndex:6},{value:"时间轴的时间范围发生变化时触发",paraId:29,tocIndex:6},{value:"timebarstartplay",paraId:29,tocIndex:6},{value:"时间轴开始播放时触发",paraId:29,tocIndex:6},{value:"timebarendplay",paraId:29,tocIndex:6},{value:"时间轴播放结束时触发",paraId:29,tocIndex:6},{value:"Tooltip 插件：",paraId:30,tocIndex:6},{value:"事件名称",paraId:31,tocIndex:6},{value:"描述",paraId:31,tocIndex:6},{value:"tooltipchange",paraId:31,tocIndex:6},{value:"Tooltip 发生变化时触发",paraId:31,tocIndex:6},{value:"不同时机监听事件的回调参数不同，下面针对各个自定义事件的回调参数进行说明。",paraId:32,tocIndex:7},{value:"无参数",paraId:33,tocIndex:8},{value:"名称",paraId:34,tocIndex:9},{value:"类型",paraId:34,tocIndex:9},{value:"描述",paraId:34,tocIndex:9},{value:"type",paraId:34,tocIndex:9},{value:"String",paraId:34,tocIndex:9},{value:"当前添加的类型",paraId:34,tocIndex:9},{value:"model",paraId:34,tocIndex:9},{value:"Object",paraId:34,tocIndex:9},{value:"item 数据模型",paraId:34,tocIndex:9},{value:"名称",paraId:35,tocIndex:10},{value:"类型",paraId:35,tocIndex:10},{value:"描述",paraId:35,tocIndex:10},{value:"item",paraId:35,tocIndex:10},{value:"Item",paraId:35,tocIndex:10},{value:"已经添加的 item 实例",paraId:35,tocIndex:10},{value:"model",paraId:35,tocIndex:10},{value:"Object",paraId:35,tocIndex:10},{value:"item 数据模型",paraId:35,tocIndex:10},{value:"名称",paraId:36,tocIndex:11},{value:"类型",paraId:36,tocIndex:11},{value:"描述",paraId:36,tocIndex:11},{value:"item",paraId:36,tocIndex:11},{value:"Item",paraId:36,tocIndex:11},{value:"被删除的 item 实例数据",paraId:36,tocIndex:11},{value:"type",paraId:36,tocIndex:11},{value:"'node' / 'edge' / 'combo'",paraId:36,tocIndex:11},{value:"被删除的 item 类型",paraId:36,tocIndex:11},{value:"名称",paraId:37,tocIndex:12},{value:"类型",paraId:37,tocIndex:12},{value:"描述",paraId:37,tocIndex:12},{value:"item",paraId:37,tocIndex:12},{value:"Item",paraId:37,tocIndex:12},{value:"要更新的 item 实例",paraId:37,tocIndex:12},{value:"model",paraId:37,tocIndex:12},{value:"Object",paraId:37,tocIndex:12},{value:"item 数据模型",paraId:37,tocIndex:12},{value:"名称",paraId:38,tocIndex:13},{value:"类型",paraId:38,tocIndex:13},{value:"描述",paraId:38,tocIndex:13},{value:"item",paraId:38,tocIndex:13},{value:"Item",paraId:38,tocIndex:13},{value:"当前操作的 item 实例",paraId:38,tocIndex:13},{value:"visible",paraId:38,tocIndex:13},{value:"Boolean",paraId:38,tocIndex:13},{value:"是否可见，",paraId:38,tocIndex:13},{value:"true",paraId:38,tocIndex:13},{value:" 为可见，",paraId:38,tocIndex:13},{value:"false",paraId:38,tocIndex:13},{value:" 为不可见",paraId:38,tocIndex:13},{value:"名称",paraId:39,tocIndex:14},{value:"类型",paraId:39,tocIndex:14},{value:"描述",paraId:39,tocIndex:14},{value:"item",paraId:39,tocIndex:14},{value:"Item",paraId:39,tocIndex:14},{value:"当前操作的 item 实例",paraId:39,tocIndex:14},{value:"state",paraId:39,tocIndex:14},{value:"String",paraId:39,tocIndex:14},{value:"状态",paraId:39,tocIndex:14},{value:"enabled",paraId:39,tocIndex:14},{value:"Boolean",paraId:39,tocIndex:14},{value:"状态是否可用，",paraId:39,tocIndex:14},{value:"true",paraId:39,tocIndex:14},{value:" 可用，",paraId:39,tocIndex:14},{value:"false",paraId:39,tocIndex:14},{value:" 不可用",paraId:39,tocIndex:14},{value:"名称",paraId:40,tocIndex:15},{value:"类型",paraId:40,tocIndex:15},{value:"描述",paraId:40,tocIndex:15},{value:"item",paraId:40,tocIndex:15},{value:"Item",paraId:40,tocIndex:15},{value:"当前操作的 item 实例",paraId:40,tocIndex:15},{value:"states",paraId:40,tocIndex:15},{value:"Array / String",paraId:40,tocIndex:15},{value:"需要批量清除的状态",paraId:40,tocIndex:15},{value:"名称",paraId:41,tocIndex:16},{value:"类型",paraId:41,tocIndex:16},{value:"描述",paraId:41,tocIndex:16},{value:"mode",paraId:41,tocIndex:16},{value:"String",paraId:41,tocIndex:16},{value:"当前的模式名称",paraId:41,tocIndex:16},{value:"名称",paraId:42,tocIndex:17},{value:"类型",paraId:42,tocIndex:17},{value:"描述",paraId:42,tocIndex:17},{value:"item",paraId:42,tocIndex:17},{value:"Item",paraId:42,tocIndex:17},{value:"当前操作的 item 实例",paraId:42,tocIndex:17},{value:"无参数",paraId:43,tocIndex:18},{value:"名称",paraId:44,tocIndex:19},{value:"类型",paraId:44,tocIndex:19},{value:"描述",paraId:44,tocIndex:19},{value:"states",paraId:44,tocIndex:19},{value:"Object",paraId:44,tocIndex:19},{value:"当前各个状态下的元素，格式举例 ",paraId:44,tocIndex:19},{value:"{ hover: [Node, Node], selected: [ Node ] }",paraId:44,tocIndex:19},{value:"名称",paraId:45,tocIndex:20},{value:"类型",paraId:45,tocIndex:20},{value:"描述",paraId:45,tocIndex:20},{value:"item",paraId:45,tocIndex:20},{value:"Item",paraId:45,tocIndex:20},{value:"当前操作的 item 实例",paraId:45,tocIndex:20},{value:"action",paraId:45,tocIndex:20},{value:"String",paraId:45,tocIndex:20},{value:"当前操作名",paraId:45,tocIndex:20},{value:"名称",paraId:46,tocIndex:21},{value:"类型",paraId:46,tocIndex:21},{value:"描述",paraId:46,tocIndex:21},{value:"target",paraId:46,tocIndex:21},{value:"Item",paraId:46,tocIndex:21},{value:"当前操作的 item 实例",paraId:46,tocIndex:21},{value:"selectedItems",paraId:46,tocIndex:21},{value:"Object",paraId:46,tocIndex:21},{value:"当前被选中的所有 item 实例，形如 ",paraId:46,tocIndex:21},{value:"{ nodes: [...], edges: [...]}",paraId:46,tocIndex:21},{value:"beforecreateedge",paraId:47,tocIndex:22},{value:" 无参数。",paraId:47,tocIndex:22},{value:"aftercreateedge",paraId:47,tocIndex:22},{value:" 参数如下：",paraId:47,tocIndex:22},{value:"名称",paraId:48,tocIndex:22},{value:"类型",paraId:48,tocIndex:22},{value:"描述",paraId:48,tocIndex:22},{value:"edge",paraId:48,tocIndex:22},{value:"Item",paraId:48,tocIndex:22},{value:"当前被创建的边实例",paraId:48,tocIndex:22},{value:"名称",paraId:49,tocIndex:23},{value:"类型",paraId:49,tocIndex:23},{value:"描述",paraId:49,tocIndex:23},{value:"action",paraId:49,tocIndex:23},{value:"string",paraId:49,tocIndex:23},{value:"具体的操作， ",paraId:49,tocIndex:23},{value:"'collapse'",paraId:49,tocIndex:23},{value:" 或 ",paraId:49,tocIndex:23},{value:"'expand'",paraId:49,tocIndex:23},{value:"combo",paraId:49,tocIndex:23},{value:"Item",paraId:49,tocIndex:23},{value:"被操作的 combo item",paraId:49,tocIndex:23},{value:"名称",paraId:50,tocIndex:24},{value:"类型",paraId:50,tocIndex:24},{value:"描述",paraId:50,tocIndex:24},{value:"item",paraId:50,tocIndex:24},{value:"Item",paraId:50,tocIndex:24},{value:"当前操作的 item 实例",paraId:50,tocIndex:24},{value:"collapsed",paraId:50,tocIndex:24},{value:"Boolean",paraId:50,tocIndex:24},{value:"当前操作后，操作对象的 collapsed 状态",paraId:50,tocIndex:24},{value:"名称",paraId:51,tocIndex:25},{value:"类型",paraId:51,tocIndex:25},{value:"描述",paraId:51,tocIndex:25},{value:"item",paraId:51,tocIndex:25},{value:"Item",paraId:51,tocIndex:25},{value:"当前操作的 item 实例",paraId:51,tocIndex:25},{value:"action",paraId:51,tocIndex:25},{value:"String",paraId:51,tocIndex:25},{value:"tooltip 当前是显示 ",paraId:51,tocIndex:25},{value:"'show'",paraId:51,tocIndex:25},{value:" 还是隐藏 ",paraId:51,tocIndex:25},{value:"'hide'",paraId:51,tocIndex:25},{value:"名称",paraId:52,tocIndex:26},{value:"类型",paraId:52,tocIndex:26},{value:"描述",paraId:52,tocIndex:26},{value:"deltaX",paraId:52,tocIndex:26},{value:"Number",paraId:52,tocIndex:26},{value:"滚动的 x 方向，取值 ",paraId:52,tocIndex:26},{value:"1",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"0",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"-1",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"0",paraId:52,tocIndex:26},{value:" 代表没有该方向的滚动",paraId:52,tocIndex:26},{value:"deltaY",paraId:52,tocIndex:26},{value:"Number",paraId:52,tocIndex:26},{value:"滚动的 y 方向，取值 ",paraId:52,tocIndex:26},{value:"1",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"0",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"-1",paraId:52,tocIndex:26},{value:"，",paraId:52,tocIndex:26},{value:"0",paraId:52,tocIndex:26},{value:" 代表没有该方向的滚动",paraId:52,tocIndex:26},{value:"... 其他滚轮事件的回调参数",paraId:52,tocIndex:26},{value:"名称",paraId:53,tocIndex:27},{value:"类型",paraId:53,tocIndex:27},{value:"描述",paraId:53,tocIndex:27},{value:"action",paraId:53,tocIndex:27},{value:"'translate' / 'move' / 'zoom'",paraId:53,tocIndex:27},{value:"视窗变换的类型，",paraId:53,tocIndex:27},{value:"'translate'",paraId:53,tocIndex:27},{value:"、",paraId:53,tocIndex:27},{value:"'move'",paraId:53,tocIndex:27},{value:"、",paraId:53,tocIndex:27},{value:"'zoom'",paraId:53,tocIndex:27},{value:" 分别标识该时机是由 ",paraId:53,tocIndex:27},{value:"graph.translate",paraId:53,tocIndex:27},{value:"、",paraId:53,tocIndex:27},{value:"graph.move",paraId:53,tocIndex:27},{value:"、还是 ",paraId:53,tocIndex:27},{value:"graph.zoom",paraId:53,tocIndex:27},{value:" 函数的调用而产生",paraId:53,tocIndex:27},{value:"matrix",paraId:53,tocIndex:27},{value:"Array",paraId:53,tocIndex:27},{value:"视窗变换后的图的矩阵",paraId:53,tocIndex:27},{value:"名称",paraId:54,tocIndex:28},{value:"类型",paraId:54,tocIndex:28},{value:"描述",paraId:54,tocIndex:28},{value:"items",paraId:54,tocIndex:28},{value:"Item[]",paraId:54,tocIndex:28},{value:"当前操作的 item 实例",paraId:54,tocIndex:28},{value:"targetItem",paraId:54,tocIndex:28},{value:"null/Node/Combo",paraId:54,tocIndex:28},{value:"拖动节点结束后，节点是放到 canvas、Node 还是 Combo 上面",paraId:54,tocIndex:28},{value:"名称",paraId:55,tocIndex:29},{value:"类型",paraId:55,tocIndex:29},{value:"描述",paraId:55,tocIndex:29},{value:"redoStack",paraId:55,tocIndex:29},{value:"Object[]",paraId:55,tocIndex:29},{value:"重做堆栈",paraId:55,tocIndex:29},{value:"undoStack",paraId:55,tocIndex:29},{value:"Object[]",paraId:55,tocIndex:29},{value:"撤销堆栈",paraId:55,tocIndex:29},{value:"action",paraId:55,tocIndex:29},{value:"String",paraId:55,tocIndex:29},{value:"操作类型",paraId:55,tocIndex:29},{value:"stackType",paraId:55,tocIndex:29},{value:"String",paraId:55,tocIndex:29},{value:"栈变更类型，撤销 undo / 重做 redo",paraId:55,tocIndex:29},{value:"名称",paraId:56,tocIndex:30},{value:"类型",paraId:56,tocIndex:30},{value:"描述",paraId:56,tocIndex:30},{value:"value",paraId:56,tocIndex:30},{value:"number[]",paraId:56,tocIndex:30},{value:"时间轴当前时间范围，",paraId:56,tocIndex:30},{value:"value[0]",paraId:56,tocIndex:30},{value:" 为起始值，",paraId:56,tocIndex:30},{value:"value[1]",paraId:56,tocIndex:30},{value:" 为结束值",paraId:56,tocIndex:30},{value:"无参数",paraId:57,tocIndex:31},{value:"名称",paraId:58,tocIndex:32},{value:"类型",paraId:58,tocIndex:32},{value:"描述",paraId:58,tocIndex:32},{value:"item",paraId:58,tocIndex:32},{value:"Item",paraId:58,tocIndex:32},{value:"tooltip 所关联的元素（节点/边）",paraId:58,tocIndex:32},{value:"action",paraId:58,tocIndex:32},{value:"'show' / 'hide'",paraId:58,tocIndex:32},{value:"tooltip 当前的变化时显示还是隐藏",paraId:58,tocIndex:32}]},38196:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Graph 是 G6 图表的载体，所有的 G6 节点实例操作以及事件，行为监听都在 Graph 实例上进行。Graph 的初始化通过 new 进行实例化，实例化时需要传入需要的参数。",paraId:0},{value:"// highlight-start\nnew G6.Graph(cfg: GraphOptions) => Graph\n// highlight-end\n\nconst graph = new G6.Graph({\n  container: '',\n  width: 500,\n  height: 500,\n  modes: {\n    default: ['drag-canvas'],\n  },\n  layout: {\n    type: 'radial',\n    unitRadius: 50,\n    center: [500, 300],\n  },\n});\n",paraId:1},{value:" ",paraId:2,tocIndex:0},{value:"string | HTMLElement",paraId:2,tocIndex:0},{value:" ",paraId:2,tocIndex:0},{value:"required",paraId:2,tocIndex:0},{value:" ",paraId:2,tocIndex:0},{value:"图的 DOM 容器，可以传入该 DOM 的 id 或者直接传入容器的 HTML 节点对象。",paraId:3,tocIndex:0},{value:" ",paraId:4,tocIndex:1},{value:"Number",paraId:4,tocIndex:1},{value:" ",paraId:4,tocIndex:1},{value:"optional",paraId:4,tocIndex:1},{value:" ",paraId:4,tocIndex:1},{value:"指定画布宽度，单位为 'px'，默认为画布容器宽度。",paraId:5,tocIndex:1},{value:" ",paraId:6,tocIndex:2},{value:"Number",paraId:6,tocIndex:2},{value:" ",paraId:6,tocIndex:2},{value:"optional",paraId:6,tocIndex:2},{value:" ",paraId:6,tocIndex:2},{value:"指定画布高度，单位为 'px'，默认为画布容器高度。",paraId:7,tocIndex:2},{value:" ",paraId:8,tocIndex:3},{value:"Boolean",paraId:8,tocIndex:3},{value:" ",paraId:8,tocIndex:3},{value:"optional",paraId:8,tocIndex:3},{value:" ",paraId:8,tocIndex:3},{value:"default:",paraId:8,tocIndex:3},{value:" ",paraId:8,tocIndex:3},{value:"false",paraId:8,tocIndex:3},{value:"是否开启画布自适应。开启后图自动适配画布大小。",paraId:9,tocIndex:3},{value:" ",paraId:10,tocIndex:4},{value:"Array | Number",paraId:10,tocIndex:4},{value:" ",paraId:10,tocIndex:4},{value:"optional",paraId:10,tocIndex:4},{value:" ",paraId:10,tocIndex:4},{value:"default:",paraId:10,tocIndex:4},{value:" ",paraId:10,tocIndex:4},{value:"0",paraId:10,tocIndex:4},{value:"fitView",paraId:11,tocIndex:4},{value:" 为 ",paraId:11,tocIndex:4},{value:"true",paraId:11,tocIndex:4},{value:" 时生效。图适应画布时，指定四周的留白。",paraId:11,tocIndex:4},{value:"- 可以是一个值, 例如：",paraId:11,tocIndex:4},{value:"fitViewPadding: 20",paraId:11,tocIndex:4},{value:"- 也可以是一个数组，例如：",paraId:11,tocIndex:4},{value:"fitViewPadding: [ 20, 40, 50, 20 ]",paraId:11,tocIndex:4},{value:"当指定一个值时，四边的边距都相等，当指定数组时，数组内数值依次对应 上，右，下，左四边的边距。",paraId:11,tocIndex:4},{value:" ",paraId:12,tocIndex:5},{value:"Boolean",paraId:12,tocIndex:5},{value:" ",paraId:12,tocIndex:5},{value:"optional",paraId:12,tocIndex:5},{value:" ",paraId:12,tocIndex:5},{value:"default:",paraId:12,tocIndex:5},{value:" ",paraId:12,tocIndex:5},{value:"false",paraId:12,tocIndex:5},{value:"*v3.5.1 后支持。*开启后，图将会被平移，图的中心将对齐到画布中心，但不缩放。优先级低于 fitView。",paraId:13,tocIndex:5},{value:" ",paraId:14,tocIndex:6},{value:"Boolean",paraId:14,tocIndex:6},{value:" ",paraId:14,tocIndex:6},{value:"optional",paraId:14,tocIndex:6},{value:" ",paraId:14,tocIndex:6},{value:"default:",paraId:14,tocIndex:6},{value:" ",paraId:14,tocIndex:6},{value:"false",paraId:14,tocIndex:6},{value:"指定边是否连入节点的中心。",paraId:15,tocIndex:6},{value:" ",paraId:16,tocIndex:7},{value:"Boolean",paraId:16,tocIndex:7},{value:" ",paraId:16,tocIndex:7},{value:"optional",paraId:16,tocIndex:7},{value:" ",paraId:16,tocIndex:7},{value:"default:",paraId:16,tocIndex:7},{value:" ",paraId:16,tocIndex:7},{value:"true",paraId:16,tocIndex:7},{value:"各种元素是否在一个分组内，决定节点和边的层级问题，默认情况下所有的节点在一个分组中，所有的边在一个分组中，当这个参数为 false 时，节点和边的层级根据生成的顺序确定。当使用 Combo 时，",paraId:17,tocIndex:7},{value:"必须",paraId:17,tocIndex:7},{value:"将其设置为 ",paraId:17,tocIndex:7},{value:"false",paraId:17,tocIndex:7},{value:" 。",paraId:17,tocIndex:7},{value:" ",paraId:18,tocIndex:8},{value:"Boolean",paraId:18,tocIndex:8},{value:" ",paraId:18,tocIndex:8},{value:"optional",paraId:18,tocIndex:8},{value:" ",paraId:18,tocIndex:8},{value:"default:",paraId:18,tocIndex:8},{value:" ",paraId:18,tocIndex:8},{value:"true",paraId:18,tocIndex:8},{value:"当图中元素更新，或视口变换时，是否自动重绘。建议在批量操作节点时关闭，以提高性能，完成批量操作后再打开，参见后面的 setAutoPaint() 方法。",paraId:19,tocIndex:8},{value:" ",paraId:20,tocIndex:9},{value:"Object",paraId:20,tocIndex:9},{value:" ",paraId:20,tocIndex:9},{value:"optional",paraId:20,tocIndex:9},{value:" ",paraId:20,tocIndex:9},{value:"default:",paraId:20,tocIndex:9},{value:" ",paraId:20,tocIndex:9},{value:"{}",paraId:20,tocIndex:9},{value:"设置画布的交互模式。详情可见 ",paraId:21,tocIndex:9},{value:"交互模式 Mode",paraId:22,tocIndex:9},{value:" 文档。",paraId:21,tocIndex:9},{value:" ",paraId:23,tocIndex:10},{value:"Object",paraId:23,tocIndex:10},{value:" ",paraId:23,tocIndex:10},{value:"optional",paraId:23,tocIndex:10},{value:" ",paraId:23,tocIndex:10},{value:"default:",paraId:23,tocIndex:10},{value:" ",paraId:23,tocIndex:10},{value:"[]",paraId:23,tocIndex:10},{value:"画布默认的模式。详情可参见 ",paraId:24,tocIndex:10},{value:"内置的 Behavior",paraId:25,tocIndex:10},{value:" 文档。",paraId:24,tocIndex:10},{value:" ",paraId:26,tocIndex:11},{value:"Object",paraId:26,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"optional",paraId:26,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"default:",paraId:26,tocIndex:11},{value:" ",paraId:26,tocIndex:11},{value:"{}",paraId:26,tocIndex:11},{value:"各个状态下节点的样式，例如 ",paraId:27,tocIndex:11},{value:"hover",paraId:27,tocIndex:11},{value:"、",paraId:27,tocIndex:11},{value:"selected",paraId:27,tocIndex:11},{value:"，3.1 版本新增。",paraId:27,tocIndex:11},{value:"⚠️ 注意:",paraId:28,tocIndex:11},{value:" G6 3.1 版本中实例化 Graph 时，新增了 ",paraId:28,tocIndex:11},{value:"nodeStateStyles",paraId:28,tocIndex:11},{value:" 及 ",paraId:28,tocIndex:11},{value:"edgeStateStyles",paraId:28,tocIndex:11},{value:" 两个配置项，删除了 ",paraId:28,tocIndex:11},{value:"nodeStyle",paraId:28,tocIndex:11},{value:" 和 ",paraId:28,tocIndex:11},{value:"edgeStyle",paraId:28,tocIndex:11},{value:" ，使用 3.1 以下版本的同学，只需要将 ",paraId:28,tocIndex:11},{value:"nodeStyle",paraId:28,tocIndex:11},{value:" 改成 ",paraId:28,tocIndex:11},{value:"nodeStateStyles",paraId:28,tocIndex:11},{value:" ，将 ",paraId:28,tocIndex:11},{value:"edgeStyle",paraId:28,tocIndex:11},{value:" 改成 ",paraId:28,tocIndex:11},{value:"edgeStateStyles",paraId:28,tocIndex:11},{value:" ，配置内容保持不变。",paraId:28,tocIndex:11},{value:" ",paraId:29,tocIndex:12},{value:"Object",paraId:29,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"optional",paraId:29,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"default:",paraId:29,tocIndex:12},{value:" ",paraId:29,tocIndex:12},{value:"{}",paraId:29,tocIndex:12},{value:"各个状态下边的样式，例如 ",paraId:30,tocIndex:12},{value:"hover",paraId:30,tocIndex:12},{value:"、",paraId:30,tocIndex:12},{value:"selected",paraId:30,tocIndex:12},{value:"，3.1 版本新增。",paraId:30,tocIndex:12},{value:" ",paraId:31,tocIndex:13},{value:"Object",paraId:31,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"optional",paraId:31,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"default:",paraId:31,tocIndex:13},{value:" ",paraId:31,tocIndex:13},{value:"{}",paraId:31,tocIndex:13},{value:"各个状态下 Combo 的样式，例如 ",paraId:32,tocIndex:13},{value:"hover",paraId:32,tocIndex:13},{value:"、",paraId:32,tocIndex:13},{value:"selected",paraId:32,tocIndex:13},{value:"，3.5 版本新增。",paraId:32,tocIndex:13},{value:" ",paraId:33,tocIndex:14},{value:"Object",paraId:33,tocIndex:14},{value:" ",paraId:33,tocIndex:14},{value:"optional",paraId:33,tocIndex:14},{value:" ",paraId:33,tocIndex:14},{value:"default:",paraId:33,tocIndex:14},{value:" ",paraId:33,tocIndex:14},{value:"{}",paraId:33,tocIndex:14},{value:"默认状态下节点的配置，比如 ",paraId:34,tocIndex:14},{value:"type",paraId:34,tocIndex:14},{value:", ",paraId:34,tocIndex:14},{value:"size",paraId:34,tocIndex:14},{value:", ",paraId:34,tocIndex:14},{value:"color",paraId:34,tocIndex:14},{value:"。会被写入的 data 覆盖。 见 ",paraId:34,tocIndex:14},{value:"节点的通用属性",paraId:35,tocIndex:14},{value:" 。",paraId:34,tocIndex:14},{value:" ",paraId:36,tocIndex:15},{value:"Object",paraId:36,tocIndex:15},{value:" ",paraId:36,tocIndex:15},{value:"optional",paraId:36,tocIndex:15},{value:" ",paraId:36,tocIndex:15},{value:"default:",paraId:36,tocIndex:15},{value:" ",paraId:36,tocIndex:15},{value:"{}",paraId:36,tocIndex:15},{value:"默认状态下边的配置，比如 ",paraId:37,tocIndex:15},{value:"type",paraId:37,tocIndex:15},{value:", ",paraId:37,tocIndex:15},{value:"size",paraId:37,tocIndex:15},{value:", ",paraId:37,tocIndex:15},{value:"color",paraId:37,tocIndex:15},{value:"。会被写入的 data 覆盖。 见 ",paraId:37,tocIndex:15},{value:"边的通用属性",paraId:38,tocIndex:15},{value:" 。",paraId:37,tocIndex:15},{value:" ",paraId:39,tocIndex:16},{value:"Object",paraId:39,tocIndex:16},{value:" ",paraId:39,tocIndex:16},{value:"optional",paraId:39,tocIndex:16},{value:" ",paraId:39,tocIndex:16},{value:"default:",paraId:39,tocIndex:16},{value:" ",paraId:39,tocIndex:16},{value:"{}",paraId:39,tocIndex:16},{value:"默认状态下 Combo 的配置，比如 ",paraId:40,tocIndex:16},{value:"type",paraId:40,tocIndex:16},{value:", ",paraId:40,tocIndex:16},{value:"color",paraId:40,tocIndex:16},{value:"。会被写入的 data 覆盖。3.5 版本新增。 见 ",paraId:40,tocIndex:16},{value:"Combo 的通用属性",paraId:41,tocIndex:16},{value:" 。",paraId:40,tocIndex:16},{value:" _Array _ ",paraId:42,tocIndex:17},{value:"optional",paraId:42,tocIndex:17},{value:" ",paraId:42,tocIndex:17},{value:"default:",paraId:42,tocIndex:17},{value:" ",paraId:42,tocIndex:17},{value:"[]",paraId:42,tocIndex:17},{value:"向 graph 注册插件。插件机制请见：",paraId:43,tocIndex:17},{value:"插件",paraId:44,tocIndex:17},{value:" 。",paraId:43,tocIndex:17},{value:" _Boolean _ ",paraId:45,tocIndex:18},{value:"optional",paraId:45,tocIndex:18},{value:" ",paraId:45,tocIndex:18},{value:"default:",paraId:45,tocIndex:18},{value:" ",paraId:45,tocIndex:18},{value:"false",paraId:45,tocIndex:18},{value:"是否启用全局动画。",paraId:46,tocIndex:18},{value:" ",paraId:47,tocIndex:19},{value:"Object",paraId:47,tocIndex:19},{value:" ",paraId:47,tocIndex:19},{value:"optional",paraId:47,tocIndex:19},{value:" ",paraId:47,tocIndex:19},{value:"default:",paraId:47,tocIndex:19},{value:" ",paraId:47,tocIndex:19},{value:"{}",paraId:47,tocIndex:19},{value:"动画配置项，仅在 ",paraId:48,tocIndex:19},{value:"animate",paraId:48,tocIndex:19},{value:" 为 ",paraId:48,tocIndex:19},{value:"true",paraId:48,tocIndex:19},{value:" 时有效。关于 ",paraId:48,tocIndex:19},{value:"animateCfg",paraId:48,tocIndex:19},{value:" 的更多配置项参见",paraId:48,tocIndex:19},{value:"基础动画教程",paraId:49,tocIndex:19},{value:"。",paraId:48,tocIndex:19},{value:" ",paraId:50,tocIndex:20},{value:"Function",paraId:50,tocIndex:20},{value:" ",paraId:50,tocIndex:20},{value:"optional",paraId:50,tocIndex:20},{value:" ",paraId:50,tocIndex:20},{value:"default:",paraId:50,tocIndex:20},{value:" ",paraId:50,tocIndex:20},{value:"null",paraId:50,tocIndex:20},{value:"回调函数，用于自定义节点运动路径，为空时线性运动。",paraId:51,tocIndex:20},{value:" ",paraId:52,tocIndex:21},{value:"Number",paraId:52,tocIndex:21},{value:" ",paraId:52,tocIndex:21},{value:"optional",paraId:52,tocIndex:21},{value:" ",paraId:52,tocIndex:21},{value:"default:",paraId:52,tocIndex:21},{value:" ",paraId:52,tocIndex:21},{value:"500",paraId:52,tocIndex:21},{value:"动画时长，单位为毫秒。",paraId:53,tocIndex:21},{value:" ",paraId:54,tocIndex:22},{value:"string",paraId:54,tocIndex:22},{value:" ",paraId:54,tocIndex:22},{value:"optional",paraId:54,tocIndex:22},{value:" ",paraId:54,tocIndex:22},{value:"default:",paraId:54,tocIndex:22},{value:" ",paraId:54,tocIndex:22},{value:"easeLinear",paraId:54,tocIndex:22},{value:"动画动效，可参见 d3 ease。",paraId:55,tocIndex:22},{value:" ",paraId:56,tocIndex:23},{value:"Number",paraId:56,tocIndex:23},{value:" ",paraId:56,tocIndex:23},{value:"optional",paraId:56,tocIndex:23},{value:" ",paraId:56,tocIndex:23},{value:"default:",paraId:56,tocIndex:23},{value:" ",paraId:56,tocIndex:23},{value:"0.02",paraId:56,tocIndex:23},{value:"最小缩放比例。若 fitView、zoom、zoomTo 等操作导致图的缩放比例小于该值，则将使用该值进行缩放，并返回 false。",paraId:57,tocIndex:23},{value:" ",paraId:58,tocIndex:24},{value:"Number",paraId:58,tocIndex:24},{value:" ",paraId:58,tocIndex:24},{value:"optional",paraId:58,tocIndex:24},{value:" ",paraId:58,tocIndex:24},{value:"default:",paraId:58,tocIndex:24},{value:" ",paraId:58,tocIndex:24},{value:"10",paraId:58,tocIndex:24},{value:"最大缩放比例。若 fitView、zoom、zoomTo 等操作导致图的缩放比例大于该值，则将使用该值进行缩放，并返回 false。",paraId:59,tocIndex:24},{value:" ",paraId:60,tocIndex:25},{value:"Object",paraId:60,tocIndex:25},{value:" ",paraId:60,tocIndex:25},{value:"optional",paraId:60,tocIndex:25},{value:" ",paraId:60,tocIndex:25},{value:"default:",paraId:60,tocIndex:25},{value:" ",paraId:60,tocIndex:25},{value:"{}",paraId:60,tocIndex:25},{value:"布局配置项，使用 type 字段指定使用的布局方式，type 可取以下值：random, radial, mds, circular, fruchterman, force, gForce, forceAtlas2, dagre, concentric, grid。当实例化图时没有配置 ",paraId:61,tocIndex:25},{value:"layout",paraId:61,tocIndex:25},{value:" 时：",paraId:61,tocIndex:25},{value:"若数据中节点有位置信息（",paraId:62,tocIndex:25},{value:"x",paraId:62,tocIndex:25},{value:" 和 ",paraId:62,tocIndex:25},{value:"y",paraId:62,tocIndex:25},{value:"），则按照数据的位置信息进行绘制；",paraId:62,tocIndex:25},{value:"若数据中节点没有位置信息，则默认使用 Random Layout 进行布局。",paraId:62,tocIndex:25},{value:"每种布局方法的配置项不尽相同，具体参见 ",paraId:63,tocIndex:25},{value:"Graph 内置布局",paraId:64,tocIndex:25},{value:"。",paraId:63,tocIndex:25},{value:"流水线子图布局",paraId:65,tocIndex:26},{value:" ",paraId:65,tocIndex:26},{value:"v4.3.0 新增",paraId:65,tocIndex:26},{value:"在 ",paraId:66,tocIndex:26},{value:"GraphOptions.layout",paraId:66,tocIndex:26},{value:" 中可配置 ",paraId:66,tocIndex:26},{value:"pipes",paraId:66,tocIndex:26},{value:" 达到同时对不通过子图使用不同布局的目的。",paraId:66,tocIndex:26},{value:"在实例化图时配置 ",paraId:67,tocIndex:26},{value:"layout.pipes",paraId:67,tocIndex:26},{value:" 数组，指定多个子图布局的布局类型（",paraId:67,tocIndex:26},{value:"type",paraId:67,tocIndex:26},{value:"）、布局参数、节点过滤函数（",paraId:67,tocIndex:26},{value:"nodesFilter",paraId:67,tocIndex:26},{value:"）。值得注意的是，若某些节点同时属于不同的子图（即这些节点在不同的子图的 ",paraId:67,tocIndex:26},{value:"nodesFilter",paraId:67,tocIndex:26},{value:" 配置都返回为 ",paraId:67,tocIndex:26},{value:"true",paraId:67,tocIndex:26},{value:"），则这些节点位置的计算将按照 ",paraId:67,tocIndex:26},{value:"pipes",paraId:67,tocIndex:26},{value:" 数组顺序后者覆盖前者。",paraId:67,tocIndex:26},{value:"pipes",paraId:68,tocIndex:26},{value:" 的数据类型为：",paraId:68,tocIndex:26},{value:"type Pipes =\n  {\n    // 该子图所使用的布局类型\n    type: 'random' | 'radial' | 'mds' | 'circular' | 'fruchterman' | 'force' | 'gForce' | 'dagre' | 'concentric' | 'grid' | 'forceAtlas2',\n    // 节点的筛选器，参数为节点数据，返回布尔值代表该节点是否在该子图中\n    nodesFilter: (node: NodeData) => boolean;\n    ... // 布局对应的参数，详见各个布局的参数\n  }[];\n",paraId:69,tocIndex:26},{value:"使用方法如下：",paraId:70,tocIndex:26},{value:"layout: {\n  pipes: [\n    {\n      // 该子图所使用的布局类型\n      type: 'circular',\n      // 根据节点的某个字段判断是否属于该子图\n      nodesFilter: (node) => node.subGraphId === '1'\n    },\n    {\n      type: 'grid',\n      // 该 grid 布局的其他参数\n      begin: [100, 0],\n      nodesFilter: (node) => node.subGraphId === '2'\n    }\n  ],\n},\n",paraId:71,tocIndex:26},{value:" _'canvas' / 'svg' _ ",paraId:72,tocIndex:27},{value:"optional",paraId:72,tocIndex:27},{value:" ",paraId:72,tocIndex:27},{value:"default:",paraId:72,tocIndex:27},{value:" ",paraId:72,tocIndex:27},{value:"'canvas'",paraId:72,tocIndex:27},{value:"渲染方式，该配置项除 V3.3.x 外其他版本均支持。",paraId:73,tocIndex:27},{value:" ",paraId:74,tocIndex:28},{value:"boolean",paraId:74,tocIndex:28},{value:" ",paraId:74,tocIndex:28},{value:"optional",paraId:74,tocIndex:28},{value:" ",paraId:74,tocIndex:28},{value:"default:",paraId:74,tocIndex:28},{value:" ",paraId:74,tocIndex:28},{value:"false",paraId:74,tocIndex:28},{value:"是否启用 stack，即是否开启 redo & undo 功能，该配置项 V3.6 及以上版本支持。",paraId:75,tocIndex:28},{value:" ",paraId:76,tocIndex:29},{value:"number",paraId:76,tocIndex:29},{value:" ",paraId:76,tocIndex:29},{value:"optional",paraId:76,tocIndex:29},{value:" ",paraId:76,tocIndex:29},{value:"default:",paraId:76,tocIndex:29},{value:" ",paraId:76,tocIndex:29},{value:"10",paraId:76,tocIndex:29},{value:"redo & undo 最大步数, 只有当 enabledStack 为 true 时才起作用，该配置项 V3.6 及以上版本支持。",paraId:77,tocIndex:29}]},53557:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图形分组 Graphics Group（下文简称 Group） 类似于 ",paraId:0},{value:"SVG 中的 ",paraId:0},{value:"<g>",paraId:0},{value:" 标签",paraId:0},{value:"：Group  是用来组合图形对象的容器。在 Group  上添加变换（例如剪裁、旋转、放缩、平移等）会应用到其所有的子元素上。在 Group  上添加属性（例如颜色、位置等）会被其所有的子元素继承。此外， Group 可以多层嵌套使用，因此可以用来定义复杂的对象。关于 Group 更详细的介绍请参考 ",paraId:0},{value:"图形分组 Group",paraId:1},{value:" 文档。",paraId:0},{value:"// 获取元素(节点/边/Combo)的图形对象的容器\nconst group = item.getContainer();\n\n// 等价于\nconst group = item.get('group');\n",paraId:2,tocIndex:0},{value:"向分组中添加新的分组。",paraId:3,tocIndex:2},{value:"参数",paraId:4,tocIndex:2},{value:"名称",paraId:5,tocIndex:2},{value:"类型",paraId:5,tocIndex:2},{value:"说明",paraId:5,tocIndex:2},{value:"cfg",paraId:5,tocIndex:2},{value:"Object",paraId:5,tocIndex:2},{value:"分组到配置项，非必须",paraId:5,tocIndex:2},{value:"其中，",paraId:6,tocIndex:2},{value:"cfg",paraId:6,tocIndex:2},{value:" 不是必须指定到，它包括以下字段：",paraId:6,tocIndex:2},{value:"名称",paraId:7,tocIndex:2},{value:"类型",paraId:7,tocIndex:2},{value:"说明",paraId:7,tocIndex:2},{value:"id",paraId:7,tocIndex:2},{value:"String",paraId:7,tocIndex:2},{value:"图形分组的唯一标识，非必须指定，指定则必须唯一",paraId:7,tocIndex:2},{value:"name",paraId:7,tocIndex:2},{value:"String",paraId:7,tocIndex:2},{value:"图形分组的标识，必须指定，",paraId:7,tocIndex:2},{value:"在同一元素类型中必须唯一",paraId:7,tocIndex:2},{value:"。另外，",paraId:7,tocIndex:2},{value:"name",paraId:7,tocIndex:2},{value:" 可以用于组内搜索到该元素：",paraId:7,tocIndex:2},{value:"const shape = group.find(element => element.get('name') === 'shape-name')",paraId:7,tocIndex:2},{value:"，find 函数用法见 ",paraId:7,tocIndex:2},{value:"find(fn)",paraId:8,tocIndex:2},{value:"capture",paraId:7,tocIndex:2},{value:"Boolean",paraId:7,tocIndex:2},{value:"非必须指定，该图形分组是否可以被鼠标事件捕捉到，即是否能够响应各鼠标事件。非必须指定",paraId:7,tocIndex:2},{value:"visible",paraId:7,tocIndex:2},{value:"Boolean",paraId:7,tocIndex:2},{value:"非必须指定，该图形分组是否可见。非必须指定，默认为 ",paraId:7,tocIndex:2},{value:"true",paraId:7,tocIndex:2},{value:"draggable",paraId:7,tocIndex:2},{value:"Boolean",paraId:7,tocIndex:2},{value:"非必须指定，该图形分组是否允许被拖拽。例如，自定义节点通过 ",paraId:7,tocIndex:2},{value:"addGroup",paraId:7,tocIndex:2},{value:" 添加图形分组，当该图形分组的 ",paraId:7,tocIndex:2},{value:"draggable",paraId:7,tocIndex:2},{value:" 值为 ",paraId:7,tocIndex:2},{value:"true",paraId:7,tocIndex:2},{value:" 时，鼠标在该自定义节点的这个图形分组上才能够响应 ",paraId:7,tocIndex:2},{value:"dragstart",paraId:7,tocIndex:2},{value:"，",paraId:7,tocIndex:2},{value:"drag",paraId:7,tocIndex:2},{value:"，与 ",paraId:7,tocIndex:2},{value:"dragend",paraId:7,tocIndex:2},{value:" 事件；在实例化图时的 ",paraId:7,tocIndex:2},{value:"modes",paraId:7,tocIndex:2},{value:" 中配置的 ",paraId:7,tocIndex:2},{value:"'drag-node'",paraId:7,tocIndex:2},{value:" 交互才可以在该图形分组上进行拖拽时生效",paraId:7,tocIndex:2},{value:"zIndex",paraId:7,tocIndex:2},{value:"Number",paraId:7,tocIndex:2},{value:"非必须指定，该图形分组的视觉层次 z-index。非必须指定。指定后，调用 ",paraId:7,tocIndex:2},{value:"group.sort()",paraId:7,tocIndex:2},{value:" 可以对组内所有图形根据各自 zIndex 进行视觉层次的排序",paraId:7,tocIndex:2},{value:"用法",paraId:9,tocIndex:2},{value:"// No configurations\ngroup.addGroup();\n\n// Configured\ngroup.addGroup({\n  id: 'groupId',\n  draggable: true,\n  // other configurations\n});\n",paraId:10,tocIndex:2},{value:"向分组中添加新的图形。",paraId:11,tocIndex:3},{value:"⚠️ 注意:",paraId:11,tocIndex:3},{value:" 在分组上添加的 clip， transform 等操作会影响到该分组中的所有图形。所有图形及其绘图属性请见 ",paraId:11,tocIndex:3},{value:"Shape Doc",paraId:12,tocIndex:3},{value:"。",paraId:11,tocIndex:3},{value:"参数",paraId:13,tocIndex:3},{value:"名称",paraId:14,tocIndex:3},{value:"类型",paraId:14,tocIndex:3},{value:"说明",paraId:14,tocIndex:3},{value:"type",paraId:14,tocIndex:3},{value:"String",paraId:14,tocIndex:3},{value:"图元素类型，值可以为：",paraId:14,tocIndex:3},{value:"'rect'",paraId:14,tocIndex:3},{value:"、",paraId:14,tocIndex:3},{value:"'circle'",paraId:14,tocIndex:3},{value:"、",paraId:14,tocIndex:3},{value:"'fan'",paraId:14,tocIndex:3},{value:"、",paraId:14,tocIndex:3},{value:"'ellipse'",paraId:14,tocIndex:3},{value:"、",paraId:14,tocIndex:3},{value:"'marker'",paraId:14,tocIndex:3},{value:"、",paraId:14,tocIndex:3},{value:"'image'",paraId:14,tocIndex:3},{value:" 等，具体参考 ",paraId:14,tocIndex:3},{value:"Shape 的类型及属性",paraId:15,tocIndex:3},{value:" 教程",paraId:14,tocIndex:3},{value:"cfg",paraId:14,tocIndex:3},{value:"Object",paraId:14,tocIndex:3},{value:"图元素的属性",paraId:14,tocIndex:3},{value:"其中，",paraId:16,tocIndex:3},{value:"cfg",paraId:16,tocIndex:3},{value:" 包括以下字段：",paraId:16,tocIndex:3},{value:"名称",paraId:17,tocIndex:3},{value:"类型",paraId:17,tocIndex:3},{value:"说明",paraId:17,tocIndex:3},{value:"attrs",paraId:17,tocIndex:3},{value:"Object",paraId:17,tocIndex:3},{value:"图形样式，必须配置，例如：",paraId:17,tocIndex:3},{value:"{x: 0, y: 10, fill: '#0f0'}",paraId:17,tocIndex:3},{value:"name",paraId:17,tocIndex:3},{value:"String",paraId:17,tocIndex:3},{value:"图形的标识，必须指定，",paraId:17,tocIndex:3},{value:"在同一元素类型中必须唯一",paraId:17,tocIndex:3},{value:"。另外，",paraId:17,tocIndex:3},{value:"name",paraId:17,tocIndex:3},{value:" 可以用于组内搜索到该元素：",paraId:17,tocIndex:3},{value:"const shape = group.find(element => element.get('name') === 'shape-name')",paraId:17,tocIndex:3},{value:"，find 函数用法见 ",paraId:17,tocIndex:3},{value:"find(fn)",paraId:18,tocIndex:3},{value:"capture",paraId:17,tocIndex:3},{value:"Boolean",paraId:17,tocIndex:3},{value:"该图形是否可以被鼠标事件捕捉到，即是否能够响应各鼠标事件。非必须指定",paraId:17,tocIndex:3},{value:"visible",paraId:17,tocIndex:3},{value:"Boolean",paraId:17,tocIndex:3},{value:"该图形是否可见。非必须指定，默认为 ",paraId:17,tocIndex:3},{value:"true",paraId:17,tocIndex:3},{value:"draggable",paraId:17,tocIndex:3},{value:"Boolean",paraId:17,tocIndex:3},{value:"该图形是否允许被拖拽。例如，自定义节点通过 ",paraId:17,tocIndex:3},{value:"addShape",paraId:17,tocIndex:3},{value:" 添加图形，当该图形的 ",paraId:17,tocIndex:3},{value:"draggable",paraId:17,tocIndex:3},{value:" 值为 ",paraId:17,tocIndex:3},{value:"true",paraId:17,tocIndex:3},{value:" 时，鼠标在该自定义节点的这个图形上才能够响应 ",paraId:17,tocIndex:3},{value:"dragstart",paraId:17,tocIndex:3},{value:"，",paraId:17,tocIndex:3},{value:"drag",paraId:17,tocIndex:3},{value:"，与 ",paraId:17,tocIndex:3},{value:"dragend",paraId:17,tocIndex:3},{value:" 事件；在实例化图时的 ",paraId:17,tocIndex:3},{value:"modes",paraId:17,tocIndex:3},{value:" 中配置的 ",paraId:17,tocIndex:3},{value:"'drag-node'",paraId:17,tocIndex:3},{value:" 交互才可以在该图形上进行拖拽时生效",paraId:17,tocIndex:3},{value:"zIndex",paraId:17,tocIndex:3},{value:"Number",paraId:17,tocIndex:3},{value:"该图形的视觉层次 z-index。非必须指定。指定后，调用 ",paraId:17,tocIndex:3},{value:"group.sort()",paraId:17,tocIndex:3},{value:" 可以对组内所有图形根据各自 zIndex 进行视觉层次的排序",paraId:17,tocIndex:3},{value:"用法",paraId:19,tocIndex:3},{value:"group.addShape('rect', {\n  attrs: {\n    x: 0, // 必须配置\n    y: 0, // 必须配置\n    fill: 'red',\n    stroke: 'red',\n    shadowOffsetX: 10,\n    shadowOffsetY: 10,\n    shadowColor: 'blue',\n    shadowBlur: 10,\n    opacity: 0.8,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n  zIndex: 1,\n});\n",paraId:20,tocIndex:3},{value:"该分组是否包含此元素。",paraId:21,tocIndex:4},{value:"返回值: Boolean",paraId:21,tocIndex:4},{value:"参数",paraId:22,tocIndex:4},{value:"名称",paraId:23,tocIndex:4},{value:"类型",paraId:23,tocIndex:4},{value:"说明",paraId:23,tocIndex:4},{value:"child",paraId:23,tocIndex:4},{value:"Group / Shape",paraId:23,tocIndex:4},{value:"子 Group 或 Shape 实例",paraId:23,tocIndex:4},{value:"用法",paraId:24,tocIndex:4},{value:"const has = group.contain(child);\n",paraId:25,tocIndex:4},{value:"根据指定条件返回对应元素，",paraId:26,tocIndex:5},{value:"只返回符合条件的第一个元素",paraId:26,tocIndex:5},{value:"。",paraId:26,tocIndex:5},{value:"参数",paraId:27,tocIndex:5},{value:"名称",paraId:28,tocIndex:5},{value:"类型",paraId:28,tocIndex:5},{value:"说明",paraId:28,tocIndex:5},{value:"fn",paraId:28,tocIndex:5},{value:"Function",paraId:28,tocIndex:5},{value:"自定义回调函数",paraId:28,tocIndex:5},{value:"用法",paraId:29,tocIndex:5},{value:"const child = group.find(function (item) {\n  return item.attr('fill') === 'red'; // 找到首个填充为红色的图形\n});\n",paraId:30,tocIndex:5},{value:"根据元素 ID 返回对应的实例。",paraId:31,tocIndex:6},{value:"返回值：Object。",paraId:31,tocIndex:6},{value:"参数",paraId:32,tocIndex:6},{value:"名称",paraId:33,tocIndex:6},{value:"类型",paraId:33,tocIndex:6},{value:"说明",paraId:33,tocIndex:6},{value:"id",paraId:33,tocIndex:6},{value:"String",paraId:33,tocIndex:6},{value:"Group 实例 ID",paraId:33,tocIndex:6},{value:"用法",paraId:34,tocIndex:6},{value:"const group1 = group.findById('group1');\n",paraId:35,tocIndex:6},{value:"返回所有符合条件的元素。",paraId:36,tocIndex:7},{value:"返回值: [ Object ]",paraId:36,tocIndex:7},{value:"参数",paraId:37,tocIndex:7},{value:"名称",paraId:38,tocIndex:7},{value:"类型",paraId:38,tocIndex:7},{value:"说明",paraId:38,tocIndex:7},{value:"fn",paraId:38,tocIndex:7},{value:"Function",paraId:38,tocIndex:7},{value:"自定义回调函数",paraId:38,tocIndex:7},{value:"用法",paraId:39,tocIndex:7},{value:"const children = group.findAll(function (item) {\n  return item.get('id') < 10; // 获取所有id小于10的元素\n});\n",paraId:40,tocIndex:7},{value:"返回该坐标点最上层的元素。",paraId:41,tocIndex:8},{value:"返回值: Object",paraId:41,tocIndex:8},{value:"参数",paraId:42,tocIndex:8},{value:"名称",paraId:43,tocIndex:8},{value:"类型",paraId:43,tocIndex:8},{value:"说明",paraId:43,tocIndex:8},{value:"x",paraId:43,tocIndex:8},{value:"Number",paraId:43,tocIndex:8},{value:"x 坐标",paraId:43,tocIndex:8},{value:"y",paraId:43,tocIndex:8},{value:"Number",paraId:43,tocIndex:8},{value:"y 坐标",paraId:43,tocIndex:8},{value:"用法",paraId:44,tocIndex:8},{value:"// 获取 (10, 30) 坐标点上层的元素\nconst element = group.getShape(10, 30);\n",paraId:45,tocIndex:8},{value:"获取该分组的第一个子元素。",paraId:46,tocIndex:9},{value:"返回值: Object",paraId:46,tocIndex:9},{value:"用法",paraId:47,tocIndex:9},{value:"const child = group.getFirst();\n\n// 等价于\nconst childrens = group.get('children');\nconst child = childrens[0];\n",paraId:48,tocIndex:9},{value:"获取该分组的最后一个子元素。",paraId:49,tocIndex:10},{value:"返回值: Object",paraId:49,tocIndex:10},{value:"用法",paraId:50,tocIndex:10},{value:"const child = group.getLast();\n\n// 等价于\nconst childrens = group.get('children');\nconst child = childrens[childrens.length - 1];\n",paraId:51,tocIndex:10},{value:"返回第 ",paraId:52,tocIndex:11},{value:"index",paraId:52,tocIndex:11},{value:"  个子元素，从 ",paraId:52,tocIndex:11},{value:"0",paraId:52,tocIndex:11},{value:" 开始计数。",paraId:52,tocIndex:11},{value:"返回值: Object",paraId:52,tocIndex:11},{value:"参数",paraId:53,tocIndex:11},{value:"名称",paraId:54,tocIndex:11},{value:"类型",paraId:54,tocIndex:11},{value:"说明",paraId:54,tocIndex:11},{value:"index",paraId:54,tocIndex:11},{value:"Number",paraId:54,tocIndex:11},{value:"子元素的序号，默认为 ",paraId:54,tocIndex:11},{value:"0",paraId:54,tocIndex:11},{value:"用法",paraId:55,tocIndex:11},{value:"const child = group.getChildByIndex(2);\n",paraId:56,tocIndex:11},{value:"从分组中删除一个分组或一个图形。",paraId:57,tocIndex:12},{value:"参数",paraId:58,tocIndex:12},{value:"名称",paraId:59,tocIndex:12},{value:"类型",paraId:59,tocIndex:12},{value:"说明",paraId:59,tocIndex:12},{value:"child",paraId:59,tocIndex:12},{value:"Group / Shape",paraId:59,tocIndex:12},{value:"子 group 或 Shape 实例",paraId:59,tocIndex:12},{value:"用法",paraId:60,tocIndex:12},{value:"group.removeChild(child);\n",paraId:61,tocIndex:12},{value:"排序方法。",paraId:62,tocIndex:13},{value:"一般用于在设置子元素层叠顺序时使用。",paraId:62,tocIndex:13},{value:"典型使用场景：通过 ",paraId:63,tocIndex:13},{value:"group.addShape()",paraId:63,tocIndex:13},{value:" 添加 ",paraId:63,tocIndex:13},{value:"shape",paraId:63,tocIndex:13},{value:" 时，添加的每个 ",paraId:63,tocIndex:13},{value:"shape",paraId:63,tocIndex:13},{value:" 都设置了 ",paraId:63,tocIndex:13},{value:"index",paraId:63,tocIndex:13},{value:"，在最后调用 ",paraId:63,tocIndex:13},{value:"group.sort()",paraId:63,tocIndex:13},{value:" 可以对添加的 ",paraId:63,tocIndex:13},{value:"shape",paraId:63,tocIndex:13},{value:" 进行排序。",paraId:63,tocIndex:13},{value:"用法",paraId:64,tocIndex:13},{value:"group.sort();\n",paraId:65,tocIndex:13},{value:"清除该组的所有子元素。",paraId:66,tocIndex:14},{value:"用法",paraId:67,tocIndex:14},{value:"group.clear();\n",paraId:68,tocIndex:14}]},50471:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Combo 继承自 Node，具有 Node 的所有特性。本文仅介绍 Combo 类的通用方法，内置Combo见 ",paraId:0},{value:"内置 Combo 文档",paraId:1},{value:" 和 ",paraId:0},{value:"demo",paraId:2},{value:"，自定义Combo见 ",paraId:0},{value:"自定义 Combo 文档",paraId:3},{value:" 和 ",paraId:0},{value:"demo",paraId:4},{value:"。",paraId:0},{value:"获取 Combo 中所有的子元素，包括 Combo 和 Node。",paraId:5,tocIndex:0},{value:"返回值",paraId:6,tocIndex:0},{value:"返回值为子 node 和 combo 的集合：",paraId:7,tocIndex:0},{value:"{ nodes: INode[], combos: ICombo[] }",paraId:7,tocIndex:0},{value:"用法",paraId:8,tocIndex:0},{value:"const elements = combo.getChildren();\n",paraId:9,tocIndex:0},{value:"获取 Combo 中所有子节点。",paraId:10,tocIndex:1},{value:"返回值",paraId:11,tocIndex:1},{value:"返回值类型为 ",paraId:12,tocIndex:1},{value:"INode[]",paraId:12,tocIndex:1},{value:"。",paraId:12,tocIndex:1},{value:"获取 Combo 中所有子 combo。",paraId:13,tocIndex:2},{value:"返回值",paraId:14,tocIndex:2},{value:"返回值类型为 ",paraId:15,tocIndex:2},{value:"ICombo[]",paraId:15,tocIndex:2},{value:"。",paraId:15,tocIndex:2},{value:"向 Combo 中添加子 Node 或子 Combo。",paraId:16,tocIndex:3},{value:"参数",paraId:17,tocIndex:3},{value:"名称",paraId:18,tocIndex:3},{value:"类型",paraId:18,tocIndex:3},{value:"是否必选",paraId:18,tocIndex:3},{value:"描述",paraId:18,tocIndex:3},{value:"item",paraId:18,tocIndex:3},{value:"INode / ICombo",paraId:18,tocIndex:3},{value:"是",paraId:18,tocIndex:3},{value:"节点或 Combo 的实例",paraId:18,tocIndex:3},{value:"返回值",paraId:19,tocIndex:3},{value:"类型： ",paraId:20,tocIndex:3},{value:"boolean",paraId:20,tocIndex:3},{value:"；",paraId:20,tocIndex:3},{value:"含义：返回 ",paraId:20,tocIndex:3},{value:"true",paraId:20,tocIndex:3},{value:" 表示添加成功。",paraId:20,tocIndex:3},{value:"用法",paraId:21,tocIndex:3},{value:"const node = graph.findById('node1');\n\n// 如果返回结果为 true，则说明添加成功\nconst result = combo.addChild(node);\n",paraId:22,tocIndex:3},{value:"向 combo 中添加节点。",paraId:23,tocIndex:4},{value:"参数",paraId:24,tocIndex:4},{value:"名称",paraId:25,tocIndex:4},{value:"类型",paraId:25,tocIndex:4},{value:"是否必选",paraId:25,tocIndex:4},{value:"描述",paraId:25,tocIndex:4},{value:"node",paraId:25,tocIndex:4},{value:"string / INode",paraId:25,tocIndex:4},{value:"是",paraId:25,tocIndex:4},{value:"节点 ID 或节点实例",paraId:25,tocIndex:4},{value:"返回值",paraId:26,tocIndex:4},{value:"类型： ",paraId:27,tocIndex:4},{value:"boolean",paraId:27,tocIndex:4},{value:"；",paraId:27,tocIndex:4},{value:"含义：返回 ",paraId:27,tocIndex:4},{value:"true",paraId:27,tocIndex:4},{value:" 表示添加成功。",paraId:27,tocIndex:4},{value:"向 combo 中添加 combo。",paraId:28,tocIndex:5},{value:"参数",paraId:29,tocIndex:5},{value:"名称",paraId:30,tocIndex:5},{value:"类型",paraId:30,tocIndex:5},{value:"是否必选",paraId:30,tocIndex:5},{value:"描述",paraId:30,tocIndex:5},{value:"combo",paraId:30,tocIndex:5},{value:"ICombo",paraId:30,tocIndex:5},{value:"是",paraId:30,tocIndex:5},{value:"combo 实例",paraId:30,tocIndex:5},{value:"返回值",paraId:31,tocIndex:5},{value:"类型： ",paraId:32,tocIndex:5},{value:"boolean",paraId:32,tocIndex:5},{value:"；",paraId:32,tocIndex:5},{value:"含义：返回 ",paraId:32,tocIndex:5},{value:"true",paraId:32,tocIndex:5},{value:" 表示添加成功。",paraId:32,tocIndex:5},{value:"移除子元素（子节点或子 combo）。",paraId:33,tocIndex:6},{value:"参数",paraId:34,tocIndex:6},{value:"名称",paraId:35,tocIndex:6},{value:"类型",paraId:35,tocIndex:6},{value:"是否必选",paraId:35,tocIndex:6},{value:"描述",paraId:35,tocIndex:6},{value:"item",paraId:35,tocIndex:6},{value:"INode / ICombo",paraId:35,tocIndex:6},{value:"是",paraId:35,tocIndex:6},{value:"节点或 Combo 的实例",paraId:35,tocIndex:6},{value:"返回值",paraId:36,tocIndex:6},{value:"类型： ",paraId:37,tocIndex:6},{value:"boolean",paraId:37,tocIndex:6},{value:"；",paraId:37,tocIndex:6},{value:"含义：返回 ",paraId:37,tocIndex:6},{value:"true",paraId:37,tocIndex:6},{value:" 表示移除成功。",paraId:37,tocIndex:6},{value:"移除指定的子 combo。注意：移除后 ",paraId:38,tocIndex:7},{value:"combo",paraId:38,tocIndex:7},{value:" 不再属于该父 Combo，但没有被删除。需要删除 ",paraId:38,tocIndex:7},{value:"combo",paraId:38,tocIndex:7},{value:" 请调用 ",paraId:38,tocIndex:7},{value:"graph.removeItem",paraId:39,tocIndex:7},{value:"参数",paraId:40,tocIndex:7},{value:"名称",paraId:41,tocIndex:7},{value:"类型",paraId:41,tocIndex:7},{value:"是否必选",paraId:41,tocIndex:7},{value:"描述",paraId:41,tocIndex:7},{value:"combo",paraId:41,tocIndex:7},{value:"ICombo",paraId:41,tocIndex:7},{value:"是",paraId:41,tocIndex:7},{value:"Combo 的实例",paraId:41,tocIndex:7},{value:"返回值",paraId:42,tocIndex:7},{value:"类型： ",paraId:43,tocIndex:7},{value:"boolean",paraId:43,tocIndex:7},{value:"；",paraId:43,tocIndex:7},{value:"含义：返回 ",paraId:43,tocIndex:7},{value:"true",paraId:43,tocIndex:7},{value:" 表示移除成功。",paraId:43,tocIndex:7},{value:"移除指定的子 Node。注意：移除后该节点不再属于该 Combo，但没有被删除。需要删除节点请调用 ",paraId:44,tocIndex:8},{value:"graph.removeItem",paraId:45,tocIndex:8},{value:"参数",paraId:46,tocIndex:8},{value:"名称",paraId:47,tocIndex:8},{value:"类型",paraId:47,tocIndex:8},{value:"是否必选",paraId:47,tocIndex:8},{value:"描述",paraId:47,tocIndex:8},{value:"node",paraId:47,tocIndex:8},{value:"INode",paraId:47,tocIndex:8},{value:"是",paraId:47,tocIndex:8},{value:"节点 ID 或节点实例",paraId:47,tocIndex:8},{value:"返回值",paraId:48,tocIndex:8},{value:"类型： ",paraId:49,tocIndex:8},{value:"boolean",paraId:49,tocIndex:8},{value:"；",paraId:49,tocIndex:8},{value:"含义：返回 ",paraId:49,tocIndex:8},{value:"true",paraId:49,tocIndex:8},{value:" 表示移除成功。",paraId:49,tocIndex:8}]},62077:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:" ",paraId:0,tocIndex:0},{value:"String",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:"required",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:"一个 Combo 的唯一标识，",paraId:1,tocIndex:0},{value:"必须是 string 类型，必须唯一",paraId:1,tocIndex:0},{value:"。",paraId:1,tocIndex:0},{value:" ",paraId:2,tocIndex:1},{value:"String",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"optional",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"该 Combo 的父 Combo 的 ID。",paraId:3,tocIndex:1},{value:" ",paraId:4,tocIndex:2},{value:"String",paraId:4,tocIndex:2},{value:" ",paraId:4,tocIndex:2},{value:"optional",paraId:4,tocIndex:2},{value:" ",paraId:4,tocIndex:2},{value:"Combo 的最小大小，默认 'circle' 类型 Combo 的 size 为 20，'rect' 类型的为 [20, 5]。",paraId:5,tocIndex:2},{value:" ",paraId:6,tocIndex:3},{value:"Number | Number[]",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"optional",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"该 Combo 内边距。",paraId:7,tocIndex:3},{value:" ",paraId:8,tocIndex:4},{value:"Object",paraId:8,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"optional",paraId:8,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"该 Combo 的样式配置项，详见",paraId:9,tocIndex:4},{value:"内置 Combo 配置文档",paraId:10,tocIndex:4},{value:"。",paraId:9,tocIndex:4},{value:" ",paraId:11,tocIndex:5},{value:"String",paraId:11,tocIndex:5},{value:" ",paraId:11,tocIndex:5},{value:"optional",paraId:11,tocIndex:5},{value:" ",paraId:11,tocIndex:5},{value:"该 Combo 的文本标签。",paraId:12,tocIndex:5},{value:" ",paraId:13,tocIndex:6},{value:"Object",paraId:13,tocIndex:6},{value:" ",paraId:13,tocIndex:6},{value:"optional",paraId:13,tocIndex:6},{value:" ",paraId:13,tocIndex:6},{value:"该 Combo 的文本标签样式配置项，详见",paraId:14,tocIndex:6},{value:"内置 Combo 配置文档",paraId:15,tocIndex:6},{value:"及各类型 Combo 的文档。",paraId:14,tocIndex:6},{value:" ",paraId:16,tocIndex:7},{value:"Object",paraId:16,tocIndex:7},{value:" ",paraId:16,tocIndex:7},{value:"optional",paraId:16,tocIndex:7},{value:" ",paraId:16,tocIndex:7},{value:"指定该 Combo 的类型，可以是内置 Combo 的类型名，也可以是自定义 Combo 的类型名。默认是 'circle'。",paraId:17,tocIndex:7},{value:"名称",paraId:18,tocIndex:7},{value:"描述",paraId:18,tocIndex:7},{value:"默认示例",paraId:18,tocIndex:7},{value:"circle",paraId:18,tocIndex:7},{value:"圆形：",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"size",paraId:18,tocIndex:7},{value:" 是单个数字，表示直径",paraId:18,tocIndex:7},{value:"- 圆心位置对应 Combo 的位置",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"color",paraId:18,tocIndex:7},{value:" 字段默认在描边上生效",paraId:18,tocIndex:7},{value:"- 标签文本默认在 Combo 正上方",paraId:18,tocIndex:7},{value:"- 更多字段见 ",paraId:18,tocIndex:7},{value:"Circle",paraId:19,tocIndex:7},{value:" Combo 教程",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"Demo",paraId:18,tocIndex:7},{value:"rect",paraId:18,tocIndex:7},{value:"矩形：",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"size",paraId:18,tocIndex:7},{value:" 是数组，例如：[100, 50]",paraId:18,tocIndex:7},{value:"- 矩形的中心位置是 COmbo 的位置，而不是左上角",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"color",paraId:18,tocIndex:7},{value:" 字段默认在描边上生效",paraId:18,tocIndex:7},{value:"- 标签文本默认在 Combo 左上角",paraId:18,tocIndex:7},{value:"- 更多字段见 ",paraId:18,tocIndex:7},{value:"Rect",paraId:20,tocIndex:7},{value:" Combo 教程",paraId:18,tocIndex:7},{value:"- ",paraId:18,tocIndex:7},{value:"Demo",paraId:18,tocIndex:7},{value:"内置各个内置 Combo 的特有属性见 ",paraId:21,tocIndex:8},{value:"内置 Combo",paraId:22,tocIndex:8},{value:" 目录下各文档。",paraId:21,tocIndex:8}]},58140:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Edge 继承自 Item。所以 Item 的方法在 Edge 实例中都可以使用。本文仅介绍 Edge 类的通用方法，内置边见 ",paraId:0},{value:"内置边文档",paraId:1},{value:" 和 ",paraId:0},{value:"demo",paraId:2},{value:"，自定义边见 ",paraId:0},{value:"自定义边文档",paraId:3},{value:" 和 ",paraId:0},{value:"demo",paraId:4},{value:"。",paraId:0},{value:"设置边的起始节点。",paraId:5,tocIndex:0},{value:"参数",paraId:6,tocIndex:0},{value:"名称",paraId:7,tocIndex:0},{value:"类型",paraId:7,tocIndex:0},{value:"是否必选",paraId:7,tocIndex:0},{value:"描述",paraId:7,tocIndex:0},{value:"source",paraId:7,tocIndex:0},{value:"Node",paraId:7,tocIndex:0},{value:"true",paraId:7,tocIndex:0},{value:"起始节点实例",paraId:7,tocIndex:0},{value:"用法",paraId:8,tocIndex:0},{value:"const edge = new Edge({\n  // ...\n});\n\nconst node = new Node({\n  // ..\n});\n\nedge.setSource(node);\n",paraId:9,tocIndex:0},{value:"设置边的终止节点。",paraId:10,tocIndex:1},{value:"参数",paraId:11,tocIndex:1},{value:"名称",paraId:12,tocIndex:1},{value:"类型",paraId:12,tocIndex:1},{value:"是否必选",paraId:12,tocIndex:1},{value:"描述",paraId:12,tocIndex:1},{value:"target",paraId:12,tocIndex:1},{value:"Node",paraId:12,tocIndex:1},{value:"true",paraId:12,tocIndex:1},{value:"终止节点实例",paraId:12,tocIndex:1},{value:"用法",paraId:13,tocIndex:1},{value:"edge.setTarget(node);\n",paraId:14,tocIndex:1},{value:"获取当前边的起始节点。",paraId:15,tocIndex:2},{value:"返回值",paraId:16,tocIndex:2},{value:"返回值类型：Node；",paraId:17,tocIndex:2},{value:"返回值为起始节点的实例。",paraId:17,tocIndex:2},{value:"用法",paraId:18,tocIndex:2},{value:"const node = edge.getSource();\n",paraId:19,tocIndex:2},{value:"获取当前边的终止节点。",paraId:20,tocIndex:3},{value:"返回值",paraId:21,tocIndex:3},{value:"返回值类型：Node；",paraId:22,tocIndex:3},{value:"返回值为终止节点的实例。",paraId:22,tocIndex:3},{value:"用法",paraId:23,tocIndex:3},{value:"const node = edge.getTarget();\n",paraId:24,tocIndex:3}]},75762:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:" ",paraId:0,tocIndex:1},{value:"String",paraId:0,tocIndex:1},{value:" ",paraId:0,tocIndex:1},{value:"required",paraId:0,tocIndex:1},{value:" ",paraId:0,tocIndex:1},{value:"边唯一 ID，",paraId:1,tocIndex:1},{value:"必须",paraId:1,tocIndex:1},{value:"是唯一的 string。",paraId:1,tocIndex:1},{value:" ",paraId:2,tocIndex:2},{value:"String | Number",paraId:2,tocIndex:2},{value:" ",paraId:2,tocIndex:2},{value:"optional",paraId:2,tocIndex:2},{value:" ",paraId:2,tocIndex:2},{value:"起始点 id 。",paraId:3,tocIndex:2},{value:" ",paraId:4,tocIndex:3},{value:"String | Number",paraId:4,tocIndex:3},{value:" ",paraId:4,tocIndex:3},{value:"optional",paraId:4,tocIndex:3},{value:" ",paraId:4,tocIndex:3},{value:"结束点 id 。",paraId:5,tocIndex:3},{value:" ",paraId:6,tocIndex:4},{value:"String",paraId:6,tocIndex:4},{value:" ",paraId:6,tocIndex:4},{value:"optional",paraId:6,tocIndex:4},{value:" ",paraId:6,tocIndex:4},{value:"default:",paraId:6,tocIndex:4},{value:" ",paraId:6,tocIndex:4},{value:"'line'",paraId:6,tocIndex:4},{value:"指定边的类型，可以是内置边的类型名称，也可以是自定义边的名称。默认为 ",paraId:7,tocIndex:4},{value:"'line'",paraId:7,tocIndex:4},{value:"。",paraId:7,tocIndex:4},{value:" ",paraId:8,tocIndex:5},{value:"Number",paraId:8,tocIndex:5},{value:" ",paraId:8,tocIndex:5},{value:"optional",paraId:8,tocIndex:5},{value:" ",paraId:8,tocIndex:5},{value:"边的起始节点上的锚点的索引值。",paraId:9,tocIndex:5},{value:" ",paraId:10,tocIndex:6},{value:"Number",paraId:10,tocIndex:6},{value:" ",paraId:10,tocIndex:6},{value:"optional",paraId:10,tocIndex:6},{value:" ",paraId:10,tocIndex:6},{value:"边的终止节点上的锚点的索引值。",paraId:11,tocIndex:6},{value:" ",paraId:12,tocIndex:7},{value:"Object",paraId:12,tocIndex:7},{value:" ",paraId:12,tocIndex:7},{value:"optional",paraId:12,tocIndex:7},{value:" ",paraId:12,tocIndex:7},{value:"通过 ",paraId:13,tocIndex:7},{value:"style",paraId:13,tocIndex:7},{value:" 配置来修改边的填充色、边框颜色、阴影等属性，具体配置属性见：",paraId:13,tocIndex:7},{value:"图形样式属性",paraId:14,tocIndex:7},{value:"。",paraId:13,tocIndex:7},{value:" ",paraId:15,tocIndex:8},{value:"String",paraId:15,tocIndex:8},{value:" ",paraId:15,tocIndex:8},{value:"optional",paraId:15,tocIndex:8},{value:" ",paraId:15,tocIndex:8},{value:"文本文字，如果没有则不会显示。",paraId:16,tocIndex:8},{value:"label",paraId:17,tocIndex:9},{value:" String 类型。标签文本的文字内容。",paraId:17,tocIndex:9},{value:"labelCfg",paraId:17,tocIndex:9},{value:" Object 类型。配置标签文本。下面是 ",paraId:17,tocIndex:9},{value:"labelCfg",paraId:17,tocIndex:9},{value:" 对象中的常用配置项：",paraId:17,tocIndex:9},{value:"名称",paraId:18,tocIndex:9},{value:"是否必须",paraId:18,tocIndex:9},{value:"类型",paraId:18,tocIndex:9},{value:"备注",paraId:18,tocIndex:9},{value:"refX",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"Number",paraId:18,tocIndex:9},{value:"标签在 x 方向的偏移量",paraId:18,tocIndex:9},{value:"refY",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"Number",paraId:18,tocIndex:9},{value:"标签在 y 方向的偏移量",paraId:18,tocIndex:9},{value:"position",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"String",paraId:18,tocIndex:9},{value:"文本相对于边的位置，目前支持的位置有：",paraId:18,tocIndex:9},{value:"'start'",paraId:18,tocIndex:9},{value:"，",paraId:18,tocIndex:9},{value:"'middle'",paraId:18,tocIndex:9},{value:"，",paraId:18,tocIndex:9},{value:"'end'",paraId:18,tocIndex:9},{value:"。默认为",paraId:18,tocIndex:9},{value:"'middle'",paraId:18,tocIndex:9},{value:"。",paraId:18,tocIndex:9},{value:"autoRotate",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"Boolean",paraId:18,tocIndex:9},{value:"标签文字是否跟随边旋转，默认 ",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"style",paraId:18,tocIndex:9},{value:"false",paraId:18,tocIndex:9},{value:"Object",paraId:18,tocIndex:9},{value:"标签的样式属性，具体配置项参见统一整理在 ",paraId:18,tocIndex:9},{value:"图形样式属性 - Text 图形",paraId:19,tocIndex:9},{value:"各个内置节点的特有属性见 ",paraId:20,tocIndex:10},{value:"内置边",paraId:21,tocIndex:10},{value:" 目录下各文档。",paraId:20,tocIndex:10}]},31765:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Item 是 G6 中绘图元素实例，目前包含节点和边的实例。对于实例的变更建议在 graph 上进行。",paraId:0},{value:"根据元素数据项，更新元素。",paraId:1,tocIndex:1},{value:"参数",paraId:2,tocIndex:1},{value:"名称",paraId:3,tocIndex:1},{value:"类型",paraId:3,tocIndex:1},{value:"是否必选",paraId:3,tocIndex:1},{value:"描述",paraId:3,tocIndex:1},{value:"model",paraId:3,tocIndex:1},{value:"Object",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:"元素描述项，包括数据和样式",paraId:3,tocIndex:1},{value:" 提示：",paraId:4,tocIndex:1},{value:"其中参数 model 可包括以下属性，下面属性的详细描述参见 ",paraId:5,tocIndex:1},{value:"元素配置项",paraId:6,tocIndex:1},{value:"：",paraId:5,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"是否必选",paraId:7,tocIndex:1},{value:"描述",paraId:7,tocIndex:1},{value:"style",paraId:7,tocIndex:1},{value:"Object",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"元素样式",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"元素的类型，不传则使用默认值",paraId:7,tocIndex:1},{value:"label",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"元素的文本标签，有该字段时默认会渲染 label",paraId:7,tocIndex:1},{value:"labelCfg",paraId:7,tocIndex:1},{value:"Object",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"元素文本标签的样式",paraId:7,tocIndex:1},{value:"用法",paraId:8,tocIndex:1},{value:"const model = {\n  id: 'node',\n  type: 'rect',\n  label: 'node',\n  style: {\n    fill: 'red',\n  },\n};\n\nitem.update(model);\n",paraId:9,tocIndex:1},{value:"刷新元素，包括更新元素位置，更新元素样式，清除之前的缓存。",paraId:10,tocIndex:2},{value:"一般在以下情况时，会刷新元素：",paraId:11,tocIndex:2},{value:"item model 被改变；",paraId:12,tocIndex:2},{value:"边的位置发生改变，需要重新计算边。",paraId:12,tocIndex:2},{value:"用法",paraId:13,tocIndex:2},{value:"item.refresh();\n",paraId:14,tocIndex:2},{value:"更新元素位置，避免整体重新绘制。",paraId:15,tocIndex:3},{value:"参数",paraId:16,tocIndex:3},{value:"名称",paraId:17,tocIndex:3},{value:"类型",paraId:17,tocIndex:3},{value:"是否必选",paraId:17,tocIndex:3},{value:"描述",paraId:17,tocIndex:3},{value:"cfg",paraId:17,tocIndex:3},{value:"Object",paraId:17,tocIndex:3},{value:"true",paraId:17,tocIndex:3},{value:"元素配置项，包括 ",paraId:17,tocIndex:3},{value:"x",paraId:17,tocIndex:3},{value:"、",paraId:17,tocIndex:3},{value:"y",paraId:17,tocIndex:3},{value:" 属性，如果参数中无 ",paraId:17,tocIndex:3},{value:"x",paraId:17,tocIndex:3},{value:"、",paraId:17,tocIndex:3},{value:"y",paraId:17,tocIndex:3},{value:" 属性，则更新时使用数据项中的值。",paraId:17,tocIndex:3},{value:"用法",paraId:18,tocIndex:3},{value:"const cfg = {\n  x: 100,\n  y: 200,\n};\n// 由于 cfg 中存在 x 与 y，则下面操作将会使用 cfg 中的 x、y 坐标\nitem.updatePosition(cfg);\n\nconst cfg1 = {\n  name: 'abc',\n  dept: 'antv',\n};\n// 由于 cfg 中不存在 x 与 y，下面才做将会使用 item.getModel() 中的 x、y 坐标值\nitem.updatePosition(cfg1);\n",paraId:19,tocIndex:3},{value:"销毁元素，主要包括停止动画、删除 group 中的所有元素、清空配置项、设置 ",paraId:20,tocIndex:5},{value:"destroyed",paraId:20,tocIndex:5},{value:" 为 ",paraId:20,tocIndex:5},{value:"true",paraId:20,tocIndex:5},{value:" 等操作。",paraId:20,tocIndex:5},{value:"用法",paraId:21,tocIndex:5},{value:"item.destroy();\n",paraId:22,tocIndex:5},{value:"获取元素的包围盒。",paraId:23,tocIndex:7},{value:"返回值",paraId:24,tocIndex:7},{value:"返回值类型：Object。",paraId:25,tocIndex:7},{value:"返回值对象包括以下属性：",paraId:26,tocIndex:7},{value:"名称",paraId:27,tocIndex:7},{value:"类型",paraId:27,tocIndex:7},{value:"描述",paraId:27,tocIndex:7},{value:"x",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"视口 x 坐标",paraId:27,tocIndex:7},{value:"y",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"视口 y 坐标",paraId:27,tocIndex:7},{value:"width",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"bbox 宽度",paraId:27,tocIndex:7},{value:"height",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"bbox 高度",paraId:27,tocIndex:7},{value:"centerX",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"中心点 x 坐标",paraId:27,tocIndex:7},{value:"centerY",paraId:27,tocIndex:7},{value:"number",paraId:27,tocIndex:7},{value:"中心点 y 坐标",paraId:27,tocIndex:7},{value:"用法",paraId:28,tocIndex:7},{value:"item.getBBox();\n",paraId:29,tocIndex:7},{value:"获取元素的容器。",paraId:30,tocIndex:8},{value:"返回值",paraId:31,tocIndex:8},{value:"返回值类型：G.Group；",paraId:32,tocIndex:8},{value:"返回元素所在的 graphics group。",paraId:32,tocIndex:8},{value:"用法",paraId:33,tocIndex:8},{value:"// 获取元素的容器\nconst group = item.getContainer();\n\n// 等价于\nconst group = item.get('group');\n",paraId:34,tocIndex:8},{value:"获取元素的关键形状，用于计算节点大小、连线截距等。",paraId:35,tocIndex:9},{value:"返回值",paraId:36,tocIndex:9},{value:"返回值类型：G.Shape；",paraId:37,tocIndex:9},{value:"返回元素的 keyShape。",paraId:37,tocIndex:9},{value:"用法",paraId:38,tocIndex:9},{value:"// 获取元素的 keyShape\nconst keyShape = item.getKeyShape();\n\n// 等价于\nconst keyShape = item.get('keyShape');\n",paraId:39,tocIndex:9},{value:"获取元素的数据模型。",paraId:40,tocIndex:10},{value:"返回值",paraId:41,tocIndex:10},{value:"返回值类型：Object；",paraId:42,tocIndex:10},{value:"返回元素的数据模型。",paraId:42,tocIndex:10},{value:"用法",paraId:43,tocIndex:10},{value:"// 获取元素的数据模型\nconst model = item.getModel();\n\n// 等价于\nconst model = item.get('model');\n",paraId:44,tocIndex:10},{value:"获取元素的类型。",paraId:45,tocIndex:11},{value:"返回值",paraId:46,tocIndex:11},{value:"返回值类型：String；",paraId:47,tocIndex:11},{value:"返回元素的类型，可能是 ",paraId:47,tocIndex:11},{value:"'node'",paraId:47,tocIndex:11},{value:" 或 ",paraId:47,tocIndex:11},{value:"'edge'",paraId:47,tocIndex:11},{value:"。",paraId:47,tocIndex:11},{value:"用法",paraId:48,tocIndex:11},{value:"// 获取元素的类型\nconst type = item.getType();\n\n// 等价于\nconst type = item.get('type');\n",paraId:49,tocIndex:11},{value:"是否拾取及触发该元素的交互事件。",paraId:50,tocIndex:12},{value:"参数",paraId:51,tocIndex:12},{value:"名称",paraId:52,tocIndex:12},{value:"类型",paraId:52,tocIndex:12},{value:"是否必选",paraId:52,tocIndex:12},{value:"描述",paraId:52,tocIndex:12},{value:"enable",paraId:52,tocIndex:12},{value:"Boolean",paraId:52,tocIndex:12},{value:"true",paraId:52,tocIndex:12},{value:"是否允许该元素响应事件的标识，如果为 ",paraId:52,tocIndex:12},{value:"true",paraId:52,tocIndex:12},{value:"，则允许，否则不允许",paraId:52,tocIndex:12},{value:"用法",paraId:53,tocIndex:12},{value:"// 不允许元素响应事件\nitem.enableCapture(false);\n\n// 允许元素响应事件\nitem.enableCapture(true);\n",paraId:54,tocIndex:12},{value:"更新或刷新等操作后，清除缓存。",paraId:55,tocIndex:13},{value:"用法",paraId:56,tocIndex:13},{value:"// 清除缓存\nitem.clearCache();\n",paraId:57,tocIndex:13},{value:"显示元素。只显示 item 自身，若需要在显示节点的同时显示相关边，应调用 ",paraId:58,tocIndex:15},{value:"graph.showItem(item)",paraId:59,tocIndex:15},{value:"。",paraId:58,tocIndex:15},{value:"用法",paraId:60,tocIndex:15},{value:"item.show();\n",paraId:61,tocIndex:15},{value:"隐藏元素。只隐藏 item 自身，若需要在隐藏节点的同时隐藏相关边，应调用 ",paraId:62,tocIndex:16},{value:"graph.hideItem(item)",paraId:63,tocIndex:16},{value:"。",paraId:62,tocIndex:16},{value:"用法",paraId:64,tocIndex:16},{value:"item.hide();\n",paraId:65,tocIndex:16},{value:"更改元素是否显示。",paraId:66,tocIndex:17},{value:"参数",paraId:67,tocIndex:17},{value:"名称",paraId:68,tocIndex:17},{value:"类型",paraId:68,tocIndex:17},{value:"是否必选",paraId:68,tocIndex:17},{value:"描述",paraId:68,tocIndex:17},{value:"visible",paraId:68,tocIndex:17},{value:"Boolean",paraId:68,tocIndex:17},{value:"true",paraId:68,tocIndex:17},{value:"是否显示元素，",paraId:68,tocIndex:17},{value:"true",paraId:68,tocIndex:17},{value:" 为显示，",paraId:68,tocIndex:17},{value:"false",paraId:68,tocIndex:17},{value:" 为隐藏",paraId:68,tocIndex:17},{value:"用法",paraId:69,tocIndex:17},{value:"// 显示元素\nitem.changeVisibility(true);\n\n// 隐藏元素\nitem.changeVisibility(false);\n",paraId:70,tocIndex:17},{value:"查询元素显示状态。",paraId:71,tocIndex:18},{value:"返回值",paraId:72,tocIndex:18},{value:"返回值类型：Boolean；",paraId:73,tocIndex:18},{value:"返回值为 true，则表示当前元素处于显示状态，否则处于隐藏状态。",paraId:73,tocIndex:18},{value:"用法",paraId:74,tocIndex:18},{value:"const visible = item.isVisible();\n",paraId:75,tocIndex:18},{value:"将元素的层级设置到最上层，即当有元素重叠时，将元素置于顶层。",paraId:76,tocIndex:19},{value:"用法",paraId:77,tocIndex:19},{value:"item.toFront();\n",paraId:78,tocIndex:19},{value:"将元素的层级设置到最下层，即当有元素重叠时，将元素置于底层。",paraId:79,tocIndex:20},{value:"用法",paraId:80,tocIndex:20},{value:"item.toBack();\n",paraId:81,tocIndex:20},{value:"更新元素的状态。",paraId:82,tocIndex:21},{value:"参数",paraId:83,tocIndex:21},{value:"名称",paraId:84,tocIndex:21},{value:"类型",paraId:84,tocIndex:21},{value:"是否必选",paraId:84,tocIndex:21},{value:"描述",paraId:84,tocIndex:21},{value:"state",paraId:84,tocIndex:21},{value:"String",paraId:84,tocIndex:21},{value:"true",paraId:84,tocIndex:21},{value:"元素的状态名，如 ",paraId:84,tocIndex:21},{value:"'selected'",paraId:84,tocIndex:21},{value:"、",paraId:84,tocIndex:21},{value:"'hover'",paraId:84,tocIndex:21},{value:"enable",paraId:84,tocIndex:21},{value:"Boolean",paraId:84,tocIndex:21},{value:"true",paraId:84,tocIndex:21},{value:"是否启用状态的标识，为 ",paraId:84,tocIndex:21},{value:"true",paraId:84,tocIndex:21},{value:" 表示启用该状态，否则不启用。",paraId:84,tocIndex:21},{value:"用法",paraId:85,tocIndex:21},{value:"item.setState('selected', true);\nitem.setState('actived', false);\n",paraId:86,tocIndex:21},{value:"清除指定的状态，如果不传 states ，则默认清除",paraId:87,tocIndex:22},{value:"第一个",paraId:87,tocIndex:22},{value:"状态。",paraId:87,tocIndex:22},{value:"参数",paraId:88,tocIndex:22},{value:"名称",paraId:89,tocIndex:22},{value:"类型",paraId:89,tocIndex:22},{value:"是否必选",paraId:89,tocIndex:22},{value:"描述",paraId:89,tocIndex:22},{value:"states",paraId:89,tocIndex:22},{value:"String / Array",paraId:89,tocIndex:22},{value:"true",paraId:89,tocIndex:22},{value:"要清除的元素状态名",paraId:89,tocIndex:22},{value:"用法",paraId:90,tocIndex:22},{value:"// 清除 'selected' 状态\nitem.clearStates('selected');\n\n// 清除 'active' 与 'hover' 状态\nitem.clearStates(['actived', 'hover']);\n",paraId:91,tocIndex:22},{value:"获取当前元素的所有状态。",paraId:92,tocIndex:23},{value:"返回值",paraId:93,tocIndex:23},{value:"返回值类型：Array；",paraId:94,tocIndex:23},{value:"返回当前元素的所有状态，是一个字符串数组，数组中值表示元素的状态。",paraId:94,tocIndex:23},{value:"用法",paraId:95,tocIndex:23},{value:"// 获取元素的所有状态\nconst states = item.getStates();\n",paraId:96,tocIndex:23},{value:"判断元素是否具有某种指定的状态。",paraId:97,tocIndex:24},{value:"参数",paraId:98,tocIndex:24},{value:"名称",paraId:99,tocIndex:24},{value:"类型",paraId:99,tocIndex:24},{value:"是否必选",paraId:99,tocIndex:24},{value:"描述",paraId:99,tocIndex:24},{value:"state",paraId:99,tocIndex:24},{value:"String",paraId:99,tocIndex:24},{value:"true",paraId:99,tocIndex:24},{value:"元素的状态名",paraId:99,tocIndex:24},{value:"返回值",paraId:100,tocIndex:24},{value:"返回值类型：Boolean；",paraId:101,tocIndex:24},{value:"返回值表示是否具有指定的状态，如果返回 ",paraId:101,tocIndex:24},{value:"true",paraId:101,tocIndex:24},{value:"，则说明元素有指定的状态，否则没有。",paraId:101,tocIndex:24},{value:"用法",paraId:102,tocIndex:24},{value:"// 获取元素的 'hover' 状态值\nconst state = item.hasState('hover');\n",paraId:103,tocIndex:24},{value:"获取元素指定状态的样式，返回的样式会将全局样式、默认样式和元素自定义样式合并。",paraId:104,tocIndex:26},{value:"参数",paraId:105,tocIndex:26},{value:"名称",paraId:106,tocIndex:26},{value:"类型",paraId:106,tocIndex:26},{value:"是否必选",paraId:106,tocIndex:26},{value:"描述",paraId:106,tocIndex:26},{value:"state",paraId:106,tocIndex:26},{value:"String",paraId:106,tocIndex:26},{value:"true",paraId:106,tocIndex:26},{value:"元素的状态名",paraId:106,tocIndex:26},{value:"返回值",paraId:107,tocIndex:26},{value:"返回值类型：Object；",paraId:108,tocIndex:26},{value:"返回的样式会将全局样式、默认样式和元素自定义样式合并。",paraId:108,tocIndex:26},{value:"用法",paraId:109,tocIndex:26},{value:"// 获取元素的指定状态的样式\nconst style = item.getStateStyle('selected');\n",paraId:110,tocIndex:26},{value:"获取元素 keyShape 的样式。",paraId:111,tocIndex:27},{value:"返回值",paraId:112,tocIndex:27},{value:"返回值类型：Object | undefined；",paraId:113,tocIndex:27},{value:"如果存在 keyShape ，则返回 ",paraId:113,tocIndex:27},{value:"keyShape",paraId:113,tocIndex:27},{value:" 的样式，否则返回 ",paraId:113,tocIndex:27},{value:"undefined",paraId:113,tocIndex:27},{value:" 。",paraId:113,tocIndex:27},{value:"用法",paraId:114,tocIndex:27},{value:"const style = item.getOriginStyle();\n",paraId:115,tocIndex:27},{value:"获取当前元素的所有状态的样式。",paraId:116,tocIndex:28},{value:"返回值",paraId:117,tocIndex:28},{value:"返回值类型：Object；",paraId:118,tocIndex:28},{value:"返回值表示当前元素所有状态的样式。",paraId:118,tocIndex:28},{value:"用法",paraId:119,tocIndex:28},{value:"const styles = item.getCurrentStatesStyle();\n",paraId:120,tocIndex:28}]},99285:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 图上的元素包括节点、边、节点分组 Combo。每一个元素是一个 ",paraId:0},{value:"item",paraId:1},{value:" 实例，而实例中的数据模型 ",paraId:0},{value:"model",paraId:0},{value:" 定义了该元素的样式、配置等。在 ",paraId:0},{value:"入门教程-元素及其配置",paraId:2},{value:" 中，我们知道配置元素属性有两种方式：实例化图时全局配置；在数据中配置。无论何种方式，都是在配置每个元素的数据模型 ",paraId:0},{value:"model",paraId:0},{value:"。本文介绍节点、边、节点分组 Combo 的 ",paraId:0},{value:"model",paraId:0},{value:" 配置项。",paraId:0},{value:" ",paraId:3,tocIndex:0},{value:"String",paraId:3,tocIndex:0},{value:" ",paraId:3,tocIndex:0},{value:"required",paraId:3,tocIndex:0},{value:" ",paraId:3,tocIndex:0},{value:"说明： 元素的标识 ID，",paraId:4,tocIndex:0},{value:"必须",paraId:4,tocIndex:0},{value:"是唯一的 string",paraId:4,tocIndex:0},{value:" ",paraId:5,tocIndex:1},{value:"Object",paraId:5,tocIndex:1},{value:" ",paraId:5,tocIndex:1},{value:"optional",paraId:5,tocIndex:1},{value:" ",paraId:5,tocIndex:1},{value:"元素 ",paraId:6,tocIndex:1},{value:"keyShape",paraId:7,tocIndex:1},{value:" 的样式属性，可配置内容与该 keyShape 的图形类型相关，各图形的具体属性参见",paraId:6,tocIndex:1},{value:"各图形样式属性",paraId:8,tocIndex:1},{value:" |",paraId:6,tocIndex:1},{value:" ",paraId:9,tocIndex:2},{value:"String",paraId:9,tocIndex:2},{value:" ",paraId:9,tocIndex:2},{value:"optional",paraId:9,tocIndex:2},{value:" ",paraId:9,tocIndex:2},{value:"元素的类型，不传则使用默认值，节点默认类型为 'circle'，边默认类型为 'line'，Combo 默认类型为 ",paraId:10,tocIndex:2},{value:"circle",paraId:10,tocIndex:2},{value:"。",paraId:10,tocIndex:2},{value:" ",paraId:11,tocIndex:3},{value:"String",paraId:11,tocIndex:3},{value:" ",paraId:11,tocIndex:3},{value:"optional",paraId:11,tocIndex:3},{value:" ",paraId:11,tocIndex:3},{value:"元素的文本标签，有该字段时默认会渲染 label 。",paraId:12,tocIndex:3},{value:" ",paraId:13,tocIndex:4},{value:"Object",paraId:13,tocIndex:4},{value:" ",paraId:13,tocIndex:4},{value:"optional",paraId:13,tocIndex:4},{value:" ",paraId:13,tocIndex:4},{value:"元素文本标签的配置项，节点、Combo 与 边的配置不同，详见各子模块内容。",paraId:14,tocIndex:4}]},57122:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Node 继承自 Item。所以 Item 上面的方法在 Node 实例中都可以调用。本文仅介绍 Node 类的通用方法，内置节点见 ",paraId:0},{value:"内置节点文档",paraId:1},{value:" 和 ",paraId:0},{value:"demo",paraId:2},{value:"，自定义节点见 ",paraId:0},{value:"自定义节点文档",paraId:3},{value:" 和 ",paraId:0},{value:"demo",paraId:4},{value:"。",paraId:0},{value:"3.1.4 版本新增",paraId:5,tocIndex:0},{value:"锁定当前节点，锁定节点后，该节点不再响应拖动节点的事件。",paraId:6,tocIndex:0},{value:"提示：锁定节点后，拖动画布和缩放画布的操作依然对该节点有效。如果想在锁定节点后，不响应拖动画布和缩放的事件，需要自定义拖动画布和缩放的 Behavior，具体可参考 ",paraId:7,tocIndex:0},{value:"锁定节点不响应拖动画布的事件",paraId:8,tocIndex:0},{value:" 和 ",paraId:7,tocIndex:0},{value:"锁定节点不响应缩放事件",paraId:9,tocIndex:0},{value:"。",paraId:7,tocIndex:0},{value:"用法",paraId:10,tocIndex:0},{value:"const node = graph.findById('node');\nnode.lock();\n",paraId:11,tocIndex:0},{value:"3.1.4 版本新增",paraId:12,tocIndex:1},{value:"解锁锁定的节点。",paraId:13,tocIndex:1},{value:"用法",paraId:14,tocIndex:1},{value:"const node = graph.findById('node');\nnode.unlock();\n",paraId:15,tocIndex:1},{value:"3.1.4 版本新增",paraId:16,tocIndex:2},{value:"检测节点是否处于锁定状态。",paraId:17,tocIndex:2},{value:"返回值",paraId:18,tocIndex:2},{value:"返回值类型：Boolean；",paraId:19,tocIndex:2},{value:"返回 true 表示当前解锁处于锁定状态，否则表示未锁定。",paraId:19,tocIndex:2},{value:"用法",paraId:20,tocIndex:2},{value:"const node = graph.findById('node');\nconst hasLocked = node.hasLocked();\n",paraId:21,tocIndex:2},{value:"参数",paraId:22,tocIndex:3},{value:"名称",paraId:23,tocIndex:3},{value:"类型",paraId:23,tocIndex:3},{value:"是否必选",paraId:23,tocIndex:3},{value:"描述",paraId:23,tocIndex:3},{value:"type",paraId:23,tocIndex:3},{value:"'source' / 'target' / undefined",paraId:23,tocIndex:3},{value:"false",paraId:23,tocIndex:3},{value:"邻居类型， 'source' 只获取当前节点的源节点，'target' 只获取当前节点指向的目标节点， 若不指定则返回所有类型的邻居",paraId:23,tocIndex:3},{value:"返回值",paraId:24,tocIndex:3},{value:"返回值类型：Array；",paraId:25,tocIndex:3},{value:"返回值符合要求的节点实例数组。",paraId:25,tocIndex:3},{value:"用法",paraId:26,tocIndex:3},{value:"const neighbors = node.getNeighbors('source');\n",paraId:27,tocIndex:3},{value:"获取与当前节点有关联的所有边。",paraId:28,tocIndex:4},{value:"返回值",paraId:29,tocIndex:4},{value:"返回值类型：Edge[]；",paraId:30,tocIndex:4},{value:"返回边实例的集合。",paraId:30,tocIndex:4},{value:"用法",paraId:31,tocIndex:4},{value:"// 获取与 node 关联的所有边\nconst edges = node.getEdges();\n",paraId:32,tocIndex:4},{value:"获取与当前节点关联的所有入边。",paraId:33,tocIndex:5},{value:"返回值",paraId:34,tocIndex:5},{value:"返回值类型：Edge[]；",paraId:35,tocIndex:5},{value:"返回入边实例的集合。",paraId:35,tocIndex:5},{value:"用法",paraId:36,tocIndex:5},{value:"// 获取与 node 关联的所有入边\nconst edges = node.getInEdges();\n",paraId:37,tocIndex:5},{value:"获取与当前节点关联的所有出边。",paraId:38,tocIndex:6},{value:"返回值",paraId:39,tocIndex:6},{value:"返回值类型：Edge[]；",paraId:40,tocIndex:6},{value:"返回出边实例的集合。",paraId:40,tocIndex:6},{value:"用法",paraId:41,tocIndex:6},{value:"// 获取与 node 关联的所有出边\nconst edges = node.getOutEdges();\n",paraId:42,tocIndex:6},{value:"获取节点上面定义的锚点。",paraId:43,tocIndex:7},{value:"返回值",paraId:44,tocIndex:7},{value:"返回值类型：Array；",paraId:45,tocIndex:7},{value:"返回值的数据结构：",paraId:45,tocIndex:7},{value:"[\n  [100, 105],\n  [200, 105]\n];\n",paraId:46,tocIndex:7},{value:"用法",paraId:47,tocIndex:7},{value:"// 获取定义在节点上的锚点数据\nconst anchor = node.getAnchorPoints();\n",paraId:48,tocIndex:7},{value:"获取距离指定坐标最近的一个锚点。",paraId:49,tocIndex:8},{value:"参数",paraId:50,tocIndex:8},{value:"名称",paraId:51,tocIndex:8},{value:"类型",paraId:51,tocIndex:8},{value:"是否必选",paraId:51,tocIndex:8},{value:"描述",paraId:51,tocIndex:8},{value:"point",paraId:51,tocIndex:8},{value:"Object",paraId:51,tocIndex:8},{value:"true",paraId:51,tocIndex:8},{value:"节点外部的一个点，用于计算交点及最近的锚点",paraId:51,tocIndex:8},{value:"返回值",paraId:52,tocIndex:8},{value:"返回值类型：Object；",paraId:53,tocIndex:8},{value:"返回值表示连接点的坐标 (x, y)，如果没有合适的锚点和连接点，则返回中心点。",paraId:53,tocIndex:8},{value:"用法",paraId:54,tocIndex:8},{value:"const point = {\n  x: 100,\n  y: 105,\n};\n// 获取连接点\nconst linkPoint = node.getLinkPoint(point);\n",paraId:55,tocIndex:8},{value:"根据锚点索引获取连接点的 x、y 坐标。",paraId:56,tocIndex:9},{value:"参数",paraId:57,tocIndex:9},{value:"名称",paraId:58,tocIndex:9},{value:"类型",paraId:58,tocIndex:9},{value:"是否必选",paraId:58,tocIndex:9},{value:"描述",paraId:58,tocIndex:9},{value:"index",paraId:58,tocIndex:9},{value:"Number",paraId:58,tocIndex:9},{value:"true",paraId:58,tocIndex:9},{value:"锚点的索引",paraId:58,tocIndex:9},{value:"返回值",paraId:59,tocIndex:9},{value:"返回值类型：Object；",paraId:60,tocIndex:9},{value:"返回值表示连接点的坐标 (x, y)。",paraId:60,tocIndex:9},{value:"用法",paraId:61,tocIndex:9},{value:"// 获取定义在节点上的第一个锚点\nconst anchor = node.getLinkPointByAnchor(0);\n",paraId:62,tocIndex:9},{value:"添加指定的边到当前节点上。",paraId:63,tocIndex:10},{value:"参数",paraId:64,tocIndex:10},{value:"名称",paraId:65,tocIndex:10},{value:"类型",paraId:65,tocIndex:10},{value:"是否必选",paraId:65,tocIndex:10},{value:"描述",paraId:65,tocIndex:10},{value:"edge",paraId:65,tocIndex:10},{value:"Edge",paraId:65,tocIndex:10},{value:"true",paraId:65,tocIndex:10},{value:"Edge 实例",paraId:65,tocIndex:10},{value:"用法",paraId:66,tocIndex:10},{value:"const edge = new Edge({\n  // TODO\n});\nnode.addEdge(edge);\n",paraId:67,tocIndex:10},{value:"移除与当前节点相关的指定边。",paraId:68,tocIndex:11},{value:"参数",paraId:69,tocIndex:11},{value:"名称",paraId:70,tocIndex:11},{value:"类型",paraId:70,tocIndex:11},{value:"是否必选",paraId:70,tocIndex:11},{value:"描述",paraId:70,tocIndex:11},{value:"edge",paraId:70,tocIndex:11},{value:"Edge",paraId:70,tocIndex:11},{value:"true",paraId:70,tocIndex:11},{value:"Edge 实例",paraId:70,tocIndex:11},{value:"用法",paraId:71,tocIndex:11},{value:"const edge = graph.findById('edge1');\nnode.removeEdge(edge);\n",paraId:72,tocIndex:11}]},94623:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"节点继承自元素类。除了",paraId:0},{value:"元素通用属性",paraId:1},{value:"外，每种节点拥有一些特有的属性。",paraId:0},{value:" ",paraId:2,tocIndex:1},{value:"String",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"required",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"节点唯一 ID，",paraId:3,tocIndex:1},{value:"必须",paraId:3,tocIndex:1},{value:"是唯一的 string。",paraId:3,tocIndex:1},{value:" ",paraId:4,tocIndex:2},{value:"Number",paraId:4,tocIndex:2},{value:" ",paraId:4,tocIndex:2},{value:"optional",paraId:4,tocIndex:2},{value:" ",paraId:4,tocIndex:2},{value:"x 坐标。",paraId:5,tocIndex:2},{value:" ",paraId:6,tocIndex:3},{value:"Number",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"optional",paraId:6,tocIndex:3},{value:" ",paraId:6,tocIndex:3},{value:"y 坐标。",paraId:7,tocIndex:3},{value:" ",paraId:8,tocIndex:4},{value:"String",paraId:8,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"optional",paraId:8,tocIndex:4},{value:" ",paraId:8,tocIndex:4},{value:"default:",paraId:8,tocIndex:4},{value:": ",paraId:8,tocIndex:4},{value:"'circle'",paraId:8,tocIndex:4},{value:"指定节点类型，内置节点类型名称或自定义节点的名称。默认为 ",paraId:9,tocIndex:4},{value:"'circle'",paraId:9,tocIndex:4},{value:"。",paraId:9,tocIndex:4},{value:" ",paraId:10,tocIndex:5},{value:"Number | Array",paraId:10,tocIndex:5},{value:" ",paraId:10,tocIndex:5},{value:"optional",paraId:10,tocIndex:5},{value:" ",paraId:10,tocIndex:5},{value:"default:",paraId:10,tocIndex:5},{value:": ",paraId:10,tocIndex:5},{value:"20",paraId:10,tocIndex:5},{value:"节点的大小。",paraId:11,tocIndex:5},{value:" ",paraId:12,tocIndex:6},{value:"Array",paraId:12,tocIndex:6},{value:" ",paraId:12,tocIndex:6},{value:"optional",paraId:12,tocIndex:6},{value:" ",paraId:12,tocIndex:6},{value:"指定边连入节点的连接点的位置（相对于该节点而言），可以为空。例如: ",paraId:13,tocIndex:6},{value:"[0, 0]",paraId:13,tocIndex:6},{value:"，代表节点左上角的锚点，",paraId:13,tocIndex:6},{value:"[1, 1]",paraId:13,tocIndex:6},{value:",代表节点右下角的锚点。",paraId:13,tocIndex:6},{value:" ",paraId:14,tocIndex:7},{value:"Object",paraId:14,tocIndex:7},{value:" ",paraId:14,tocIndex:7},{value:"optional",paraId:14,tocIndex:7},{value:" ",paraId:14,tocIndex:7},{value:"通过 ",paraId:15,tocIndex:7},{value:"style",paraId:15,tocIndex:7},{value:" 配置来修改节点关键图形的填充色、边框颜色、阴影等属性，具体配置属性见：",paraId:15,tocIndex:7},{value:"图形样式属性",paraId:16,tocIndex:7},{value:"。",paraId:15,tocIndex:7},{value:" ",paraId:17,tocIndex:8},{value:"String",paraId:17,tocIndex:8},{value:" ",paraId:17,tocIndex:8},{value:"optional",paraId:17,tocIndex:8},{value:" ",paraId:17,tocIndex:8},{value:"文本文字。",paraId:18,tocIndex:8},{value:"名称",paraId:19,tocIndex:9},{value:"是否必须",paraId:19,tocIndex:9},{value:"类型",paraId:19,tocIndex:9},{value:"备注",paraId:19,tocIndex:9},{value:"position",paraId:19,tocIndex:9},{value:"false",paraId:19,tocIndex:9},{value:"String",paraId:19,tocIndex:9},{value:"文本相对于节点的位置，目前支持的位置有：",paraId:19,tocIndex:9},{value:"'center'",paraId:19,tocIndex:9},{value:"，",paraId:19,tocIndex:9},{value:"'top'",paraId:19,tocIndex:9},{value:"，",paraId:19,tocIndex:9},{value:"'left'",paraId:19,tocIndex:9},{value:"，",paraId:19,tocIndex:9},{value:"'right'",paraId:19,tocIndex:9},{value:"，",paraId:19,tocIndex:9},{value:"'bottom'",paraId:19,tocIndex:9},{value:"。默认为 ",paraId:19,tocIndex:9},{value:"'center'",paraId:19,tocIndex:9},{value:"。modelRect 节点不支持该属性",paraId:19,tocIndex:9},{value:"offset",paraId:19,tocIndex:9},{value:"false",paraId:19,tocIndex:9},{value:"Number",paraId:19,tocIndex:9},{value:"文本的偏移，",paraId:19,tocIndex:9},{value:"position",paraId:19,tocIndex:9},{value:" 为 ",paraId:19,tocIndex:9},{value:"'bottom'",paraId:19,tocIndex:9},{value:" 时，文本的上方偏移量；",paraId:19,tocIndex:9},{value:"position",paraId:19,tocIndex:9},{value:" 为 ",paraId:19,tocIndex:9},{value:"'left'",paraId:19,tocIndex:9},{value:" 时，文本的右方偏移量；以此类推在其他 ",paraId:19,tocIndex:9},{value:"position",paraId:19,tocIndex:9},{value:" 时的情况。modelRect 节点的 ",paraId:19,tocIndex:9},{value:"offset",paraId:19,tocIndex:9},{value:" 为左边距",paraId:19,tocIndex:9},{value:"style",paraId:19,tocIndex:9},{value:"false",paraId:19,tocIndex:9},{value:"Object",paraId:19,tocIndex:9},{value:"标签的样式属性，具体配置项参见统一整理在 ",paraId:19,tocIndex:9},{value:"图形样式属性 - Text 图形",paraId:20,tocIndex:9},{value:"各个内置节点的特有属性见 ",paraId:21,tocIndex:10},{value:"内置节点",paraId:22,tocIndex:10},{value:" 目录下各文档。",paraId:21,tocIndex:10}]},58424:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了一些可插拔的组件，包括：",paraId:0},{value:"Legend",paraId:1},{value:" ",paraId:2},{value:"v4.3.0 起支持",paraId:2},{value:"SnapLine",paraId:3},{value:" ",paraId:2},{value:"v4.3.0 起支持",paraId:2},{value:"Grid",paraId:4},{value:"Minimap",paraId:5},{value:"ImageMinimap",paraId:6},{value:"Edge Bundling",paraId:7},{value:"Menu",paraId:8},{value:"ToolBar",paraId:9},{value:"TimeBar",paraId:10},{value:"Tooltip",paraId:11},{value:"Fisheye",paraId:12},{value:"EdgeFilterLens",paraId:13},{value:"引入 G6 后，首先实例化需要使用的某插件对象。然后，在实例化图时将其配置到 ",paraId:14,tocIndex:0},{value:"plugins",paraId:14,tocIndex:0},{value:" 中：",paraId:14,tocIndex:0},{value:"// 实例化 Grid 插件\nconst grid = new G6.Grid();\nconst minimap = new G6.Minimap();\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [grid, minimap], // 配置 Grid 插件和 Minimap 插件\n});\n",paraId:15,tocIndex:0},{value:"Legend 是 G6 内置的图例插件。用于说明图中不同类型的节点和边所代表的含义，并可以通过与图例的交互做简单的高亮和过滤。 ",paraId:16,tocIndex:1},{value:"v4.3.0 起支持",paraId:16,tocIndex:1},{value:"。",paraId:16,tocIndex:1},{value:"名称",paraId:17,tocIndex:2},{value:"类型",paraId:17,tocIndex:2},{value:"描述",paraId:17,tocIndex:2},{value:"data",paraId:17,tocIndex:2},{value:"GraphData",paraId:17,tocIndex:2},{value:"图例的数据，与图数据格式相同。节点图例目前支持 ",paraId:17,tocIndex:2},{value:"'circle'",paraId:17,tocIndex:2},{value:"，",paraId:17,tocIndex:2},{value:"'rect'",paraId:17,tocIndex:2},{value:"，和 ",paraId:17,tocIndex:2},{value:"'ellipse'",paraId:17,tocIndex:2},{value:"，边图例目前支持 ",paraId:17,tocIndex:2},{value:"'line'",paraId:17,tocIndex:2},{value:"、",paraId:17,tocIndex:2},{value:"'cubic'",paraId:17,tocIndex:2},{value:"、",paraId:17,tocIndex:2},{value:"'quadratic'",paraId:17,tocIndex:2},{value:"。通过指定每个数据项中的 ",paraId:17,tocIndex:2},{value:"type",paraId:17,tocIndex:2},{value:" 字段以确定图例元素的类型，每个数据项中的 ",paraId:17,tocIndex:2},{value:"order",paraId:17,tocIndex:2},{value:" 字段可用于同组图例的排序",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:"'top' / 'top-left' / 'top-right' / 'right' / 'right-top' / 'right-bottom' / 'left' / 'left-top' / 'left-bottom' / 'bottom' / 'bottom-left' / 'bottom-right'",paraId:17,tocIndex:2},{value:"图例在画布中的相对位置，默认为 ",paraId:17,tocIndex:2},{value:"'top'",paraId:17,tocIndex:2},{value:"，代表在画布正上方",paraId:17,tocIndex:2},{value:"padding",paraId:17,tocIndex:2},{value:"number / number[]",paraId:17,tocIndex:2},{value:"图例区域内部内容到边框的距离，四位数组分别代表上、右、下、左边距",paraId:17,tocIndex:2},{value:"margin",paraId:17,tocIndex:2},{value:"number / number[]",paraId:17,tocIndex:2},{value:"图例区域与画布边界的距离，四位数组分别代表上、右、下、左边距。在 ",paraId:17,tocIndex:2},{value:"position:'top'",paraId:17,tocIndex:2},{value:" 时只有上边距生效，其他情况类似",paraId:17,tocIndex:2},{value:"offsetX",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例区域离 ",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:" 对应的默认位置的 x 方向的偏移量，可被用于图例位置的微调",paraId:17,tocIndex:2},{value:"offsetY",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例区域离 ",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:" 对应的默认位置的 y 方向的偏移量，可被用于图例位置的微调",paraId:17,tocIndex:2},{value:"containerStyle",paraId:17,tocIndex:2},{value:"ShapeStyle",paraId:17,tocIndex:2},{value:"图例背景框的样式，格式与 ",paraId:17,tocIndex:2},{value:"rect 图形的样式",paraId:18,tocIndex:2},{value:"相同",paraId:17,tocIndex:2},{value:"horiSep",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例之间的水平间距",paraId:17,tocIndex:2},{value:"vertiSep",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例之间的竖直间距",paraId:17,tocIndex:2},{value:"layout",paraId:17,tocIndex:2},{value:"'vertical' / 'horizontal'",paraId:17,tocIndex:2},{value:"图例的布局方式。默认为 ",paraId:17,tocIndex:2},{value:"'horizontal'",paraId:17,tocIndex:2},{value:" 横向布局",paraId:17,tocIndex:2},{value:"align",paraId:17,tocIndex:2},{value:"'center' / 'right' / 'left'",paraId:17,tocIndex:2},{value:"图例的对齐方式，可以是居中、右对齐、左对齐。默认为 ",paraId:17,tocIndex:2},{value:"'center'",paraId:17,tocIndex:2},{value:" 居中",paraId:17,tocIndex:2},{value:"title",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"图例的标题文本内容，样式通过 ",paraId:17,tocIndex:2},{value:"titleConfig",paraId:17,tocIndex:2},{value:" 设置",paraId:17,tocIndex:2},{value:"titleConfig",paraId:17,tocIndex:2},{value:"object",paraId:17,tocIndex:2},{value:"图例标题的样式，具体配置项如下",paraId:17,tocIndex:2},{value:"titleConfig.position",paraId:17,tocIndex:2},{value:"'center' / 'right' / 'left'",paraId:17,tocIndex:2},{value:"图例标题的对齐方式，可以是居中、右对齐、左对齐。默认为 ",paraId:17,tocIndex:2},{value:"'center'",paraId:17,tocIndex:2},{value:" 居中",paraId:17,tocIndex:2},{value:"titleConfig.offsetX",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例标题的 x 方向偏移，用于微调标题位置",paraId:17,tocIndex:2},{value:"titleConfig.offsetY",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例标题的 y 方向偏移，用于微调标题位置",paraId:17,tocIndex:2},{value:"titleConfig[key]",paraId:17,tocIndex:2},{value:"ShapeStyle",paraId:17,tocIndex:2},{value:"其他对于文本本身的样式，支持的内容与 ",paraId:17,tocIndex:2},{value:"text 图形的样式",paraId:19,tocIndex:2},{value:"相同",paraId:17,tocIndex:2},{value:"filter",paraId:17,tocIndex:2},{value:"object",paraId:17,tocIndex:2},{value:"通过图例的交互对主图元素进行过滤的配置项，具体配置如下",paraId:17,tocIndex:2},{value:"filter.enable",paraId:17,tocIndex:2},{value:"boolean",paraId:17,tocIndex:2},{value:"是否允许通过图例的交互对主图元素过滤，默认为 ",paraId:17,tocIndex:2},{value:"false",paraId:17,tocIndex:2},{value:"filter.multiple",paraId:17,tocIndex:2},{value:"boolean",paraId:17,tocIndex:2},{value:"是否支持多种元素过滤，默认为 ",paraId:17,tocIndex:2},{value:"false",paraId:17,tocIndex:2},{value:"。当它为 ",paraId:17,tocIndex:2},{value:"true",paraId:17,tocIndex:2},{value:" 时，只有 ",paraId:17,tocIndex:2},{value:"filter.trigger",paraId:17,tocIndex:2},{value:" 为 ",paraId:17,tocIndex:2},{value:"'click'",paraId:17,tocIndex:2},{value:" 时方可多选图例",paraId:17,tocIndex:2},{value:"filter.trigger",paraId:17,tocIndex:2},{value:"'click' / 'mouseenter'",paraId:17,tocIndex:2},{value:"触发主图元素过滤的图例交互方式，默认为 ",paraId:17,tocIndex:2},{value:"click",paraId:17,tocIndex:2},{value:"filter.legendStateStyles",paraId:17,tocIndex:2},{value:"{ active?: ShapeStyle, inactive?: ShapeStyle",paraId:17,tocIndex:2},{value:"在过滤时，图例本身的状态样式，包括 ",paraId:17,tocIndex:2},{value:"filter.legendStateStyles.active",paraId:17,tocIndex:2},{value:" 和 ",paraId:17,tocIndex:2},{value:"filter.legendStateStyles.inactive",paraId:17,tocIndex:2},{value:" 两种，每种的类型均为 ShapeStyle。类似图的 ",paraId:17,tocIndex:2},{value:"nodeStateStyles",paraId:17,tocIndex:2},{value:" 配置",paraId:17,tocIndex:2},{value:"filter.graphActiveState",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"主图元素过滤时，被选中的主图元素的状态名，将寻找主图元素的对应的状态样式进行主图元素的更新。默认值为 ",paraId:17,tocIndex:2},{value:"'active'",paraId:17,tocIndex:2},{value:"filter.graphInactiveState",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"主图元素过滤时，未被选中的主图元素的状态名，将寻找主图元素的对应的状态样式进行主图元素的更新。默认值为 ",paraId:17,tocIndex:2},{value:"'inactive'",paraId:17,tocIndex:2},{value:"filter.filterFunctions",paraId:17,tocIndex:2},{value:"{ [key: string]: (d) => boolean; }",paraId:17,tocIndex:2},{value:"由于图例的数据与主图解耦，因此需要配置每种图例对应的主图过滤函数，",paraId:17,tocIndex:2},{value:"key",paraId:17,tocIndex:2},{value:" 为图例数据的 ",paraId:17,tocIndex:2},{value:"type",paraId:17,tocIndex:2},{value:"，值为函数，函数的参数为主图元素的数据，返回值为布尔型，代表是否被选中",paraId:17,tocIndex:2},{value:"SnapLine 是 G6 内置的对齐线插件。 ",paraId:20,tocIndex:3},{value:"v4.3.0 起支持",paraId:20,tocIndex:3},{value:"。",paraId:20,tocIndex:3},{value:"实例化时可以通过配置项调整 SnapLine 的样式和功能。",paraId:21,tocIndex:3},{value:"名称",paraId:22,tocIndex:4},{value:"类型",paraId:22,tocIndex:4},{value:"描述",paraId:22,tocIndex:4},{value:"line",paraId:22,tocIndex:4},{value:"ShapeStyle",paraId:22,tocIndex:4},{value:"辅助线的样式",paraId:22,tocIndex:4},{value:"itemAlignType",paraId:22,tocIndex:4},{value:"boolean、'horizontal' 、'vertical'、'center';",paraId:22,tocIndex:4},{value:"辅助线类型，true 表示全部",paraId:22,tocIndex:4},{value:"Grid 插件在画布上绘制了网格。",paraId:23,tocIndex:5},{value:"使用 ",paraId:24,tocIndex:5},{value:"配置方法",paraId:25,tocIndex:5},{value:" 中代码实例化时可以通过配置项调整 Grid 的图片。",paraId:24,tocIndex:5},{value:"名称",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"描述",paraId:26,tocIndex:6},{value:"img",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"grid 图片，base64 格式字符串",paraId:26,tocIndex:6},{value:"Minimap 是用于快速预览和探索图的工具。",paraId:27,tocIndex:7},{value:"实例化时可以通过配置项调整 Minimap 的样式和功能。",paraId:28,tocIndex:7},{value:"名称",paraId:29,tocIndex:8},{value:"类型",paraId:29,tocIndex:8},{value:"描述",paraId:29,tocIndex:8},{value:"container",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"放置 Minimap 的 DOM 容器。若不指定则自动生成",paraId:29,tocIndex:8},{value:"className",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"生成的 DOM 元素的 className",paraId:29,tocIndex:8},{value:"viewportClassName",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"Minimap 上视窗 DOM 元素的 className",paraId:29,tocIndex:8},{value:"type",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"选项：",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:"：渲染图上所有图形；",paraId:29,tocIndex:8},{value:"'keyShape'",paraId:29,tocIndex:8},{value:"：只渲染图上元素的 keyShape，以减少渲染成本；",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:"：只渲染图上元素的大致图形，以降低渲染成本。渲染成本 ",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:" > ",paraId:29,tocIndex:8},{value:"'keyShape'",paraId:29,tocIndex:8},{value:" > ",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:"。默认为 ",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:"size",paraId:29,tocIndex:8},{value:"Array",paraId:29,tocIndex:8},{value:"Minimap 的大小",paraId:29,tocIndex:8},{value:"delegateStyle",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"在 ",paraId:29,tocIndex:8},{value:"type",paraId:29,tocIndex:8},{value:" 为 ",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:" 时生效，代表元素大致图形的样式",paraId:29,tocIndex:8},{value:"hideEdge",paraId:29,tocIndex:8},{value:"Boolean",paraId:29,tocIndex:8},{value:"false",paraId:29,tocIndex:8},{value:"其中，delegateStyle 可以设置如下属性：",paraId:30,tocIndex:8},{value:"名称",paraId:31,tocIndex:8},{value:"类型",paraId:31,tocIndex:8},{value:"描述",paraId:31,tocIndex:8},{value:"fill",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"填充颜色",paraId:31,tocIndex:8},{value:"stroke",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"描边颜色",paraId:31,tocIndex:8},{value:"lineWidth",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"描边宽度",paraId:31,tocIndex:8},{value:"opacity",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"透明度",paraId:31,tocIndex:8},{value:"fillOpacity",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"填充透明度",paraId:31,tocIndex:8},{value:"由于 ",paraId:32,tocIndex:9},{value:"Minimap",paraId:33,tocIndex:9},{value:" 的原理是将主画布内容复制到 minimap 的画布上，在大数据量下可能会造成双倍的绘制效率成本。为缓解该问题，Image Minimap 采用另一种机制，根据提供的图片地址或 base64 字符串 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:" 绘制 ",paraId:32,tocIndex:9},{value:"<img />",paraId:32,tocIndex:9},{value:" 代替 minimap 上的 canvas。该方法可以大大减轻两倍 canvas 绘制的压力。但 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:" 完全交由 G6 的用户控制，需要注意主画布更新时需要使用 ",paraId:32,tocIndex:9},{value:"updateGraphImg",paraId:32,tocIndex:9},{value:" 方法替换 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:"。",paraId:32,tocIndex:9},{value:"实例化时可以通过配置项调整 Image inimap 的样式和功能。",paraId:34,tocIndex:9},{value:"名称",paraId:35,tocIndex:10},{value:"类型",paraId:35,tocIndex:10},{value:"是否必须",paraId:35,tocIndex:10},{value:"描述",paraId:35,tocIndex:10},{value:"graphImg",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"true",paraId:35,tocIndex:10},{value:"minimap 的图片地址或 base64 文本",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"Number",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"minimap 的宽度。Image Minimap 的长宽比一定等于主图长宽比。因此，若设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"，则按照主画布容器长宽比确定 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"，也就是说，",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 的优先级高于 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"。",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"Number",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"minimap 的高度。Image Minimap 的长宽比一定等于主图长宽比。若未设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"，但设置了 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"，则按照主画布容器长宽比确定 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"；若设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 则以 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 为准",paraId:35,tocIndex:10},{value:"container",paraId:35,tocIndex:10},{value:"Object",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"放置 Minimap 的 DOM 容器。若不指定则自动生成",paraId:35,tocIndex:10},{value:"className",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"生成的 DOM 元素的 className",paraId:35,tocIndex:10},{value:"viewportClassName",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"Minimap 上视窗 DOM 元素的 className",paraId:35,tocIndex:10},{value:"delegateStyle",paraId:35,tocIndex:10},{value:"Object",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"在 ",paraId:35,tocIndex:10},{value:"type",paraId:35,tocIndex:10},{value:" 为 ",paraId:35,tocIndex:10},{value:"'delegate'",paraId:35,tocIndex:10},{value:" 时生效，代表元素大致图形的样式",paraId:35,tocIndex:10},{value:"其中，",paraId:36,tocIndex:10},{value:"delegateStyle",paraId:36,tocIndex:10},{value:" 可以设置如下属性：",paraId:36,tocIndex:10},{value:"名称",paraId:37,tocIndex:10},{value:"类型",paraId:37,tocIndex:10},{value:"描述",paraId:37,tocIndex:10},{value:"fill",paraId:37,tocIndex:10},{value:"String",paraId:37,tocIndex:10},{value:"填充颜色",paraId:37,tocIndex:10},{value:"stroke",paraId:37,tocIndex:10},{value:"String",paraId:37,tocIndex:10},{value:"描边颜色",paraId:37,tocIndex:10},{value:"lineWidth",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"描边宽度",paraId:37,tocIndex:10},{value:"opacity",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"透明度",paraId:37,tocIndex:10},{value:"fillOpacity",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"填充透明度",paraId:37,tocIndex:10},{value:"更新 minimap 图片。建议在主画布更新时使用该方法同步更新 minimap 图片。",paraId:38,tocIndex:12},{value:"参数：",paraId:39,tocIndex:12},{value:"名称",paraId:40,tocIndex:12},{value:"类型",paraId:40,tocIndex:12},{value:"是否必须",paraId:40,tocIndex:12},{value:"描述",paraId:40,tocIndex:12},{value:"img",paraId:40,tocIndex:12},{value:"String",paraId:40,tocIndex:12},{value:"true",paraId:40,tocIndex:12},{value:"minimap 的图片地址或 base64 文本",paraId:40,tocIndex:12},{value:"实例化 Image Minimap 插件时，",paraId:41,tocIndex:13},{value:"graphImg",paraId:41,tocIndex:13},{value:" 是必要参数。",paraId:41,tocIndex:13},{value:"// 实例化 Image Minimap 插件\nconst imageMinimap = new G6.ImageMinimap({\n  width: 200,\n  graphImg: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ'\n});\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [imageMinimap], // 配置 imageMinimap 插件\n});\n\ngraph.data(data);\ngraph.render()\n\n... // 一些主画布更新操作\nimageMinimap.updateGraphImg(img); // 使用新的图片（用户自己生成）替换 minimap 图片\n\n",paraId:42,tocIndex:13},{value:"在关系复杂、繁多的大规模图上，通过边绑定可以降低视觉复杂度。",paraId:43,tocIndex:14},{value:"美国航线图边绑定。",paraId:44,tocIndex:14},{value:"Demo 链接",paraId:44,tocIndex:14},{value:"。该 ",paraId:44,tocIndex:14},{value:"Demo 教程",paraId:44,tocIndex:14},{value:"。",paraId:44,tocIndex:14},{value:"实例化时可以通过配置项调整边绑定的功能。",paraId:45,tocIndex:14},{value:"名称",paraId:46,tocIndex:15},{value:"类型",paraId:46,tocIndex:15},{value:"默认值",paraId:46,tocIndex:15},{value:"描述",paraId:46,tocIndex:15},{value:"K",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.1",paraId:46,tocIndex:15},{value:"边绑定的强度",paraId:46,tocIndex:15},{value:"lambda",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.1",paraId:46,tocIndex:15},{value:"算法的初始步长",paraId:46,tocIndex:15},{value:"divisions",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"1",paraId:46,tocIndex:15},{value:"初始的切割点数，即每条边将会被切割成的份数。每次迭代将会被乘以 ",paraId:46,tocIndex:15},{value:"divRate",paraId:46,tocIndex:15},{value:"divRate",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"2",paraId:46,tocIndex:15},{value:"切割增长率，每次迭代都会乘以该数字。数字越大，绑定越平滑，但计算量将增大",paraId:46,tocIndex:15},{value:"cycles",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"6",paraId:46,tocIndex:15},{value:"迭代次数",paraId:46,tocIndex:15},{value:"iterations",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"90",paraId:46,tocIndex:15},{value:"初始的内迭代次数，每次外迭代中将会被乘以 ",paraId:46,tocIndex:15},{value:"iterRate",paraId:46,tocIndex:15},{value:"iterRate",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.6666667",paraId:46,tocIndex:15},{value:"迭代下降率",paraId:46,tocIndex:15},{value:"bundleThreshold",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.6",paraId:46,tocIndex:15},{value:"判定边是否应该绑定在一起的相似容忍度，数值越大，被绑在一起的边相似度越低，数量越多",paraId:46,tocIndex:15},{value:"Menu 用于配置节点上的右键菜单。",paraId:47,tocIndex:16},{value:"名称",paraId:48,tocIndex:17},{value:"类型",paraId:48,tocIndex:17},{value:"默认值",paraId:48,tocIndex:17},{value:"描述",paraId:48,tocIndex:17},{value:"className",paraId:48,tocIndex:17},{value:"string",paraId:48,tocIndex:17},{value:"null",paraId:48,tocIndex:17},{value:"menu 容器的 class 类名",paraId:48,tocIndex:17},{value:"getContent",paraId:48,tocIndex:17},{value:"(evt?: IG6GraphEvent) => HTMLDivElement / string",paraId:48,tocIndex:17},{value:"菜单项内容，支持 DOM 元素或字符串",paraId:48,tocIndex:17},{value:"handleMenuClick",paraId:48,tocIndex:17},{value:"(target: HTMLElement, item: Item, graph?: IGraph) => void",paraId:48,tocIndex:17},{value:"undefined",paraId:48,tocIndex:17},{value:"点击菜单项的回调函数",paraId:48,tocIndex:17},{value:"shouldBegin",paraId:48,tocIndex:17},{value:"(evt: G6Event) => boolean",paraId:48,tocIndex:17},{value:"undefined",paraId:48,tocIndex:17},{value:"是否允许 menu 出现，可以根据 ",paraId:48,tocIndex:17},{value:"evt.item",paraId:48,tocIndex:17},{value:"（当前鼠标事件中的元素） 或 ",paraId:48,tocIndex:17},{value:"evt.target",paraId:48,tocIndex:17},{value:"（当前鼠标事件中的图形）的内容判断此时是否允许 menu 出现",paraId:48,tocIndex:17},{value:"offsetX",paraId:48,tocIndex:17},{value:"number",paraId:48,tocIndex:17},{value:"6",paraId:48,tocIndex:17},{value:"menu 的 x 方向偏移值，需要考虑父级容器的 padding",paraId:48,tocIndex:17},{value:"offsetY",paraId:48,tocIndex:17},{value:"number",paraId:48,tocIndex:17},{value:"6",paraId:48,tocIndex:17},{value:"menu 的 y 方向偏移值，需要考虑父级容器的 padding",paraId:48,tocIndex:17},{value:"itemTypes",paraId:48,tocIndex:17},{value:"string[]",paraId:48,tocIndex:17},{value:"['node', 'edge', 'combo']",paraId:48,tocIndex:17},{value:"menu 作用在哪些类型的元素上，若只想在节点上显示，可将其设置为 ['node']",paraId:48,tocIndex:17},{value:"trigger",paraId:48,tocIndex:17},{value:"'click' / 'contextmenu'",paraId:48,tocIndex:17},{value:"'contextmenu'",paraId:48,tocIndex:17},{value:"menu 出现的触发方式，默认为 ",paraId:48,tocIndex:17},{value:"'contextmenu'",paraId:48,tocIndex:17},{value:"，即右击。",paraId:48,tocIndex:17},{value:"'click'",paraId:48,tocIndex:17},{value:" 代表左击。",paraId:48,tocIndex:17},{value:"v4.3.2 起支持 'click'",paraId:48,tocIndex:17},{value:"实例化 Menu 插件时，如果不传参数，则使用 G6 默认提供的值，只能展示默认的菜单项，不能进行任何操作。",paraId:49,tocIndex:18},{value:"// 实例化 Menu 插件\nconst menu = new G6.Menu();\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:50,tocIndex:18},{value:"const menu = new G6.Menu({\n  offsetX: 6,\n  offsetX: 10,\n  itemTypes: ['node'],\n  getContent(e) {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `<ul>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n      </ul>`\n    return outDiv\n  },\n  handleMenuClick(target, item) {\n    console.log(target, item)\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:51,tocIndex:19},{value:"const menu = new G6.Menu({\n  getContent(evt) {\n    return `<ul>\n      <li title='1'>测试02</li>\n      <li title='2'>测试02</li>\n      <li>测试02</li>\n      <li>测试02</li>\n      <li>测试02</li>\n    </ul>`;\n  },\n  handleMenuClick(target, item) {\n    console.log(target, item)\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:52,tocIndex:20},{value:"ToolBar 集成了以下常见的操作：",paraId:53,tocIndex:21},{value:"重做；",paraId:54,tocIndex:21},{value:"撤销；",paraId:54,tocIndex:21},{value:"放大；",paraId:54,tocIndex:21},{value:"缩小；",paraId:54,tocIndex:21},{value:"适应屏幕；",paraId:54,tocIndex:21},{value:"实际大小。",paraId:54,tocIndex:21},{value:"名称",paraId:55,tocIndex:22},{value:"类型",paraId:55,tocIndex:22},{value:"默认值",paraId:55,tocIndex:22},{value:"描述",paraId:55,tocIndex:22},{value:"container",paraId:55,tocIndex:22},{value:"HTMLDivElement",paraId:55,tocIndex:22},{value:"null",paraId:55,tocIndex:22},{value:"ToolBar 容器，如果不设置，则默认使用 canvas 的 DOM 容器",paraId:55,tocIndex:22},{value:"className",paraId:55,tocIndex:22},{value:"string",paraId:55,tocIndex:22},{value:"null",paraId:55,tocIndex:22},{value:"ToolBar 内容元素的 class 类名",paraId:55,tocIndex:22},{value:"getContent",paraId:55,tocIndex:22},{value:"(graph?: IGraph) => HTMLDivElement",paraId:55,tocIndex:22},{value:"string",paraId:55,tocIndex:22},{value:"handleClick",paraId:55,tocIndex:22},{value:"(code: string, graph: IGraph) => void",paraId:55,tocIndex:22},{value:"undefined",paraId:55,tocIndex:22},{value:"点击 ToolBar 中每个图标的回调函数",paraId:55,tocIndex:22},{value:"position",paraId:55,tocIndex:22},{value:"Point",paraId:55,tocIndex:22},{value:"null",paraId:55,tocIndex:22},{value:"ToolBar 的位置坐标",paraId:55,tocIndex:22},{value:"默认的 ToolBar 提供了撤销、重做、放大等功能。",paraId:56,tocIndex:24},{value:"const toolbar = new G6.ToolBar();\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:57,tocIndex:24},{value:"const tc = document.createElement('div');\ntc.id = 'toolbarContainer';\ndocument.body.appendChild(tc);\n\nconst toolbar = new G6.ToolBar({\n  container: tc,\n  getContent: () => {\n    return `\n      <ul>\n        <li code='add'>增加节点</li>\n        <li code='undo'>撤销</li>\n      </ul>\n    `\n  },\n  handleClick: (code, graph) => {\n    if (code === 'add') {\n      graph.addItem('node', {\n        id: 'node2',\n        label: 'node2',\n        x: 300,\n        y: 150\n      })\n    } else if (code === 'undo') {\n      // 自定义 undo\n      toolbar.undo()\n      toolbar.autoZoom()\n    } else {\n      // 其他操作保持默认不变\n      toolbar.handleDefaultOperator(code)\n    }\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:58,tocIndex:25},{value:"const toolbar = new G6.ToolBar({\n  getContent: () => {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `<ul>\n        <li>测试01</li>\n        <li>测试02</li>\n        <li>测试03</li>\n        <li>测试04</li>\n        <li>测试05</li>\n      </ul>`\n    return outDiv\n  },\n  handleClick: (code, graph) => {\n\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:59,tocIndex:26},{value:"Tooltip 插件主要用于在节点和边上展示一些辅助信息，G6 4.0 以后，Tooltip 插件将会替换 Behavior 中的 tooltip。",paraId:60,tocIndex:27},{value:"名称",paraId:61,tocIndex:28},{value:"类型",paraId:61,tocIndex:28},{value:"默认值",paraId:61,tocIndex:28},{value:"描述",paraId:61,tocIndex:28},{value:"className",paraId:61,tocIndex:28},{value:"string",paraId:61,tocIndex:28},{value:"null",paraId:61,tocIndex:28},{value:"tooltip 容器的 class 类名",paraId:61,tocIndex:28},{value:"container",paraId:61,tocIndex:28},{value:"HTMLDivElement",paraId:61,tocIndex:28},{value:"null",paraId:61,tocIndex:28},{value:"Tooltip 容器，如果不设置，则默认使用 canvas 的 DOM 容器",paraId:61,tocIndex:28},{value:"getContent",paraId:61,tocIndex:28},{value:"(evt?: IG6GraphEvent) => HTMLDivElement / string",paraId:61,tocIndex:28},{value:"tooltip 内容，支持 DOM 元素或字符串",paraId:61,tocIndex:28},{value:"shouldBegin",paraId:61,tocIndex:28},{value:"(evt: G6Event) => boolean",paraId:61,tocIndex:28},{value:"undefined",paraId:61,tocIndex:28},{value:"是否允许 tooltip 出现，可以根据 ",paraId:61,tocIndex:28},{value:"evt.item",paraId:61,tocIndex:28},{value:"（当前鼠标事件中的元素） 或 ",paraId:61,tocIndex:28},{value:"evt.target",paraId:61,tocIndex:28},{value:"（当前鼠标事件中的图形）的内容判断此时是否允许 tooltip 出现",paraId:61,tocIndex:28},{value:"offsetX",paraId:61,tocIndex:28},{value:"number",paraId:61,tocIndex:28},{value:"6",paraId:61,tocIndex:28},{value:"tooltip 的 x 方向偏移值，需要考虑父级容器的 padding",paraId:61,tocIndex:28},{value:"offsetY",paraId:61,tocIndex:28},{value:"number",paraId:61,tocIndex:28},{value:"6",paraId:61,tocIndex:28},{value:"tooltip 的 y 方向偏移值，需要考虑父级容器的 padding",paraId:61,tocIndex:28},{value:"itemTypes",paraId:61,tocIndex:28},{value:"string[]",paraId:61,tocIndex:28},{value:"['node', 'edge', 'combo']",paraId:61,tocIndex:28},{value:"tooltip 作用在哪些类型的元素上，若只想在节点上显示，可将其设置为 ['node']",paraId:61,tocIndex:28},{value:"trigger",paraId:61,tocIndex:28},{value:"'mouseenter' / 'click'",paraId:61,tocIndex:28},{value:"'mouseenter'",paraId:61,tocIndex:28},{value:"v4.2.1 支持。出现 tooltip 的触发方式。默认为鼠标进入节点/边/combo。设置为 ",paraId:61,tocIndex:28},{value:"'click'",paraId:61,tocIndex:28},{value:" 代表触发方式为点击节点/边/combo",paraId:61,tocIndex:28},{value:"fixToNode",paraId:61,tocIndex:28},{value:"boolean / [number, number]",paraId:61,tocIndex:28},{value:"false",paraId:61,tocIndex:28},{value:"v4.2.1 支持。是否固定出现在相对于目标节点的某个位置，鼠标在节点上方移动时不实时更新。",paraId:61,tocIndex:28},{value:"false",paraId:61,tocIndex:28},{value:" 代表不固定，",paraId:61,tocIndex:28},{value:"[number, number]",paraId:61,tocIndex:28},{value:" 类型的值用于指定固定位置，例如 ",paraId:61,tocIndex:28},{value:"[1, 0.5]",paraId:61,tocIndex:28},{value:" 代表 tooltip 的左上角固定到目标节点的正右方（数组代表的类似 ",paraId:61,tocIndex:28},{value:"Anchor Point",paraId:62,tocIndex:28},{value:" 的位置定义）。仅在节点上生效",paraId:61,tocIndex:28},{value:"默认的 Tooltip 只展示元素类型和 ID，一般情况下都需要用户自己定义 Tooltip 上面展示的内容。",paraId:63,tocIndex:29},{value:"const tooltip = new G6.Tooltip({\n  offsetX: 10,\n  offsetY: 20,\n  getContent(e) {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `\n      <h4>自定义tooltip</h4>\n      <ul>\n        <li>Label: ${e.item.getModel().label || e.item.getModel().id}</li>\n      </ul>`\n    return outDiv\n  },\n  itemTypes: ['node']\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [tooltip], // 配置 Tooltip 插件\n});\n",paraId:64,tocIndex:30},{value:"const tooltip = new G6.Tooltip({\n  getContent(e) {\n    return `<div style='width: 180px;'>\n      <ul id='menu'>\n        <li title='1'>测试02</li>\n        <li title='2'>测试02</li>\n        <li>测试02</li>\n        <li>测试02</li>\n        <li>测试02</li>\n      </ul>\n    </div>`;\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [tooltip], // 配置 Tooltip 插件\n});\n",paraId:65,tocIndex:31},{value:"Tooltip 插件暴露除了几个时机事件，方便用户监听内部状态的变化。以下事件可通过 ",paraId:66,tocIndex:32},{value:"graph.on('eventname', e => {})",paraId:66,tocIndex:32},{value:" 进行监听。",paraId:66,tocIndex:32},{value:"事件名称",paraId:67,tocIndex:32},{value:"描述",paraId:67,tocIndex:32},{value:"tooltipchange",paraId:67,tocIndex:32},{value:"Tooltip 发生变化时触发",paraId:67,tocIndex:32},{value:"Fisheye 鱼眼放大镜是为 focus+context 的探索场景设计的，它能够保证在放大关注区域的同时，保证上下文以及上下文与关注中心的关系不丢失。",paraId:68,tocIndex:33},{value:"名称",paraId:69,tocIndex:34},{value:"类型",paraId:69,tocIndex:34},{value:"默认值",paraId:69,tocIndex:34},{value:"描述",paraId:69,tocIndex:34},{value:"trigger",paraId:69,tocIndex:34},{value:"'mousemove' / 'click' / 'drag'",paraId:69,tocIndex:34},{value:"'mousemove'",paraId:69,tocIndex:34},{value:"放大镜的触发事件",paraId:69,tocIndex:34},{value:"d",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"1.5",paraId:69,tocIndex:34},{value:"放大系数，数值越大，放大程度越大",paraId:69,tocIndex:34},{value:"r",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"300",paraId:69,tocIndex:34},{value:"放大区域的范围半径",paraId:69,tocIndex:34},{value:"delegateStyle",paraId:69,tocIndex:34},{value:"Object",paraId:69,tocIndex:34},{value:"{ stroke: '#000', strokeOpacity: 0.8, lineWidth: 2, fillOpacity: 0.1, fill: '#ccc' }",paraId:69,tocIndex:34},{value:"放大镜蒙层样式",paraId:69,tocIndex:34},{value:"showLabel",paraId:69,tocIndex:34},{value:"Boolean",paraId:69,tocIndex:34},{value:"false",paraId:69,tocIndex:34},{value:"若 label 默认被隐藏，是否在关注区域内展示 label",paraId:69,tocIndex:34},{value:"maxR",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"图的高度",paraId:69,tocIndex:34},{value:"滚轮调整缩放范围的最大半径",paraId:69,tocIndex:34},{value:"minR",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"0.05 * 图的高度",paraId:69,tocIndex:34},{value:"滚轮调整缩放范围的最小半径",paraId:69,tocIndex:34},{value:"maxD",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"5",paraId:69,tocIndex:34},{value:"trigger",paraId:69,tocIndex:34},{value:" 为 ",paraId:69,tocIndex:34},{value:"'mousemove'",paraId:69,tocIndex:34},{value:" / ",paraId:69,tocIndex:34},{value:"'click'",paraId:69,tocIndex:34},{value:" 时，可以在放大镜上左右拖拽调整缩放系数。maxD 指定了这种调整方式的最大缩放系数，建议取值范围 [0, 5]。若使用 ",paraId:69,tocIndex:34},{value:"minimap.updateParam",paraId:69,tocIndex:34},{value:" 更新参数不受该系数限制",paraId:69,tocIndex:34},{value:"minD",paraId:69,tocIndex:34},{value:"Number",paraId:69,tocIndex:34},{value:"0",paraId:69,tocIndex:34},{value:"trigger",paraId:69,tocIndex:34},{value:" 为 ",paraId:69,tocIndex:34},{value:"'mousemove'",paraId:69,tocIndex:34},{value:" / ",paraId:69,tocIndex:34},{value:"'click'",paraId:69,tocIndex:34},{value:" 时，可以在放大镜上左右拖拽调整缩放系数。maxD 指定了这种调整方式的最小缩放系数，建议取值范围 [0, 5]。若使用 ",paraId:69,tocIndex:34},{value:"minimap.updateParam",paraId:69,tocIndex:34},{value:" 更新参数不受该系数限制",paraId:69,tocIndex:34},{value:"scaleRBy",paraId:69,tocIndex:34},{value:"'wheel'/'drag'/'unset'/undefined",paraId:69,tocIndex:34},{value:"false",paraId:69,tocIndex:34},{value:"'unset'",paraId:69,tocIndex:34},{value:"scaleDBy",paraId:69,tocIndex:34},{value:"'wheel'/'drag'/'unset'/undefined",paraId:69,tocIndex:34},{value:"false",paraId:69,tocIndex:34},{value:"'unset'",paraId:69,tocIndex:34},{value:"showDPercent",paraId:69,tocIndex:34},{value:"Boolean",paraId:69,tocIndex:34},{value:"false",paraId:69,tocIndex:34},{value:"true",paraId:69,tocIndex:34},{value:"用于更新该 FishEye 的部分配置项，包括 ",paraId:70,tocIndex:36},{value:"trigger",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"d",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"r",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"maxR",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"minR",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"maxD",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"minD",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"scaleRBy",paraId:70,tocIndex:36},{value:"，",paraId:70,tocIndex:36},{value:"scaleDBy",paraId:70,tocIndex:36},{value:"。例如：",paraId:70,tocIndex:36},{value:"const fisheye = new G6.Fisheye({\n  trigger: 'mousemove'\n});\n\n... // 其他操作\n\nfisheye.updateParams({\n  d: 2,\n  r: 500,\n  // ...\n})\n",paraId:71,tocIndex:36},{value:"const fisheye = new G6.Fisheye({\n  trigger: 'mousemove',\n  d: 1.5,\n  r: 300,\n  delegateStyle: clone(lensDelegateStyle),\n  showLabel: false\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [fisheye], // 配置 fisheye 插件\n});\n",paraId:72,tocIndex:37},{value:"EdgeFilterLens 边过滤镜可以将关注的边保留在过滤镜范围内，其他边将在该范围内不显示。",paraId:73,tocIndex:38},{value:"名称",paraId:74,tocIndex:39},{value:"类型",paraId:74,tocIndex:39},{value:"默认值",paraId:74,tocIndex:39},{value:"描述",paraId:74,tocIndex:39},{value:"trigger",paraId:74,tocIndex:39},{value:"'drag' / 'mousemove' / 'click'",paraId:74,tocIndex:39},{value:"'mousemove'",paraId:74,tocIndex:39},{value:"过滤镜的触发事件",paraId:74,tocIndex:39},{value:"type",paraId:74,tocIndex:39},{value:"'one' / 'both' / 'only-source' / 'only-target'",paraId:74,tocIndex:39},{value:"'both'",paraId:74,tocIndex:39},{value:"根据边两端点作为边过滤的简单条件。",paraId:74,tocIndex:39},{value:"'one'",paraId:74,tocIndex:39},{value:"：边至少有一个端点在过滤镜区域内，则在该区域内显示该边；",paraId:74,tocIndex:39},{value:"'both'",paraId:74,tocIndex:39},{value:"：两个端点都在过滤区域内，则在该区域显示该边；",paraId:74,tocIndex:39},{value:"'only-source'",paraId:74,tocIndex:39},{value:"：只有起始端在过滤镜区域内，则在该区域显示该边；",paraId:74,tocIndex:39},{value:"'only-target'",paraId:74,tocIndex:39},{value:"：只有结束端在过滤区域内，则在该区域显示该边。更复杂的条件可以使用 ",paraId:74,tocIndex:39},{value:"shouldShow",paraId:74,tocIndex:39},{value:" 指定",paraId:74,tocIndex:39},{value:"shouldShow",paraId:74,tocIndex:39},{value:"(d?: unknown) => boolean",paraId:74,tocIndex:39},{value:"undefined",paraId:74,tocIndex:39},{value:"边过滤的自定义条件。参数 ",paraId:74,tocIndex:39},{value:"d",paraId:74,tocIndex:39},{value:" 为边每条边的数据，用户可以根据边的参数返回布尔值。返回 ",paraId:74,tocIndex:39},{value:"true",paraId:74,tocIndex:39},{value:" 代表该边需要在过滤镜区域内显示，",paraId:74,tocIndex:39},{value:"false",paraId:74,tocIndex:39},{value:" 反之。",paraId:74,tocIndex:39},{value:"r",paraId:74,tocIndex:39},{value:"Number",paraId:74,tocIndex:39},{value:"60",paraId:74,tocIndex:39},{value:"过滤镜的范围半径",paraId:74,tocIndex:39},{value:"delegateStyle",paraId:74,tocIndex:39},{value:"Object",paraId:74,tocIndex:39},{value:"{ stroke: '#000', strokeOpacity: 0.8, lineWidth: 2, fillOpacity: 0.1, fill: '#ccc' }",paraId:74,tocIndex:39},{value:"过滤镜蒙层样式",paraId:74,tocIndex:39},{value:"showLabel",paraId:74,tocIndex:39},{value:"'edge' / 'node' / 'both'",paraId:74,tocIndex:39},{value:"'edge'",paraId:74,tocIndex:39},{value:"若 label 默认被隐藏，是否在关注区域内展示对应元素类型的 label。'both' 代表节点和边的 label 都在过滤镜区域显示",paraId:74,tocIndex:39},{value:"maxR",paraId:74,tocIndex:39},{value:"Number",paraId:74,tocIndex:39},{value:"图的高度",paraId:74,tocIndex:39},{value:"滚轮调整过滤镜的最大半径",paraId:74,tocIndex:39},{value:"minR",paraId:74,tocIndex:39},{value:"Number",paraId:74,tocIndex:39},{value:"0.05 * 图的高度",paraId:74,tocIndex:39},{value:"滚轮调整过滤镜的最小半径",paraId:74,tocIndex:39},{value:"scaleRBy",paraId:74,tocIndex:39},{value:"'wheel' / undefined",paraId:74,tocIndex:39},{value:"'wheel'",paraId:74,tocIndex:39},{value:"终端用户调整过滤镜大小的方式，undefined 代表不允许终端用户调整",paraId:74,tocIndex:39},{value:"用于更新该过滤镜的部分配置项，包括 ",paraId:75,tocIndex:41},{value:"trigger",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"type",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"r",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"maxR",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"minR",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"scaleRBy",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"showLabel",paraId:75,tocIndex:41},{value:"，",paraId:75,tocIndex:41},{value:"shouldShow",paraId:75,tocIndex:41},{value:"。例如：",paraId:75,tocIndex:41},{value:"const filterLens = new G6.EdgeFilterLens({\n  trigger: 'drag'\n});\n\n... // 其他操作\n\nfilterLens.updateParams({\n  r: 500,\n  // ...\n})\n",paraId:76,tocIndex:41},{value:"const filterLens = new G6.EdgeFilterLens({\n  trigger: 'mousemove',\n  r: 300,\n  shouldShow: d => {\n    return d.size > 10;\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [filterLens], // 配置 filterLens 插件\n});\n",paraId:77,tocIndex:42},{value:"AntV G6",paraId:78,tocIndex:43},{value:" 内置了三种形态的 TimeBar 组件：",paraId:78,tocIndex:43},{value:"带有趋势图的 TimeBar 组件；",paraId:79,tocIndex:43},{value:"简易版的 TimeBar 组件；",paraId:79,tocIndex:43},{value:"刻度 TimeBar 组件。",paraId:79,tocIndex:43},{value:"并且每种类型的 TimeBar 组件都可以配合播放、快进、后退等控制按钮组使用。",paraId:80,tocIndex:43},{value:"趋势图 TimeBar 组件",paraId:81},{value:"简易版 TimeBar 组件",paraId:81},{value:"刻度 TimeBar 组件",paraId:81},{value:"在趋势图 TimeBar 基础上，我们可以通过配置数据，实现更加复杂的趋势图 TimeBar 组件，如下图所示。",paraId:82,tocIndex:43},{value:"虽然 G6 提供了各种不同类型的 TimeBar 组件，但在使用的方式却非常简单，通过配置字段就可以进行区分。",paraId:83,tocIndex:43},{value:" ",paraId:83,tocIndex:43},{value:"关于 TimeBar 的使用案例，请参考",paraId:83,tocIndex:43},{value:"这里",paraId:83,tocIndex:43},{value:"。",paraId:83,tocIndex:43},{value:"使用 G6 内置的 TimeBar 组件，和使用其他组件的方式完全相同。",paraId:84,tocIndex:44},{value:"import G6 from '@antv/g6';\n\nconst timebar = new G6.TimeBar({\n  width: 500,\n  height: 150,\n  padding: 10,\n  type: 'trend',\n  trend: {\n    data: timeBarData,\n  },\n});\n\nconst graph = new G6.Graph({\n  container: 'container',\n  width,\n  height,\n  plugins: [timebar],\n});\n",paraId:85,tocIndex:44},{value:"通过上面的方式，我们就可以在图中使用 TimeBar 组件了，当实例化 TimeBar 时，type 参数值为 trend，表示我们实例化的是趋势图组件，效果如下图所示。",paraId:86,tocIndex:44},{value:"当设置 type 为 simple 时，就可以使用简易版的 TimeBar。",paraId:87,tocIndex:44},{value:"当设置 type 为 tick 时，表示我们要使用刻度 TimeBar 组件，但此时要注意的是，",paraId:88,tocIndex:44},{value:"刻度时间轴的配置项是通过 tick 对象配置而不是 trend 对象",paraId:88,tocIndex:44},{value:"，这也是刻度时间轴和趋势即简易时间轴不同的地方。",paraId:88,tocIndex:44},{value:"const timebar = new G6.TimeBar({\n  width,\n  height: 150,\n  type: 'tick',\n  tick: {\n    data: timeBarData,\n    width,\n    height: 42,\n    tickLabelFormatter: (d) => {\n      const dateStr = `${d.date}`;\n      if ((count - 1) % 10 === 0) {\n        return `${dateStr.substr(0, 4)}-${dateStr.substr(4, 2)}-${dateStr.substr(6, 2)}`;\n      }\n      return false;\n    },\n    tooltipFomatter: (d) => {\n      const dateStr = `${d}`;\n      return `${dateStr.substr(0, 4)}-${dateStr.substr(4, 2)}-${dateStr.substr(6, 2)}`;\n    },\n  },\n});\n",paraId:89,tocIndex:44},{value:"TimeBar 插件暴露除了几个时机事件，方便用户监听内部状态的变化。以下事件可通过 ",paraId:90,tocIndex:45},{value:"graph.on('eventname', e => {})",paraId:90,tocIndex:45},{value:" 进行监听。",paraId:90,tocIndex:45},{value:"事件名称",paraId:91,tocIndex:45},{value:"描述",paraId:91,tocIndex:45},{value:"valuechange",paraId:91,tocIndex:45},{value:"时间轴的时间范围发生变化时触发",paraId:91,tocIndex:45},{value:"timebarstartplay",paraId:91,tocIndex:45},{value:"时间轴开始播放时触发",paraId:91,tocIndex:45},{value:"timebarendplay",paraId:91,tocIndex:45},{value:"时间轴播放结束时触发",paraId:91,tocIndex:45},{value:"使用 API 控制时间轴开始播放。e.g. ",paraId:92,tocIndex:47},{value:"timebar.play()",paraId:92,tocIndex:47},{value:"。",paraId:92,tocIndex:47},{value:"使用 API 控制时间轴暂停播放。e.g. ",paraId:93,tocIndex:48},{value:"timebar.pause()",paraId:93,tocIndex:48},{value:"。",paraId:93,tocIndex:48},{value:"完整的 TimeBar 的接口定义如下：",paraId:94,tocIndex:49},{value:"interface TimeBarConfig extends IPluginBaseConfig {\n  // position size\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  readonly padding?: number;\n\n  readonly type?: 'trend' | 'simple' | 'tick';\n  // 趋势图配置项\n  readonly trend?: TrendConfig;\n  // 滑块、及前后背景的配置\n  readonly slider?: SliderOption;\n\n  // 当 type 是 tick 时，这是 tick 类型时间轴的配置项\n  // 当 type 是 trend 或 simple 时，这是时间轴下方时间刻度文本的配置项\n  readonly tick?: TimeBarSliceOption | TickCfg;\n\n  // 控制按钮\n  readonly controllerCfg?: ControllerCfg;\n\n  // [v4.5.1 起支持] 容器的 CSS 样式\n  readonly containerCSS?: Object;\n\n  // [v4.5.1 起支持] 过滤的类型, ['node', 'edge'], 默认为 ['node']\n  readonly filterItemTypes?: string[];\n\n  // [v4.5.1 起废弃，由 filterItemTypes 代替] 是否过滤边，若为 true，则需要配合边数据上有 date 字段，过滤节点同时将不满足 date 在选中范围内的边也过滤出去；若为 false，则仅过滤节点以及两端节点都被过滤出去的边\n  readonly filterEdge?: boolean;\n\n  // [v4.5.1 起支持] 是否通过增删图上元素（graph.addItem graph.removeItem）从而达到筛选目的。若为 false 则将使用 graph.hideItem 和 graph.showItem 以隐藏/展示图上元素从而达到筛选目的\n  readonly changeData?: boolean;\n\n  // TimeBar 时间范围变化时的回调函数，当不定义该函数时，时间范围变化时默认过滤图上的数据\n  rangeChange?: (graph: IGraph, minValue: string, maxValue: string) => void;\n\n  // [v4.5.1 起支持] 用户根据节点/边数据返回对应时间值的方法\n  getDate?: (d: any) => number;\n\n  // [v4.5.1 起支持] 用户根据节点/边数据返回对应 value 的方法。value 用于在 type 为 trend 的时间轴上显示趋势线\n  getValue?: (d: any) => number;\n\n  // [v4.5.1 起支持] 在过滤图元素时是否要忽略某些元素。返回 true，则忽略。否则按照正常过滤逻辑处理\n  shouldIgnore?: (itemType: 'node' | 'edge', model: any, dateRage: { min: number, max: number }) => boolean;\n}\n",paraId:95,tocIndex:49},{value:"名称",paraId:96,tocIndex:50},{value:"类型",paraId:96,tocIndex:50},{value:"默认值",paraId:96,tocIndex:50},{value:"描述",paraId:96,tocIndex:50},{value:"container",paraId:96,tocIndex:50},{value:"HTMLDivElement",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"TimeBar 容器，如果不设置，则默认创建 className 为 g6-component-timebar 的 DOM 容器",paraId:96,tocIndex:50},{value:"x",paraId:96,tocIndex:50},{value:"number",paraId:96,tocIndex:50},{value:"0",paraId:96,tocIndex:50},{value:"TimeBar 开始 x 坐标",paraId:96,tocIndex:50},{value:"y",paraId:96,tocIndex:50},{value:"number",paraId:96,tocIndex:50},{value:"0",paraId:96,tocIndex:50},{value:"TimeBar 开始 y 坐标",paraId:96,tocIndex:50},{value:"width",paraId:96,tocIndex:50},{value:"number",paraId:96,tocIndex:50},{value:"必选",paraId:96,tocIndex:50},{value:"，TimeBar 容器宽度",paraId:96,tocIndex:50},{value:"height",paraId:96,tocIndex:50},{value:"number",paraId:96,tocIndex:50},{value:"必选",paraId:96,tocIndex:50},{value:"，TimeBar 高度",paraId:96,tocIndex:50},{value:"padding",paraId:96,tocIndex:50},{value:"number/number[]",paraId:96,tocIndex:50},{value:"10",paraId:96,tocIndex:50},{value:"TimeBar 距离容器的间距值",paraId:96,tocIndex:50},{value:"type",paraId:96,tocIndex:50},{value:"'trend' / 'simple' / 'tick'",paraId:96,tocIndex:50},{value:"trend",paraId:96,tocIndex:50},{value:"默认的 TimeBar 类型，默认为趋势图样式",paraId:96,tocIndex:50},{value:"trend",paraId:96,tocIndex:50},{value:"TrendConfig",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"Timebar 中趋势图的配置项，当 type 为 trend 或 simple 时，该字段必选",paraId:96,tocIndex:50},{value:"slider",paraId:96,tocIndex:50},{value:"SliderOption",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"TimeBar 组件背景及控制调节范围的滑块的配置项",paraId:96,tocIndex:50},{value:"tick",paraId:96,tocIndex:50},{value:"TimeBarSliceOption / TickCfg",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"当 type 是 tick 时，这是 tick 类型时间轴的配置项，该字段必须按；当 type 是 trend 或 simple 时，这是时间轴下方时间刻度文本的配置项",paraId:96,tocIndex:50},{value:"controllerCfg",paraId:96,tocIndex:50},{value:"ControllerCfg",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"控制按钮组配置项",paraId:96,tocIndex:50},{value:"containerCSS",paraId:96,tocIndex:50},{value:"Object",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"[v4.5.1 起支持] 容器的 CSS 样式",paraId:96,tocIndex:50},{value:"filterItemTypes",paraId:96,tocIndex:50},{value:"string[]",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"[v4.5.1 起支持] 过滤的类型, ['node', 'edge'], 默认为 ['node']",paraId:96,tocIndex:50},{value:"filterEdge",paraId:96,tocIndex:50},{value:"boolean",paraId:96,tocIndex:50},{value:"false",paraId:96,tocIndex:50},{value:"[v4.5.1 起废弃，由 filterItemTypes 代替] 是否过滤边，若为 true，则需要配合边数据上有 date 字段，过滤节点同时将不满足 date 在选中范围内的边也过滤出去；若为 false，则仅过滤节点以及两端节点都被过滤出去的边",paraId:96,tocIndex:50},{value:"changeData",paraId:96,tocIndex:50},{value:"boolean",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"[v4.5.1 起支持] 是否通过 graph.changeData 改变图上数据从而达到筛选目的。若为 false 则将使用 graph.hideItem 和 graph.showItem 以隐藏/展示图上元素从而达到筛选目的",paraId:96,tocIndex:50},{value:"rangeChange",paraId:96,tocIndex:50},{value:"Function",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"TimeBar 时间范围变化时的回调函数，当不定义该函数时，时间范围变化时默认过滤图上的数据",paraId:96,tocIndex:50},{value:"getDate",paraId:96,tocIndex:50},{value:"(d: any) => number",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"[v4.5.1 起支持] 用户根据节点/边数据返回对应时间值的方法",paraId:96,tocIndex:50},{value:"getValue",paraId:96,tocIndex:50},{value:"(d: any) => number",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"[v4.5.1 起支持] 用户根据节点/边数据返回对应 value 的方法。value 用于在 type 为 trend 的时间轴上显示趋势线",paraId:96,tocIndex:50},{value:"shouldIgnore",paraId:96,tocIndex:50},{value:"(itemType: 'node'",paraId:96,tocIndex:50},{value:"'edge', model: any, dateRage: { min: number, max: number }) => boolean",paraId:96,tocIndex:50},{value:"null",paraId:96,tocIndex:50},{value:"暂不支持刻度文本的样式配置",paraId:97,tocIndex:51},{value:"interface TrendConfig {\n  // 数据\n  readonly data: {\n    date: string;\n    value: string;\n  }[];\n  // 位置大小\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  // 样式\n  readonly smooth?: boolean;\n  readonly isArea?: boolean;\n  readonly lineStyle?: ShapeStyle;\n  readonly areaStyle?: ShapeStyle;\n  readonly interval?: Interval;\n}\n",paraId:98,tocIndex:51},{value:"名称",paraId:99,tocIndex:52},{value:"类型",paraId:99,tocIndex:52},{value:"默认值",paraId:99,tocIndex:52},{value:"描述",paraId:99,tocIndex:52},{value:"x",paraId:99,tocIndex:52},{value:"number",paraId:99,tocIndex:52},{value:"0",paraId:99,tocIndex:52},{value:"趋势图开始 x 坐标",paraId:99,tocIndex:52},{value:"y",paraId:99,tocIndex:52},{value:"number",paraId:99,tocIndex:52},{value:"0",paraId:99,tocIndex:52},{value:"趋势图开始 y 坐标",paraId:99,tocIndex:52},{value:"width",paraId:99,tocIndex:52},{value:"number",paraId:99,tocIndex:52},{value:"TimeBar 容器宽度",paraId:99,tocIndex:52},{value:"TimeBar 趋势图宽度，不建议自己设定，如果设定时需要同步设置 slider 中的 width 值",paraId:99,tocIndex:52},{value:"height",paraId:99,tocIndex:52},{value:"number",paraId:99,tocIndex:52},{value:"type=trend：默认为 28",paraId:99,tocIndex:52},{value:"type=simple：默认为 8",paraId:99,tocIndex:52},{value:"TimeBar 趋势图高度，不建议自己设定，如果设定时需要同步设置 slider 中的 height 值",paraId:99,tocIndex:52},{value:"smooth",paraId:99,tocIndex:52},{value:"boolean",paraId:99,tocIndex:52},{value:"false",paraId:99,tocIndex:52},{value:"是否是平滑的曲线",paraId:99,tocIndex:52},{value:"isArea",paraId:99,tocIndex:52},{value:"boolean",paraId:99,tocIndex:52},{value:"false",paraId:99,tocIndex:52},{value:"是否显示面积图",paraId:99,tocIndex:52},{value:"lineStyle",paraId:99,tocIndex:52},{value:"ShapeStyle",paraId:99,tocIndex:52},{value:"null",paraId:99,tocIndex:52},{value:"折线的样式配置",paraId:99,tocIndex:52},{value:"areaStyle",paraId:99,tocIndex:52},{value:"ShapeStyle",paraId:99,tocIndex:52},{value:"null",paraId:99,tocIndex:52},{value:"面积的样式配置项，只有当 isArea 为 true 时生效",paraId:99,tocIndex:52},{value:"interval",paraId:99,tocIndex:52},{value:"Interval",paraId:99,tocIndex:52},{value:"null",paraId:99,tocIndex:52},{value:"柱状图配置项，当配置了该项后，趋势图上会展现为混合图样式。",paraId:99,tocIndex:52},{value:"Interval = { data: number[], style: ShapeStyle }",paraId:99,tocIndex:52},{value:"，",paraId:99,tocIndex:52},{value:"style",paraId:99,tocIndex:52},{value:" 除 ",paraId:99,tocIndex:52},{value:"ShapeStyle",paraId:99,tocIndex:52},{value:" 类型中图形的样式外，还可配置 ",paraId:99,tocIndex:52},{value:"barWidth",paraId:99,tocIndex:52},{value:" 配置柱状图柱子的宽度。",paraId:99,tocIndex:52},{value:"export type SliderOption = Partial<{\n  readonly width?: number;\n  readonly height?: number;\n  readonly backgroundStyle?: ShapeStyle;\n  readonly foregroundStyle?: ShapeStyle;\n  // 滑块样式\n  readonly handlerStyle?: {\n    width?: number;\n    height?: number;\n    style?: ShapeStyle;\n  };\n  readonly textStyle?: ShapeStyle;\n  // 初始位置\n  readonly start: number;\n  readonly end: number;\n  // 滑块文本\n  readonly minText: string;\n  readonly maxText: string;\n}>;\n",paraId:100,tocIndex:53},{value:"名称",paraId:101,tocIndex:54},{value:"类型",paraId:101,tocIndex:54},{value:"默认值",paraId:101,tocIndex:54},{value:"描述",paraId:101,tocIndex:54},{value:"width",paraId:101,tocIndex:54},{value:"number",paraId:101,tocIndex:54},{value:"TimeBar 容器宽度 - 2 * padding",paraId:101,tocIndex:54},{value:"趋势图背景框宽度，不建议自己设定，如果设定时要同步修改 trend 中 width 值",paraId:101,tocIndex:54},{value:"height",paraId:101,tocIndex:54},{value:"number",paraId:101,tocIndex:54},{value:"趋势图默认为 28",paraId:101,tocIndex:54},{value:"简易版默认为 8",paraId:101,tocIndex:54},{value:"TimeBar 趋势图高度，不建议自己设定，如果设定时需要同步设置 trend 中的 height 值",paraId:101,tocIndex:54},{value:"backgroundStyle",paraId:101,tocIndex:54},{value:"ShapeStyle",paraId:101,tocIndex:54},{value:"null",paraId:101,tocIndex:54},{value:"背景样式配置项",paraId:101,tocIndex:54},{value:"foregroundStyle",paraId:101,tocIndex:54},{value:"ShapeStyle",paraId:101,tocIndex:54},{value:"null",paraId:101,tocIndex:54},{value:"前景色样式配置，即选中范围的样式配置项",paraId:101,tocIndex:54},{value:"handlerStyle",paraId:101,tocIndex:54},{value:"ShapeStyle",paraId:101,tocIndex:54},{value:"null",paraId:101,tocIndex:54},{value:"滑块的样式配置项",paraId:101,tocIndex:54},{value:"textStyle",paraId:101,tocIndex:54},{value:"ShapeStyle",paraId:101,tocIndex:54},{value:"null",paraId:101,tocIndex:54},{value:"滑块上文本的样式配置项",paraId:101,tocIndex:54},{value:"start",paraId:101,tocIndex:54},{value:"number",paraId:101,tocIndex:54},{value:"0.1",paraId:101,tocIndex:54},{value:"开始位置",paraId:101,tocIndex:54},{value:"end",paraId:101,tocIndex:54},{value:"number",paraId:101,tocIndex:54},{value:"0.9",paraId:101,tocIndex:54},{value:"结束位置",paraId:101,tocIndex:54},{value:"minText",paraId:101,tocIndex:54},{value:"string",paraId:101,tocIndex:54},{value:"min",paraId:101,tocIndex:54},{value:"最小值文本",paraId:101,tocIndex:54},{value:"maxText",paraId:101,tocIndex:54},{value:"string",paraId:101,tocIndex:54},{value:"max",paraId:101,tocIndex:54},{value:"最大值文本",paraId:101,tocIndex:54},{value:"export interface TimeBarSliceOption {\n  // position size\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  readonly padding?: number;\n\n  // styles\n  readonly selectedTickStyle?: TickStyle;\n  readonly unselectedTickStyle?: TickStyle\n  readonly tooltipBackgroundColor?: string;\n\n  readonly start?: number;\n  readonly end?: number;\n\n  // 数据\n  readonly data: {\n    date: string;\n    value: string;\n  }[];\n\n  // 自定义标签格式化函数\n  readonly tickLabelFormatter?: (d: any) => string | boolean;\n  // 自定义 tooltip 内容格式化函数\n  readonly tooltipFomatter?: (d: any) => string;\n}\n",paraId:102,tocIndex:55},{value:"名称",paraId:103,tocIndex:56},{value:"类型",paraId:103,tocIndex:56},{value:"默认值",paraId:103,tocIndex:56},{value:"描述",paraId:103,tocIndex:56},{value:"x",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"0",paraId:103,tocIndex:56},{value:"刻度 TimeBar 开始 x 坐标",paraId:103,tocIndex:56},{value:"y",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"0",paraId:103,tocIndex:56},{value:"刻度 TimeBar 开始 y 坐标",paraId:103,tocIndex:56},{value:"width",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"必选，刻度 TimeBar 宽度",paraId:103,tocIndex:56},{value:"height",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"必选，刻度 TimeBar 高度",paraId:103,tocIndex:56},{value:"padding",paraId:103,tocIndex:56},{value:"number / number[]",paraId:103,tocIndex:56},{value:"0",paraId:103,tocIndex:56},{value:"刻度 TimeBar 距离边界的间距",paraId:103,tocIndex:56},{value:"selectedTickStyle",paraId:103,tocIndex:56},{value:"ShapeStyle",paraId:103,tocIndex:56},{value:"null",paraId:103,tocIndex:56},{value:"选中刻度的样式配置项",paraId:103,tocIndex:56},{value:"unselectedTickStyle",paraId:103,tocIndex:56},{value:"ShapeStyle",paraId:103,tocIndex:56},{value:"null",paraId:103,tocIndex:56},{value:"未选中刻度的样式配置项",paraId:103,tocIndex:56},{value:"tooltipBackgroundColor",paraId:103,tocIndex:56},{value:"ShapeStyle",paraId:103,tocIndex:56},{value:"null",paraId:103,tocIndex:56},{value:"tooltip 背景框配置项",paraId:103,tocIndex:56},{value:"start",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"0.1",paraId:103,tocIndex:56},{value:"开始位置",paraId:103,tocIndex:56},{value:"end",paraId:103,tocIndex:56},{value:"number",paraId:103,tocIndex:56},{value:"0.9",paraId:103,tocIndex:56},{value:"结束位置",paraId:103,tocIndex:56},{value:"data",paraId:103,tocIndex:56},{value:"any[]",paraId:103,tocIndex:56},{value:"[]",paraId:103,tocIndex:56},{value:"必选，刻度时间轴的刻度数据",paraId:103,tocIndex:56},{value:"tickLabelFormatter",paraId:103,tocIndex:56},{value:"Function",paraId:103,tocIndex:56},{value:"null",paraId:103,tocIndex:56},{value:"刻度的格式化回调函数",paraId:103,tocIndex:56},{value:"tooltipFomatter",paraId:103,tocIndex:56},{value:"Function",paraId:103,tocIndex:56},{value:"null",paraId:103,tocIndex:56},{value:"tooltip 上内容格式化的回调函数",paraId:103,tocIndex:56},{value:"export interface TickCfg {\n  // 时间轴下方文本的格式化函数\n  readonly tickLabelFormatter?: (d: any) => string | undefined;\n  // 时间轴下方文本的图形样式。[v4.5.1 起支持] 可配置 tickLabelStyle.rotate 以控制时间轴下方每个文本的旋转角度，可避免文本相互重叠\n  readonly tickLabelStyle?: ShapeStyle;\n  // 时间轴下方文本上的竖线图形样式\n  readonly tickLineStyle?: ShapeStyle;\n}\n",paraId:104,tocIndex:57},{value:"Name",paraId:105,tocIndex:58},{value:"Type",paraId:105,tocIndex:58},{value:"Default Value",paraId:105,tocIndex:58},{value:"Description",paraId:105,tocIndex:58},{value:"tickLabelFormatter",paraId:105,tocIndex:58},{value:"Function",paraId:105,tocIndex:58},{value:"null",paraId:105,tocIndex:58},{value:"时间轴下方文本的格式化函数",paraId:105,tocIndex:58},{value:"tickLabelStyle",paraId:105,tocIndex:58},{value:"ShapeStyle",paraId:105,tocIndex:58},{value:"{}",paraId:105,tocIndex:58},{value:"时间轴下方文本的图形样式。[v4.5.1 起支持] 可配置 tickLabelStyle.rotate 以控制时间轴下方每个文本的旋转角度，可避免文本相互重叠",paraId:105,tocIndex:58},{value:"tickLineStyle",paraId:105,tocIndex:58},{value:"ShapeStyle",paraId:105,tocIndex:58},{value:"{}",paraId:105,tocIndex:58},{value:"时间轴下方文本上方的竖线的图形样式",paraId:105,tocIndex:58},{value:"暂不支持",paraId:106,tocIndex:59},{value:"控制按钮暂不支持配置样式",paraId:107,tocIndex:59},{value:"不支持循环播放",paraId:108,tocIndex:59},{value:"type ControllerCfg = Partial<{\n\n  /** 控制栏的起始位置以及宽高，width height 将不缩放内部子控制器，仅影响它们的位置分布。需要缩放请使用 scale */\n  readonly x?: number;\n  readonly y?: number;\n  readonly width: number;\n  readonly height: number;\n  /** 控制栏缩放比例 */\n  readonly scale?: number;\n  /** 控制器背景的颜色和描边色 */\n  readonly fill?: string;\n  readonly stroke?: string;\n  /** 整个控制栏的字体样式，优先级低于各个子控制器的 text 内的 fontFamily */\n  readonly fontFamily?: string;\n\n  /** 播放速度，1 个 tick 花费时间 */\n  readonly speed?: number;\n  /** 是否循环播放 */\n  readonly loop?: boolean;\n  /** 是否隐藏右下角的 ’播放时间类型切换器‘ */\n  readonly hideTimeTypeController: boolean;\n\n  /** ‘上一帧’按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly preBtnStyle?: ShapeStyle;\n\n  /** ‘下一帧’按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly nextBtnStyle?: ShapeStyle;\n\n  /** ‘播放’ 与 ‘暂停’ 按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly playBtnStyle?: ShapeStyle;\n\n  /** [v4.7.11 起支持配置] 时间播放类型默认值，不配置则为 'range' 即‘时间范围’ */\n  readonly defaultTimeType?: 'single' | 'range';\n\n  /** ‘速度控制器’ 的样式，包括速度的指针、速度指示滚轮（横线）、文本的样式，同时可以为 speedControllerStyle 及其子图形样式配置 scale、offsetX、offsetY 单独控制该控制器及其子图形的缩放以及平移） */\n  readonly speedControllerStyle?: {\n    offsetX?: number,\n    offsetY?: number;\n    scale?: number\n    pointer?: ShapeStyle,\n    scroller?: ShapeStyle,\n    text?: ShapeStyle\n  };\n\n  /** ‘播放时间类型切换器’ 的样式，包括 checkbox 的框、checkbox 的选中勾、文本的样式，同时可以为 timeTypeControllerStyle 及其子图形样式配置 scale、offsetX、offsetY 单独控制该控制器及其子图形的缩放以及平移  */\n  readonly timeTypeControllerStyle?: {\n    offsetX?: number,\n    offsetY?: number;\n    scale?: number\n    check?: ShapeStyle,\n    box?: ShapeStyle,\n    text?: ShapeStyle\n  };\n  /** [v4.5.1 起支持] 控制栏背景方框的样式 */\n  readonly containerStyle?: ExtendedShapeStyle;\n  /** ‘播放时间类型切换器’单一文本时的文本，默认为‘单一时间’ */\n  readonly timePointControllerText?: string;\n  /** ‘播放时间类型切换器’单一文本时的文本，默认为‘时间范围’ */\n  readonly timeRangeControllerText?: string;\n}>\n",paraId:109,tocIndex:59},{value:"名称",paraId:110,tocIndex:60},{value:"类型",paraId:110,tocIndex:60},{value:"默认值",paraId:110,tocIndex:60},{value:"描述",paraId:110,tocIndex:60},{value:"x",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"0",paraId:110,tocIndex:60},{value:"控制栏开始 x 坐标",paraId:110,tocIndex:60},{value:"y",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"0",paraId:110,tocIndex:60},{value:"控制栏开始 y 坐标",paraId:110,tocIndex:60},{value:"width",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"TimeBar 宽度",paraId:110,tocIndex:60},{value:"控制栏宽度，将不缩放内部子控制器，仅影响它们的位置分布",paraId:110,tocIndex:60},{value:"height",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"40",paraId:110,tocIndex:60},{value:"控制栏高度，将不缩放内部子控制器，仅影响它们的位置分布",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"1",paraId:110,tocIndex:60},{value:"控制栏缩放比例",paraId:110,tocIndex:60},{value:"speed",paraId:110,tocIndex:60},{value:"number",paraId:110,tocIndex:60},{value:"1",paraId:110,tocIndex:60},{value:"播放速度",paraId:110,tocIndex:60},{value:"loop",paraId:110,tocIndex:60},{value:"boolean",paraId:110,tocIndex:60},{value:"false",paraId:110,tocIndex:60},{value:"暂不支持，是否循环播放",paraId:110,tocIndex:60},{value:"hideTimeTypeController",paraId:110,tocIndex:60},{value:"boolean",paraId:110,tocIndex:60},{value:"true",paraId:110,tocIndex:60},{value:"是否隐藏时间类型切换",paraId:110,tocIndex:60},{value:"fill",paraId:110,tocIndex:60},{value:"string",paraId:110,tocIndex:60},{value:"控制栏背景框填充色",paraId:110,tocIndex:60},{value:"stroke",paraId:110,tocIndex:60},{value:"string",paraId:110,tocIndex:60},{value:"整个控制栏的字体样式，优先级低于各个子控制器的 text 内的 fontFamily",paraId:110,tocIndex:60},{value:"preBtnStyle",paraId:110,tocIndex:60},{value:"string",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"控制栏背景框边框色",paraId:110,tocIndex:60},{value:"preBtnStyle",paraId:110,tocIndex:60},{value:"ShapeStyle",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"‘上一帧’按钮的样式，同时可以为其配置 ",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetX",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetY",paraId:110,tocIndex:60},{value:" 单独控制该控制器的缩放以及平移",paraId:110,tocIndex:60},{value:"nextBtnStyle",paraId:110,tocIndex:60},{value:"ShapeStyle",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"‘下一帧’按钮的样式，同时可以为其配置 ",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetX",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetY",paraId:110,tocIndex:60},{value:" 单独控制该控制器的缩放以及平移",paraId:110,tocIndex:60},{value:"playBtnStyle",paraId:110,tocIndex:60},{value:"ShapeStyle",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"‘播放’ 与 ‘暂停’ 按钮的样式，同时可以为其配置 ",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetX",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetY",paraId:110,tocIndex:60},{value:" 单独控制该控制器的缩放以及平移",paraId:110,tocIndex:60},{value:"speedControllerStyle",paraId:110,tocIndex:60},{value:"{ offsetX?: number, offsetY?: number, scale?: number, pointer?: ShapeStyle, text?: ShapeStyle, scroller?: ShapeStyle}",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"‘速度控制器’ 的样式，包括速度的指针、速度指示滚轮（横线）、文本的样式，同时可以为 ",paraId:110,tocIndex:60},{value:"speedControllerStyle",paraId:110,tocIndex:60},{value:" 及其子图形样式配置 ",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetX",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetY",paraId:110,tocIndex:60},{value:" 单独控制该控制器及其子图形的缩放以及平移",paraId:110,tocIndex:60},{value:"timeTypeControllerStyle",paraId:110,tocIndex:60},{value:"{ offsetX?: number, offsetY?: number, scale?: number, box?: ShapeStyle, check?: ShapeStyle, text?: ShapeStyle }",paraId:110,tocIndex:60},{value:"null",paraId:110,tocIndex:60},{value:"‘播放时间类型切换器’ 的样式，包括 checkbox 的框、checkbox 的选中勾、文本的样式，同时可以为 ",paraId:110,tocIndex:60},{value:"timeTypeControllerStyle",paraId:110,tocIndex:60},{value:" 及其子图形样式配置 ",paraId:110,tocIndex:60},{value:"scale",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetX",paraId:110,tocIndex:60},{value:"、",paraId:110,tocIndex:60},{value:"offsetY",paraId:110,tocIndex:60},{value:" 单独控制该控制器及其子图形的缩放以及平移",paraId:110,tocIndex:60},{value:"containerStyle ｜ ShapeStyle",paraId:110,tocIndex:60},{value:"{}",paraId:110,tocIndex:60},{value:"控制栏背景方框的样式",paraId:110,tocIndex:60},{value:"timePointControllerText",paraId:110,tocIndex:60},{value:"string",paraId:110,tocIndex:60},{value:'"单一时间"',paraId:110,tocIndex:60},{value:"右下角“单一时间”文本，默认为”单一时间“",paraId:110,tocIndex:60},{value:"timePointControllerText",paraId:110,tocIndex:60},{value:"string",paraId:110,tocIndex:60},{value:'"时间范围"',paraId:110,tocIndex:60},{value:"右下角“单一时间”文本，默认为”时间范围时间“",paraId:110,tocIndex:60}]},45723:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"创建 TreeGraph 实例。",paraId:0},{value:"// highlight-start\nnew G6.TreeGraph(cfg: GraphOptions) => TreeGraph\n// highlight-end\n\nconst treeGraph = new G6.TreeGraph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  modes: {\n    default: [\n      {\n        type: 'collapse-expand',\n        onChange(item, collapsed) {\n          const icon = item.get('group').findByClassName('collapse-icon');\n          if (collapsed) {\n            icon.attr('symbol', EXPAND_ICON);\n          } else {\n            icon.attr('symbol', COLLAPSE_ICON);\n          }\n        },\n      },\n      'drag-canvas',\n      'zoom-canvas',\n    ],\n  },\n  layout: {\n    type: 'dendrogram',\n    direction: 'LR', // H / V / LR / RL / TB / BT\n    nodeSep: 50,\n    rankSep: 100,\n    radial: true,\n  },\n});\n",paraId:1},{value:"TreeGraph 是 G6 专门为树图场景打造的图。",paraId:2},{value:"G6.TreeGraph",paraId:2},{value:" 与 ",paraId:2},{value:"G6.Graph",paraId:2},{value:" 最大的区别就是数据结构和内置布局计算。主要考虑：",paraId:2},{value:"数据结构：树图的数据一般是嵌套结构，边的数据隐含在嵌套结构中，并不会特意指定 edge 。此布局要求数据中一个节点需要有 ",paraId:3},{value:"id",paraId:3},{value:" 和 ",paraId:3},{value:"children",paraId:3},{value:" 两个数据项，最精简的数据结构如下所示：",paraId:3},{value:"const data = {\n  id: 'root',\n  children: [\n    {\n      id: 'subTree1',\n      children: [...]\n    },\n    {\n      id: 'subTree2',\n      children: [...]\n    }\n  ]\n};\n",paraId:4},{value:"布局特殊性：\n",paraId:5},{value:"树图的布局算法一般是不改变源数据的，而是重新生成一份数据，将源数据作为新数据的一个属性。如果每次都需要做次遍历转换数据到节点和边的数据增加了用户的实现复杂度。",paraId:6},{value:"树图的每次新增/删除/展开/收缩节点，都需要重新计算布局。遍历一份结构化数据对应到图上每个节点去做更新操作，也很麻烦。",paraId:6},{value:"TreeGraph 继承自 Graph，配置项参考 ",paraId:7},{value:"G6.Graph(GraphOptions)",paraId:8},{value:"。其中， layout 配置项支持的布局类型 (",paraId:7},{value:"type",paraId:7},{value:" 属性) 和 Graph 中所支持的类型不同，TreeGraph 中 layout 目前支持 dendrogram、compactBox、mindmap 和 indented 四种布局方式，具体配置方式见 ",paraId:7},{value:"TreeGraph Layout",paraId:9},{value:"。",paraId:7}]},63602:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了一些工具方法，方便用户做数据的预处理、图形计算等。",paraId:0},{value:"引入 G6 后，可通过 ",paraId:1,tocIndex:0},{value:"G6.Util.functionName",paraId:1,tocIndex:0},{value:" 调用到 G6 抛出的工具方法。下面代码演示了使用 ",paraId:1,tocIndex:0},{value:"processParallelEdges",paraId:1,tocIndex:0},{value:" 处理两节点之间存在多条边的情况。",paraId:1,tocIndex:0},{value:"import G6 from '@antv/g6';\n\nconst data = {\n  nodes: [\n    { id: '1' }, { id: '2' }\n  ]\n  edges: [\n    { source: '1', target: '2' },\n    { source: '1', target: '2' },\n  ];\n}\n\nconst offsetDiff = 10;\nconst multiEdgeType = 'quadratic';\nconst singleEdgeType = 'line';\nconst loopEdgeType = 'loop';\nG6.Util.processParallelEdges(data.edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType);\n",paraId:2,tocIndex:0},{value:"若两条边的两个端点相同，则称这两条边相互平行。当一对节点节点之间存在多条边，不做处理直接绘制可能会导致边相互重叠。该 Util 方法将找到数据中的平行边，为它们计算合理的贝塞尔曲线控制点偏移量 ",paraId:3,tocIndex:2},{value:"curveOffset",paraId:3,tocIndex:2},{value:"，挂载到相应的边数据上，使得平行边在渲染时可以根据 ",paraId:3,tocIndex:2},{value:"curveOffset",paraId:3,tocIndex:2},{value:" 绘制贝塞尔曲线，从而不相互重叠。因此该方法适用于将平行边处理为 ",paraId:3,tocIndex:2},{value:"quadratic",paraId:3,tocIndex:2},{value:" 或基于 ",paraId:3,tocIndex:2},{value:"quadratic",paraId:3,tocIndex:2},{value:" 自定义的边类型。",paraId:3,tocIndex:2},{value:"名称",paraId:4,tocIndex:3},{value:"类型",paraId:4,tocIndex:3},{value:"是否必须",paraId:4,tocIndex:3},{value:"描述",paraId:4,tocIndex:3},{value:"edges",paraId:4,tocIndex:3},{value:"EdgeConfig[]",paraId:4,tocIndex:3},{value:"true",paraId:4,tocIndex:3},{value:"需要处理的边数据数组",paraId:4,tocIndex:3},{value:"offsetDiff",paraId:4,tocIndex:3},{value:"number",paraId:4,tocIndex:3},{value:"false",paraId:4,tocIndex:3},{value:"两条平行边的之间的距离，默认为 15",paraId:4,tocIndex:3},{value:"multiEdgeType",paraId:4,tocIndex:3},{value:"string",paraId:4,tocIndex:3},{value:"false",paraId:4,tocIndex:3},{value:"两节点之间若存在多条边时，这些边的类型，默认为 'quadratic'",paraId:4,tocIndex:3},{value:"singleEdgeType",paraId:4,tocIndex:3},{value:"string",paraId:4,tocIndex:3},{value:"false",paraId:4,tocIndex:3},{value:"两节点之间仅有一条边时，该边的类型，默认为 undefined，即不改变这种边的类型",paraId:4,tocIndex:3},{value:"loopEdgeType",paraId:4,tocIndex:3},{value:"string",paraId:4,tocIndex:3},{value:"false",paraId:4,tocIndex:3},{value:"若一条边的起点和终点是同一个节点（自环边），该边的类型，默认为 undefined，即不改变这种边的类型",paraId:4,tocIndex:3},{value:"Demo",paraId:5},{value:"从根节点到叶子节点的由上至下的深度优先遍历树数据。",paraId:6,tocIndex:5},{value:"名称",paraId:7,tocIndex:6},{value:"类型",paraId:7,tocIndex:6},{value:"是否必须",paraId:7,tocIndex:6},{value:"描述",paraId:7,tocIndex:6},{value:"data",paraId:7,tocIndex:6},{value:"TreeData",paraId:7,tocIndex:6},{value:"true",paraId:7,tocIndex:6},{value:"需要遍历的树数据",paraId:7,tocIndex:6},{value:"fn",paraId:7,tocIndex:6},{value:"function",paraId:7,tocIndex:6},{value:"true",paraId:7,tocIndex:6},{value:"遍历到每个节点时的回调函数，返回 ",paraId:7,tocIndex:6},{value:"false",paraId:7,tocIndex:6},{value:" 将终止遍历",paraId:7,tocIndex:6},{value:"上表中的回调函数 fn 的参数：",paraId:8,tocIndex:6},{value:"Name",paraId:9,tocIndex:6},{value:"Type",paraId:9,tocIndex:6},{value:"Description",paraId:9,tocIndex:6},{value:"node",paraId:9,tocIndex:6},{value:"T",paraId:9,tocIndex:6},{value:"当前正在访问的树上的节点",paraId:9,tocIndex:6},{value:"parent",paraId:9,tocIndex:6},{value:"T",paraId:9,tocIndex:6},{value:"null",paraId:9,tocIndex:6},{value:"index",paraId:9,tocIndex:6},{value:"number",paraId:9,tocIndex:6},{value:"当前节点在父节点的子节点列表中的顺序",paraId:9,tocIndex:6},{value:"const treeData = {\n  id: '1',\n  children: [\n    {\n      id: '2',\n      children: [{ id: '3' }, { id: '4' }],\n    },\n    {\n      id: '5',\n      children: [\n        { id: '6' },\n        {\n          id: '7',\n          children: [{ id: '8' }, { id: '9' }],\n        },\n      ],\n    },\n    {\n      id: '10',\n      children: [{ id: '11' }],\n    },\n  ],\n};\n\ntraverseTree(treeData, (subTree) => {\n  subTree.color = '#f00';\n  return true;\n});\n",paraId:10,tocIndex:7},{value:"从叶子节点到根节点的由下至上的深度优先遍历树数据。",paraId:11,tocIndex:8},{value:"名称",paraId:12,tocIndex:9},{value:"类型",paraId:12,tocIndex:9},{value:"是否必须",paraId:12,tocIndex:9},{value:"描述",paraId:12,tocIndex:9},{value:"data",paraId:12,tocIndex:9},{value:"TreeData",paraId:12,tocIndex:9},{value:"true",paraId:12,tocIndex:9},{value:"需要遍历的树数据",paraId:12,tocIndex:9},{value:"fn",paraId:12,tocIndex:9},{value:"function",paraId:12,tocIndex:9},{value:"true",paraId:12,tocIndex:9},{value:"遍历到每个节点时的回调函数，返回 ",paraId:12,tocIndex:9},{value:"false",paraId:12,tocIndex:9},{value:" 将终止遍历",paraId:12,tocIndex:9},{value:"上表中的回调函数 fn 的参数：",paraId:13,tocIndex:9},{value:"Name",paraId:14,tocIndex:9},{value:"Type",paraId:14,tocIndex:9},{value:"Description",paraId:14,tocIndex:9},{value:"node",paraId:14,tocIndex:9},{value:"T",paraId:14,tocIndex:9},{value:"当前正在访问的树上的节点",paraId:14,tocIndex:9},{value:"parent",paraId:14,tocIndex:9},{value:"T",paraId:14,tocIndex:9},{value:"null",paraId:14,tocIndex:9},{value:"index",paraId:14,tocIndex:9},{value:"number",paraId:14,tocIndex:9},{value:"当前节点在父节点的子节点列表中的顺序",paraId:14,tocIndex:9},{value:"const treeData = {\n  id: '1',\n  children: [\n    {\n      id: '2',\n      children: [{ id: '3' }, { id: '4' }],\n    },\n    {\n      id: '5',\n      children: [\n        { id: '6' },\n        {\n          id: '7',\n          children: [{ id: '8' }, { id: '9' }],\n        },\n      ],\n    },\n    {\n      id: '10',\n      children: [{ id: '11' }],\n    },\n  ],\n};\n\ntraverseTreeUp(treeData, (subTree) => {\n  subTree.color = '#f00';\n  return true;\n});\n",paraId:15,tocIndex:10},{value:"名称",paraId:16,tocIndex:12},{value:"类型",paraId:16,tocIndex:12},{value:"是否必须",paraId:16,tocIndex:12},{value:"描述",paraId:16,tocIndex:12},{value:"items",paraId:16,tocIndex:12},{value:"Item[]",paraId:16,tocIndex:12},{value:"true",paraId:16,tocIndex:12},{value:"节点数组",paraId:16,tocIndex:12}]},92397:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"根据当前数据中的节点位置，动画更新节点位置。将会使用 graph 上的 ",paraId:0,tocIndex:0},{value:"animateCfg",paraId:0,tocIndex:0},{value:" 配置项作为动画行为的依据。",paraId:0,tocIndex:0},{value:"停止画布上的所有动画。",paraId:1,tocIndex:1},{value:"用法",paraId:2,tocIndex:1},{value:"graph.stopAnimate();\n",paraId:3,tocIndex:1},{value:"判断当前是否有正在执行的动画。",paraId:4,tocIndex:2}]},38186:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"新增行为，将单个或多个行为添加到单个或多个模式中。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"behaviors",paraId:2,tocIndex:0},{value:"string / Array",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"添加的行为的名称",paraId:2,tocIndex:0},{value:"modes",paraId:2,tocIndex:0},{value:"string / Array",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"模式的名称",paraId:2,tocIndex:0},{value:"用法",paraId:3,tocIndex:0},{value:"// 将单个 Behavior 添加到单个模式（默认的 default 模式）中\ngraph.addBehaviors('click-select', 'default');\n\n// 将多个 Behavior 添加到单个模式（默认的 default 模式）中\ngraph.addBehaviors(['brush-select', 'click-select'], 'default');\n\n// 将单个 Behavior 添加到多个模式中\ngraph.addBehaviors('brush-select', ['default', 'select']);\n\n// 将多个 Behavior 添加到多个模式中\ngraph.addBehaviors(['brush-select', 'click-select'], ['default', 'select']);\n",paraId:4,tocIndex:0},{value:"移除行为，将单个或多个行为从单个或多个模式中去除。",paraId:5,tocIndex:1},{value:"参数",paraId:6,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"是否必选",paraId:7,tocIndex:1},{value:"描述",paraId:7,tocIndex:1},{value:"behaviors",paraId:7,tocIndex:1},{value:"string / Array",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"删除的行为的名称",paraId:7,tocIndex:1},{value:"modes",paraId:7,tocIndex:1},{value:"string / Array",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"模式的名称",paraId:7,tocIndex:1},{value:"用法",paraId:8,tocIndex:1},{value:"// 从单个模式中移除单个 Behavior\ngraph.removeBehaviors('click-select', 'default');\n\n// 从单个模式中移除多个 Behavior\ngraph.removeBehaviors(['brush-select', 'click-select'], 'default');\n\n// 从多个模式中移除单个 Behavior\ngraph.removeBehaviors('brush-select', ['default', 'select']);\n\n// 从多个模式中移除多个 Behavior\ngraph.removeBehaviors(['brush-select', 'click-select'], ['default', 'select']);\n",paraId:9,tocIndex:1},{value:"更新某个模式下的 behavior 的参数。",paraId:10,tocIndex:2},{value:"参数",paraId:11,tocIndex:2},{value:"名称",paraId:12,tocIndex:2},{value:"类型",paraId:12,tocIndex:2},{value:"是否必选",paraId:12,tocIndex:2},{value:"描述",paraId:12,tocIndex:2},{value:"behavior",paraId:12,tocIndex:2},{value:"string",paraId:12,tocIndex:2},{value:"true",paraId:12,tocIndex:2},{value:"需要更新的 behavior 类型名",paraId:12,tocIndex:2},{value:"newCfg",paraId:12,tocIndex:2},{value:"object",paraId:12,tocIndex:2},{value:"true",paraId:12,tocIndex:2},{value:"新的配置项",paraId:12,tocIndex:2},{value:"mode",paraId:12,tocIndex:2},{value:"string",paraId:12,tocIndex:2},{value:"false",paraId:12,tocIndex:2},{value:"需要修改的 behavior 所在的模式名称，默认为 'default'",paraId:12,tocIndex:2},{value:"用法",paraId:13,tocIndex:2},{value:"const graph = new Graph({\n  ... // 其他配置项\n  modes: {\n    default: ['zoom-canvas', 'drag-canvas'],\n    select: ['click-select']\n  }\n})\n\ngraph.data(data);\ngraph.render();\n\n// 更新 'default' 模式下的 behavior 'zoom-canvas'\ngraph.updateBehavior('zoom-canvas', { sensitivity: 1.5, enableOptimize: true}, 'default');\n\n// 更新 'select' 模式下的 behavior 'click-select'\ngraph.updateBehavior('click-select', { trigger: 'ctrl' }, 'select');\n",paraId:14,tocIndex:2}]},93071:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"获取节点的出度、入度、总度数，或同时获得以上三种。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"node",paraId:2,tocIndex:0},{value:"string / INode",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"节点 ID 或实例",paraId:2,tocIndex:0},{value:"degreeType",paraId:2,tocIndex:0},{value:"'in'",paraId:2,tocIndex:0},{value:" \\ ",paraId:2,tocIndex:0},{value:"'out'",paraId:2,tocIndex:0},{value:" \\ ",paraId:2,tocIndex:0},{value:"'total'",paraId:2,tocIndex:0},{value:" \\ ",paraId:2,tocIndex:0},{value:"'all'",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"获取度数的类型。设置为 ",paraId:2,tocIndex:0},{value:"'in'",paraId:2,tocIndex:0},{value:" 将返回入度；",paraId:2,tocIndex:0},{value:"'out'",paraId:2,tocIndex:0},{value:" 将返回出度；",paraId:2,tocIndex:0},{value:"'total'",paraId:2,tocIndex:0},{value:" 将返回总度数；",paraId:2,tocIndex:0},{value:"'all'",paraId:2,tocIndex:0},{value:" 将返回一个含有三种度数的对象：",paraId:2,tocIndex:0},{value:"{ inDegree, outDegree, degree}",paraId:2,tocIndex:0},{value:"；若不指定，将返回总度数",paraId:2,tocIndex:0},{value:"refresh",paraId:2,tocIndex:0},{value:"boolean",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"是否强制更新整个图的度数缓存。默认为 ",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"。当通过 ",paraId:2,tocIndex:0},{value:"addItem",paraId:2,tocIndex:0},{value:" 添加边后，再使用 getNodeDegree 时应当将 ",paraId:2,tocIndex:0},{value:"refresh",paraId:2,tocIndex:0},{value:" 设置为 ",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"用法",paraId:3,tocIndex:0},{value:"graph.getNodeDegree('node1', 'in');\n",paraId:4,tocIndex:0},{value:"获取图中两两节点之间的最短路径矩阵。",paraId:5,tocIndex:1},{value:"参数",paraId:6,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"是否必选",paraId:7,tocIndex:1},{value:"描述",paraId:7,tocIndex:1},{value:"cache",paraId:7,tocIndex:1},{value:"boolean",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"是否使用缓存，默认为 true",paraId:7,tocIndex:1},{value:"directed",paraId:7,tocIndex:1},{value:"boolean",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"是否是有向图，默认取 graph.get('directed')",paraId:7,tocIndex:1},{value:"返回值",paraId:8,tocIndex:1},{value:"返回图的最短路径矩阵。",paraId:9,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"const matrix = graph.getShortestPathMatrix();\n",paraId:11,tocIndex:1},{value:"获取邻接矩阵。",paraId:12,tocIndex:2},{value:"参数",paraId:13,tocIndex:2},{value:"名称",paraId:14,tocIndex:2},{value:"类型",paraId:14,tocIndex:2},{value:"是否必选",paraId:14,tocIndex:2},{value:"描述",paraId:14,tocIndex:2},{value:"cache",paraId:14,tocIndex:2},{value:"boolean",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"是否使用缓存，默认为 true",paraId:14,tocIndex:2},{value:"directed",paraId:14,tocIndex:2},{value:"boolean",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"是否是有向图，默认取 graph.get('directed')",paraId:14,tocIndex:2},{value:"返回值",paraId:15,tocIndex:2},{value:"返回图的邻接矩阵。",paraId:16,tocIndex:2},{value:"用法",paraId:17,tocIndex:2},{value:"const matrix = graph.getAdjMatrix();\n",paraId:18,tocIndex:2}]},968:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"收起指定的 Combo。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"combo",paraId:2,tocIndex:0},{value:"string / ICombo",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"combo ID 或 combo 实例",paraId:2,tocIndex:0},{value:"用法",paraId:3,tocIndex:0},{value:"graph.collapseCombo('combo1')\n",paraId:4,tocIndex:0},{value:"展开指定的 Combo。",paraId:5,tocIndex:1},{value:"参数",paraId:6,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"是否必选",paraId:7,tocIndex:1},{value:"描述",paraId:7,tocIndex:1},{value:"combo",paraId:7,tocIndex:1},{value:"string / ICombo",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"combo ID 或 combo 实例",paraId:7,tocIndex:1},{value:"用法",paraId:8,tocIndex:1},{value:"graph.expandCombo('combo1')\n",paraId:9,tocIndex:1},{value:"展开或收缩指定的 Combo。",paraId:10,tocIndex:2},{value:"参数",paraId:11,tocIndex:2},{value:"名称",paraId:12,tocIndex:2},{value:"类型",paraId:12,tocIndex:2},{value:"是否必选",paraId:12,tocIndex:2},{value:"描述",paraId:12,tocIndex:2},{value:"combo",paraId:12,tocIndex:2},{value:"string / ICombo",paraId:12,tocIndex:2},{value:"true",paraId:12,tocIndex:2},{value:"combo ID 或 combo 实例",paraId:12,tocIndex:2},{value:"用法",paraId:13,tocIndex:2},{value:"graph.collapseExpandCombo('combo1')\n",paraId:14,tocIndex:2},{value:"根据已经存在的节点或 combo 创建新的 combo。",paraId:15,tocIndex:3},{value:"参数",paraId:16,tocIndex:3},{value:"名称",paraId:17,tocIndex:3},{value:"类型",paraId:17,tocIndex:3},{value:"是否必选",paraId:17,tocIndex:3},{value:"描述",paraId:17,tocIndex:3},{value:"combo",paraId:17,tocIndex:3},{value:"string / ComboConfig",paraId:17,tocIndex:3},{value:"true",paraId:17,tocIndex:3},{value:"combo ID 或 Combo 配置",paraId:17,tocIndex:3},{value:"elements",paraId:17,tocIndex:3},{value:"string[]",paraId:17,tocIndex:3},{value:"true",paraId:17,tocIndex:3},{value:"添加到 Combo 中的元素 ID，包括节点和 combo",paraId:17,tocIndex:3},{value:"stack",paraId:17,tocIndex:3},{value:"boolean",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"v4.7.17 及后续版本支持",paraId:17,tocIndex:3},{value:" 操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:17,tocIndex:3},{value:"用法",paraId:18,tocIndex:3},{value:"// 第一个参数为 combo ID\ngraph.createCombo('combo1', ['node1', 'node2', 'combo2'])\n\n// 第一个参数为 combo 配置\ngraph.createCombo({\n  id: 'combo1',\n  style: {\n    fill: '#f00'\n  }\n}, ['node1', 'node2', 'combo2'])\n",paraId:19,tocIndex:3},{value:"拆解 Combo，即拆分组/解组。调用后，combo 本身将被删除，而该分组内部的子元素将会成为该分组父分组（若存在）的子元素。",paraId:20,tocIndex:4},{value:"参数",paraId:21,tocIndex:4},{value:"名称",paraId:22,tocIndex:4},{value:"类型",paraId:22,tocIndex:4},{value:"是否必选",paraId:22,tocIndex:4},{value:"描述",paraId:22,tocIndex:4},{value:"combo",paraId:22,tocIndex:4},{value:"string / ICombo",paraId:22,tocIndex:4},{value:"true",paraId:22,tocIndex:4},{value:"需要被拆解的 Combo item 或 id",paraId:22,tocIndex:4},{value:"stack",paraId:22,tocIndex:4},{value:"boolean",paraId:22,tocIndex:4},{value:"false",paraId:22,tocIndex:4},{value:"v4.7.17 及后续版本支持",paraId:22,tocIndex:4},{value:" 操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:22,tocIndex:4},{value:"用法",paraId:23,tocIndex:4},{value:"graph.uncombo('combo1')\n",paraId:24,tocIndex:4},{value:"根据子元素（子节点与子 combo）的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围。",paraId:25,tocIndex:5},{value:"用法",paraId:26,tocIndex:5},{value:"// 更新所有 combos\ngraph.updateCombos();\n",paraId:27,tocIndex:5},{value:"仅更新 combo 及其所有祖先 combo。建议在使用 graph.updateItem 来更新节点位置时，调用该方法以更新节点的祖先 combos。",paraId:28,tocIndex:6},{value:"参数",paraId:29,tocIndex:6},{value:"名称",paraId:30,tocIndex:6},{value:"类型",paraId:30,tocIndex:6},{value:"是否必选",paraId:30,tocIndex:6},{value:"描述",paraId:30,tocIndex:6},{value:"combo",paraId:30,tocIndex:6},{value:"string / ICombo",paraId:30,tocIndex:6},{value:"true",paraId:30,tocIndex:6},{value:"Combo ID 或 Combo 实例",paraId:30,tocIndex:6},{value:"用法",paraId:31,tocIndex:6},{value:"// 更新了某个节点的位置\nconst node1 = graph.findById('node1');\ngraph.updateItem(node1, {\n  x: 100,\n  y: 100,\n});\nconst comboId = node1.getModel().comboId;\n\n// 更新 node1 所属的 combo 及其所有祖先 combo 的大小和位置\ngraph.updateCombo(comboId);\n",paraId:32,tocIndex:6},{value:"更新 Combo 结构，例如移动子树等。",paraId:33,tocIndex:7},{value:"参数",paraId:34,tocIndex:7},{value:"名称",paraId:35,tocIndex:7},{value:"类型",paraId:35,tocIndex:7},{value:"是否必选",paraId:35,tocIndex:7},{value:"描述",paraId:35,tocIndex:7},{value:"item",paraId:35,tocIndex:7},{value:"string / INode / ICombo",paraId:35,tocIndex:7},{value:"true",paraId:35,tocIndex:7},{value:"需要被更新的 Combo 或 节点 ID",paraId:35,tocIndex:7},{value:"parentId",paraId:35,tocIndex:7},{value:"string / undefined",paraId:35,tocIndex:7},{value:"false",paraId:35,tocIndex:7},{value:"新的父 combo ID，undefined 代表没有父 combo",paraId:35,tocIndex:7},{value:"用法",paraId:36,tocIndex:7},{value:"// 将 combo1 从父 combo 中移出，完成后同原父 combo 平级\ngraph.updateComboTree('combo1')\n\n// 将 combo1 移动到 Combo2 下面，作为 Combo2 的子元素\ngraph.updateComboTree('combo1', 'combo2')\n",paraId:37,tocIndex:7}]},82257:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"这部分主要是说明渲染坐标、Canvas 坐标和页面坐标之前的相互转换。三种坐标系的关系参见文档：",paraId:0},{value:"G6 坐标系深度解析",paraId:1},{value:"。",paraId:0},{value:"将屏幕/页面坐标转换为渲染坐标。",paraId:2,tocIndex:0},{value:"参数",paraId:3,tocIndex:0},{value:"名称",paraId:4,tocIndex:0},{value:"类型",paraId:4,tocIndex:0},{value:"是否必选",paraId:4,tocIndex:0},{value:"描述",paraId:4,tocIndex:0},{value:"clientX",paraId:4,tocIndex:0},{value:"Number",paraId:4,tocIndex:0},{value:"true",paraId:4,tocIndex:0},{value:"屏幕 x 坐标",paraId:4,tocIndex:0},{value:"clientY",paraId:4,tocIndex:0},{value:"Number",paraId:4,tocIndex:0},{value:"true",paraId:4,tocIndex:0},{value:"屏幕 y 坐标",paraId:4,tocIndex:0},{value:"返回值",paraId:5,tocIndex:0},{value:"返回值类型：Object；",paraId:6,tocIndex:0},{value:"包含的属性：x 和 y 属性，分别表示渲染的 x 、y 坐标。",paraId:6,tocIndex:0},{value:"用法",paraId:7,tocIndex:0},{value:"const point = graph.getPointByClient(e.clientX, e.clientY);\nconsole.log('渲染坐标 x/y 分别为:', point.x, point.y);\n",paraId:8,tocIndex:0},{value:"将渲染坐标转换为屏幕/页面坐标。",paraId:9,tocIndex:1},{value:"参数",paraId:10,tocIndex:1},{value:"名称",paraId:11,tocIndex:1},{value:"类型",paraId:11,tocIndex:1},{value:"是否必选",paraId:11,tocIndex:1},{value:"描述",paraId:11,tocIndex:1},{value:"x",paraId:11,tocIndex:1},{value:"Number",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:"渲染坐标系下的 x 坐标",paraId:11,tocIndex:1},{value:"y",paraId:11,tocIndex:1},{value:"Number",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:"渲染坐标系下的 y 坐标",paraId:11,tocIndex:1},{value:"返回值",paraId:12,tocIndex:1},{value:"返回值类型：Object；",paraId:13,tocIndex:1},{value:"包含的属性：",paraId:13,tocIndex:1},{value:"x",paraId:13,tocIndex:1},{value:" 和 ",paraId:13,tocIndex:1},{value:"y",paraId:13,tocIndex:1},{value:" 属性，分别表示屏幕/页面的 x、y 坐标。",paraId:13,tocIndex:1},{value:"用法",paraId:14,tocIndex:1},{value:"const point = graph.getClientByPoint(100, 200);\nconsole.log('屏幕/页面x/y坐标分别为:', point.x, point.y);\n",paraId:15,tocIndex:1},{value:"将 Canvas 画布坐标转换为渲染坐标。",paraId:16,tocIndex:2},{value:"参数",paraId:17,tocIndex:2},{value:"名称",paraId:18,tocIndex:2},{value:"类型",paraId:18,tocIndex:2},{value:"是否必选",paraId:18,tocIndex:2},{value:"描述",paraId:18,tocIndex:2},{value:"canvasX",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"true",paraId:18,tocIndex:2},{value:"画布 x 坐标",paraId:18,tocIndex:2},{value:"canvasY",paraId:18,tocIndex:2},{value:"Number",paraId:18,tocIndex:2},{value:"true",paraId:18,tocIndex:2},{value:"画布 y 坐标",paraId:18,tocIndex:2},{value:"返回值",paraId:19,tocIndex:2},{value:"返回值类型：Object；",paraId:20,tocIndex:2},{value:"包含的属性：x 和 y 属性，分别表示渲染的 x、y 坐标。",paraId:20,tocIndex:2},{value:"用法",paraId:21,tocIndex:2},{value:"const point = graph.getPointByCanvas(100, 200);\nconsole.log('渲染坐标 x/y 分别为:', point.x, point.y);\n",paraId:22,tocIndex:2},{value:"将渲染坐标转换为 Canvas 画布坐标。",paraId:23,tocIndex:3},{value:"参数",paraId:24,tocIndex:3},{value:"名称",paraId:25,tocIndex:3},{value:"类型",paraId:25,tocIndex:3},{value:"是否必选",paraId:25,tocIndex:3},{value:"描述",paraId:25,tocIndex:3},{value:"x",paraId:25,tocIndex:3},{value:"Number",paraId:25,tocIndex:3},{value:"true",paraId:25,tocIndex:3},{value:"渲染坐标系下的 x 坐标",paraId:25,tocIndex:3},{value:"y",paraId:25,tocIndex:3},{value:"Number",paraId:25,tocIndex:3},{value:"true",paraId:25,tocIndex:3},{value:"渲染坐标系下的 y 坐标",paraId:25,tocIndex:3},{value:"返回值",paraId:26,tocIndex:3},{value:"返回值类型：Object；",paraId:27,tocIndex:3},{value:"包含的属性：x 和 y 属性，分别表示 Canvas 画布的 x、y 坐标。",paraId:27,tocIndex:3},{value:"用法",paraId:28,tocIndex:3},{value:"const point = graph.getCanvasByPoint(100, 200);\nconsole.log('Canvas 画布的 x/y 坐标分别为:', point.x, point.y);\n",paraId:29,tocIndex:3},{value:"获取图内容的中心绘制坐标。v4.2.1 支持。",paraId:30,tocIndex:4},{value:"参数",paraId:31,tocIndex:4},{value:"无",paraId:32,tocIndex:4},{value:"返回值",paraId:33,tocIndex:4},{value:"返回值类型：Object；",paraId:34,tocIndex:4},{value:"包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。",paraId:34,tocIndex:4},{value:"用法",paraId:35,tocIndex:4},{value:"const point = graph.getGraphCenterPoint();\nconsole.log('图内容中心的绘制坐标是', point.x, point.y);\n",paraId:36,tocIndex:4},{value:"获取视口中心绘制坐标。v4.2.1 支持。",paraId:37,tocIndex:5},{value:"参数",paraId:38,tocIndex:5},{value:"无",paraId:39,tocIndex:5},{value:"返回值",paraId:40,tocIndex:5},{value:"返回值类型：Object；",paraId:41,tocIndex:5},{value:"包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。",paraId:41,tocIndex:5},{value:"用法",paraId:42,tocIndex:5},{value:"const point = graph.getViewPortCenterPoint();\nconsole.log('视口中心的绘制坐标是', point.x, point.y);\n",paraId:43,tocIndex:5}]},82580:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"设置图初始化数据。",paraId:0},{value:"data",paraId:1},{value:" ",paraId:2,tocIndex:0},{value:"Object",paraId:2,tocIndex:0},{value:" ",paraId:2,tocIndex:0},{value:"required",paraId:2,tocIndex:0},{value:" ",paraId:2,tocIndex:0},{value:"初始化的图数据，是一个包括 nodes 数组和 edges 数组的对象。",paraId:3,tocIndex:0},{value:"用法",paraId:4,tocIndex:0},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n    },\n    {\n      id: 'node2',\n      label: 'node2',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n  ],\n};\n\n// graph 是 Graph 的实例\ngraph.data(data);\n",paraId:5,tocIndex:0},{value:"获取图数据。",paraId:6,tocIndex:1},{value:"该方法无参数。",paraId:7,tocIndex:1},{value:"返回值",paraId:8,tocIndex:1},{value:"返回值类型：Object；",paraId:9,tocIndex:1},{value:"返回值包括所有节点和边，数据结构如下下所示：",paraId:9,tocIndex:1},{value:"{\n\tnodes: [],\n  edges: [],\n  groups: [],\n}\n",paraId:10,tocIndex:1},{value:"用法",paraId:11,tocIndex:1},{value:"graph.save();\n",paraId:12,tocIndex:1},{value:"接收数据，并进行渲染，read 方法的功能相当于 data 和 render 方法的结合。",paraId:13,tocIndex:2},{value:"参数",paraId:14,tocIndex:2},{value:"名称",paraId:15,tocIndex:2},{value:"类型",paraId:15,tocIndex:2},{value:"是否必选",paraId:15,tocIndex:2},{value:"描述",paraId:15,tocIndex:2},{value:"data",paraId:15,tocIndex:2},{value:"Object",paraId:15,tocIndex:2},{value:"true",paraId:15,tocIndex:2},{value:"初始化的图数据，是一个包括 nodes 和 edges 的对象",paraId:15,tocIndex:2},{value:"用法",paraId:16,tocIndex:2},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n    },\n    {\n      id: 'node2',\n      label: 'node2',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n  ],\n};\n\n// graph是Graph的实例\ngraph.read(data);\n",paraId:17,tocIndex:2},{value:"更新数据源，根据新的数据重新渲染视图。",paraId:18,tocIndex:3},{value:"参数",paraId:19,tocIndex:3},{value:"名称",paraId:20,tocIndex:3},{value:"类型",paraId:20,tocIndex:3},{value:"是否必选",paraId:20,tocIndex:3},{value:"描述",paraId:20,tocIndex:3},{value:"data",paraId:20,tocIndex:3},{value:"Object",paraId:20,tocIndex:3},{value:"false",paraId:20,tocIndex:3},{value:"图数据，是一个包括 nodes 和 edges 的对象。若不指定该参数，则使用当前数据重新渲染",paraId:20,tocIndex:3},{value:"stack",paraId:20,tocIndex:3},{value:"boolean",paraId:20,tocIndex:3},{value:"false",paraId:20,tocIndex:3},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:20,tocIndex:3},{value:"用法",paraId:21,tocIndex:3},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n    },\n    {\n      id: 'node2',\n      label: 'node2',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n  ],\n};\n\n// graph是Graph的实例\ngraph.changeData(data);\n// 若不指定该参数，则使用当前图上的数据重新渲染\ngraph.changeData();\n",paraId:22,tocIndex:3}]},1050:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"清除画布元素。该方法一般用于清空数据源，重新设置数据源，重新 render 的场景，此时所有的图形都会被清除。",paraId:0,tocIndex:0},{value:"该方法无参数。",paraId:1,tocIndex:0},{value:"用法",paraId:2,tocIndex:0},{value:"graph.clear();\n",paraId:3,tocIndex:0},{value:"销毁画布。",paraId:4,tocIndex:1},{value:"该方法无参数。",paraId:5,tocIndex:1},{value:"用法",paraId:6,tocIndex:1},{value:"graph.destroy();\n",paraId:7,tocIndex:1}]},92039:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"将画布上的元素导出为图片。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"name",paraId:2,tocIndex:0},{value:"String",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"图片的名称，不指定则为 'graph'",paraId:2,tocIndex:0},{value:"type",paraId:2,tocIndex:0},{value:"'image/png'",paraId:2,tocIndex:0},{value:" / ",paraId:2,tocIndex:0},{value:"'image/jpeg'",paraId:2,tocIndex:0},{value:" / ",paraId:2,tocIndex:0},{value:"'image/webp'",paraId:2,tocIndex:0},{value:" / ",paraId:2,tocIndex:0},{value:"'image/bmp'",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"图片的类型。图的 ",paraId:2,tocIndex:0},{value:"renderer",paraId:2,tocIndex:0},{value:" 为默认的 ",paraId:2,tocIndex:0},{value:"'canvas'",paraId:2,tocIndex:0},{value:" 时生效，图的 ",paraId:2,tocIndex:0},{value:"renderer",paraId:2,tocIndex:0},{value:" 为 ",paraId:2,tocIndex:0},{value:"'svg'",paraId:2,tocIndex:0},{value:" 时将导出 svg 文件",paraId:2,tocIndex:0},{value:"imageConfig",paraId:2,tocIndex:0},{value:"Object",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"图片的配置项，可选，具体字段见下方",paraId:2,tocIndex:0},{value:"其中，imageConfig 为导出图片的配置参数：",paraId:3,tocIndex:0},{value:"名称",paraId:4,tocIndex:0},{value:"类型",paraId:4,tocIndex:0},{value:"是否必选",paraId:4,tocIndex:0},{value:"描述",paraId:4,tocIndex:0},{value:"backgroundColor",paraId:4,tocIndex:0},{value:"String",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"图片的背景色，可选，不传值时将导出透明背景的图片",paraId:4,tocIndex:0},{value:"padding",paraId:4,tocIndex:0},{value:"Number / Number[]",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"导出图片的上左下右 padding 值。当 ",paraId:4,tocIndex:0},{value:"padding",paraId:4,tocIndex:0},{value:" 为 number 类型时，四周 ",paraId:4,tocIndex:0},{value:"padding",paraId:4,tocIndex:0},{value:" 相等",paraId:4,tocIndex:0},{value:"用法",paraId:5,tocIndex:0},{value:"graph.downloadFullImage('tree-graph', 'image/png', {\n  backgroundColor: '#ddd',\n  padding: [30, 15, 15, 15],\n});\n",paraId:6,tocIndex:0},{value:"将画布上的元素导出为图片。",paraId:7,tocIndex:1},{value:"参数",paraId:8,tocIndex:1},{value:"名称",paraId:9,tocIndex:1},{value:"类型",paraId:9,tocIndex:1},{value:"是否必选",paraId:9,tocIndex:1},{value:"描述",paraId:9,tocIndex:1},{value:"name",paraId:9,tocIndex:1},{value:"String",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:"图片的名称，不指定则为 'graph'",paraId:9,tocIndex:1},{value:"type",paraId:9,tocIndex:1},{value:"'image/png'",paraId:9,tocIndex:1},{value:" / ",paraId:9,tocIndex:1},{value:"'image/jpeg'",paraId:9,tocIndex:1},{value:" / ",paraId:9,tocIndex:1},{value:"'image/webp'",paraId:9,tocIndex:1},{value:" / ",paraId:9,tocIndex:1},{value:"'image/bmp'",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:"图片的类型。图的 ",paraId:9,tocIndex:1},{value:"renderer",paraId:9,tocIndex:1},{value:" 为默认的 ",paraId:9,tocIndex:1},{value:"'canvas'",paraId:9,tocIndex:1},{value:" 时生效，图的 ",paraId:9,tocIndex:1},{value:"renderer",paraId:9,tocIndex:1},{value:" 为 ",paraId:9,tocIndex:1},{value:"'svg'",paraId:9,tocIndex:1},{value:" 时将导出 svg 文件",paraId:9,tocIndex:1},{value:"backgroundColor",paraId:9,tocIndex:1},{value:"String",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:"图片的背景色，可选，不传值时将导出透明背景的图片",paraId:9,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"graph.downloadImage();\n",paraId:11,tocIndex:1},{value:"将画布上元素生成为图片的 URL。",paraId:12,tocIndex:2},{value:"参数",paraId:13,tocIndex:2},{value:"名称",paraId:14,tocIndex:2},{value:"类型",paraId:14,tocIndex:2},{value:"是否必选",paraId:14,tocIndex:2},{value:"描述",paraId:14,tocIndex:2},{value:"callback",paraId:14,tocIndex:2},{value:"Function",paraId:14,tocIndex:2},{value:"true",paraId:14,tocIndex:2},{value:"异步生成 dataUrl 完成后的回调函数，在这里处理生成的 dataUrl 字符串",paraId:14,tocIndex:2},{value:"type",paraId:14,tocIndex:2},{value:"'image/png'",paraId:14,tocIndex:2},{value:" / ",paraId:14,tocIndex:2},{value:"'image/jpeg'",paraId:14,tocIndex:2},{value:" / ",paraId:14,tocIndex:2},{value:"'image/webp'",paraId:14,tocIndex:2},{value:" / ",paraId:14,tocIndex:2},{value:"'image/bmp'",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"图片的类型。图的 ",paraId:14,tocIndex:2},{value:"renderer",paraId:14,tocIndex:2},{value:" 为默认的 ",paraId:14,tocIndex:2},{value:"'canvas'",paraId:14,tocIndex:2},{value:" 时生效，图的 ",paraId:14,tocIndex:2},{value:"renderer",paraId:14,tocIndex:2},{value:" 为 ",paraId:14,tocIndex:2},{value:"'svg'",paraId:14,tocIndex:2},{value:" 时将导出 svg 文件",paraId:14,tocIndex:2},{value:"imageConfig",paraId:14,tocIndex:2},{value:"Object",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"图片的配置项，可选，具体字段见下方",paraId:14,tocIndex:2},{value:"其中，imageConfig 为导出图片的配置参数：",paraId:15,tocIndex:2},{value:"名称",paraId:16,tocIndex:2},{value:"类型",paraId:16,tocIndex:2},{value:"是否必选",paraId:16,tocIndex:2},{value:"描述",paraId:16,tocIndex:2},{value:"backgroundColor",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"图片的背景色，可选，不传值时将导出透明背景的图片",paraId:16,tocIndex:2},{value:"padding",paraId:16,tocIndex:2},{value:"Number / Number[]",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"导出图片的上左下右 padding 值。当 ",paraId:16,tocIndex:2},{value:"padding",paraId:16,tocIndex:2},{value:" 为 number 类型时，四周 ",paraId:16,tocIndex:2},{value:"padding",paraId:16,tocIndex:2},{value:" 相等",paraId:16,tocIndex:2},{value:"无返回值，生成的结果请在 callback 中处理。如下示例：",paraId:17,tocIndex:2},{value:"用法",paraId:18,tocIndex:2},{value:"graph.toFullDataUrl(\n  // 第一个参数为 callback，必须\n  (res) => {\n    // ... something\n    console.log(res); // 打印出结果\n  },\n  // 后两个参数不是必须\n  'image/jpeg',\n  (imageConfig: {\n    backgroundColor: '#fff',\n    padding: 10,\n  }),\n);\n",paraId:19,tocIndex:2},{value:"将画布上元素生成为图片的 URL。",paraId:20,tocIndex:3},{value:"参数",paraId:21,tocIndex:3},{value:"名称",paraId:22,tocIndex:3},{value:"类型",paraId:22,tocIndex:3},{value:"是否必选",paraId:22,tocIndex:3},{value:"描述",paraId:22,tocIndex:3},{value:"type",paraId:22,tocIndex:3},{value:"'image/png'",paraId:22,tocIndex:3},{value:" / ",paraId:22,tocIndex:3},{value:"'image/jpeg'",paraId:22,tocIndex:3},{value:" / ",paraId:22,tocIndex:3},{value:"'image/webp'",paraId:22,tocIndex:3},{value:" / ",paraId:22,tocIndex:3},{value:"'image/bmp'",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"图片的类型。图的 ",paraId:22,tocIndex:3},{value:"renderer",paraId:22,tocIndex:3},{value:" 为默认的 ",paraId:22,tocIndex:3},{value:"'canvas'",paraId:22,tocIndex:3},{value:" 时生效，图的 ",paraId:22,tocIndex:3},{value:"renderer",paraId:22,tocIndex:3},{value:" 为 ",paraId:22,tocIndex:3},{value:"'svg'",paraId:22,tocIndex:3},{value:" 时将导出 svg 文件",paraId:22,tocIndex:3},{value:"backgroundColor",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"图片的背景色，可选，不传值时将导出透明背景的图片",paraId:22,tocIndex:3},{value:"返回值",paraId:23,tocIndex:3},{value:"返回值类型：String；",paraId:24,tocIndex:3},{value:"返回值表示生成的图片的 URL。",paraId:24,tocIndex:3},{value:"用法",paraId:25,tocIndex:3},{value:"const dataURL = graph.toDataURL();\n",paraId:26,tocIndex:3}]},38151:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"获取图中所有节点的实例。",paraId:0,tocIndex:0},{value:"⚠️ 注意:",paraId:1,tocIndex:0},{value:" 这里返回的是节点的实例，而不是节点的数据项。",paraId:1,tocIndex:0},{value:"返回值",paraId:2,tocIndex:0},{value:"返回值类型：Array；",paraId:3,tocIndex:0},{value:"返回值表示图中所有节点的实例。",paraId:3,tocIndex:0},{value:"用法",paraId:4,tocIndex:0},{value:"const nodes = graph.getNodes();\n",paraId:5,tocIndex:0},{value:"获取图中所有边的实例。",paraId:6,tocIndex:1},{value:"⚠️ 注意:",paraId:7,tocIndex:1},{value:" 这里返回的是边的实例，而不是边的数据项。",paraId:7,tocIndex:1},{value:"返回值",paraId:8,tocIndex:1},{value:"返回值类型：Array；",paraId:9,tocIndex:1},{value:"返回值表示图中所有边的实例。",paraId:9,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"const edges = graph.getEdges();\n",paraId:11,tocIndex:1},{value:"获取当前图中所有 combo 的实例。",paraId:12,tocIndex:2},{value:"返回值",paraId:13,tocIndex:2},{value:"返回值类型：Array；",paraId:14,tocIndex:2},{value:"返回值表示图中所有 combo 的实例。",paraId:14,tocIndex:2},{value:"用法",paraId:15,tocIndex:2},{value:"const combos = graph.getCombos();\n",paraId:16,tocIndex:2},{value:"获取指定 combo 中所有的子节点及子 combo。",paraId:17,tocIndex:3},{value:"参数",paraId:18,tocIndex:3},{value:"名称",paraId:19,tocIndex:3},{value:"类型",paraId:19,tocIndex:3},{value:"是否必选",paraId:19,tocIndex:3},{value:"描述",paraId:19,tocIndex:3},{value:"combo",paraId:19,tocIndex:3},{value:"string / ICombo",paraId:19,tocIndex:3},{value:"true",paraId:19,tocIndex:3},{value:"Combo ID 或 combo 实例",paraId:19,tocIndex:3},{value:"返回值",paraId:20,tocIndex:3},{value:"返回值类型：Object，格式如下",paraId:21,tocIndex:3},{value:"{\n    nodes: INode[],\n    edges: ICombo[]\n}\n",paraId:22,tocIndex:3},{value:"返回指定 combo 中的子元素（子节点及子 combo）。",paraId:23,tocIndex:3},{value:"用法",paraId:24,tocIndex:3},{value:"const elements: {\n  nodes: INode[],\n  combos: ICombo[]\n} = graph.getComboChildren('combo1')\n",paraId:25,tocIndex:3},{value:"参数",paraId:26,tocIndex:4},{value:"名称",paraId:27,tocIndex:4},{value:"类型",paraId:27,tocIndex:4},{value:"是否必选",paraId:27,tocIndex:4},{value:"描述",paraId:27,tocIndex:4},{value:"node",paraId:27,tocIndex:4},{value:"string / INode",paraId:27,tocIndex:4},{value:"true",paraId:27,tocIndex:4},{value:"节点 ID 或节点实例",paraId:27,tocIndex:4},{value:"type",paraId:27,tocIndex:4},{value:"'source' / 'target' / undefined",paraId:27,tocIndex:4},{value:"false",paraId:27,tocIndex:4},{value:"邻居类型， 'source' 只获取当前节点的源节点，'target' 只获取当前节点指向的目标节点， 若不指定则返回所有类型的邻居",paraId:27,tocIndex:4},{value:"返回值",paraId:28,tocIndex:4},{value:"返回值类型：Array；",paraId:29,tocIndex:4},{value:"返回值符合要求的节点数组。",paraId:29,tocIndex:4},{value:"用法",paraId:30,tocIndex:4},{value:"const neighbors = graph.getNeighbors('node1', 'source');\n",paraId:31,tocIndex:4},{value:"根据具体规则查找单个元素。",paraId:32,tocIndex:5},{value:"参数",paraId:33,tocIndex:5},{value:"名称",paraId:34,tocIndex:5},{value:"类型",paraId:34,tocIndex:5},{value:"是否必选",paraId:34,tocIndex:5},{value:"描述",paraId:34,tocIndex:5},{value:"type",paraId:34,tocIndex:5},{value:"string",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:"元素类型，可选值为 ",paraId:34,tocIndex:5},{value:"'node'",paraId:34,tocIndex:5},{value:"、",paraId:34,tocIndex:5},{value:"'edge'",paraId:34,tocIndex:5},{value:"fn",paraId:34,tocIndex:5},{value:"Function",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:"查找的规则",paraId:34,tocIndex:5},{value:"返回值",paraId:35,tocIndex:5},{value:"返回值类型：Object；",paraId:36,tocIndex:5},{value:"如果有符合规则的元素实例，则返回第一个匹配的元素实例，否则返回 ",paraId:36,tocIndex:5},{value:"undefined",paraId:36,tocIndex:5},{value:" 。",paraId:36,tocIndex:5},{value:"用法",paraId:37,tocIndex:5},{value:"const findNode = graph.find('node', (node) => {\n  return node.get('model').x === 100;\n});\n",paraId:38,tocIndex:5},{value:"根据 ID，查询对应的元素实例。",paraId:39,tocIndex:6},{value:"参数",paraId:40,tocIndex:6},{value:"名称",paraId:41,tocIndex:6},{value:"类型",paraId:41,tocIndex:6},{value:"是否必选",paraId:41,tocIndex:6},{value:"描述",paraId:41,tocIndex:6},{value:"id",paraId:41,tocIndex:6},{value:"string",paraId:41,tocIndex:6},{value:"true",paraId:41,tocIndex:6},{value:"元素 ID",paraId:41,tocIndex:6},{value:"返回值",paraId:42,tocIndex:6},{value:"返回值类型：Object；",paraId:43,tocIndex:6},{value:"如果有符合规则的元素实例，则返回该元素实例，否则返回 ",paraId:43,tocIndex:6},{value:"undefined",paraId:43,tocIndex:6},{value:"。",paraId:43,tocIndex:6},{value:"用法",paraId:44,tocIndex:6},{value:"const node = graph.findById('node');\n",paraId:45,tocIndex:6},{value:"查询所有满足规则的元素。",paraId:46,tocIndex:7},{value:"参数",paraId:47,tocIndex:7},{value:"名称",paraId:48,tocIndex:7},{value:"类型",paraId:48,tocIndex:7},{value:"是否必选",paraId:48,tocIndex:7},{value:"描述",paraId:48,tocIndex:7},{value:"type",paraId:48,tocIndex:7},{value:"string",paraId:48,tocIndex:7},{value:"true",paraId:48,tocIndex:7},{value:"元素类型，可选值为 ",paraId:48,tocIndex:7},{value:"'node'",paraId:48,tocIndex:7},{value:"、",paraId:48,tocIndex:7},{value:"'edge'",paraId:48,tocIndex:7},{value:"fn",paraId:48,tocIndex:7},{value:"Function",paraId:48,tocIndex:7},{value:"true",paraId:48,tocIndex:7},{value:"查找的规则",paraId:48,tocIndex:7},{value:"返回值",paraId:49,tocIndex:7},{value:"返回值类型：Array；",paraId:50,tocIndex:7},{value:"如果有符合规则的元素实例，则返回所有元素实例，否则返回 ",paraId:50,tocIndex:7},{value:"undefined",paraId:50,tocIndex:7},{value:"。",paraId:50,tocIndex:7},{value:"用法",paraId:51,tocIndex:7},{value:"const nodes = graph.findAll('node', (node) => {\n  return node.get('model').x;\n});\n",paraId:52,tocIndex:7},{value:"查找所有处于指定状态的元素。",paraId:53,tocIndex:8},{value:"参数",paraId:54,tocIndex:8},{value:"名称",paraId:55,tocIndex:8},{value:"类型",paraId:55,tocIndex:8},{value:"是否必选",paraId:55,tocIndex:8},{value:"描述",paraId:55,tocIndex:8},{value:"type",paraId:55,tocIndex:8},{value:"string",paraId:55,tocIndex:8},{value:"true",paraId:55,tocIndex:8},{value:"元素类型，可选值为 ",paraId:55,tocIndex:8},{value:"'node'",paraId:55,tocIndex:8},{value:"、",paraId:55,tocIndex:8},{value:"'edge'",paraId:55,tocIndex:8},{value:"state",paraId:55,tocIndex:8},{value:"string",paraId:55,tocIndex:8},{value:"true",paraId:55,tocIndex:8},{value:"状态名称",paraId:55,tocIndex:8},{value:"返回值",paraId:56,tocIndex:8},{value:"返回值类型：Array；",paraId:57,tocIndex:8},{value:"返回所有指定状态的元素实例。",paraId:57,tocIndex:8},{value:"用法",paraId:58,tocIndex:8},{value:"// 查询所有选中的元素\nconst nodes = graph.findAllByState('node', 'selected');\n",paraId:59,tocIndex:8}]},37292:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"根据 key 获取属性值。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"key",paraId:2,tocIndex:0},{value:"string",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"属性的键",paraId:2,tocIndex:0},{value:"用法",paraId:3,tocIndex:0},{value:"// 获取 group\nconst group = graph.get('group');\n\n// 获取 canvas 实例\nconst canvas = graph.get('canvas');\n\n// 获取 autoPaint 值\nconst autoPaint = graph.get('autoPaint');\n",paraId:4,tocIndex:0},{value:"设置属性值。",paraId:5,tocIndex:1},{value:"参数",paraId:6,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"是否必选",paraId:7,tocIndex:1},{value:"描述",paraId:7,tocIndex:1},{value:"key",paraId:7,tocIndex:1},{value:"string",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"属性的键",paraId:7,tocIndex:1},{value:"val",paraId:7,tocIndex:1},{value:"string / Object / Array",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"属性的值",paraId:7,tocIndex:1},{value:"用法",paraId:8,tocIndex:1},{value:"// 设置 capture 值为 false\ngraph.set('capture', false);\n\n// 设置 customGroup 值为 group\ngraph.set('customGroup', group);\n\n// 设置 nodeIdList 值为数组\ngraph.set('nodeIdList', [1, 3, 5]);\n",paraId:9,tocIndex:1},{value:"获取 Graph 的 DOM 容器。",paraId:10,tocIndex:2},{value:"参数",paraId:11,tocIndex:2},{value:"无参数",paraId:12,tocIndex:2},{value:"用法",paraId:13,tocIndex:2},{value:"graph.getContainer();\n",paraId:14,tocIndex:2},{value:"获取 Graph 根",paraId:15,tocIndex:3},{value:"图形分组",paraId:16,tocIndex:3},{value:"。",paraId:15,tocIndex:3},{value:"参数",paraId:17,tocIndex:3},{value:"无参数",paraId:18,tocIndex:3},{value:"用法",paraId:19,tocIndex:3},{value:"graph.getGroup();\n",paraId:20,tocIndex:3},{value:"获取 graph 当前允许的最小缩放比例。",paraId:21,tocIndex:4},{value:"参数",paraId:22,tocIndex:4},{value:"无参数",paraId:23,tocIndex:4},{value:"用法",paraId:24,tocIndex:4},{value:"graph.getMinZoom();\n",paraId:25,tocIndex:4},{value:"设置 graph 当前允许的最小缩放比例。",paraId:26,tocIndex:5},{value:"参数",paraId:27,tocIndex:5},{value:"名称",paraId:28,tocIndex:5},{value:"类型",paraId:28,tocIndex:5},{value:"是否必选",paraId:28,tocIndex:5},{value:"描述",paraId:28,tocIndex:5},{value:"ratio",paraId:28,tocIndex:5},{value:"number",paraId:28,tocIndex:5},{value:"true",paraId:28,tocIndex:5},{value:"最小缩放比例值",paraId:28,tocIndex:5},{value:"用法",paraId:29,tocIndex:5},{value:"graph.setMinZoom(0.001);\n",paraId:30,tocIndex:5},{value:"获取 graph 当前允许的最大缩放比例。",paraId:31,tocIndex:6},{value:"参数",paraId:32,tocIndex:6},{value:"无参数",paraId:33,tocIndex:6},{value:"用法",paraId:34,tocIndex:6},{value:"graph.getMaxZoom();\n",paraId:35,tocIndex:6},{value:"设置 graph 当前允许的最大缩放比例。",paraId:36,tocIndex:7},{value:"参数",paraId:37,tocIndex:7},{value:"名称",paraId:38,tocIndex:7},{value:"类型",paraId:38,tocIndex:7},{value:"是否必选",paraId:38,tocIndex:7},{value:"描述",paraId:38,tocIndex:7},{value:"ratio",paraId:38,tocIndex:7},{value:"number",paraId:38,tocIndex:7},{value:"true",paraId:38,tocIndex:7},{value:"最大缩放比例值",paraId:38,tocIndex:7},{value:"用法",paraId:39,tocIndex:7},{value:"graph.setMaxZoom(1000);\n",paraId:40,tocIndex:7},{value:"获取 graph 当前的宽度。",paraId:41,tocIndex:8},{value:"参数",paraId:42,tocIndex:8},{value:"无参数",paraId:43,tocIndex:8},{value:"用法",paraId:44,tocIndex:8},{value:"graph.getWidth();\n",paraId:45,tocIndex:8},{value:"获取 graph 当前的高度。",paraId:46,tocIndex:9},{value:"参数",paraId:47,tocIndex:9},{value:"无参数",paraId:48,tocIndex:9},{value:"用法",paraId:49,tocIndex:9},{value:"graph.getHeight();\n",paraId:50,tocIndex:9}]},47179:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"参数",paraId:0,tocIndex:0},{value:"名称",paraId:1,tocIndex:0},{value:"类型",paraId:1,tocIndex:0},{value:"是否必选",paraId:1,tocIndex:0},{value:"描述",paraId:1,tocIndex:0},{value:"cfg",paraId:1,tocIndex:0},{value:"HullCfg",paraId:1,tocIndex:0},{value:"true",paraId:1,tocIndex:0},{value:"轮廓配置项",paraId:1,tocIndex:0},{value:"轮廓包裹的形状支持 ",paraId:2,tocIndex:0},{value:"round-convex",paraId:2,tocIndex:0},{value:" / ",paraId:2,tocIndex:0},{value:"smooth-convex",paraId:2,tocIndex:0},{value:" / ",paraId:2,tocIndex:0},{value:"bubble",paraId:2,tocIndex:0},{value:" 三种类型，默认为 ",paraId:2,tocIndex:0},{value:"round-convex",paraId:2,tocIndex:0},{value:" 类型。",paraId:2,tocIndex:0},{value:"round-convex",paraId:2,tocIndex:0},{value:" 为圆角凸包轮廓，smooth-convex 为平滑曲线凸包轮廓，这两种凸包轮廓不可绕开配置项中的 nonMembers；bubble 为自由凹包轮廓，可以绕开 nonMembers。配置项（ HullCfg）支持的配置参数详情如下：",paraId:2,tocIndex:0},{value:"名称",paraId:3,tocIndex:0},{value:"类型",paraId:3,tocIndex:0},{value:"是否必选",paraId:3,tocIndex:0},{value:"描述",paraId:3,tocIndex:0},{value:"id",paraId:3,tocIndex:0},{value:"string",paraId:3,tocIndex:0},{value:"true",paraId:3,tocIndex:0},{value:"包裹的 id",paraId:3,tocIndex:0},{value:"type",paraId:3,tocIndex:0},{value:"round-convex",paraId:3,tocIndex:0},{value:" / ",paraId:3,tocIndex:0},{value:"smooth-convex",paraId:3,tocIndex:0},{value:" / ",paraId:3,tocIndex:0},{value:"bubble",paraId:3,tocIndex:0},{value:"false",paraId:3,tocIndex:0},{value:"包裹的类型：",paraId:3,tocIndex:0},{value:"round-convex",paraId:3,tocIndex:0},{value:" 生成圆角凸包轮廓，",paraId:3,tocIndex:0},{value:"smooth-convex",paraId:3,tocIndex:0},{value:" 生成平滑凸包轮廓 / ",paraId:3,tocIndex:0},{value:"bubble",paraId:3,tocIndex:0},{value:" 产生一种可以避开 nonMembers 的平滑凹包轮廓（",paraId:3,tocIndex:0},{value:"算法",paraId:3,tocIndex:0},{value:"）。 默认值是 ",paraId:3,tocIndex:0},{value:"round-convex",paraId:3,tocIndex:0},{value:"。",paraId:3,tocIndex:0},{value:"members",paraId:3,tocIndex:0},{value:"Item[] / string[]",paraId:3,tocIndex:0},{value:"true",paraId:3,tocIndex:0},{value:"在包裹内部的节点实例或节点 Id 数组",paraId:3,tocIndex:0},{value:"nonMembers",paraId:3,tocIndex:0},{value:"Item[] / string[]",paraId:3,tocIndex:0},{value:"false",paraId:3,tocIndex:0},{value:"不在轮廓内部的节点数组，只在 ",paraId:3,tocIndex:0},{value:"bubble",paraId:3,tocIndex:0},{value:" 类型的包裹中生效",paraId:3,tocIndex:0},{value:"padding",paraId:3,tocIndex:0},{value:"number",paraId:3,tocIndex:0},{value:"false",paraId:3,tocIndex:0},{value:"轮廓边缘和内部成员的间距",paraId:3,tocIndex:0},{value:"style",paraId:3,tocIndex:0},{value:"object",paraId:3,tocIndex:0},{value:"false",paraId:3,tocIndex:0},{value:"轮廓的样式属性，属性包括 fill (填充颜色), stroke (描边颜色), opacity (透明度)",paraId:3,tocIndex:0},{value:"用法",paraId:4,tocIndex:0},{value:"let centerNodes = graph.getNodes().filter((node) => !node.getModel().isLeaf);\ngraph.on('afterlayout', () => {\n  const hull1 = graph.createHull({\n    id: 'centerNode-hull',\n    type: 'bubble',\n    members: centerNodes,\n    padding: 10,\n  });\n\n  const hull2 = graph.createHull({\n    id: 'leafNode-hull1',\n    members: ['node6', 'node7'],\n    padding: 10,\n    style: {\n      fill: 'lightgreen',\n      stroke: 'green',\n    },\n  });\n\n  const hull3 = graph.createHull({\n    id: 'leafNode-hull2',\n    members: ['node8', 'node9', 'node10', 'node11', 'node12'],\n    padding: 10,\n    style: {\n      fill: 'lightgreen',\n      stroke: 'green',\n    },\n  });\n\n  graph.on('afterupdateitem', (e) => {\n    hull1.updateData(hull1.members);\n    hull2.updateData(hull2.members);\n    hull3.updateData(hull3.members);\n  });\n});\n",paraId:5,tocIndex:0},{value:"获取图上所有的包裹轮廓。",paraId:6,tocIndex:1},{value:"返回值",paraId:7,tocIndex:1},{value:"返回值类型：Object；对象中的 key 是字符串类型，代表 hull 的 ID ，对象中的 value 是对应的 hull 实例。",paraId:8,tocIndex:1},{value:"返回值表示当前 graph 中所有轮廓 ID 到 轮廓实例的映射。",paraId:8,tocIndex:1},{value:"用法",paraId:9,tocIndex:1},{value:"const hullMap = graph.getHulls();\n",paraId:10,tocIndex:1},{value:"移除指定 id 或指定实例的轮廓。",paraId:11,tocIndex:2},{value:"参数",paraId:12,tocIndex:2},{value:"名称",paraId:13,tocIndex:2},{value:"类型",paraId:13,tocIndex:2},{value:"是否必选",paraId:13,tocIndex:2},{value:"描述",paraId:13,tocIndex:2},{value:"hull",paraId:13,tocIndex:2},{value:"string / Hull",paraId:13,tocIndex:2},{value:"true",paraId:13,tocIndex:2},{value:"轮廓 id 或轮廓实例",paraId:13,tocIndex:2},{value:"用法",paraId:14,tocIndex:2},{value:"graph.removeHull('myHull');\n",paraId:15,tocIndex:2},{value:"移除当前图上所有轮廓实例。",paraId:16,tocIndex:3},{value:"参数",paraId:17,tocIndex:3},{value:"无参数。",paraId:18,tocIndex:3},{value:"用法",paraId:19,tocIndex:3},{value:"graph.removeHulls();\n",paraId:20,tocIndex:3}]},3735:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"新增元素（节点和边）。",paraId:0,tocIndex:1},{value:"⚠️ 注意: ",paraId:1,tocIndex:1},{value:"将会直接使用 ",paraId:1,tocIndex:1},{value:"model",paraId:1,tocIndex:1},{value:" 对象作为新增元素的数据模型，G6 内部可能会对其增加或修改一些必要的字段。若不希望原始参数被修改，建议在使用深拷贝后的 ",paraId:1,tocIndex:1},{value:"model",paraId:1,tocIndex:1},{value:"。",paraId:1,tocIndex:1},{value:"参数",paraId:2,tocIndex:1},{value:"名称",paraId:3,tocIndex:1},{value:"类型",paraId:3,tocIndex:1},{value:"是否必选",paraId:3,tocIndex:1},{value:"描述",paraId:3,tocIndex:1},{value:"type",paraId:3,tocIndex:1},{value:"string",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:"元素类型，可选值为 ",paraId:3,tocIndex:1},{value:"'node'",paraId:3,tocIndex:1},{value:"、",paraId:3,tocIndex:1},{value:"'edge'",paraId:3,tocIndex:1},{value:"model",paraId:3,tocIndex:1},{value:"Object",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:"元素的数据模型，具体内容参见",paraId:3,tocIndex:1},{value:"元素配置项",paraId:4,tocIndex:1},{value:"。",paraId:3,tocIndex:1},{value:"stack",paraId:3,tocIndex:1},{value:"boolean",paraId:3,tocIndex:1},{value:"false",paraId:3,tocIndex:1},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:3,tocIndex:1},{value:"用法",paraId:5,tocIndex:1},{value:"const model = {\n  id: 'node',\n  label: 'node',\n  address: 'cq',\n  x: 200,\n  y: 150,\n  style: {\n    fill: 'blue',\n  },\n};\n\ngraph.addItem('node', model);\n",paraId:6,tocIndex:1},{value:"删除元素，当 item 为 group ID 时候，则删除分组。",paraId:7,tocIndex:2},{value:"参数",paraId:8,tocIndex:2},{value:"名称",paraId:9,tocIndex:2},{value:"类型",paraId:9,tocIndex:2},{value:"是否必选",paraId:9,tocIndex:2},{value:"描述",paraId:9,tocIndex:2},{value:"item",paraId:9,tocIndex:2},{value:"string / Object",paraId:9,tocIndex:2},{value:"true",paraId:9,tocIndex:2},{value:"元素 ID 或元素实例",paraId:9,tocIndex:2},{value:"stack",paraId:9,tocIndex:2},{value:"boolean",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:9,tocIndex:2},{value:"用法",paraId:10,tocIndex:2},{value:"// 通过 ID 查询节点实例\nconst item = graph.findById('node');\ngraph.removeItem(item);\n\n// 该操作不会进入到 undo & redo 栈，即 redo & undo 操作会忽略该操作\ngraph.removeItem(item, false);\n",paraId:11,tocIndex:2},{value:"更新元素，包括更新数据、样式等。若图上有 combo，使用该函数更新一个节点位置后，需要调用 ",paraId:12,tocIndex:4},{value:"updateCombo(combo)",paraId:13,tocIndex:4},{value:" 以更新相关 combo 的位置。",paraId:12,tocIndex:4},{value:"参数",paraId:14,tocIndex:4},{value:"名称",paraId:15,tocIndex:4},{value:"类型",paraId:15,tocIndex:4},{value:"是否必选",paraId:15,tocIndex:4},{value:"描述",paraId:15,tocIndex:4},{value:"item",paraId:15,tocIndex:4},{value:"string / Object",paraId:15,tocIndex:4},{value:"true",paraId:15,tocIndex:4},{value:"元素 ID 或元素实例",paraId:15,tocIndex:4},{value:"model",paraId:15,tocIndex:4},{value:"Object",paraId:15,tocIndex:4},{value:"true",paraId:15,tocIndex:4},{value:"需要更新的数据模型，具体内容参见",paraId:15,tocIndex:4},{value:"元素配置项",paraId:16,tocIndex:4},{value:"stack",paraId:15,tocIndex:4},{value:"boolean",paraId:15,tocIndex:4},{value:"false",paraId:15,tocIndex:4},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:15,tocIndex:4},{value:"用法",paraId:17,tocIndex:4},{value:"const model = {\n  id: 'node',\n  label: 'node',\n  address: 'cq',\n  x: 200,\n  y: 150,\n  style: {\n    fill: 'blue',\n  },\n};\n\n// 通过 ID 查询节点实例\nconst item = graph.findById('node');\ngraph.updateItem(item, model);\n",paraId:18,tocIndex:4},{value:"刷新指定元素。",paraId:19,tocIndex:5},{value:"参数",paraId:20,tocIndex:5},{value:"名称",paraId:21,tocIndex:5},{value:"类型",paraId:21,tocIndex:5},{value:"是否必选",paraId:21,tocIndex:5},{value:"描述",paraId:21,tocIndex:5},{value:"item",paraId:21,tocIndex:5},{value:"string / Object",paraId:21,tocIndex:5},{value:"true",paraId:21,tocIndex:5},{value:"元素 ID 或元素实例",paraId:21,tocIndex:5},{value:"用法",paraId:22,tocIndex:5},{value:"// 通过 ID 查询节点实例\nconst item = graph.findById('node');\ngraph.refreshItem(item);\n",paraId:23,tocIndex:5},{value:"当节点位置发生变化时，刷新所有节点位置，并重计算边的位置。",paraId:24,tocIndex:6},{value:"该方法无参数。",paraId:25,tocIndex:6},{value:"用法",paraId:26,tocIndex:6},{value:"graph.refreshPositions();\n",paraId:27,tocIndex:6},{value:"根据子元素（子节点与子 combo）的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围。",paraId:28,tocIndex:7},{value:"用法",paraId:29,tocIndex:7},{value:"// 更新所有 combos\ngraph.updateCombos();\n",paraId:30,tocIndex:7},{value:"仅更新 combo 及其所有祖先 combo。建议在使用 graph.updateItem 来更新节点位置时，调用该方法以更新节点的祖先 combos。",paraId:31,tocIndex:8},{value:"参数",paraId:32,tocIndex:8},{value:"名称",paraId:33,tocIndex:8},{value:"类型",paraId:33,tocIndex:8},{value:"是否必选",paraId:33,tocIndex:8},{value:"描述",paraId:33,tocIndex:8},{value:"combo",paraId:33,tocIndex:8},{value:"string / ICombo",paraId:33,tocIndex:8},{value:"true",paraId:33,tocIndex:8},{value:"Combo ID 或 Combo 实例",paraId:33,tocIndex:8},{value:"用法",paraId:34,tocIndex:8},{value:"// 更新了某个节点的位置\nconst node1 = graph.findById('node1');\ngraph.updateItem(node1, {\n  x: 100,\n  y: 100,\n});\nconst comboId = node1.getModel().comboId;\n\n// 更新 node1 所属的 combo 及其所有祖先 combo 的大小和位置\ngraph.updateCombo(comboId);\n",paraId:35,tocIndex:8},{value:"更新 Combo 结构，例如移动子树等。",paraId:36,tocIndex:9},{value:"参数",paraId:37,tocIndex:9},{value:"名称",paraId:38,tocIndex:9},{value:"类型",paraId:38,tocIndex:9},{value:"是否必选",paraId:38,tocIndex:9},{value:"描述",paraId:38,tocIndex:9},{value:"item",paraId:38,tocIndex:9},{value:"string / INode / ICombo",paraId:38,tocIndex:9},{value:"true",paraId:38,tocIndex:9},{value:"需要被更新的 Combo 或 节点 ID",paraId:38,tocIndex:9},{value:"parentId",paraId:38,tocIndex:9},{value:"string / undefined",paraId:38,tocIndex:9},{value:"false",paraId:38,tocIndex:9},{value:"新的父 combo ID，undefined 代表没有父 combo",paraId:38,tocIndex:9},{value:"用法",paraId:39,tocIndex:9},{value:"// 将 combo1 从父 combo 中移出，完成后同原父 combo 平级\ngraph.updateComboTree('combo1')\n\n// 将 combo1 移动到 Combo2 下面，作为 Combo2 的子元素\ngraph.updateComboTree('combo1', 'combo2')\n",paraId:40,tocIndex:9},{value:"设置各个节点样式及其他配置，以及在各个状态下节点的 KeyShape 的样式。",paraId:41,tocIndex:11},{value:"提示:",paraId:42,tocIndex:11},{value:" 该方法必须",paraId:42,tocIndex:11},{value:"在 render 之前调用",paraId:42,tocIndex:11},{value:"，否则不起作用。",paraId:42,tocIndex:11},{value:"参数",paraId:43,tocIndex:11},{value:"名称",paraId:44,tocIndex:11},{value:"类型",paraId:44,tocIndex:11},{value:"是否必选",paraId:44,tocIndex:11},{value:"描述",paraId:44,tocIndex:11},{value:"nodeFn",paraId:44,tocIndex:11},{value:"Function",paraId:44,tocIndex:11},{value:"true",paraId:44,tocIndex:11},{value:"返回每个节点的配置",paraId:44,tocIndex:11},{value:"用法",paraId:45,tocIndex:11},{value:"graph.node((node) => {\n  return {\n    id: node.id,\n    type: 'rect',\n    style: {\n      fill: 'blue',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:46,tocIndex:11},{value:"设置各个边样式及其他配置，以及在各个状态下节点的 KeyShape 的样式。",paraId:47,tocIndex:12},{value:"提示:",paraId:48,tocIndex:12},{value:" 该方法必须",paraId:48,tocIndex:12},{value:"在 render 之前调用",paraId:48,tocIndex:12},{value:"，否则不起作用。",paraId:48,tocIndex:12},{value:"参数",paraId:49,tocIndex:12},{value:"名称",paraId:50,tocIndex:12},{value:"类型",paraId:50,tocIndex:12},{value:"是否必选",paraId:50,tocIndex:12},{value:"描述",paraId:50,tocIndex:12},{value:"edgeFn",paraId:50,tocIndex:12},{value:"Function",paraId:50,tocIndex:12},{value:"true",paraId:50,tocIndex:12},{value:"返回每条边的配置",paraId:50,tocIndex:12},{value:"用法",paraId:51,tocIndex:12},{value:"graph.edge((edge) => {\n  return {\n    id: edge.id,\n    type: 'cubic-horizontal',\n    style: {\n      stroke: 'green',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:52,tocIndex:12},{value:"设置各个 combo 样式及其他配置，以及在各个状态下节点的 KeyShape 的样式。",paraId:53,tocIndex:13},{value:"提示:",paraId:54,tocIndex:13},{value:" 该方法必须",paraId:54,tocIndex:13},{value:"在 render 之前调用",paraId:54,tocIndex:13},{value:"，否则不起作用。",paraId:54,tocIndex:13},{value:"参数",paraId:55,tocIndex:13},{value:"名称",paraId:56,tocIndex:13},{value:"类型",paraId:56,tocIndex:13},{value:"是否必选",paraId:56,tocIndex:13},{value:"描述",paraId:56,tocIndex:13},{value:"comboFn",paraId:56,tocIndex:13},{value:"Function",paraId:56,tocIndex:13},{value:"true",paraId:56,tocIndex:13},{value:"返回每个 combo 的配置",paraId:56,tocIndex:13},{value:"用法",paraId:57,tocIndex:13},{value:"graph.combo((combo) => {\n  return {\n    id: combo.id,\n    type: 'rect',\n    style: {\n      stroke: 'green',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:58,tocIndex:13},{value:"显示指定的元素。若 item 为节点，则相关边也会随之显示。而 ",paraId:59,tocIndex:15},{value:"item.show()",paraId:60,tocIndex:15},{value:" 则将只显示自身。",paraId:59,tocIndex:15},{value:"参数",paraId:61,tocIndex:15},{value:"名称",paraId:62,tocIndex:15},{value:"类型",paraId:62,tocIndex:15},{value:"是否必选",paraId:62,tocIndex:15},{value:"描述",paraId:62,tocIndex:15},{value:"item",paraId:62,tocIndex:15},{value:"string / Object",paraId:62,tocIndex:15},{value:"true",paraId:62,tocIndex:15},{value:"元素 ID 或元素实例",paraId:62,tocIndex:15},{value:"stack",paraId:62,tocIndex:15},{value:"boolean",paraId:62,tocIndex:15},{value:"false",paraId:62,tocIndex:15},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:62,tocIndex:15},{value:"用法",paraId:63,tocIndex:15},{value:"// 通过 ID 查询节点实例\nconst item = graph.findById('nodeId');\ngraph.showItem(item);\n\n// 等价于\ngraph.showItem('nodeId');\n",paraId:64,tocIndex:15},{value:"隐藏指定元素。若 item 为节点，则相关边也会随之隐藏。而 ",paraId:65,tocIndex:16},{value:"item.hide()",paraId:66,tocIndex:16},{value:" 则将只隐藏自身。",paraId:65,tocIndex:16},{value:"参数",paraId:67,tocIndex:16},{value:"名称",paraId:68,tocIndex:16},{value:"类型",paraId:68,tocIndex:16},{value:"是否必选",paraId:68,tocIndex:16},{value:"描述",paraId:68,tocIndex:16},{value:"item",paraId:68,tocIndex:16},{value:"string / Object",paraId:68,tocIndex:16},{value:"true",paraId:68,tocIndex:16},{value:"元素 ID 或元素实例",paraId:68,tocIndex:16},{value:"stack",paraId:68,tocIndex:16},{value:"boolean",paraId:68,tocIndex:16},{value:"false",paraId:68,tocIndex:16},{value:"操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可",paraId:68,tocIndex:16},{value:"用法",paraId:69,tocIndex:16},{value:"// 通过 ID 查询节点实例\nconst item = graph.findById('nodeId');\ngraph.hideItem(item);\n\n// 等价于\ngraph.hideItem('nodeId');\n",paraId:70,tocIndex:16}]},8312:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 3.1 内置了丰富的布局。关于如何使用 G6 中内置的布局，请参考  ",paraId:0},{value:"图布局 API",paraId:1},{value:" 或 ",paraId:0},{value:"树图布局 API",paraId:2},{value:"。",paraId:0},{value:"重新以当前配置的属性进行一次布局。",paraId:3,tocIndex:0},{value:"用法",paraId:4,tocIndex:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'force',\n  },\n  modes: {\n    default: ['drag-node'],\n  },\n});\n\ngraph.data({\n  nodes: data.nodes,\n  edges: data.edges.map((edge, i) => {\n    edge.id = 'edge' + i;\n    return Object.assign({}, edge);\n  }),\n});\n\ngraph.render();\n\nfunction refreshDragedNodePosition(e) {\n  const model = e.item.get('model');\n  model.fx = e.x;\n  model.fy = e.y;\n}\n\ngraph.on('node:dragstart', (e) => {\n  // 拖动节点时重新布局\n  graph.layout();\n  refreshDragedNodePosition(e);\n});\n\ngraph.on('node:drag', (e) => {\n  refreshDragedNodePosition(e);\n});\n\ngraph.on('node:dragend', (e) => {\n  e.item.get('model').fx = null;\n  e.item.get('model').fy = null;\n});\n",paraId:5,tocIndex:0},{value:"更新布局配置项。",paraId:6,tocIndex:1},{value:"如果参数 ",paraId:7,tocIndex:1},{value:"cfg",paraId:7,tocIndex:1},{value:" 中含有 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 字段，",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 字段类型为 String，且与现有布局方法不同，则更换布局；",paraId:7,tocIndex:1},{value:"如果参数 ",paraId:7,tocIndex:1},{value:"cfg",paraId:7,tocIndex:1},{value:" 中不包含 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 字段，则保持原有布局，仅更新布局配置项。",paraId:7,tocIndex:1},{value:"参数",paraId:8,tocIndex:1},{value:"名称",paraId:9,tocIndex:1},{value:"类型",paraId:9,tocIndex:1},{value:"是否必选",paraId:9,tocIndex:1},{value:"描述",paraId:9,tocIndex:1},{value:"cfg",paraId:9,tocIndex:1},{value:"Object",paraId:9,tocIndex:1},{value:"true",paraId:9,tocIndex:1},{value:"新布局配置项",paraId:9,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  modes: {\n    default: ['drag-canvas', 'drag-node'],\n  },\n  layout: {\n    type: 'circular',\n    center: [500, 300],\n  },\n  animate: true,\n});\ngraph.data(data);\ngraph.render();\n\n// 实例化时通过 layout 指定布局，在合适的时候通过 updateLayout 更新布局配置\ngraph.updateLayout({\n  radius: 200,\n  startAngle: Math.PI / 4,\n  endAngle: Math.PI,\n  divisions: 5,\n  ordering: 'degree',\n});\n",paraId:11,tocIndex:1},{value:"销毁布局方法，在此之后调用 ",paraId:12,tocIndex:2},{value:"changeData",paraId:12,tocIndex:2},{value:" 等方法将不会按照原有的布局算法进行布局。",paraId:12,tocIndex:2},{value:"用法",paraId:13,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  modes: {\n    default: ['drag-canvas', 'drag-node'],\n  },\n  layout: {\n    type: 'circular',\n    center: [500, 300],\n  },\n  animate: true,\n});\ngraph.data(data);\ngraph.render();\ngraph.destroyLayout();\n// 此时 changeData，若 data2 中的节点没有位置信息，将按照初始化计算方法被放置；若有位置信息，则按照该信息被放置\ngraph.changeData(data2);\n",paraId:14,tocIndex:2}]},49254:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"切换图行为模式。主要用于不同模式下的行为切换，如从编辑模式下切换到只读模式。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"mode",paraId:2,tocIndex:0},{value:"string",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"模式的名称",paraId:2,tocIndex:0},{value:"用法",paraId:3,tocIndex:0},{value:"const graph = new G6.Graph({\n    container: div,\n    width: 500,\n    height: 500,\n    modes: {\n      default: [...],\n      custom: [...]\n    }\n})\n\ngraph.setMode('custom')\n",paraId:4,tocIndex:0},{value:"获取当前的行为模式。",paraId:5,tocIndex:1},{value:"该方法无参数。",paraId:6,tocIndex:1},{value:"返回值",paraId:7,tocIndex:1},{value:"返回值类型：String；",paraId:8,tocIndex:1},{value:"返回值表示当前的行为模式。",paraId:8,tocIndex:1},{value:"用法",paraId:9,tocIndex:1},{value:"// 返回值 mode 表示当前的行为模式\nconst mode = graph.getCurrentMode();\n",paraId:10,tocIndex:1}]},86697:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"为图绑定事件监听。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"eventName",paraId:2,tocIndex:0},{value:"string",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"事件名，可选事件名参见 ",paraId:2,tocIndex:0},{value:"Event",paraId:3,tocIndex:0},{value:"handler",paraId:2,tocIndex:0},{value:"Function",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"监听函数",paraId:2,tocIndex:0},{value:"这里对 ",paraId:4,tocIndex:0},{value:"handler",paraId:4,tocIndex:0},{value:" 的参数 ",paraId:4,tocIndex:0},{value:"evt",paraId:4,tocIndex:0},{value:" 中 ",paraId:4,tocIndex:0},{value:"item",paraId:4,tocIndex:0},{value:" 和 ",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:" 参数进行解释：",paraId:4,tocIndex:0},{value:"名称",paraId:5,tocIndex:0},{value:"类型",paraId:5,tocIndex:0},{value:"是否必选",paraId:5,tocIndex:0},{value:"描述",paraId:5,tocIndex:0},{value:"item",paraId:5,tocIndex:0},{value:"Item",paraId:5,tocIndex:0},{value:"true",paraId:5,tocIndex:0},{value:"被操作的 item",paraId:5,tocIndex:0},{value:"target",paraId:5,tocIndex:0},{value:"Ishape",paraId:5,tocIndex:0},{value:"true",paraId:5,tocIndex:0},{value:"被操作的具体",paraId:5,tocIndex:0},{value:"图形",paraId:6,tocIndex:0},{value:"用法",paraId:7,tocIndex:0},{value:"// 为图上的所有节点绑定点击监听\ngraph.on('node:click', (evt) => {\n  const item = evt.item; // 被操作的节点 item\n  const target = evt.target; // 被操作的具体图形\n  // ...\n});\n\n// 为画布绑定点击监听\ngraph.on('click', (evt) => {\n  // ...\n});\n",paraId:8,tocIndex:0},{value:"手动触发某个事件。类似于 dispatch。",paraId:9,tocIndex:1},{value:"参数",paraId:10,tocIndex:1},{value:"名称",paraId:11,tocIndex:1},{value:"类型",paraId:11,tocIndex:1},{value:"是否必选",paraId:11,tocIndex:1},{value:"描述",paraId:11,tocIndex:1},{value:"eventName",paraId:11,tocIndex:1},{value:"string",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:"事件名，可选事件名参见 ",paraId:11,tocIndex:1},{value:"Event",paraId:12,tocIndex:1},{value:"。也可以是自定事件名，同样通过 graph.on 监听该事件名",paraId:11,tocIndex:1},{value:"params",paraId:11,tocIndex:1},{value:"object",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:"触发该事件的参数。若用于触发 ",paraId:11,tocIndex:1},{value:"Event",paraId:13,tocIndex:1},{value:" 中的事件，可能需要模拟一些必要的",paraId:11,tocIndex:1},{value:"事件参数",paraId:14,tocIndex:1},{value:"用法",paraId:15,tocIndex:1},{value:"const node = graph.findById('node1');\n// 模拟触发节点点击事件\ngraph.emit('node:click', {\n  item: node, // 被点击的节点\n  target: node.getKeyShape(), // 具体图形，这里使用了节点的 keyShape，也可以是该节点 node.getContainer() 图形分组中的其它图形\n  x: 10,\n  y: 10\n  // ...\n})\n\n// 模拟触发一个自定义名为 someevent 的事件，并传入自定义参数\n// 使用 graph.on('someevent', e => {}) 可监听该事件。注意，请在该事件触发之前绑定监听（graph.on）\ngraph.emit('someevent', {\n  name: 'xxx',\n  value: 'xxx'\n});\n\n",paraId:16,tocIndex:1},{value:"为图解除指定的事件监听。",paraId:17,tocIndex:2},{value:"参数",paraId:18,tocIndex:2},{value:"名称",paraId:19,tocIndex:2},{value:"类型",paraId:19,tocIndex:2},{value:"是否必选",paraId:19,tocIndex:2},{value:"描述",paraId:19,tocIndex:2},{value:"eventName",paraId:19,tocIndex:2},{value:"string",paraId:19,tocIndex:2},{value:"true",paraId:19,tocIndex:2},{value:"事件名，可选事件名参见 ",paraId:19,tocIndex:2},{value:"Event",paraId:20,tocIndex:2},{value:"handler",paraId:19,tocIndex:2},{value:"Function",paraId:19,tocIndex:2},{value:"true",paraId:19,tocIndex:2},{value:"监听函数",paraId:19,tocIndex:2},{value:"这里对 ",paraId:21,tocIndex:2},{value:"handler",paraId:21,tocIndex:2},{value:" 的参数 ",paraId:21,tocIndex:2},{value:"evt",paraId:21,tocIndex:2},{value:" 中 ",paraId:21,tocIndex:2},{value:"item",paraId:21,tocIndex:2},{value:" 和 ",paraId:21,tocIndex:2},{value:"target",paraId:21,tocIndex:2},{value:" 同 ",paraId:21,tocIndex:2},{value:"graph.on(eventName, handler)",paraId:22,tocIndex:2},{value:"。该 ",paraId:21,tocIndex:2},{value:"handler",paraId:21,tocIndex:2},{value:" 必须与绑定该事件的 ",paraId:21,tocIndex:2},{value:"handler",paraId:21,tocIndex:2},{value:" 是同一对象。",paraId:21,tocIndex:2},{value:"用法",paraId:23,tocIndex:2},{value:"// 监听函数\nconst fn = (evt) => {\n  const item = evt.item; // 被操作的节点 item\n  const target = evt.target; // 被操作的具体图形\n  // ...\n};\n// 为图上的所有节点绑定点击监听\ngraph.on('node:click', fn);\n\n// 解除上面的点击监听事件，注意 fn 必须是同一个对象\ngraph.off('node:click', fn);\n",paraId:24,tocIndex:2},{value:"为图解除某事件的所有监听。",paraId:25,tocIndex:3},{value:"参数",paraId:26,tocIndex:3},{value:"名称",paraId:27,tocIndex:3},{value:"类型",paraId:27,tocIndex:3},{value:"是否必选",paraId:27,tocIndex:3},{value:"描述",paraId:27,tocIndex:3},{value:"eventName",paraId:27,tocIndex:3},{value:"string",paraId:27,tocIndex:3},{value:"true",paraId:27,tocIndex:3},{value:"事件名，可选事件名参见 ",paraId:27,tocIndex:3},{value:"Event",paraId:28,tocIndex:3},{value:"用法",paraId:29,tocIndex:3},{value:"// 监听函数\nconst fn1 = (evt) => {\n  const item = evt.item; // 被操作的节点 item\n  const target = evt.target; // 被操作的具体图形\n  // ...\n};\nconst fn2 = (evt) => {\n  // ...\n};\n// 为图上的所有节点绑定点击监听\ngraph.on('node:click', fn1);\ngraph.on('node:click', fn2);\n\n// 解除上面的所有节点点击监听事件\ngraph.off('node:click');\n",paraId:30,tocIndex:3},{value:"为图解除所有监听。该函数无参数。",paraId:31,tocIndex:4},{value:"用法",paraId:32,tocIndex:4},{value:"// 监听函数\nconst fn1 = (evt) => {\n  // ...\n};\nconst fn2 = (evt) => {\n  // ...\n};\n// 为图上的所有节点绑定点击监听\ngraph.on('node:mouseenter', fn1);\ngraph.on('afteranimate', fn2);\n\n// 解除图上所有监听事件\ngraph.off();\n",paraId:33,tocIndex:4}]},58399:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"根据提供的数据渲染视图。",paraId:0,tocIndex:0},{value:"用法",paraId:1,tocIndex:0},{value:"graph.render();\n",paraId:2,tocIndex:0}]},35379:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"入栈操作。",paraId:0,tocIndex:0},{value:"实现 undo 功能，可参考",paraId:1,tocIndex:0},{value:"这里",paraId:1,tocIndex:0},{value:"实现 redo 功能，可参考",paraId:2,tocIndex:0},{value:"这里",paraId:2,tocIndex:0},{value:"参数",paraId:3,tocIndex:0},{value:"| 名称      | 类型    | 是否必选 | 描述                      |\n| --------- | ------- | -------- | ------------------------- | --------------------- |\n| action    | string  | false    | 操作类型，默认值为 update |\n| data      | unknown | false    | 入栈的数据                |\n| stackType | 'redo'  / 'undo'   | false                     | 入栈类型，默认为 undo |",paraId:4,tocIndex:0},{value:"获取 undo 栈。",paraId:5,tocIndex:1},{value:"获取 redo 栈。",paraId:6,tocIndex:2},{value:"获取栈中的数据。",paraId:7,tocIndex:3},{value:"返回值类型为：",paraId:8,tocIndex:3},{value:"{\n  undoStack: StackData[];\n  redoStack: StackData[];\n};\n",paraId:9,tocIndex:3},{value:"清空栈中的数据。",paraId:10,tocIndex:4}]},76646:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"设置元素状态。支持单个状态多值的情况，详情参考 ",paraId:0,tocIndex:0},{value:"G6 状态管理最佳实践",paraId:1,tocIndex:0},{value:"。",paraId:0,tocIndex:0},{value:"该方法在执行过程中会触发 ",paraId:2,tocIndex:0},{value:"beforitemstatechange",paraId:2,tocIndex:0},{value:"，",paraId:2,tocIndex:0},{value:"afteritemstatechange",paraId:2,tocIndex:0},{value:" 事件。",paraId:2,tocIndex:0},{value:"参数",paraId:3,tocIndex:0},{value:"名称",paraId:4,tocIndex:0},{value:"类型",paraId:4,tocIndex:0},{value:"是否必选",paraId:4,tocIndex:0},{value:"描述",paraId:4,tocIndex:0},{value:"item",paraId:4,tocIndex:0},{value:"string / Item",paraId:4,tocIndex:0},{value:"true",paraId:4,tocIndex:0},{value:"元素 ID 或元素实例",paraId:4,tocIndex:0},{value:"state",paraId:4,tocIndex:0},{value:"string",paraId:4,tocIndex:0},{value:"true",paraId:4,tocIndex:0},{value:"状态值，支持自定义，如 selected、hover、actived 等。",paraId:4,tocIndex:0},{value:"value",paraId:4,tocIndex:0},{value:"Boolean / string",paraId:4,tocIndex:0},{value:"true",paraId:4,tocIndex:0},{value:"是否启用状态",paraId:4,tocIndex:0},{value:"用法",paraId:5,tocIndex:0},{value:"// 布尔状态 'selected'\ngraph.setItemState('node1', 'selected', true);\n\n// 多值状态 'body'\ngraph.setItemState('node1', 'body', 'health');\ngraph.setItemState('node2', 'body', 'ill');\n",paraId:6,tocIndex:0},{value:"清除元素状态，可以一次性清除多个状态。",paraId:7,tocIndex:1},{value:"参数",paraId:8,tocIndex:1},{value:"名称",paraId:9,tocIndex:1},{value:"类型",paraId:9,tocIndex:1},{value:"是否必选",paraId:9,tocIndex:1},{value:"描述",paraId:9,tocIndex:1},{value:"item",paraId:9,tocIndex:1},{value:"string / Object",paraId:9,tocIndex:1},{value:"true",paraId:9,tocIndex:1},{value:"元素 ID 或元素实例",paraId:9,tocIndex:1},{value:"states",paraId:9,tocIndex:1},{value:"string / Array / null",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:"取值可以是单个状态值，也可以是状态值数组",paraId:9,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"// 清除单个状态\ngraph.clearItemStates(node, 'a');\n\n// 清除多个状态\ngraph.clearItemStates(node, ['a', 'b']);\n\n// 清除所有\ngraph.clearItemStates(node);\n",paraId:11,tocIndex:1},{value:"将指定状态的优先级提升为最高优先级。",paraId:12,tocIndex:2},{value:"参数",paraId:13,tocIndex:2},{value:"名称",paraId:14,tocIndex:2},{value:"类型",paraId:14,tocIndex:2},{value:"是否必选",paraId:14,tocIndex:2},{value:"描述",paraId:14,tocIndex:2},{value:"item",paraId:14,tocIndex:2},{value:"string / Object",paraId:14,tocIndex:2},{value:"true",paraId:14,tocIndex:2},{value:"元素 ID 或元素实例",paraId:14,tocIndex:2},{value:"states",paraId:14,tocIndex:2},{value:"string",paraId:14,tocIndex:2},{value:"true",paraId:14,tocIndex:2},{value:"状态名称",paraId:14,tocIndex:2},{value:"用法",paraId:15,tocIndex:2},{value:"// 将 node 的 a 状态调整为优先级最高\ngraph.priorityState(node, 'a');\n",paraId:16,tocIndex:2}]},7229:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"获取当前视口的缩放比例。",paraId:0,tocIndex:0},{value:"该方法无参数。",paraId:1,tocIndex:0},{value:"返回值",paraId:2,tocIndex:0},{value:"返回值类型：Number；",paraId:3,tocIndex:0},{value:"返回值表示当前视口的缩放比例， 默认值为 ",paraId:3,tocIndex:0},{value:"1",paraId:3,tocIndex:0},{value:"。",paraId:3,tocIndex:0},{value:"用法",paraId:4,tocIndex:0},{value:"// 返回值zoom表示当前视口的缩放比例\nconst zoom = graph.getZoom();\n",paraId:5,tocIndex:0},{value:"改变视口的缩放比例，在当前画布比例下缩放，是相对比例。",paraId:6,tocIndex:1},{value:"参数",paraId:7,tocIndex:1},{value:"名称",paraId:8,tocIndex:1},{value:"类型",paraId:8,tocIndex:1},{value:"是否必选",paraId:8,tocIndex:1},{value:"描述",paraId:8,tocIndex:1},{value:"ratio",paraId:8,tocIndex:1},{value:"Number",paraId:8,tocIndex:1},{value:"true",paraId:8,tocIndex:1},{value:"缩放比例",paraId:8,tocIndex:1},{value:"center",paraId:8,tocIndex:1},{value:"Object",paraId:8,tocIndex:1},{value:"false",paraId:8,tocIndex:1},{value:"以 ",paraId:8,tocIndex:1},{value:"center",paraId:8,tocIndex:1},{value:" 的 ",paraId:8,tocIndex:1},{value:"x",paraId:8,tocIndex:1},{value:"、",paraId:8,tocIndex:1},{value:"y",paraId:8,tocIndex:1},{value:" 坐标为中心缩放，如果省略了 ",paraId:8,tocIndex:1},{value:"center",paraId:8,tocIndex:1},{value:" 参数，则以元素当前位置为中心缩放",paraId:8,tocIndex:1},{value:"animate",paraId:8,tocIndex:1},{value:"Boolean",paraId:8,tocIndex:1},{value:"false",paraId:8,tocIndex:1},{value:"是否开启动画",paraId:8,tocIndex:1},{value:"animateCfg",paraId:8,tocIndex:1},{value:"GraphAnimateConfig",paraId:8,tocIndex:1},{value:"false",paraId:8,tocIndex:1},{value:"若带有动画，可配置动画，参见",paraId:8,tocIndex:1},{value:"基础动画教程",paraId:9,tocIndex:1},{value:"。若未配置，则跟随 graph 的 ",paraId:8,tocIndex:1},{value:"animateCfg",paraId:8,tocIndex:1},{value:" 参数",paraId:8,tocIndex:1},{value:"用法",paraId:10,tocIndex:1},{value:"// 以 (100, 100) 为中心点，放大到 3\ngraph.zoom(3, { x: 100, y: 100 });\n\n// 以绘制坐标系的原点 (0, 0) 为缩放中心，缩小到 0.5。注意绘制坐标系的原点 != 视窗左上角，可用 graph.getCanvasByViewport 进行转换。各坐标系解析文档： https://g6.antv.antgroup.com/manual/advanced/coordinate-system\ngraph.zoom(0.5);\n\n// 带动画以 (100, 100) 为中心点，放大到 3\ngraph.zoom(3, { x: 100, y: 100 }, true, {\n  duration: 100,\n});\n",paraId:11,tocIndex:1},{value:"缩放视窗窗口到一个固定比例。",paraId:12,tocIndex:2},{value:"参数",paraId:13,tocIndex:2},{value:"名称",paraId:14,tocIndex:2},{value:"类型",paraId:14,tocIndex:2},{value:"是否必选",paraId:14,tocIndex:2},{value:"描述",paraId:14,tocIndex:2},{value:"toRatio",paraId:14,tocIndex:2},{value:"Number",paraId:14,tocIndex:2},{value:"true",paraId:14,tocIndex:2},{value:"固定比例值",paraId:14,tocIndex:2},{value:"center",paraId:14,tocIndex:2},{value:"Object",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"以 ",paraId:14,tocIndex:2},{value:"center",paraId:14,tocIndex:2},{value:" 的 ",paraId:14,tocIndex:2},{value:"x",paraId:14,tocIndex:2},{value:"、",paraId:14,tocIndex:2},{value:"y",paraId:14,tocIndex:2},{value:" 坐标为中心缩放，如果省略了 ",paraId:14,tocIndex:2},{value:"center",paraId:14,tocIndex:2},{value:" 参数，则以元素当前位置为中心缩放",paraId:14,tocIndex:2},{value:"animate",paraId:14,tocIndex:2},{value:"Boolean",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"是否开启动画",paraId:14,tocIndex:2},{value:"animateCfg",paraId:14,tocIndex:2},{value:"GraphAnimateConfig",paraId:14,tocIndex:2},{value:"false",paraId:14,tocIndex:2},{value:"若带有动画，可配置动画，参见",paraId:14,tocIndex:2},{value:"基础动画教程",paraId:15,tocIndex:2},{value:"。若未配置，则跟随 graph 的 ",paraId:14,tocIndex:2},{value:"animateCfg",paraId:14,tocIndex:2},{value:" 参数",paraId:14,tocIndex:2},{value:"用法",paraId:16,tocIndex:2},{value:"// 以 (100, 100) 为中心点，放大3倍\ngraph.zoomTo(3, { x: 100, y: 100 });\n\n// 以当前元素位置为中心，缩小到 0.5\ngraph.zoomTo(0.5);\n\n// 带动画以 (100, 100) 为中心点，放大3倍\ngraph.zoomTo(3, { x: 100, y: 100 }, true, {\n  duration: 100,\n});\n",paraId:17,tocIndex:2},{value:"改变画布大小。",paraId:18,tocIndex:3},{value:"参数",paraId:19,tocIndex:3},{value:"名称",paraId:20,tocIndex:3},{value:"类型",paraId:20,tocIndex:3},{value:"是否必选",paraId:20,tocIndex:3},{value:"描述",paraId:20,tocIndex:3},{value:"width",paraId:20,tocIndex:3},{value:"Number",paraId:20,tocIndex:3},{value:"true",paraId:20,tocIndex:3},{value:"画布宽度",paraId:20,tocIndex:3},{value:"height",paraId:20,tocIndex:3},{value:"Number",paraId:20,tocIndex:3},{value:"true",paraId:20,tocIndex:3},{value:"画布高度",paraId:20,tocIndex:3},{value:"用法",paraId:21,tocIndex:3},{value:"graph.changeSize(600, 350);\n",paraId:22,tocIndex:3},{value:"采用",paraId:23,tocIndex:4},{value:"相对位移",paraId:23,tocIndex:4},{value:"来平移画布。",paraId:23,tocIndex:4},{value:"参数",paraId:24,tocIndex:4},{value:"名称",paraId:25,tocIndex:4},{value:"类型",paraId:25,tocIndex:4},{value:"是否必选",paraId:25,tocIndex:4},{value:"描述",paraId:25,tocIndex:4},{value:"dx",paraId:25,tocIndex:4},{value:"Number",paraId:25,tocIndex:4},{value:"true",paraId:25,tocIndex:4},{value:"水平方向位移",paraId:25,tocIndex:4},{value:"dy",paraId:25,tocIndex:4},{value:"Number",paraId:25,tocIndex:4},{value:"true",paraId:25,tocIndex:4},{value:"垂直方向位移",paraId:25,tocIndex:4},{value:"animate",paraId:25,tocIndex:4},{value:"Boolean",paraId:25,tocIndex:4},{value:"false",paraId:25,tocIndex:4},{value:"是否开启动画",paraId:25,tocIndex:4},{value:"animateCfg",paraId:25,tocIndex:4},{value:"GraphAnimateConfig",paraId:25,tocIndex:4},{value:"false",paraId:25,tocIndex:4},{value:"若带有动画，可配置动画，参见",paraId:25,tocIndex:4},{value:"基础动画教程",paraId:26,tocIndex:4},{value:"。若未配置，则跟随 graph 的 ",paraId:25,tocIndex:4},{value:"animateCfg",paraId:25,tocIndex:4},{value:" 参数",paraId:25,tocIndex:4},{value:"用法",paraId:27,tocIndex:4},{value:"graph.translate(100, 100);\n\n// 带动画\ngraph.translate(100, 100, true, {\n  duration: 100,\n});\n",paraId:28,tocIndex:4},{value:"采用",paraId:29,tocIndex:5},{value:"绝对位移",paraId:29,tocIndex:5},{value:"将画布移动到指定坐标。",paraId:29,tocIndex:5},{value:"参数",paraId:30,tocIndex:5},{value:"名称",paraId:31,tocIndex:5},{value:"类型",paraId:31,tocIndex:5},{value:"是否必选",paraId:31,tocIndex:5},{value:"描述",paraId:31,tocIndex:5},{value:"x",paraId:31,tocIndex:5},{value:"Number",paraId:31,tocIndex:5},{value:"true",paraId:31,tocIndex:5},{value:"水平方向坐标",paraId:31,tocIndex:5},{value:"y",paraId:31,tocIndex:5},{value:"Number",paraId:31,tocIndex:5},{value:"true",paraId:31,tocIndex:5},{value:"垂直方向坐标",paraId:31,tocIndex:5},{value:"animate",paraId:31,tocIndex:5},{value:"boolean",paraId:31,tocIndex:5},{value:"false",paraId:31,tocIndex:5},{value:"是否带有动画。若未配置，则跟随 graph 的 ",paraId:31,tocIndex:5},{value:"animate",paraId:31,tocIndex:5},{value:" 参数",paraId:31,tocIndex:5},{value:"animateCfg",paraId:31,tocIndex:5},{value:"Object",paraId:31,tocIndex:5},{value:"false",paraId:31,tocIndex:5},{value:"若带有动画，可配置动画，参见",paraId:31,tocIndex:5},{value:"基础动画教程",paraId:32,tocIndex:5},{value:"。若未配置，则跟随 graph 的 ",paraId:31,tocIndex:5},{value:"animateCfg",paraId:31,tocIndex:5},{value:" 参数",paraId:31,tocIndex:5},{value:"用法",paraId:33,tocIndex:5},{value:"graph.moveTo(200, 300);\n\n// 带动画\ngraph.moveTo(200, 300, true, {\n  duration: 100,\n});\n",paraId:34,tocIndex:5},{value:"让画布内容适应视口。",paraId:35,tocIndex:6},{value:"参数",paraId:36,tocIndex:6},{value:"名称",paraId:37,tocIndex:6},{value:"类型",paraId:37,tocIndex:6},{value:"是否必选",paraId:37,tocIndex:6},{value:"描述",paraId:37,tocIndex:6},{value:"padding",paraId:37,tocIndex:6},{value:"Number / Array",paraId:37,tocIndex:6},{value:"false",paraId:37,tocIndex:6},{value:"[top, right, bottom, left] 四个方向上的间距值",paraId:37,tocIndex:6},{value:"rules",paraId:37,tocIndex:6},{value:"{ onlyOutOfViewPort?: boolean; direction?: 'x' / 'y' / 'both'; ratioRule?: 'max' / 'min}",paraId:37,tocIndex:6},{value:"false",paraId:37,tocIndex:6},{value:"fitView 的规则",paraId:37,tocIndex:6},{value:"animate",paraId:37,tocIndex:6},{value:"boolean",paraId:37,tocIndex:6},{value:"false",paraId:37,tocIndex:6},{value:"*v4.6.15 后支持。*是否带有动画。若未配置，则跟随 graph 的 ",paraId:37,tocIndex:6},{value:"animate",paraId:37,tocIndex:6},{value:" 参数",paraId:37,tocIndex:6},{value:"animateCfg",paraId:37,tocIndex:6},{value:"Object",paraId:37,tocIndex:6},{value:"false",paraId:37,tocIndex:6},{value:"*v4.6.15 后支持。*若带有动画，可配置动画，参见",paraId:37,tocIndex:6},{value:"基础动画教程",paraId:38,tocIndex:6},{value:"。若未配置，则跟随 graph 的 ",paraId:37,tocIndex:6},{value:"animateCfg",paraId:37,tocIndex:6},{value:" 参数",paraId:37,tocIndex:6},{value:"用法",paraId:39,tocIndex:6},{value:"// padding 只设置为一个值，则表示 top = right = bottom = left = 20\ngraph.fitView(20);\n\n// 等价于 graph.fitView(20)\ngraph.fitView([20]);\n\n// padding 设置为数组，只传 2 个值，则 top = bottom = 20, right = left = 10\ngraph.fitView([20, 10]);\n\n// padding 设置为数组，四个方向值都指定\ngraph.fitView([20, 10, 20, 15]);\n\n// 使用fitViewByRules, 默认rules: onlyOutOfViewPort = false, direction = 'both', ratioRule = 'min'\ngraph.fitView(0, {});\n\n// 使用fitViewByRules, 自定义rules\ngraph.fitView(0, { onlyOutOfViewPort: true, direction: 'y' });\n",paraId:40,tocIndex:6},{value:"*v3.5.1 后支持。*平移图到中心将对齐到画布中心，但不缩放。优先级低于 fitView。",paraId:41,tocIndex:7},{value:"参数",paraId:42,tocIndex:7},{value:"名称",paraId:43,tocIndex:7},{value:"类型",paraId:43,tocIndex:7},{value:"是否必选",paraId:43,tocIndex:7},{value:"描述",paraId:43,tocIndex:7},{value:"animate",paraId:43,tocIndex:7},{value:"boolean",paraId:43,tocIndex:7},{value:"false",paraId:43,tocIndex:7},{value:"*v4.6.15 后支持。*是否带有动画。若未配置，则跟随 graph 的 ",paraId:43,tocIndex:7},{value:"animate",paraId:43,tocIndex:7},{value:" 参数",paraId:43,tocIndex:7},{value:"animateCfg",paraId:43,tocIndex:7},{value:"Object",paraId:43,tocIndex:7},{value:"false",paraId:43,tocIndex:7},{value:"*v4.6.15 后支持。*若带有动画，可配置动画，参见",paraId:43,tocIndex:7},{value:"基础动画教程",paraId:44,tocIndex:7},{value:"。若未配置，则跟随 graph 的 ",paraId:43,tocIndex:7},{value:"animateCfg",paraId:43,tocIndex:7},{value:" 参数",paraId:43,tocIndex:7},{value:"用法",paraId:45,tocIndex:7},{value:"// 在渲染和动画完成后调用\ngraph.fitCenter();\n",paraId:46,tocIndex:7},{value:"移动图，使得 item 对齐到视口中心，该方法可用于做搜索后的缓动动画。",paraId:47,tocIndex:8},{value:"参数",paraId:48,tocIndex:8},{value:"名称",paraId:49,tocIndex:8},{value:"类型",paraId:49,tocIndex:8},{value:"是否必选",paraId:49,tocIndex:8},{value:"描述",paraId:49,tocIndex:8},{value:"item",paraId:49,tocIndex:8},{value:"string / Object",paraId:49,tocIndex:8},{value:"true",paraId:49,tocIndex:8},{value:"元素 ID 或元素实例",paraId:49,tocIndex:8},{value:"animate",paraId:49,tocIndex:8},{value:"boolean",paraId:49,tocIndex:8},{value:"false",paraId:49,tocIndex:8},{value:"是否带有动画。若未配置，则跟随 graph 的 ",paraId:49,tocIndex:8},{value:"animate",paraId:49,tocIndex:8},{value:" 参数",paraId:49,tocIndex:8},{value:"animateCfg",paraId:49,tocIndex:8},{value:"Object",paraId:49,tocIndex:8},{value:"false",paraId:49,tocIndex:8},{value:"若带有动画，可配置动画，参见",paraId:49,tocIndex:8},{value:"基础动画教程",paraId:50,tocIndex:8},{value:"。若未配置，则跟随 graph 的 ",paraId:49,tocIndex:8},{value:"animateCfg",paraId:49,tocIndex:8},{value:" 参数",paraId:49,tocIndex:8},{value:"用法",paraId:51,tocIndex:8},{value:"graph.focusItem(item);\n\n// 动画地移动\ngraph.focusItem(item, true);\n\n// 动画地移动，并配置动画\ngraph.focusItem(item, true, {\n  easing: 'easeCubic',\n  duration: 400,\n});\n",paraId:52,tocIndex:8}]},65558:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"为画布添加文字水印。",paraId:0,tocIndex:0},{value:"参数",paraId:1,tocIndex:0},{value:"名称",paraId:2,tocIndex:0},{value:"类型",paraId:2,tocIndex:0},{value:"是否必选",paraId:2,tocIndex:0},{value:"描述",paraId:2,tocIndex:0},{value:"texts",paraId:2,tocIndex:0},{value:"String[] / string / undefined",paraId:2,tocIndex:0},{value:"true",paraId:2,tocIndex:0},{value:"水印文字内容数组，数组中的不同项将会换行",paraId:2,tocIndex:0},{value:"config",paraId:2,tocIndex:0},{value:"Object",paraId:2,tocIndex:0},{value:"false",paraId:2,tocIndex:0},{value:"文字水印配置项，可选，具体字段见下方",paraId:2,tocIndex:0},{value:"其中，config 为文字水印配置项，具体字段：",paraId:3,tocIndex:0},{value:"名称",paraId:4,tocIndex:0},{value:"类型",paraId:4,tocIndex:0},{value:"是否必选",paraId:4,tocIndex:0},{value:"描述",paraId:4,tocIndex:0},{value:"width",paraId:4,tocIndex:0},{value:"Number",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"单个水印的宽，可控制单个水印之间的水平间距，默认 ",paraId:4,tocIndex:0},{value:"150",paraId:4,tocIndex:0},{value:"height",paraId:4,tocIndex:0},{value:"Number",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"单个水印的高，可控制单个水印之间的竖直间距，默认 ",paraId:4,tocIndex:0},{value:"100",paraId:4,tocIndex:0},{value:"compatible",paraId:4,tocIndex:0},{value:"Boolean",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"是否需要兼容不支持 ",paraId:4,tocIndex:0},{value:"pointer-events",paraId:4,tocIndex:0},{value:" 属性的浏览器，默认为 ",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"text",paraId:4,tocIndex:0},{value:"Object",paraId:4,tocIndex:0},{value:"false",paraId:4,tocIndex:0},{value:"文本图形的样式属性，默认为：",paraId:4,tocIndex:0},{value:"{ x: 0, y: 60, lineHeight: 20, rotate: 20, fontSize: 14, fontFamily: 'Microsoft YaHei', fill: 'rgba(0, 0, 0, 0.1)', baseline: 'Middle', }",paraId:4,tocIndex:0},{value:"用法",paraId:5,tocIndex:0},{value:"graph.setTextWaterMarker(['AntV', 'G6']);\n",paraId:6,tocIndex:0},{value:"为画布添加图片水印。注意，使用 ",paraId:7,tocIndex:1},{value:"downloadImage",paraId:7,tocIndex:1},{value:" 或 ",paraId:7,tocIndex:1},{value:"downloadFullImage",paraId:7,tocIndex:1},{value:" 下载图片将不会带有水印。",paraId:7,tocIndex:1},{value:"参数",paraId:8,tocIndex:1},{value:"名称",paraId:9,tocIndex:1},{value:"类型",paraId:9,tocIndex:1},{value:"是否必选",paraId:9,tocIndex:1},{value:"描述",paraId:9,tocIndex:1},{value:"imgURL",paraId:9,tocIndex:1},{value:"String / undefined",paraId:9,tocIndex:1},{value:"true",paraId:9,tocIndex:1},{value:"水印图片，默认为 '",paraId:9,tocIndex:1},{value:"https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg",paraId:9,tocIndex:1},{value:"'",paraId:9,tocIndex:1},{value:"config",paraId:9,tocIndex:1},{value:"Object",paraId:9,tocIndex:1},{value:"false",paraId:9,tocIndex:1},{value:"图片水印配置项，可选，具体字段见下方",paraId:9,tocIndex:1},{value:"其中，config 为图片水印配置项，具体字段：",paraId:10,tocIndex:1},{value:"名称",paraId:11,tocIndex:1},{value:"类型",paraId:11,tocIndex:1},{value:"是否必选",paraId:11,tocIndex:1},{value:"描述",paraId:11,tocIndex:1},{value:"width",paraId:11,tocIndex:1},{value:"Number",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"单个水印的宽，可控制单个水印之间的水平间距，默认 ",paraId:11,tocIndex:1},{value:"150",paraId:11,tocIndex:1},{value:"height",paraId:11,tocIndex:1},{value:"Number",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"单个水印的高，可控制单个水印之间的竖直间距，默认 ",paraId:11,tocIndex:1},{value:"130",paraId:11,tocIndex:1},{value:"compatible",paraId:11,tocIndex:1},{value:"Boolean",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"是否需要兼容不支持 ",paraId:11,tocIndex:1},{value:"pointer-events",paraId:11,tocIndex:1},{value:" 属性的浏览器，默认为 ",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"image",paraId:11,tocIndex:1},{value:"Object",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"图片图形的样式属性，默认为：",paraId:11,tocIndex:1},{value:"{ x: 0, y: 0, width: 30, height: 20, rotate: 0 }",paraId:11,tocIndex:1},{value:"用法",paraId:12,tocIndex:1},{value:"graph.setImageWaterMarker(\n  'https://gw.alipayobjects.com/os/s/prod/antv/assets/image/logo-with-text-73b8a.svg',\n  {\n    width: 300,\n    height: 200,\n    image: { rotate: Math.PI / 3 },\n  },\n);\n",paraId:13,tocIndex:1}]},3291:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Circular 布局将所有节点布局在一个圆环上，可以选择节点在圆环上的排列顺序。可以通过参数的配置扩展出环的分组布局、螺旋形布局等。原文链接： ",paraId:0},{value:"A framework and algorithms for circular drawings of graphs",paraId:0},{value:"。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'circular',\n    center: [200, 200], // 可选，默认为图的中心\n    radius: null, // 可选\n    startRadius: 10, // 可选\n    endRadius: 100, // 可选\n    clockwise: false, // 可选\n    divisions: 5, // 可选\n    ordering: 'degree', // 可选\n    angleRatio: 1, // 可选\n  },\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：null",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：圆的半径。若设置了 radius，则 startRadius 与 endRadius 不生效",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：null",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：螺旋状布局的起始半径",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:"：Number",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:"：null",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:"：false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:"：螺旋状布局的结束半径",paraId:5,tocIndex:3},{value:"类型",paraId:6,tocIndex:4},{value:"：Boolean",paraId:6,tocIndex:4},{value:"默认值",paraId:6,tocIndex:4},{value:"：true",paraId:6,tocIndex:4},{value:"是否必须",paraId:6,tocIndex:4},{value:"：false",paraId:6,tocIndex:4},{value:"说明",paraId:6,tocIndex:4},{value:"：是否顺时针排列",paraId:6,tocIndex:4},{value:"类型",paraId:7,tocIndex:5},{value:"：Number",paraId:7,tocIndex:5},{value:"默认值",paraId:7,tocIndex:5},{value:"：1",paraId:7,tocIndex:5},{value:"是否必须",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"说明",paraId:7,tocIndex:5},{value:"：节点在环上的分段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效",paraId:7,tocIndex:5},{value:"类型",paraId:8,tocIndex:6},{value:"：String",paraId:8,tocIndex:6},{value:"默认值",paraId:8,tocIndex:6},{value:"：false",paraId:8,tocIndex:6},{value:"可选值",paraId:8,tocIndex:6},{value:"：null | 'topology' | 'degree'",paraId:8,tocIndex:6},{value:"是否必须",paraId:8,tocIndex:6},{value:"：false",paraId:8,tocIndex:6},{value:"说明",paraId:8,tocIndex:6},{value:"：节点在环上排序的依据。默认 null 代表直接使用数据中的顺序。'topology' 按照拓扑排序。'degree' 按照度数大小排序",paraId:8,tocIndex:6},{value:"类型",paraId:9,tocIndex:7},{value:"： Number",paraId:9,tocIndex:7},{value:"默认值",paraId:9,tocIndex:7},{value:"：1",paraId:9,tocIndex:7},{value:"是否必须",paraId:9,tocIndex:7},{value:"：false",paraId:9,tocIndex:7},{value:"说明",paraId:9,tocIndex:7},{value:"：从第一个节点到最后节点之间相隔多少个 2*PI",paraId:9,tocIndex:7},{value:"类型",paraId:10,tocIndex:8},{value:": Boolean",paraId:10,tocIndex:8},{value:"默认值",paraId:10,tocIndex:8},{value:": false",paraId:10,tocIndex:8},{value:"是否必须",paraId:10,tocIndex:8},{value:": false",paraId:10,tocIndex:8},{value:"说明",paraId:10,tocIndex:8},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:10,tocIndex:8},{value:"⚠️ 注意:",paraId:10,tocIndex:8},{value:" ",paraId:10,tocIndex:8},{value:"workerEnabled: true",paraId:10,tocIndex:8},{value:" 时，不支持所有函数类型的参数。",paraId:10,tocIndex:8}]},75559:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"*V4.6 新增功能。*ComboCombined 支持自由配置 combo 内部元素的布局以及最外层 combo 和节点之间的布局，默认情况下将使用 Concentric 同心圆布局作为内部布局，gForce 力导向布局作为外部布局。能够达到较好的效果以及稳定性。当您指定内部布局时，请使用同步的布局算法，可从以下布局中选择：Circular，Concentric，Grid，Dagre，MDS，Radial，或任何同步的自定义布局。也可以自定义布局作为内部/外部布局。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  groupByTypes: false, // 若希望在带有 combo 的图上，节点、边、combo 的层级符合常规逻辑，需要将 groupByTypes 设置为 false\n  layout: {\n    type: 'comboCombined',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    onLayoutEnd: () => {      // 可选\n      console.log('combo force layout done');\n    }\n  }\n);\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：10",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:3,tocIndex:1},{value:"size",paraId:3,tocIndex:1},{value:"，则默认大小为 ",paraId:3,tocIndex:1},{value:"10",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:": Number / Function",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:": 0",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:": false ",paraId:4,tocIndex:2},{value:"示例",paraId:4,tocIndex:2},{value:": Example 1: 10 ",paraId:4,tocIndex:2},{value:"Example 2:",paraId:4,tocIndex:2},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:5,tocIndex:2},{value:"描述",paraId:6,tocIndex:2},{value:": ",paraId:6,tocIndex:2},{value:"preventNodeOverlap",paraId:6,tocIndex:2},{value:" 或 ",paraId:6,tocIndex:2},{value:"preventOverlap",paraId:6,tocIndex:2},{value:" 为 ",paraId:6,tocIndex:2},{value:"true",paraId:6,tocIndex:2},{value:" 时生效, 防止重叠时节点/ combo 边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:6,tocIndex:2},{value:"类型",paraId:7,tocIndex:3},{value:": Number / Function",paraId:7,tocIndex:3},{value:"默认值",paraId:7,tocIndex:3},{value:": 10",paraId:7,tocIndex:3},{value:"是否必须",paraId:7,tocIndex:3},{value:": false ",paraId:7,tocIndex:3},{value:"示例",paraId:7,tocIndex:3},{value:": Example 1: 10 ",paraId:7,tocIndex:3},{value:"Example 2:",paraId:7,tocIndex:3},{value:"(d) => {\n  // d is a combo\n  if (d.id === 'combo1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:8,tocIndex:3},{value:"描述",paraId:9,tocIndex:3},{value:": Combo 内部的 padding 值，不用于渲染，仅用于计算力。推荐设置为与视图上 combo 内部 padding 值相同的值",paraId:9,tocIndex:3},{value:"outerLayout: new G6.Layout['gForce']({\n  ... // 该布局的参数\n});\n",paraId:10,tocIndex:4},{value:"类型",paraId:11,tocIndex:4},{value:"：Object",paraId:11,tocIndex:4},{value:"默认值",paraId:11,tocIndex:4},{value:"：GForce 实例",paraId:11,tocIndex:4},{value:"是否必须",paraId:11,tocIndex:4},{value:"：false",paraId:11,tocIndex:4},{value:"说明",paraId:11,tocIndex:4},{value:"：最外层的布局算法，默认为 gForce。具体参数详见被使用布局的文档。\n默认情况下 gForce 布局将使用以下参数：",paraId:11,tocIndex:4},{value:"outerLayout: new G6.Layout['gForce']({\n  gravity: 1,\n  factor: 2,\n  linkDistance: (edge: any, source: any, target: any) => {\n    const nodeSize = ((source.size?.[0] || 30) + (target.size?.[0] || 30)) / 2;\n    return Math.min(nodeSize * 1.5, 700);\n  }\n});\n",paraId:12,tocIndex:4},{value:"innerLayout: new G6.Layout['grid']({\n  ... // 该布局的参数\n});\n",paraId:13,tocIndex:5},{value:"类型",paraId:14,tocIndex:5},{value:"：Object",paraId:14,tocIndex:5},{value:"默认值",paraId:14,tocIndex:5},{value:"：Concentric 实例",paraId:14,tocIndex:5},{value:"是否必须",paraId:14,tocIndex:5},{value:"：false",paraId:14,tocIndex:5},{value:"说明",paraId:14,tocIndex:5},{value:"：combo 内部的布局算法，需要使用同步的布局算法，默认为 concentric。具体参数详见被使用布局的文档。\n默认情况下 concentric 布局将使用以下参数：",paraId:14,tocIndex:5},{value:"outerLayout: new G6.Layout['concentric']({\n  sortBy: 'id'\n});\n",paraId:15,tocIndex:5},{value:"类型",paraId:16,tocIndex:6},{value:": Boolean",paraId:16,tocIndex:6},{value:"默认值",paraId:16,tocIndex:6},{value:": false",paraId:16,tocIndex:6},{value:"是否必须",paraId:16,tocIndex:6},{value:": false",paraId:16,tocIndex:6},{value:"说明",paraId:16,tocIndex:6},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:16,tocIndex:6},{value:"⚠️ 注意:",paraId:16,tocIndex:6},{value:" ",paraId:16,tocIndex:6},{value:"workerEnabled: true",paraId:16,tocIndex:6},{value:" 时，不支持所有函数类型的参数。",paraId:16,tocIndex:6}]},55021:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"*V3.5 新增功能。*ComboForce 是基于力导向的专用于带有 combo 的图的布局算法。通过自研改造经典力导向算法，将根据节点的 combo 信息，施加不同的力以达到同 combo 节点尽可能聚集，不同 combo 之间尽可能无重叠的布局。",paraId:0},{value:"⚠️ 注意:",paraId:1},{value:"G6 3.1 版本中实例化 Graph 时，新增了 ",paraId:1},{value:"nodeStateStyles",paraId:1},{value:" 及  ",paraId:1},{value:"edgeStateStyles",paraId:1},{value:" 两个配置项，删除了 ",paraId:1},{value:"nodeStyle",paraId:1},{value:" 和 ",paraId:1},{value:"edgeStyle",paraId:1},{value:" ，使用 3.1 以下版本的同学，只需要将  ",paraId:1},{value:"nodeStyle",paraId:1},{value:" 改成 ",paraId:1},{value:"nodeStateStyles",paraId:1},{value:" ，将  ",paraId:1},{value:"edgeStyle",paraId:1},{value:" 改成  ",paraId:1},{value:"edgeStateStyles",paraId:1},{value:" ，配置内容保持不变。",paraId:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  groupByTypes: false, // 若希望在带有 combo 的图上，节点、边、combo 的层级符合常规逻辑，需要将 groupByTypes 设置为 false\n  layout: {\n    type: 'comboForce',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    linkDistance: 50,         // 可选，边长\n    nodeStrength: 30,         // 可选\n    edgeStrength: 0.1,        // 可选\n    onTick: () => {           // 可选\n      console.log('ticking');\n    },\n    onLayoutEnd: () => {      // 可选\n      console.log('combo force layout done');\n    }\n  }\n);\n",paraId:2},{value:"类型",paraId:3,tocIndex:0},{value:"： Array",paraId:3,tocIndex:0},{value:"示例",paraId:3,tocIndex:0},{value:"：[ 0, 0 ]",paraId:3,tocIndex:0},{value:"默认值",paraId:3,tocIndex:0},{value:"：图的中心",paraId:3,tocIndex:0},{value:"是否必须",paraId:3,tocIndex:0},{value:"：false",paraId:3,tocIndex:0},{value:"说明",paraId:3,tocIndex:0},{value:"：布局的中心",paraId:3,tocIndex:0},{value:"类型",paraId:4,tocIndex:1},{value:"： Number",paraId:4,tocIndex:1},{value:"默认值",paraId:4,tocIndex:1},{value:"：100",paraId:4,tocIndex:1},{value:"是否必须",paraId:4,tocIndex:1},{value:"：false",paraId:4,tocIndex:1},{value:"说明",paraId:4,tocIndex:1},{value:"：最大迭代次数",paraId:4,tocIndex:1},{value:"类型",paraId:5,tocIndex:2},{value:"： Number / Function",paraId:5,tocIndex:2},{value:"默认值",paraId:5,tocIndex:2},{value:"：10",paraId:5,tocIndex:2},{value:"是否必须",paraId:5,tocIndex:2},{value:"：false",paraId:5,tocIndex:2},{value:"说明",paraId:5,tocIndex:2},{value:"：边长度",paraId:5,tocIndex:2},{value:"类型",paraId:6,tocIndex:3},{value:"： Number / Function",paraId:6,tocIndex:3},{value:"默认值",paraId:6,tocIndex:3},{value:"：30",paraId:6,tocIndex:3},{value:"是否必须",paraId:6,tocIndex:3},{value:"：false",paraId:6,tocIndex:3},{value:"说明",paraId:6,tocIndex:3},{value:"：节点作用力",paraId:6,tocIndex:3},{value:"类型",paraId:7,tocIndex:4},{value:"：Number / Function",paraId:7,tocIndex:4},{value:"默认值",paraId:7,tocIndex:4},{value:"：0.2",paraId:7,tocIndex:4},{value:"是否必须",paraId:7,tocIndex:4},{value:"：false",paraId:7,tocIndex:4},{value:"说明",paraId:7,tocIndex:4},{value:"：边的作用力",paraId:7,tocIndex:4},{value:"类型",paraId:8,tocIndex:5},{value:"：Boolean",paraId:8,tocIndex:5},{value:"默认值",paraId:8,tocIndex:5},{value:"：false",paraId:8,tocIndex:5},{value:"是否必须",paraId:8,tocIndex:5},{value:"：false",paraId:8,tocIndex:5},{value:"说明",paraId:8,tocIndex:5},{value:"：是否防止节点之间以及 combo 之间的重叠，若开启，则 ",paraId:8,tocIndex:5},{value:"preventNodeOverlap",paraId:8,tocIndex:5},{value:" 与 ",paraId:8,tocIndex:5},{value:"preventComboOverlap",paraId:8,tocIndex:5},{value:" 将均被开启。详见 ",paraId:8,tocIndex:5},{value:"preventNodeOverlap",paraId:8,tocIndex:5},{value:" 与 ",paraId:8,tocIndex:5},{value:"preventComboOverlap",paraId:8,tocIndex:5},{value:" 介绍",paraId:8,tocIndex:5},{value:"类型",paraId:9,tocIndex:6},{value:"：Boolean",paraId:9,tocIndex:6},{value:"默认值",paraId:9,tocIndex:6},{value:"：true",paraId:9,tocIndex:6},{value:"是否必须",paraId:9,tocIndex:6},{value:"：false",paraId:9,tocIndex:6},{value:"说明",paraId:9,tocIndex:6},{value:"：是否防止节点之间的重叠。必须配合下面属性 ",paraId:9,tocIndex:6},{value:"nodeSize",paraId:9,tocIndex:6},{value:" 或节点数据中的 ",paraId:9,tocIndex:6},{value:"size",paraId:9,tocIndex:6},{value:" 属性，只有在数据中设置了 ",paraId:9,tocIndex:6},{value:"size",paraId:9,tocIndex:6},{value:" 或在该布局中配置了与当前图节点大小相同的 ",paraId:9,tocIndex:6},{value:"nodeSize",paraId:9,tocIndex:6},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:9,tocIndex:6},{value:"类型",paraId:10,tocIndex:7},{value:"：Boolean",paraId:10,tocIndex:7},{value:"默认值",paraId:10,tocIndex:7},{value:"：true",paraId:10,tocIndex:7},{value:"是否必须",paraId:10,tocIndex:7},{value:"：false",paraId:10,tocIndex:7},{value:"说明",paraId:10,tocIndex:7},{value:"：是否防止 combo 之间的重叠",paraId:10,tocIndex:7},{value:"类型",paraId:11,tocIndex:8},{value:"：Number",paraId:11,tocIndex:8},{value:"默认值",paraId:11,tocIndex:8},{value:"：undefined",paraId:11,tocIndex:8},{value:"是否必须",paraId:11,tocIndex:8},{value:"：false",paraId:11,tocIndex:8},{value:"说明",paraId:11,tocIndex:8},{value:"：统一设置防止节点之间以及 combo 之间重叠的力强度，范围 [0, 1]。若 ",paraId:11,tocIndex:8},{value:"collideStrength",paraId:11,tocIndex:8},{value:" 不为 ",paraId:11,tocIndex:8},{value:"undefined",paraId:11,tocIndex:8},{value:"，则 ",paraId:11,tocIndex:8},{value:"nodeCollideStrength",paraId:11,tocIndex:8},{value:" 与 ",paraId:11,tocIndex:8},{value:"comboCollideStrength",paraId:11,tocIndex:8},{value:" 将均被设置为统一的值",paraId:11,tocIndex:8},{value:"类型",paraId:12,tocIndex:9},{value:"：Number",paraId:12,tocIndex:9},{value:"默认值",paraId:12,tocIndex:9},{value:"：0.5",paraId:12,tocIndex:9},{value:"是否必须",paraId:12,tocIndex:9},{value:"：false",paraId:12,tocIndex:9},{value:"说明",paraId:12,tocIndex:9},{value:"：设置防止节点之间重叠的力强度，范围 [0, 1]",paraId:12,tocIndex:9},{value:"类型",paraId:13,tocIndex:10},{value:"：Number",paraId:13,tocIndex:10},{value:"默认值",paraId:13,tocIndex:10},{value:"：0.5",paraId:13,tocIndex:10},{value:"是否必须",paraId:13,tocIndex:10},{value:"：false",paraId:13,tocIndex:10},{value:"说明",paraId:13,tocIndex:10},{value:"：防止 combo 之间重叠的力强度，范围 [0, 1]",paraId:13,tocIndex:10},{value:"类型",paraId:14,tocIndex:11},{value:"： Number",paraId:14,tocIndex:11},{value:"默认值",paraId:14,tocIndex:11},{value:"：10",paraId:14,tocIndex:11},{value:"是否必须",paraId:14,tocIndex:11},{value:"：false",paraId:14,tocIndex:11},{value:"说明",paraId:14,tocIndex:11},{value:"：节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:14,tocIndex:11},{value:"size",paraId:14,tocIndex:11},{value:"，则默认大小为 ",paraId:14,tocIndex:11},{value:"10",paraId:14,tocIndex:11},{value:"类型",paraId:15,tocIndex:12},{value:": Number / Function",paraId:15,tocIndex:12},{value:"默认值",paraId:15,tocIndex:12},{value:": 0",paraId:15,tocIndex:12},{value:"是否必须",paraId:15,tocIndex:12},{value:": false ",paraId:15,tocIndex:12},{value:"示例",paraId:15,tocIndex:12},{value:": Example 1: 10 ",paraId:15,tocIndex:12},{value:"Example 2:",paraId:15,tocIndex:12},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:16,tocIndex:12},{value:"描述",paraId:17,tocIndex:12},{value:": ",paraId:17,tocIndex:12},{value:"preventNodeOverlap",paraId:17,tocIndex:12},{value:" 或 ",paraId:17,tocIndex:12},{value:"preventOverlap",paraId:17,tocIndex:12},{value:" 为 ",paraId:17,tocIndex:12},{value:"true",paraId:17,tocIndex:12},{value:" 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:17,tocIndex:12},{value:"类型",paraId:18,tocIndex:13},{value:": Number / Function",paraId:18,tocIndex:13},{value:"默认值",paraId:18,tocIndex:13},{value:": 0",paraId:18,tocIndex:13},{value:"是否必须",paraId:18,tocIndex:13},{value:": false ",paraId:18,tocIndex:13},{value:"示例",paraId:18,tocIndex:13},{value:": Example 1: 10 ",paraId:18,tocIndex:13},{value:"Example 2:",paraId:18,tocIndex:13},{value:"(d) => {\n  // d is a combo\n  if (d.id === 'combo1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:19,tocIndex:13},{value:"描述",paraId:20,tocIndex:13},{value:": ",paraId:20,tocIndex:13},{value:"preventComboOverlap",paraId:20,tocIndex:13},{value:" 或 ",paraId:20,tocIndex:13},{value:"preventOverlap",paraId:20,tocIndex:13},{value:" 为 ",paraId:20,tocIndex:13},{value:"true",paraId:20,tocIndex:13},{value:" 时生效, 防止重叠时 combo 边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:20,tocIndex:13},{value:"类型",paraId:21,tocIndex:14},{value:": Number / Function",paraId:21,tocIndex:14},{value:"默认值",paraId:21,tocIndex:14},{value:": 10",paraId:21,tocIndex:14},{value:"是否必须",paraId:21,tocIndex:14},{value:": false ",paraId:21,tocIndex:14},{value:"示例",paraId:21,tocIndex:14},{value:": Example 1: 10 ",paraId:21,tocIndex:14},{value:"Example 2:",paraId:21,tocIndex:14},{value:"(d) => {\n  // d is a combo\n  if (d.id === 'combo1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:22,tocIndex:14},{value:"描述",paraId:23,tocIndex:14},{value:": Combo 内部的 padding 值，不用于渲染，仅用于计算力。推荐设置为与视图上 combo 内部 padding 值相同的值",paraId:23,tocIndex:14},{value:"类型",paraId:24,tocIndex:15},{value:"：Number",paraId:24,tocIndex:15},{value:"默认值",paraId:24,tocIndex:15},{value:"：1",paraId:24,tocIndex:15},{value:"是否必须",paraId:24,tocIndex:15},{value:"：false",paraId:24,tocIndex:15},{value:"说明",paraId:24,tocIndex:15},{value:"：当前的迭代收敛阈值",paraId:24,tocIndex:15},{value:"类型",paraId:25,tocIndex:16},{value:"：Number",paraId:25,tocIndex:16},{value:"默认值",paraId:25,tocIndex:16},{value:"：0.028",paraId:25,tocIndex:16},{value:"是否必须",paraId:25,tocIndex:16},{value:"：false",paraId:25,tocIndex:16},{value:"说明",paraId:25,tocIndex:16},{value:"：迭代阈值的衰减率。范围 [0, 1]。0.028 对应迭代数为 300",paraId:25,tocIndex:16},{value:"类型",paraId:26,tocIndex:17},{value:"：Number",paraId:26,tocIndex:17},{value:"默认值",paraId:26,tocIndex:17},{value:"：0.001",paraId:26,tocIndex:17},{value:"是否必须",paraId:26,tocIndex:17},{value:"：false",paraId:26,tocIndex:17},{value:"说明",paraId:26,tocIndex:17},{value:"：停止迭代的阈值",paraId:26,tocIndex:17},{value:"类型",paraId:27,tocIndex:18},{value:"：Function",paraId:27,tocIndex:18},{value:"默认值",paraId:27,tocIndex:18},{value:"：{}",paraId:27,tocIndex:18},{value:"是否必须",paraId:27,tocIndex:18},{value:"：false",paraId:27,tocIndex:18},{value:"说明",paraId:27,tocIndex:18},{value:"：每一次迭代的回调函数",paraId:27,tocIndex:18},{value:"类型",paraId:28,tocIndex:19},{value:"：Function",paraId:28,tocIndex:19},{value:"默认值",paraId:28,tocIndex:19},{value:"：{}",paraId:28,tocIndex:19},{value:"是否必须",paraId:28,tocIndex:19},{value:"：false",paraId:28,tocIndex:19},{value:"说明",paraId:28,tocIndex:19},{value:"：布局完成后的回调函数",paraId:28,tocIndex:19},{value:"类型",paraId:29,tocIndex:20},{value:"： Number",paraId:29,tocIndex:20},{value:"默认值",paraId:29,tocIndex:20},{value:"：10",paraId:29,tocIndex:20},{value:"是否必须",paraId:29,tocIndex:20},{value:"：false",paraId:29,tocIndex:20},{value:"说明",paraId:29,tocIndex:20},{value:"：重力的大小，影响布局的紧凑程度",paraId:29,tocIndex:20},{value:"类型",paraId:30,tocIndex:21},{value:"： Number",paraId:30,tocIndex:21},{value:"默认值",paraId:30,tocIndex:21},{value:"：30",paraId:30,tocIndex:21},{value:"是否必须",paraId:30,tocIndex:21},{value:"：false",paraId:30,tocIndex:21},{value:"说明",paraId:30,tocIndex:21},{value:"：每个 combo 内部的重力大小，影响聚类的紧凑程度",paraId:30,tocIndex:21},{value:"类型",paraId:31,tocIndex:22},{value:"： Number",paraId:31,tocIndex:22},{value:"默认值",paraId:31,tocIndex:22},{value:"：1",paraId:31,tocIndex:22},{value:"是否必须",paraId:31,tocIndex:22},{value:"：false",paraId:31,tocIndex:22},{value:"说明",paraId:31,tocIndex:22},{value:"：优化计算性能，两节点间距超过 ",paraId:31,tocIndex:22},{value:"optimizeRangeFactor * width",paraId:31,tocIndex:22},{value:" 则不再计算斥力和重叠斥力。通过合理设置该参数可以较少计算量",paraId:31,tocIndex:22},{value:"类型",paraId:32,tocIndex:23},{value:"： Number",paraId:32,tocIndex:23},{value:"默认值",paraId:32,tocIndex:23},{value:"：0.5",paraId:32,tocIndex:23},{value:"是否必须",paraId:32,tocIndex:23},{value:"：false",paraId:32,tocIndex:23},{value:"说明",paraId:32,tocIndex:23},{value:"：根据边两端节点层级差距的调整引力的系数的因子，取值范围 [0, 1]。层级差距越大，引力越小",paraId:32,tocIndex:23},{value:"类型",paraId:33,tocIndex:24},{value:"： Number",paraId:33,tocIndex:24},{value:"默认值",paraId:33,tocIndex:24},{value:"：2",paraId:33,tocIndex:24},{value:"是否必须",paraId:33,tocIndex:24},{value:"：false",paraId:33,tocIndex:24},{value:"说明",paraId:33,tocIndex:24},{value:"：根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大",paraId:33,tocIndex:24},{value:"类型",paraId:34,tocIndex:25},{value:"： Number",paraId:34,tocIndex:25},{value:"默认值",paraId:34,tocIndex:25},{value:"：0.6",paraId:34,tocIndex:25},{value:"是否必须",paraId:34,tocIndex:25},{value:"：false",paraId:34,tocIndex:25},{value:"说明",paraId:34,tocIndex:25},{value:"：节点运动速度衰减参数",paraId:34,tocIndex:25},{value:"类型",paraId:35,tocIndex:26},{value:": Boolean",paraId:35,tocIndex:26},{value:"默认值",paraId:35,tocIndex:26},{value:": false",paraId:35,tocIndex:26},{value:"是否必须",paraId:35,tocIndex:26},{value:": false",paraId:35,tocIndex:26},{value:"说明",paraId:35,tocIndex:26},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:35,tocIndex:26},{value:"⚠️ 注意:",paraId:35,tocIndex:26},{value:" ",paraId:35,tocIndex:26},{value:"workerEnabled: true",paraId:35,tocIndex:26},{value:" 时，不支持所有函数类型的参数。",paraId:35,tocIndex:26}]},92481:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Concentric 布局为同心圆布局，用户可以指定节点某个属性为排序依据（默认为节点度数 degree），该属性值越高，则该节点布局后的位置中心。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'concentric',\n    center: [ 200, 200 ],     // 可选，\n    linkDistance: 50,         // 可选，边长\n    preventOverlap: true,     // 可选，必须配合 nodeSize\n    nodeSize: 30,             // 可选\n    sweep: 10,                // 可选\n    equidistant: false,       // 可选\n    startAngle: 0,            // 可选\n    clockwise: false,         // 可选\n    maxLevelDiff: 10,         // 可选\n    sortBy: 'degree'          // 可选\n    workerEnabled: true       // 可选，开启 web-worker\n  }\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"：Boolean",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：是否防止重叠，必须配合下面属性 ",paraId:3,tocIndex:1},{value:"nodeSize",paraId:3,tocIndex:1},{value:"，只有设置了与当前图节点大小相同的 ",paraId:3,tocIndex:1},{value:"nodeSize",paraId:3,tocIndex:1},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：30",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：节点大小（直径）。用于防止节点重叠时的碰撞检测",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:"： Number",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:"：10",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:"：false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:"：环与环之间最小间距，用于调整半径",paraId:5,tocIndex:3},{value:"类型",paraId:6,tocIndex:4},{value:"： Number",paraId:6,tocIndex:4},{value:"默认值",paraId:6,tocIndex:4},{value:"：undefined",paraId:6,tocIndex:4},{value:"是否必须",paraId:6,tocIndex:4},{value:"：false",paraId:6,tocIndex:4},{value:"说明",paraId:6,tocIndex:4},{value:"：第一个节点与最后一个节点之间的弧度差。若为 undefined ，则将会被设置为  2 _ Math.PI _ (1 - 1 / |level.nodes|) ，其中 level.nodes 为该算法计算出的每一层的节点，|level.nodes| 代表该层节点数量",paraId:6,tocIndex:4},{value:"类型",paraId:7,tocIndex:5},{value:"： Boolean",paraId:7,tocIndex:5},{value:"默认值",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"是否必须",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"说明",paraId:7,tocIndex:5},{value:"：环与环之间的距离是否相等",paraId:7,tocIndex:5},{value:"类型",paraId:8,tocIndex:6},{value:"： Number",paraId:8,tocIndex:6},{value:"默认值",paraId:8,tocIndex:6},{value:"：3 / 2 * Math.PI",paraId:8,tocIndex:6},{value:"是否必须",paraId:8,tocIndex:6},{value:"：false",paraId:8,tocIndex:6},{value:"说明",paraId:8,tocIndex:6},{value:"：开始方式节点的弧度",paraId:8,tocIndex:6},{value:"类型",paraId:9,tocIndex:7},{value:"： Boolean",paraId:9,tocIndex:7},{value:"默认值",paraId:9,tocIndex:7},{value:"：false",paraId:9,tocIndex:7},{value:"是否必须",paraId:9,tocIndex:7},{value:"：false",paraId:9,tocIndex:7},{value:"说明",paraId:9,tocIndex:7},{value:"：是否按照顺时针排列",paraId:9,tocIndex:7},{value:"类型",paraId:10,tocIndex:8},{value:"： Number",paraId:10,tocIndex:8},{value:"**默认值：**undefined",paraId:10,tocIndex:8},{value:"是否必须",paraId:10,tocIndex:8},{value:"：false",paraId:10,tocIndex:8},{value:"说明",paraId:10,tocIndex:8},{value:"：每一层同心值的求和。若为 undefined，则将会被设置为 maxValue / 4 ，其中 maxValue 为最大的排序依据的属性值。例如，若 ",paraId:10,tocIndex:8},{value:"sortBy",paraId:10,tocIndex:8},{value:" 为 ",paraId:10,tocIndex:8},{value:"'degree'",paraId:10,tocIndex:8},{value:"，则 maxValue 为所有节点中度数最大的节点的度数",paraId:10,tocIndex:8},{value:"类型",paraId:11,tocIndex:9},{value:"： String",paraId:11,tocIndex:9},{value:"默认值",paraId:11,tocIndex:9},{value:"：undefined",paraId:11,tocIndex:9},{value:"是否必须",paraId:11,tocIndex:9},{value:"：false",paraId:11,tocIndex:9},{value:"说明",paraId:11,tocIndex:9},{value:"：指定排序的依据（节点属性名），数值越高则该节点被放置得越中心。若为 undefined，则会计算节点的度数，度数越高，节点将被放置得越中心",paraId:11,tocIndex:9},{value:"类型",paraId:12,tocIndex:10},{value:": Boolean",paraId:12,tocIndex:10},{value:"默认值",paraId:12,tocIndex:10},{value:": false",paraId:12,tocIndex:10},{value:"是否必须",paraId:12,tocIndex:10},{value:": false",paraId:12,tocIndex:10},{value:"说明",paraId:12,tocIndex:10},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:12,tocIndex:10},{value:"⚠️ 注意:",paraId:12,tocIndex:10},{value:" ",paraId:12,tocIndex:10},{value:"workerEnabled: true",paraId:12,tocIndex:10},{value:" 时，不支持所有函数类型的参数。",paraId:12,tocIndex:10}]},11071:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Dagre 是一种层次布局。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'dagre',\n    rankdir: 'LR', // 可选，默认为图的中心\n    align: 'DL', // 可选\n    nodesep: 20, // 可选\n    ranksep: 50, // 可选\n    controlPoints: true, // 可选\n  },\n});\n",paraId:1},{value:"自 G6 v4.5.1 起支持。",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:0},{value:"： Array",paraId:3,tocIndex:0},{value:"示例",paraId:3,tocIndex:0},{value:"：[ 0, 0 ]",paraId:3,tocIndex:0},{value:"默认值",paraId:3,tocIndex:0},{value:"：undefined",paraId:3,tocIndex:0},{value:"是否必须",paraId:3,tocIndex:0},{value:"：false",paraId:3,tocIndex:0},{value:"说明",paraId:3,tocIndex:0},{value:"：布局的左上角对齐位置。",paraId:3,tocIndex:0},{value:"类型",paraId:4,tocIndex:1},{value:"： String",paraId:4,tocIndex:1},{value:"可选值",paraId:4,tocIndex:1},{value:"：'TB' | 'BT' | 'LR' | 'RL'",paraId:4,tocIndex:1},{value:"默认值",paraId:4,tocIndex:1},{value:"：'TB'",paraId:4,tocIndex:1},{value:"是否必须",paraId:4,tocIndex:1},{value:"：false",paraId:4,tocIndex:1},{value:"说明",paraId:4,tocIndex:1},{value:"：布局的方向。T：top（上）；B：bottom（下）；L：left（左）；R：right（右）。",paraId:4,tocIndex:1},{value:"'TB'：从上至下布局；",paraId:5,tocIndex:1},{value:"'BT'：从下至上布局；",paraId:5,tocIndex:1},{value:"'LR'：从左至右布局；",paraId:5,tocIndex:1},{value:"'RL'：从右至左布局。",paraId:5,tocIndex:1},{value:"类型",paraId:6,tocIndex:2},{value:"： String",paraId:6,tocIndex:2},{value:"可选值",paraId:6,tocIndex:2},{value:"：'UL' | 'UR' | 'DL' | 'DR' | undefined",paraId:6,tocIndex:2},{value:"默认值",paraId:6,tocIndex:2},{value:"：'UL'",paraId:6,tocIndex:2},{value:"是否必须",paraId:6,tocIndex:2},{value:"：false",paraId:6,tocIndex:2},{value:"说明",paraId:6,tocIndex:2},{value:"：节点对齐方式。U：upper（上）；D：down（下）；L：left（左）；R：right（右）",paraId:6,tocIndex:2},{value:"'UL'：对齐到左上角；",paraId:7,tocIndex:2},{value:"'UR'：对齐到右上角；",paraId:7,tocIndex:2},{value:"'DL'：对齐到左下角；",paraId:7,tocIndex:2},{value:"'DR'：对齐到右下角；",paraId:7,tocIndex:2},{value:"undefined：默认，中间对齐。",paraId:7,tocIndex:2},{value:"类型",paraId:8,tocIndex:3},{value:"： Number",paraId:8,tocIndex:3},{value:"默认值",paraId:8,tocIndex:3},{value:"：50",paraId:8,tocIndex:3},{value:"是否必须",paraId:8,tocIndex:3},{value:"：false",paraId:8,tocIndex:3},{value:"说明",paraId:8,tocIndex:3},{value:"：节点间距（px）。在",paraId:8,tocIndex:3},{value:"rankdir",paraId:8,tocIndex:3},{value:" 为 ",paraId:8,tocIndex:3},{value:"'TB'",paraId:8,tocIndex:3},{value:" 或 ",paraId:8,tocIndex:3},{value:"'BT'",paraId:8,tocIndex:3},{value:" 时是节点的水平间距；在",paraId:8,tocIndex:3},{value:"rankdir",paraId:8,tocIndex:3},{value:" 为 ",paraId:8,tocIndex:3},{value:"'LR'",paraId:8,tocIndex:3},{value:" 或 ",paraId:8,tocIndex:3},{value:"'RL'",paraId:8,tocIndex:3},{value:" 时代表节点的竖直方向间距",paraId:8,tocIndex:3},{value:"类型",paraId:9,tocIndex:4},{value:"： Number",paraId:9,tocIndex:4},{value:"默认值",paraId:9,tocIndex:4},{value:"：50",paraId:9,tocIndex:4},{value:"是否必须",paraId:9,tocIndex:4},{value:"：false",paraId:9,tocIndex:4},{value:"说明",paraId:9,tocIndex:4},{value:"：层间距（px）。在",paraId:9,tocIndex:4},{value:"rankdir",paraId:9,tocIndex:4},{value:" 为 ",paraId:9,tocIndex:4},{value:"'TB'",paraId:9,tocIndex:4},{value:" 或 ",paraId:9,tocIndex:4},{value:"'BT'",paraId:9,tocIndex:4},{value:" 时是竖直方向相邻层间距；在",paraId:9,tocIndex:4},{value:"rankdir",paraId:9,tocIndex:4},{value:" 为 ",paraId:9,tocIndex:4},{value:"'LR'",paraId:9,tocIndex:4},{value:" 或 ",paraId:9,tocIndex:4},{value:"'RL'",paraId:9,tocIndex:4},{value:" 时代表水平方向相邻层间距",paraId:9,tocIndex:4},{value:"类型",paraId:10,tocIndex:5},{value:"： Function",paraId:10,tocIndex:5},{value:"默认值",paraId:10,tocIndex:5},{value:"：undefined",paraId:10,tocIndex:5},{value:"示例",paraId:10,tocIndex:5},{value:"：",paraId:10,tocIndex:5},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 100;\n  return 10;\n};\n",paraId:11,tocIndex:5},{value:"是否必须",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"说明",paraId:12,tocIndex:5},{value:"：节点间距（px）的回调函数，通过该参数可以对不同节点设置不同的节点间距。在",paraId:12,tocIndex:5},{value:"rankdir",paraId:12,tocIndex:5},{value:" 为 'TB' 或 'BT' 时是节点的水平间距；在",paraId:12,tocIndex:5},{value:"rankdir",paraId:12,tocIndex:5},{value:" 为 'LR' 或 'RL' 时代表节点的竖直方向间距。优先级高于 ",paraId:12,tocIndex:5},{value:"nodesep",paraId:12,tocIndex:5},{value:"，即若设置了 ",paraId:12,tocIndex:5},{value:"nodesepFunc",paraId:12,tocIndex:5},{value:"，则 ",paraId:12,tocIndex:5},{value:"nodesep",paraId:12,tocIndex:5},{value:" 不生效",paraId:12,tocIndex:5},{value:"类型",paraId:13,tocIndex:6},{value:"： Function",paraId:13,tocIndex:6},{value:"默认值",paraId:13,tocIndex:6},{value:"：undefined",paraId:13,tocIndex:6},{value:"示例",paraId:13,tocIndex:6},{value:"：",paraId:13,tocIndex:6},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 100;\n  return 10;\n};\n",paraId:14,tocIndex:6},{value:"是否必须",paraId:15,tocIndex:6},{value:"：false",paraId:15,tocIndex:6},{value:"说明",paraId:15,tocIndex:6},{value:"：层间距（px）的回调函数，通过该参数可以对不同节点设置不同的层间距。在",paraId:15,tocIndex:6},{value:"rankdir",paraId:15,tocIndex:6},{value:" 为 'TB' 或 'BT' 时是竖直方向相邻层间距；在",paraId:15,tocIndex:6},{value:"rankdir",paraId:15,tocIndex:6},{value:" 为 'LR' 或 'RL' 时代表水平方向相邻层间距。优先级高于 ",paraId:15,tocIndex:6},{value:"ranksep",paraId:15,tocIndex:6},{value:"，即若设置了 ",paraId:15,tocIndex:6},{value:"ranksepFunc",paraId:15,tocIndex:6},{value:"，则 ",paraId:15,tocIndex:6},{value:"ranksep",paraId:15,tocIndex:6},{value:" 不生效",paraId:15,tocIndex:6},{value:"类型",paraId:16,tocIndex:7},{value:"： Boolean",paraId:16,tocIndex:7},{value:"默认值",paraId:16,tocIndex:7},{value:"：false",paraId:16,tocIndex:7},{value:"是否必须",paraId:16,tocIndex:7},{value:"：false",paraId:16,tocIndex:7},{value:"说明",paraId:16,tocIndex:7},{value:"：是否保留布局连线的控制点",paraId:16,tocIndex:7},{value:"类型",paraId:17,tocIndex:8},{value:": Boolean",paraId:17,tocIndex:8},{value:"默认值",paraId:17,tocIndex:8},{value:": false",paraId:17,tocIndex:8},{value:"是否必须",paraId:17,tocIndex:8},{value:": false",paraId:17,tocIndex:8},{value:"说明",paraId:17,tocIndex:8},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:17,tocIndex:8},{value:"⚠️ 注意:",paraId:17,tocIndex:8},{value:" ",paraId:17,tocIndex:8},{value:"workerEnabled: true",paraId:17,tocIndex:8},{value:" 时，不支持所有函数类型的参数。",paraId:17,tocIndex:8},{value:"类型",paraId:18,tocIndex:9},{value:": Boolean",paraId:18,tocIndex:9},{value:"默认值",paraId:18,tocIndex:9},{value:": false",paraId:18,tocIndex:9},{value:"是否必须",paraId:18,tocIndex:9},{value:": false",paraId:18,tocIndex:9},{value:"说明",paraId:18,tocIndex:9},{value:": 同一层节点是否根据每个节点数据中的 ",paraId:18,tocIndex:9},{value:"comboId",paraId:18,tocIndex:9},{value:" 进行排序，以防止 combo 重叠",paraId:18,tocIndex:9},{value:"自 G6 v4.5.0 起支持。",paraId:19,tocIndex:10},{value:"类型",paraId:20,tocIndex:10},{value:": string[]",paraId:20,tocIndex:10},{value:"默认值",paraId:20,tocIndex:10},{value:": undefined",paraId:20,tocIndex:10},{value:"是否必须",paraId:20,tocIndex:10},{value:": false",paraId:20,tocIndex:10},{value:"说明",paraId:20,tocIndex:10},{value:": 同层节点顺序的参考数组，存放节点 id 值。若未指定，则将按照 dagre 本身机制排列同层节点顺序。",paraId:20,tocIndex:10},{value:"自 G6 v4.5.0 起支持。",paraId:21,tocIndex:11},{value:"类型",paraId:22,tocIndex:11},{value:":",paraId:22,tocIndex:11},{value:"{\n  nodes: {\n    x: number, // 位置\n    y: number, // 位置\n    layer?: number, // 指定层级\n    _order?: number // 若为上一次 dagre 布局的输出，则有该字段，代表同层节点的顺序\n  }[]\n}\n",paraId:23,tocIndex:11},{value:"默认值",paraId:24,tocIndex:11},{value:": undefined",paraId:24,tocIndex:11},{value:"是否必须",paraId:24,tocIndex:11},{value:": false",paraId:24,tocIndex:11},{value:"说明",paraId:24,tocIndex:11},{value:": 布局计算时参考的节点位置，一般用于切换数据时保证重新布局的连续性，可使用上一次布局的结果数据作为输入。",paraId:24,tocIndex:11},{value:"自 G6 v4.5.0 起支持。",paraId:25,tocIndex:12},{value:"在节点数据中配置 ",paraId:26,tocIndex:12},{value:"layer",paraId:26,tocIndex:12},{value:" 字段（从 0 开始计数），可以为节点指定层级。注意，",paraId:26,tocIndex:12},{value:"layer",paraId:26,tocIndex:12},{value:" 的指定不能违背图结构与层次布局原则，即每一条边的起点的 ",paraId:26,tocIndex:12},{value:"layer",paraId:26,tocIndex:12},{value:" 一定小于终点的 ",paraId:26,tocIndex:12},{value:"layer",paraId:26,tocIndex:12},{value:" 值。若违背该规则，则可能导致布局失败。",paraId:26,tocIndex:12}]},70596:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Force 布局经典的力导向布局方法，与 d3 的力导向布局方法相对应。其属性也与 d3.js 的力导布局参数相对应。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'force',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    linkDistance: 50,         // 可选，边长\n    nodeStrength: 30,         // 可选\n    edgeStrength: 0.1,        // 可选\n    collideStrength: 0.8,     // 可选\n    nodeSize: 30,             // 可选\n    alpha: 0.3,               // 可选\n    alphaDecay: 0.028,        // 可选\n    alphaMin: 0.01,           // 可选\n    forceSimulation: null,    // 可选\n    onTick: () => {           // 可选\n      console.log('ticking');\n    },\n    onLayoutEnd: () => {      // 可选\n      console.log('force layout done');\n    }\n  }\n);\n",paraId:1},{value:"当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:2},{value:"fx",paraId:2},{value:" 与 ",paraId:2},{value:"fy",paraId:2},{value:" 作为固定的坐标。",paraId:2},{value:"Force 布局固定被拖拽节点位置的 Demo",paraId:3},{value:"。",paraId:2},{value:"类型",paraId:4,tocIndex:0},{value:"： Array",paraId:4,tocIndex:0},{value:"示例",paraId:4,tocIndex:0},{value:"：[ 0, 0 ]",paraId:4,tocIndex:0},{value:"默认值",paraId:4,tocIndex:0},{value:"：图的中心",paraId:4,tocIndex:0},{value:"是否必须",paraId:4,tocIndex:0},{value:"：false",paraId:4,tocIndex:0},{value:"说明",paraId:4,tocIndex:0},{value:"：布局的中心",paraId:4,tocIndex:0},{value:"类型",paraId:5,tocIndex:1},{value:"： Number / Function",paraId:5,tocIndex:1},{value:"默认值",paraId:5,tocIndex:1},{value:"：50",paraId:5,tocIndex:1},{value:"是否必须",paraId:5,tocIndex:1},{value:"：false",paraId:5,tocIndex:1},{value:"说明",paraId:5,tocIndex:1},{value:"：边长度",paraId:5,tocIndex:1},{value:"类型",paraId:6,tocIndex:2},{value:"： Number / Function",paraId:6,tocIndex:2},{value:"默认值",paraId:6,tocIndex:2},{value:"：null",paraId:6,tocIndex:2},{value:"是否必须",paraId:6,tocIndex:2},{value:"：false",paraId:6,tocIndex:2},{value:"说明",paraId:6,tocIndex:2},{value:"：节点作用力，正数代表节点之间的引力作用，负数代表节点之间的斥力作用",paraId:6,tocIndex:2},{value:"类型",paraId:7,tocIndex:3},{value:"：Number / Function",paraId:7,tocIndex:3},{value:"默认值",paraId:7,tocIndex:3},{value:"：null",paraId:7,tocIndex:3},{value:"是否必须",paraId:7,tocIndex:3},{value:"：false",paraId:7,tocIndex:3},{value:"说明",paraId:7,tocIndex:3},{value:"：边的作用力，范围是 0 到 1，默认根据节点的出入度自适应",paraId:7,tocIndex:3},{value:"类型",paraId:8,tocIndex:4},{value:"：Boolean",paraId:8,tocIndex:4},{value:"默认值",paraId:8,tocIndex:4},{value:"：false",paraId:8,tocIndex:4},{value:"是否必须",paraId:8,tocIndex:4},{value:"：false",paraId:8,tocIndex:4},{value:"说明",paraId:8,tocIndex:4},{value:"：是否防止重叠，必须配合下面属性 ",paraId:8,tocIndex:4},{value:"nodeSize",paraId:8,tocIndex:4},{value:" 或节点数据中的 ",paraId:8,tocIndex:4},{value:"size",paraId:8,tocIndex:4},{value:" 属性，只有在数据中设置了 ",paraId:8,tocIndex:4},{value:"size",paraId:8,tocIndex:4},{value:" 或在该布局中配置了与当前图节点大小相同的 ",paraId:8,tocIndex:4},{value:"nodeSize",paraId:8,tocIndex:4},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:8,tocIndex:4},{value:"类型",paraId:9,tocIndex:5},{value:"：Number",paraId:9,tocIndex:5},{value:"默认值",paraId:9,tocIndex:5},{value:"：1",paraId:9,tocIndex:5},{value:"是否必须",paraId:9,tocIndex:5},{value:"：false",paraId:9,tocIndex:5},{value:"说明",paraId:9,tocIndex:5},{value:"：防止重叠的力强度，范围 [0, 1]",paraId:9,tocIndex:5},{value:"类型",paraId:10,tocIndex:6},{value:"： Number",paraId:10,tocIndex:6},{value:"默认值",paraId:10,tocIndex:6},{value:"：10",paraId:10,tocIndex:6},{value:"是否必须",paraId:10,tocIndex:6},{value:"：false",paraId:10,tocIndex:6},{value:"说明",paraId:10,tocIndex:6},{value:"：节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:10,tocIndex:6},{value:"size",paraId:10,tocIndex:6},{value:"，则默认大小为 ",paraId:10,tocIndex:6},{value:"10",paraId:10,tocIndex:6},{value:"类型",paraId:11,tocIndex:7},{value:": Number / Function",paraId:11,tocIndex:7},{value:"默认值",paraId:11,tocIndex:7},{value:": 0",paraId:11,tocIndex:7},{value:"是否必须",paraId:11,tocIndex:7},{value:": false ",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:"示例",paraId:11,tocIndex:7},{value:": Example 1: 10 ",paraId:11,tocIndex:7},{value:"Example 2:",paraId:11,tocIndex:7},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:12,tocIndex:7},{value:"\n**描述**: `preventOverlap` 为 `true` 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示\n",paraId:13},{value:"类型",paraId:14,tocIndex:8},{value:"：Number",paraId:14,tocIndex:8},{value:"默认值",paraId:14,tocIndex:8},{value:"：0.3",paraId:14,tocIndex:8},{value:"是否必须",paraId:14,tocIndex:8},{value:"：false",paraId:14,tocIndex:8},{value:"说明",paraId:14,tocIndex:8},{value:"：当前的迭代收敛阈值",paraId:14,tocIndex:8},{value:"类型",paraId:15,tocIndex:9},{value:"：Number",paraId:15,tocIndex:9},{value:"默认值",paraId:15,tocIndex:9},{value:"：0.028",paraId:15,tocIndex:9},{value:"是否必须",paraId:15,tocIndex:9},{value:"：false",paraId:15,tocIndex:9},{value:"说明",paraId:15,tocIndex:9},{value:"：迭代阈值的衰减率。范围 [0, 1]。0.028 对应迭代数为 300",paraId:15,tocIndex:9},{value:"类型",paraId:16,tocIndex:10},{value:"：Number",paraId:16,tocIndex:10},{value:"默认值",paraId:16,tocIndex:10},{value:"：0.001",paraId:16,tocIndex:10},{value:"是否必须",paraId:16,tocIndex:10},{value:"：false",paraId:16,tocIndex:10},{value:"说明",paraId:16,tocIndex:10},{value:"：停止迭代的阈值",paraId:16,tocIndex:10},{value:"类型",paraId:17,tocIndex:11},{value:"：Boolean",paraId:17,tocIndex:11},{value:"默认值",paraId:17,tocIndex:11},{value:"：false",paraId:17,tocIndex:11},{value:"是否必须",paraId:17,tocIndex:11},{value:"：false",paraId:17,tocIndex:11},{value:"说明",paraId:17,tocIndex:11},{value:"：是否按照聚类信息布局",paraId:17,tocIndex:11},{value:"类型",paraId:18,tocIndex:12},{value:"：Number",paraId:18,tocIndex:12},{value:"默认值",paraId:18,tocIndex:12},{value:"：-1",paraId:18,tocIndex:12},{value:"是否必须",paraId:18,tocIndex:12},{value:"：false",paraId:18,tocIndex:12},{value:"说明",paraId:18,tocIndex:12},{value:"：聚类节点作用力。负数代表斥力",paraId:18,tocIndex:12},{value:"类型",paraId:19,tocIndex:13},{value:"：Number",paraId:19,tocIndex:13},{value:"默认值",paraId:19,tocIndex:13},{value:"：0.1",paraId:19,tocIndex:13},{value:"是否必须",paraId:19,tocIndex:13},{value:"：false",paraId:19,tocIndex:13},{value:"说明",paraId:19,tocIndex:13},{value:"：聚类边作用力",paraId:19,tocIndex:13},{value:"类型",paraId:20,tocIndex:14},{value:"：Number",paraId:20,tocIndex:14},{value:"默认值",paraId:20,tocIndex:14},{value:"：100",paraId:20,tocIndex:14},{value:"是否必须",paraId:20,tocIndex:14},{value:"：false",paraId:20,tocIndex:14},{value:"说明",paraId:20,tocIndex:14},{value:"：聚类边长度",paraId:20,tocIndex:14},{value:"类型",paraId:21,tocIndex:15},{value:"：Number",paraId:21,tocIndex:15},{value:"默认值",paraId:21,tocIndex:15},{value:"：10",paraId:21,tocIndex:15},{value:"是否必须",paraId:21,tocIndex:15},{value:"：false",paraId:21,tocIndex:15},{value:"说明",paraId:21,tocIndex:15},{value:"：聚类节点大小 / 直径，直径越大，越分散",paraId:21,tocIndex:15},{value:"类型",paraId:22,tocIndex:16},{value:"：Number",paraId:22,tocIndex:16},{value:"默认值",paraId:22,tocIndex:16},{value:"：0.8",paraId:22,tocIndex:16},{value:"是否必须",paraId:22,tocIndex:16},{value:"：false",paraId:22,tocIndex:16},{value:"说明",paraId:22,tocIndex:16},{value:"：用于 foci 的力",paraId:22,tocIndex:16},{value:"类型",paraId:23,tocIndex:17},{value:"：Object",paraId:23,tocIndex:17},{value:"默认值",paraId:23,tocIndex:17},{value:"：null",paraId:23,tocIndex:17},{value:"是否必须",paraId:23,tocIndex:17},{value:"：false",paraId:23,tocIndex:17},{value:"说明",paraId:23,tocIndex:17},{value:"：自定义 force 方法，若不指定，则使用 d3.js 的方法",paraId:23,tocIndex:17},{value:"类型",paraId:24,tocIndex:18},{value:"：Function",paraId:24,tocIndex:18},{value:"默认值",paraId:24,tocIndex:18},{value:"：{}",paraId:24,tocIndex:18},{value:"是否必须",paraId:24,tocIndex:18},{value:"：false",paraId:24,tocIndex:18},{value:"说明",paraId:24,tocIndex:18},{value:"：每一次迭代的回调函数",paraId:24,tocIndex:18},{value:"类型",paraId:25,tocIndex:19},{value:"：Function",paraId:25,tocIndex:19},{value:"默认值",paraId:25,tocIndex:19},{value:"：{}",paraId:25,tocIndex:19},{value:"是否必须",paraId:25,tocIndex:19},{value:"：false",paraId:25,tocIndex:19},{value:"说明",paraId:25,tocIndex:19},{value:"：布局完成后的回调函数",paraId:25,tocIndex:19},{value:"类型",paraId:26,tocIndex:20},{value:": Boolean",paraId:26,tocIndex:20},{value:"默认值",paraId:26,tocIndex:20},{value:": false",paraId:26,tocIndex:20},{value:"是否必须",paraId:26,tocIndex:20},{value:": false",paraId:26,tocIndex:20},{value:"说明",paraId:26,tocIndex:20},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:26,tocIndex:20},{value:"⚠️ 注意:",paraId:26,tocIndex:20},{value:" ",paraId:26,tocIndex:20},{value:"workerEnabled: true",paraId:26,tocIndex:20},{value:" 时，不支持所有函数类型的参数。",paraId:26,tocIndex:20}]},89886:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Force2 实现经典的力导向算法，G6 4.7.0 后支持。沉淀自 graphin-force，能够更加自由地支持设置节点质量、群组中心力等。相比 graphin-force，性能有显著提升。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'force2',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    linkDistance: 50,         // 可选，边长\n    nodeStrength: 30,         // 可选\n    edgeStrength: 0.1,        // 可选\n    nodeSize: 30,             // 可选\n    onTick: () => {           // 可选\n      console.log('ticking');\n    },\n    onLayoutEnd: () => {      // 可选\n      console.log('force layout done');\n    },\n    workerEnabled: true,      // 可选，开启 web-worker\n    ... // 更多参数见下方\n  }\n});\n",paraId:1},{value:"当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:2},{value:"fx",paraId:2},{value:" 与 ",paraId:2},{value:"fy",paraId:2},{value:" 作为固定的坐标。",paraId:2},{value:"Force2 布局固定被拖拽节点位置的 Demo",paraId:3},{value:"。",paraId:2},{value:"类型",paraId:4,tocIndex:0},{value:"： Array",paraId:4,tocIndex:0},{value:"示例",paraId:4,tocIndex:0},{value:"：[ 0, 0 ]",paraId:4,tocIndex:0},{value:"默认值",paraId:4,tocIndex:0},{value:"：图的中心",paraId:4,tocIndex:0},{value:"是否必须",paraId:4,tocIndex:0},{value:"：false",paraId:4,tocIndex:0},{value:"说明",paraId:4,tocIndex:0},{value:"：布局的中心",paraId:4,tocIndex:0},{value:"类型",paraId:5,tocIndex:1},{value:"： Boolean",paraId:5,tocIndex:1},{value:"示例",paraId:5,tocIndex:1},{value:"：false",paraId:5,tocIndex:1},{value:"默认值",paraId:5,tocIndex:1},{value:"：：false",paraId:5,tocIndex:1},{value:"是否必须",paraId:5,tocIndex:1},{value:"：false",paraId:5,tocIndex:1},{value:"说明",paraId:5,tocIndex:1},{value:"：是否每次迭代都刷新画布，若为 ",paraId:5,tocIndex:1},{value:"true",paraId:5,tocIndex:1},{value:" 则将表现出带有动画逐步布局的效果",paraId:5,tocIndex:1},{value:"自 G6 v4.7.0 起支持。",paraId:6,tocIndex:2},{value:"类型",paraId:7,tocIndex:2},{value:":",paraId:7,tocIndex:2},{value:"{\n  type: string; // 布局名称，可以是 random、concentric、grid、circular、radial、dagre 等静态布局\n  [key: string]: unkown; // 对应布局的配置项\n}\n",paraId:8,tocIndex:2},{value:"默认值",paraId:9,tocIndex:2},{value:": undefined",paraId:9,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:": false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:": 力导向布局的初始化布局，将先执行 preset 指定的布局，再进行力导向计算。由于力导向布局的结果非常依赖节点的初始位置，配置 preset 的可以给力导向布局一个好的初始化，让力导向算法更快收敛、效果更好。默认情况下，力导向的初始化为格子布局（grid）的结果",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"： Number / Function",paraId:10,tocIndex:3},{value:"默认值",paraId:10,tocIndex:3},{value:"1",paraId:10,tocIndex:3},{value:"是否必须",paraId:10,tocIndex:3},{value:"：false",paraId:10,tocIndex:3},{value:"说明",paraId:10,tocIndex:3},{value:"：边长度",paraId:10,tocIndex:3},{value:"类型",paraId:11,tocIndex:4},{value:"： Number / Function",paraId:11,tocIndex:4},{value:"默认值",paraId:11,tocIndex:4},{value:"：1000",paraId:11,tocIndex:4},{value:"是否必须",paraId:11,tocIndex:4},{value:"：false",paraId:11,tocIndex:4},{value:"说明",paraId:11,tocIndex:4},{value:"：节点作用力，正数代表节点之间的斥力作用，负数代表节点之间的引力作用（注意与 'force' 相反）",paraId:11,tocIndex:4},{value:"类型",paraId:12,tocIndex:5},{value:"：Number / Function",paraId:12,tocIndex:5},{value:"默认值",paraId:12,tocIndex:5},{value:"：200",paraId:12,tocIndex:5},{value:"是否必须",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"说明",paraId:12,tocIndex:5},{value:"：边的作用力（引力）大小",paraId:12,tocIndex:5},{value:"类型",paraId:13,tocIndex:6},{value:"：Boolean",paraId:13,tocIndex:6},{value:"默认值",paraId:13,tocIndex:6},{value:"：false",paraId:13,tocIndex:6},{value:"是否必须",paraId:13,tocIndex:6},{value:"：false",paraId:13,tocIndex:6},{value:"说明",paraId:13,tocIndex:6},{value:"：是否防止重叠，必须配合下面属性 ",paraId:13,tocIndex:6},{value:"nodeSize",paraId:13,tocIndex:6},{value:" 或节点数据中的 ",paraId:13,tocIndex:6},{value:"size",paraId:13,tocIndex:6},{value:" 属性，只有在数据中设置了 ",paraId:13,tocIndex:6},{value:"size",paraId:13,tocIndex:6},{value:" 或在该布局中配置了与当前图节点大小相同的 ",paraId:13,tocIndex:6},{value:"nodeSize",paraId:13,tocIndex:6},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:13,tocIndex:6},{value:"类型",paraId:14,tocIndex:7},{value:"： Number",paraId:14,tocIndex:7},{value:"默认值",paraId:14,tocIndex:7},{value:"：10",paraId:14,tocIndex:7},{value:"是否必须",paraId:14,tocIndex:7},{value:"：false",paraId:14,tocIndex:7},{value:"说明",paraId:14,tocIndex:7},{value:"：节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:14,tocIndex:7},{value:"size",paraId:14,tocIndex:7},{value:"，则默认大小为 ",paraId:14,tocIndex:7},{value:"10",paraId:14,tocIndex:7},{value:"类型",paraId:15,tocIndex:8},{value:": Number / Function",paraId:15,tocIndex:8},{value:"默认值",paraId:15,tocIndex:8},{value:": 0",paraId:15,tocIndex:8},{value:"是否必须",paraId:15,tocIndex:8},{value:": false ",paraId:15,tocIndex:8},{value:"示例",paraId:15,tocIndex:8},{value:": Example 1: 10 ",paraId:15,tocIndex:8},{value:"Example 2:",paraId:15,tocIndex:8},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:16,tocIndex:8},{value:"描述",paraId:17,tocIndex:8},{value:": ",paraId:17,tocIndex:8},{value:"preventOverlap",paraId:17,tocIndex:8},{value:" 为 ",paraId:17,tocIndex:8},{value:"true",paraId:17,tocIndex:8},{value:" 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:17,tocIndex:8},{value:"类型",paraId:18,tocIndex:9},{value:"：Number",paraId:18,tocIndex:9},{value:"默认值",paraId:18,tocIndex:9},{value:"：0.5",paraId:18,tocIndex:9},{value:"是否必须",paraId:18,tocIndex:9},{value:"：false",paraId:18,tocIndex:9},{value:"说明",paraId:18,tocIndex:9},{value:"：当一次迭代的平均/最大/最小（根据",paraId:18,tocIndex:9},{value:"distanceThresholdMode",paraId:18,tocIndex:9},{value:"决定）移动长度小于该值时停止迭代。数字越小，布局越收敛，所用时间将越长",paraId:18,tocIndex:9},{value:"类型",paraId:19,tocIndex:10},{value:"：'mean' | 'max' ｜ 'min'",paraId:19,tocIndex:10},{value:"默认值",paraId:19,tocIndex:10},{value:"：'mean'",paraId:19,tocIndex:10},{value:"是否必须",paraId:19,tocIndex:10},{value:"：false",paraId:19,tocIndex:10},{value:"说明",paraId:19,tocIndex:10},{value:"：",paraId:19,tocIndex:10},{value:"minMovement",paraId:19,tocIndex:10},{value:" 的使用条件，",paraId:19,tocIndex:10},{value:"'mean'",paraId:19,tocIndex:10},{value:" 代表平均移动距离小于 ",paraId:19,tocIndex:10},{value:"minMovement",paraId:19,tocIndex:10},{value:" 时停止迭代，",paraId:19,tocIndex:10},{value:"'max'",paraId:19,tocIndex:10},{value:" / ",paraId:19,tocIndex:10},{value:"'min'",paraId:19,tocIndex:10},{value:" 代表最大/最小移动距离小于时 ",paraId:19,tocIndex:10},{value:"minMovement",paraId:19,tocIndex:10},{value:" 时停时迭代。默认为 ",paraId:19,tocIndex:10},{value:"'mean'",paraId:19,tocIndex:10},{value:"类型",paraId:20,tocIndex:11},{value:"：Number",paraId:20,tocIndex:11},{value:"默认值",paraId:20,tocIndex:11},{value:"：1000",paraId:20,tocIndex:11},{value:"是否必须",paraId:20,tocIndex:11},{value:"：false",paraId:20,tocIndex:11},{value:"说明",paraId:20,tocIndex:11},{value:"：最大迭代次数。当迭代次数超过该值，但平均移动长度仍然没有达到 minMovement，也将强制停止迭代",paraId:20,tocIndex:11},{value:"类型",paraId:21,tocIndex:12},{value:"：Number",paraId:21,tocIndex:12},{value:"默认值",paraId:21,tocIndex:12},{value:"：0.9",paraId:21,tocIndex:12},{value:"是否必须",paraId:21,tocIndex:12},{value:"：false",paraId:21,tocIndex:12},{value:"说明",paraId:21,tocIndex:12},{value:"：阻尼系数，取值范围 [0, 1]。数字越大，速度降低得越慢",paraId:21,tocIndex:12},{value:"类型",paraId:22,tocIndex:13},{value:"：Number",paraId:22,tocIndex:13},{value:"默认值",paraId:22,tocIndex:13},{value:"：0.02",paraId:22,tocIndex:13},{value:"是否必须",paraId:22,tocIndex:13},{value:"：false",paraId:22,tocIndex:13},{value:"说明",paraId:22,tocIndex:13},{value:"：控制每个迭代节点的移动速度",paraId:22,tocIndex:13},{value:"类型",paraId:23,tocIndex:14},{value:"：Number",paraId:23,tocIndex:14},{value:"默认值",paraId:23,tocIndex:14},{value:"：1000",paraId:23,tocIndex:14},{value:"是否必须",paraId:23,tocIndex:14},{value:"：false",paraId:23,tocIndex:14},{value:"说明",paraId:23,tocIndex:14},{value:"：一次迭代的最大移动长度",paraId:23,tocIndex:14},{value:"类型",paraId:24,tocIndex:15},{value:"：Number",paraId:24,tocIndex:15},{value:"默认值",paraId:24,tocIndex:15},{value:"：1",paraId:24,tocIndex:15},{value:"是否必须",paraId:24,tocIndex:15},{value:"：false",paraId:24,tocIndex:15},{value:"说明",paraId:24,tocIndex:15},{value:"：斥力系数，数值越大，斥力越大",paraId:24,tocIndex:15},{value:"类型",paraId:25,tocIndex:16},{value:"：Number",paraId:25,tocIndex:16},{value:"默认值",paraId:25,tocIndex:16},{value:"：0.005",paraId:25,tocIndex:16},{value:"是否必须",paraId:25,tocIndex:16},{value:"：false",paraId:25,tocIndex:16},{value:"说明",paraId:25,tocIndex:16},{value:"：库伦系数，斥力的一个系数，数字越大，节点之间的斥力越大",paraId:25,tocIndex:16},{value:"类型",paraId:26,tocIndex:17},{value:"：Function",paraId:26,tocIndex:17},{value:"默认值",paraId:26,tocIndex:17},{value:"：undefined",paraId:26,tocIndex:17},{value:"是否必须",paraId:26,tocIndex:17},{value:"：false",paraId:26,tocIndex:17},{value:"说明",paraId:26,tocIndex:17},{value:"：每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量。使用方法与 ",paraId:26,tocIndex:17},{value:"nodeSpacing",paraId:26,tocIndex:17},{value:" 类似，每个回调函数返回一个数值作为该节点的质量",paraId:26,tocIndex:17},{value:"类型",paraId:27,tocIndex:18},{value:"：Function",paraId:27,tocIndex:18},{value:"默认值",paraId:27,tocIndex:18},{value:"：undefined",paraId:27,tocIndex:18},{value:"是否必须",paraId:27,tocIndex:18},{value:"：false",paraId:27,tocIndex:18},{value:"说明",paraId:27,tocIndex:18},{value:"：每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力",paraId:27,tocIndex:18},{value:"示例",paraId:27,tocIndex:18},{value:":",paraId:27,tocIndex:18},{value:"(d, degree) => {\n  // d is a node, degree is the degree of the node\n  if (d.clusterId === 'c1') return [100, 100, 10]; // x, y, strength\n  if (degree === 0) return [250, 250, 15];\n  return [180, 180, 5]; // x, y, strength\n};\n",paraId:28,tocIndex:18},{value:"类型",paraId:29,tocIndex:19},{value:"：Number",paraId:29,tocIndex:19},{value:"默认值",paraId:29,tocIndex:19},{value:"：10",paraId:29,tocIndex:19},{value:"是否必须",paraId:29,tocIndex:19},{value:"：false",paraId:29,tocIndex:19},{value:"说明",paraId:29,tocIndex:19},{value:"：中心力大小，指所有节点被吸引到 ",paraId:29,tocIndex:19},{value:"center",paraId:29,tocIndex:19},{value:" 的力。数字越大，布局越紧凑",paraId:29,tocIndex:19},{value:"类型",paraId:30,tocIndex:20},{value:"：CentripetalOptions（见下文类型说明）",paraId:30,tocIndex:20},{value:"默认值",paraId:30,tocIndex:20},{value:"：见下文",paraId:30,tocIndex:20},{value:"是否必须",paraId:30,tocIndex:20},{value:"：false",paraId:30,tocIndex:20},{value:"说明",paraId:30,tocIndex:20},{value:"：详细配置见下文。向心力配置，包括叶子节点、离散点、其他节点的向心中心及向心力大小",paraId:30,tocIndex:20},{value:"CentripetalOptions",paraId:31,tocIndex:20},{value:" 类型说明：",paraId:31,tocIndex:20},{value:"参数名",paraId:32,tocIndex:20},{value:"类型",paraId:32,tocIndex:20},{value:"示例",paraId:32,tocIndex:20},{value:"默认值",paraId:32,tocIndex:20},{value:"说明",paraId:32,tocIndex:20},{value:"single",paraId:32,tocIndex:20},{value:"number / Function",paraId:32,tocIndex:20},{value:"2",paraId:32,tocIndex:20},{value:"2,",paraId:32,tocIndex:20},{value:"离散节点（即度数为 0 的节点）受到的向心力大小",paraId:32,tocIndex:20},{value:"leaf",paraId:32,tocIndex:20},{value:"number / Function",paraId:32,tocIndex:20},{value:"2",paraId:32,tocIndex:20},{value:"2",paraId:32,tocIndex:20},{value:"叶子节点（即度数为 1 的节点）受到的向心力大小",paraId:32,tocIndex:20},{value:"others",paraId:32,tocIndex:20},{value:"number / Function",paraId:32,tocIndex:20},{value:"1",paraId:32,tocIndex:20},{value:"1",paraId:32,tocIndex:20},{value:"除离散节点、叶子节点以外的其他节点（即度数 > 1 的节点）受到的向心力大小",paraId:32,tocIndex:20},{value:"center",paraId:32,tocIndex:20},{value:"Function",paraId:32,tocIndex:20},{value:"(node, nodes, edges) => ({ x: 10, y: 10 })",paraId:32,tocIndex:20},{value:"图的中心",paraId:32,tocIndex:20},{value:"向心力发出的位置，可根据节点、边的情况返回不同的值",paraId:32,tocIndex:20},{value:"centripetalOptions",paraId:33,tocIndex:20},{value:" 示例：",paraId:33,tocIndex:20},{value:"centripetalOptions: {\n  // single、leaf、others 的函数形式的参数为当前节点数据、所有节点数据、所有边数据\n  single: (node, nodes, edges) => node.field1 || 1,\n  leaf: (node, nodes, edges) => node.field2 || 1,\n  others: (node, nodes, edges) => node.field3|| 1,\n  // 参数为当前节点数据、所有节点数据、所有边数据、画布宽度、画布高度\n  center: (node, nodes, edges, width, height) => {\n    if (node.field4) return { x: width / 2, y: height / 2 };\n    if (node.field5) return { x: node.field6, y: node.field7 };\n    // ...\n  }\n}\n",paraId:34,tocIndex:20},{value:"类型",paraId:35,tocIndex:21},{value:"：Boolean",paraId:35,tocIndex:21},{value:"默认值",paraId:35,tocIndex:21},{value:"：false",paraId:35,tocIndex:21},{value:"是否必须",paraId:35,tocIndex:21},{value:"：false",paraId:35,tocIndex:21},{value:"说明",paraId:35,tocIndex:21},{value:"：是否需要叶子结点聚类，若为 ",paraId:35,tocIndex:21},{value:"true",paraId:35,tocIndex:21},{value:"，则 centripetalOptions.single 将为 100；centripetalOptions.leaf 将使用 ",paraId:35,tocIndex:21},{value:"getClusterNodeStrength",paraId:35,tocIndex:21},{value:" 返回值；getClusterNodeStrength.center 将为叶子节点返回当前所有叶子节点的平均中心",paraId:35,tocIndex:21},{value:"类型",paraId:36,tocIndex:22},{value:"：Boolean",paraId:36,tocIndex:22},{value:"默认值",paraId:36,tocIndex:22},{value:"：false",paraId:36,tocIndex:22},{value:"是否必须",paraId:36,tocIndex:22},{value:"：false",paraId:36,tocIndex:22},{value:"说明",paraId:36,tocIndex:22},{value:"：是否需要全部节点聚类，若为 ",paraId:36,tocIndex:22},{value:"true",paraId:36,tocIndex:22},{value:"，将使用 ",paraId:36,tocIndex:22},{value:"nodeClusterBy",paraId:36,tocIndex:22},{value:" 配置的节点数据中的字段作为聚类依据。 centripetalOptions.single、centripetalOptions.leaf、centripetalOptions.others 将使用 ",paraId:36,tocIndex:22},{value:"getClusterNodeStrength",paraId:36,tocIndex:22},{value:" 返回值；leaf、centripetalOptions.center 将使用当前节点所属聚类中所有节点的平均中心",paraId:36,tocIndex:22},{value:"类型",paraId:37,tocIndex:23},{value:"：String",paraId:37,tocIndex:23},{value:"默认值",paraId:37,tocIndex:23},{value:"：undefined",paraId:37,tocIndex:23},{value:"是否必须",paraId:37,tocIndex:23},{value:"：false",paraId:37,tocIndex:23},{value:"说明",paraId:37,tocIndex:23},{value:"：指定节点数据中的字段名称作为节点聚类的依据，",paraId:37,tocIndex:23},{value:"clustering",paraId:37,tocIndex:23},{value:" 为 ",paraId:37,tocIndex:23},{value:"true",paraId:37,tocIndex:23},{value:" 时生效，自动生成 ",paraId:37,tocIndex:23},{value:"centripetalOptions",paraId:37,tocIndex:23},{value:"，可配合 ",paraId:37,tocIndex:23},{value:"clusterNodeStrength",paraId:37,tocIndex:23},{value:" 使用",paraId:37,tocIndex:23},{value:"类型",paraId:38,tocIndex:24},{value:"：Number | Function",paraId:38,tocIndex:24},{value:"默认值",paraId:38,tocIndex:24},{value:"：20",paraId:38,tocIndex:24},{value:"是否必须",paraId:38,tocIndex:24},{value:"：false",paraId:38,tocIndex:24},{value:"说明",paraId:38,tocIndex:24},{value:"：配合 ",paraId:38,tocIndex:24},{value:"clustering",paraId:38,tocIndex:24},{value:" 和 ",paraId:38,tocIndex:24},{value:"nodeClusterBy",paraId:38,tocIndex:24},{value:" 使用，指定聚类向心力的大小",paraId:38,tocIndex:24},{value:"类型",paraId:39,tocIndex:25},{value:"：",paraId:39,tocIndex:25},{value:"(params:{ energy: number, nodes: NodeData[], edges: EdgeData[], iterations: number }) => void",paraId:39,tocIndex:25},{value:"默认值",paraId:39,tocIndex:25},{value:"：undefined",paraId:39,tocIndex:25},{value:"是否必须",paraId:39,tocIndex:25},{value:"：false",paraId:39,tocIndex:25},{value:"说明",paraId:39,tocIndex:25},{value:"：每个迭代的监控信息回调，",paraId:39,tocIndex:25},{value:"energy",paraId:39,tocIndex:25},{value:" 表示布局的收敛能量。若配置可能带来额外的计算能量性能消耗，不配置则不计算",paraId:39,tocIndex:25},{value:"类型",paraId:40,tocIndex:26},{value:"：Function",paraId:40,tocIndex:26},{value:"默认值",paraId:40,tocIndex:26},{value:"：{}",paraId:40,tocIndex:26},{value:"是否必须",paraId:40,tocIndex:26},{value:"：false",paraId:40,tocIndex:26},{value:"说明",paraId:40,tocIndex:26},{value:"：每一次迭代的回调函数",paraId:40,tocIndex:26},{value:"类型",paraId:41,tocIndex:27},{value:"：Function",paraId:41,tocIndex:27},{value:"默认值",paraId:41,tocIndex:27},{value:"：{}",paraId:41,tocIndex:27},{value:"是否必须",paraId:41,tocIndex:27},{value:"：false",paraId:41,tocIndex:27},{value:"说明",paraId:41,tocIndex:27},{value:"：布局完成后的回调函数",paraId:41,tocIndex:27},{value:"类型",paraId:42,tocIndex:28},{value:": Boolean",paraId:42,tocIndex:28},{value:"默认值",paraId:42,tocIndex:28},{value:": false",paraId:42,tocIndex:28},{value:"是否必须",paraId:42,tocIndex:28},{value:": false",paraId:42,tocIndex:28},{value:"说明",paraId:42,tocIndex:28},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:42,tocIndex:28},{value:"⚠️ 注意:",paraId:42,tocIndex:28},{value:" ",paraId:42,tocIndex:28},{value:"workerEnabled: true",paraId:42,tocIndex:28},{value:" 时，不支持所有函数类型的参数。",paraId:42,tocIndex:28}]},96183:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"*V4.2.2 新增功能。*Force Atlas 2 是一种力导向布局的变形，比 force 收敛地更好，更紧凑。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'forceAtlas2',\n    width: 300,\n    height: 300,\n  },\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：图的宽度",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：布局的宽度范围",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：图的高度",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：布局的高度范围",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:": Boolean",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:": false",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:": false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:5,tocIndex:3},{value:"⚠️ 注意:",paraId:5,tocIndex:3},{value:" ",paraId:5,tocIndex:3},{value:"workerEnabled: true",paraId:5,tocIndex:3},{value:" 时，不支持所有函数类型的参数。",paraId:5,tocIndex:3},{value:"自 G6 v4.7.0 起支持。",paraId:6,tocIndex:4},{value:"类型",paraId:7,tocIndex:4},{value:":",paraId:7,tocIndex:4},{value:"{\n  type: string; // 布局名称，可以是 random、concentric、grid、circular、radial、dagre 等静态布局\n  [key: string]: unkown; // 对应布局的配置项\n}\n",paraId:8,tocIndex:4},{value:"默认值",paraId:9,tocIndex:4},{value:": undefined",paraId:9,tocIndex:4},{value:"是否必须",paraId:9,tocIndex:4},{value:": false",paraId:9,tocIndex:4},{value:"说明",paraId:9,tocIndex:4},{value:": 力导向布局的初始化布局，将先执行 preset 指定的布局，再进行力导向计算。由于力导向布局的结果非常依赖节点的初始位置，配置 preset 的可以给力导向布局一个好的初始化，让力导向算法更快收敛、效果更好。默认情况下，力导向的初始化为格子布局（grid）的结果",paraId:9,tocIndex:4},{value:"类型",paraId:10,tocIndex:5},{value:"： Number",paraId:10,tocIndex:5},{value:"默认值",paraId:10,tocIndex:5},{value:"：5",paraId:10,tocIndex:5},{value:"是否必须",paraId:10,tocIndex:5},{value:"：false",paraId:10,tocIndex:5},{value:"说明",paraId:10,tocIndex:5},{value:"：斥力系数，可用于调整布局的紧凑程度。kr 越大，布局越松散",paraId:10,tocIndex:5},{value:"类型",paraId:11,tocIndex:6},{value:"： Number",paraId:11,tocIndex:6},{value:"默认值",paraId:11,tocIndex:6},{value:"：5",paraId:11,tocIndex:6},{value:"是否必须",paraId:11,tocIndex:6},{value:"：false",paraId:11,tocIndex:6},{value:"说明",paraId:11,tocIndex:6},{value:"：重力系数。kg 越大，布局越聚集在中心",paraId:11,tocIndex:6},{value:"类型",paraId:12,tocIndex:7},{value:"： Number",paraId:12,tocIndex:7},{value:"默认值",paraId:12,tocIndex:7},{value:"：0.1",paraId:12,tocIndex:7},{value:"是否必须",paraId:12,tocIndex:7},{value:"：false",paraId:12,tocIndex:7},{value:"说明",paraId:12,tocIndex:7},{value:"：控制迭代过程中，节点移动的速度",paraId:12,tocIndex:7},{value:"类型",paraId:13,tocIndex:8},{value:"： Number",paraId:13,tocIndex:8},{value:"默认值",paraId:13,tocIndex:8},{value:"：0.1",paraId:13,tocIndex:8},{value:"是否必须",paraId:13,tocIndex:8},{value:"：false",paraId:13,tocIndex:8},{value:"说明",paraId:13,tocIndex:8},{value:"：迭代接近收敛时停止震荡的容忍度",paraId:13,tocIndex:8},{value:"类型",paraId:14,tocIndex:9},{value:"： 'normal' | 'linlog'",paraId:14,tocIndex:9},{value:"默认值",paraId:14,tocIndex:9},{value:"：'normal'",paraId:14,tocIndex:9},{value:"是否必须",paraId:14,tocIndex:9},{value:"：false",paraId:14,tocIndex:9},{value:"说明",paraId:14,tocIndex:9},{value:"：'linlog' 模式下，聚类将更加紧凑",paraId:14,tocIndex:9},{value:"类型",paraId:15,tocIndex:10},{value:"： boolean",paraId:15,tocIndex:10},{value:"默认值",paraId:15,tocIndex:10},{value:"：false",paraId:15,tocIndex:10},{value:"是否必须",paraId:15,tocIndex:10},{value:"：false",paraId:15,tocIndex:10},{value:"说明",paraId:15,tocIndex:10},{value:"：是否防止节点重叠",paraId:15,tocIndex:10},{value:"类型",paraId:16,tocIndex:11},{value:"： boolean",paraId:16,tocIndex:11},{value:"默认值",paraId:16,tocIndex:11},{value:"：false",paraId:16,tocIndex:11},{value:"是否必须",paraId:16,tocIndex:11},{value:"：false",paraId:16,tocIndex:11},{value:"说明",paraId:16,tocIndex:11},{value:"：是否打开 hub 模式。若为 true，相比与出度大的节点，入度大的节点将会有更高的优先级被放置在中心位置",paraId:16,tocIndex:11},{value:"类型",paraId:17,tocIndex:12},{value:"： boolean",paraId:17,tocIndex:12},{value:"默认值",paraId:17,tocIndex:12},{value:"：undefined",paraId:17,tocIndex:12},{value:"是否必须",paraId:17,tocIndex:12},{value:"：false",paraId:17,tocIndex:12},{value:"说明",paraId:17,tocIndex:12},{value:"：是否打开 barnes hut 加速，即四叉树加速。由于每次迭代需要更新构建四叉树，建议在较大规模图上打开。默认情况下为 undefined，当节点数量大于 250 时它将会被激活。设置为 false 则不会自动被激活",paraId:17,tocIndex:12},{value:"类型",paraId:18,tocIndex:13},{value:"： boolean",paraId:18,tocIndex:13},{value:"默认值",paraId:18,tocIndex:13},{value:"：undefined",paraId:18,tocIndex:13},{value:"是否必须",paraId:18,tocIndex:13},{value:"：false",paraId:18,tocIndex:13},{value:"说明",paraId:18,tocIndex:13},{value:"：是否开启自动剪枝模式。默认情况下为 undefined，当节点数量大于 100 时它将会被激活。注意，剪枝能够提高收敛速度，但可能会降低图的布局质量。设置为 false 则不会自动被激活",paraId:18,tocIndex:13},{value:"类型",paraId:19,tocIndex:14},{value:"： number",paraId:19,tocIndex:14},{value:"默认值",paraId:19,tocIndex:14},{value:"：0",paraId:19,tocIndex:14},{value:"是否必须",paraId:19,tocIndex:14},{value:"：false",paraId:19,tocIndex:14},{value:"说明",paraId:19,tocIndex:14},{value:"：最大迭代次数，若为 0 则将自动调整",paraId:19,tocIndex:14},{value:"类型",paraId:20,tocIndex:15},{value:"： function",paraId:20,tocIndex:15},{value:"默认值",paraId:20,tocIndex:15},{value:"：undefined",paraId:20,tocIndex:15},{value:"是否必须",paraId:20,tocIndex:15},{value:"：false",paraId:20,tocIndex:15},{value:"说明",paraId:20,tocIndex:15},{value:"：节点宽度的函数，参数为节点数据",paraId:20,tocIndex:15},{value:"类型",paraId:21,tocIndex:16},{value:"： function",paraId:21,tocIndex:16},{value:"默认值",paraId:21,tocIndex:16},{value:"：undefined",paraId:21,tocIndex:16},{value:"是否必须",paraId:21,tocIndex:16},{value:"：false",paraId:21,tocIndex:16},{value:"说明",paraId:21,tocIndex:16},{value:"：节点高度的函数，参数为节点数据",paraId:21,tocIndex:16},{value:"类型",paraId:22,tocIndex:17},{value:"： function",paraId:22,tocIndex:17},{value:"默认值",paraId:22,tocIndex:17},{value:"：undefined",paraId:22,tocIndex:17},{value:"是否必须",paraId:22,tocIndex:17},{value:"：false",paraId:22,tocIndex:17},{value:"说明",paraId:22,tocIndex:17},{value:"：布局结束后的回调函数",paraId:22,tocIndex:17},{value:"类型",paraId:23,tocIndex:18},{value:"： function",paraId:23,tocIndex:18},{value:"默认值",paraId:23,tocIndex:18},{value:"：undefined",paraId:23,tocIndex:18},{value:"是否必须",paraId:23,tocIndex:18},{value:"：false",paraId:23,tocIndex:18},{value:"说明",paraId:23,tocIndex:18},{value:"：布局每次迭代的回调函数",paraId:23,tocIndex:18}]},23245:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Fruchterman 布局是一种力导布局。算法原文： ",paraId:0},{value:"Graph Drawing by Force-directed Placement",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'fruchterman',\n    center: [200, 200], // 可选，默认为图的中心\n    gravity: 20, // 可选\n    speed: 2, // 可选\n    clustering: true, // 可选\n    clusterGravity: 30, // 可选\n    maxIteration: 2000, // 可选，迭代次数\n    workerEnabled: true, // 可选，开启 web-worker\n    gpuEnabled: true, // 可选，开启 GPU 并行计算，G6 4.0 支持\n  },\n});\n",paraId:1},{value:"当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:2},{value:"fx",paraId:2},{value:" 与 ",paraId:2},{value:"fy",paraId:2},{value:" 作为固定的坐标。",paraId:2},{value:"Fruchterman 布局固定被拖拽节点位置的 Demo",paraId:3},{value:"。",paraId:2},{value:"类型",paraId:4,tocIndex:0},{value:"： Array",paraId:4,tocIndex:0},{value:"示例",paraId:4,tocIndex:0},{value:"：[ 0, 0 ]",paraId:4,tocIndex:0},{value:"默认值",paraId:4,tocIndex:0},{value:"：图的中心",paraId:4,tocIndex:0},{value:"是否必须",paraId:4,tocIndex:0},{value:"：false",paraId:4,tocIndex:0},{value:"说明",paraId:4,tocIndex:0},{value:"：布局的中心",paraId:4,tocIndex:0},{value:"自 G6 v4.7.0 起支持。",paraId:5,tocIndex:1},{value:"类型",paraId:6,tocIndex:1},{value:":",paraId:6,tocIndex:1},{value:"{\n  type: string; // 布局名称，可以是 random、concentric、grid、circular、radial、dagre 等静态布局\n  [key: string]: unkown; // 对应布局的配置项\n}\n",paraId:7,tocIndex:1},{value:"默认值",paraId:8,tocIndex:1},{value:": undefined",paraId:8,tocIndex:1},{value:"是否必须",paraId:8,tocIndex:1},{value:": false",paraId:8,tocIndex:1},{value:"说明",paraId:8,tocIndex:1},{value:": 力导向布局的初始化布局，将先执行 preset 指定的布局，再进行力导向计算。由于力导向布局的结果非常依赖节点的初始位置，配置 preset 的可以给力导向布局一个好的初始化，让力导向算法更快收敛、效果更好。默认情况下，力导向的初始化为格子布局（grid）的结果",paraId:8,tocIndex:1},{value:"类型",paraId:9,tocIndex:2},{value:"： Number",paraId:9,tocIndex:2},{value:"默认值",paraId:9,tocIndex:2},{value:"：1000",paraId:9,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"：false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:"：最大迭代次数",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"： Number",paraId:10,tocIndex:3},{value:"默认值",paraId:10,tocIndex:3},{value:"：10",paraId:10,tocIndex:3},{value:"是否必须",paraId:10,tocIndex:3},{value:"：false",paraId:10,tocIndex:3},{value:"说明",paraId:10,tocIndex:3},{value:"：重力的大小，影响布局的紧凑程度",paraId:10,tocIndex:3},{value:"类型",paraId:11,tocIndex:4},{value:"： Number",paraId:11,tocIndex:4},{value:"默认值",paraId:11,tocIndex:4},{value:"：1",paraId:11,tocIndex:4},{value:"是否必须",paraId:11,tocIndex:4},{value:"：false",paraId:11,tocIndex:4},{value:"说明",paraId:11,tocIndex:4},{value:"：每次迭代节点移动的速度。速度太快可能会导致强烈震荡",paraId:11,tocIndex:4},{value:"类型",paraId:12,tocIndex:5},{value:"： Boolean",paraId:12,tocIndex:5},{value:"默认值",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"是否必须",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"说明",paraId:12,tocIndex:5},{value:"：是否按照聚类布局",paraId:12,tocIndex:5},{value:"类型",paraId:13,tocIndex:6},{value:"： Number",paraId:13,tocIndex:6},{value:"默认值",paraId:13,tocIndex:6},{value:"：10",paraId:13,tocIndex:6},{value:"是否必须",paraId:13,tocIndex:6},{value:"：false",paraId:13,tocIndex:6},{value:"说明",paraId:13,tocIndex:6},{value:"：聚类内部的重力大小，影响聚类的紧凑程度，在 ",paraId:13,tocIndex:6},{value:"clustering",paraId:13,tocIndex:6},{value:" 为 ",paraId:13,tocIndex:6},{value:"true",paraId:13,tocIndex:6},{value:" 时生效",paraId:13,tocIndex:6},{value:"类型",paraId:14,tocIndex:7},{value:": Boolean",paraId:14,tocIndex:7},{value:"默认值",paraId:14,tocIndex:7},{value:": false",paraId:14,tocIndex:7},{value:"是否必须",paraId:14,tocIndex:7},{value:": false",paraId:14,tocIndex:7},{value:"说明",paraId:14,tocIndex:7},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:14,tocIndex:7},{value:"⚠️ 注意:",paraId:14,tocIndex:7},{value:" ",paraId:14,tocIndex:7},{value:"workerEnabled: true",paraId:14,tocIndex:7},{value:" 时，不支持所有函数类型的参数。",paraId:14,tocIndex:7},{value:"类型",paraId:15,tocIndex:8},{value:": Boolean",paraId:15,tocIndex:8},{value:"默认值",paraId:15,tocIndex:8},{value:": false",paraId:15,tocIndex:8},{value:"是否必须",paraId:15,tocIndex:8},{value:": false",paraId:15,tocIndex:8},{value:"说明",paraId:15,tocIndex:8},{value:": 是否启用 GPU 并行计算。若用户的机器或浏览器不支持 GPU 计算，将会自动降级为 CPU 计算。自 G6 4.0 起支持，性能提升概览： ",paraId:15,tocIndex:8}]},12910:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"GForce 实现了经典的力导向算法，G6 4.0 支持。能够更加自由地支持设置节点质量、群组中心力等。更重要的是，它支持 GPU 并行计算。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'gForce',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    linkDistance: 50,         // 可选，边长\n    nodeStrength: 30,         // 可选\n    edgeStrength: 0.1,        // 可选\n    nodeSize: 30,             // 可选\n    onTick: () => {           // 可选\n      console.log('ticking');\n    },\n    onLayoutEnd: () => {      // 可选\n      console.log('force layout done');\n    },\n    workerEnabled: true,      // 可选，开启 web-worker\n    gpuEnabled: true          // 可选，开启 GPU 并行计算，G6 4.0 支持\n    ... // 更多参数见下方\n  }\n});\n",paraId:1},{value:"当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:2},{value:"fx",paraId:2},{value:" 与 ",paraId:2},{value:"fy",paraId:2},{value:" 作为固定的坐标。",paraId:2},{value:"GForce 布局固定被拖拽节点位置的 Demo",paraId:3},{value:"。",paraId:2},{value:"类型",paraId:4,tocIndex:0},{value:"： Array",paraId:4,tocIndex:0},{value:"示例",paraId:4,tocIndex:0},{value:"：[ 0, 0 ]",paraId:4,tocIndex:0},{value:"默认值",paraId:4,tocIndex:0},{value:"：图的中心",paraId:4,tocIndex:0},{value:"是否必须",paraId:4,tocIndex:0},{value:"：false",paraId:4,tocIndex:0},{value:"说明",paraId:4,tocIndex:0},{value:"：布局的中心",paraId:4,tocIndex:0},{value:"自 G6 v4.7.0 起支持。",paraId:5,tocIndex:1},{value:"类型",paraId:6,tocIndex:1},{value:":",paraId:6,tocIndex:1},{value:"{\n  type: string; // 布局名称，可以是 random、concentric、grid、circular、radial、dagre 等静态布局\n  [key: string]: unkown; // 对应布局的配置项\n}\n",paraId:7,tocIndex:1},{value:"默认值",paraId:8,tocIndex:1},{value:": undefined",paraId:8,tocIndex:1},{value:"是否必须",paraId:8,tocIndex:1},{value:": false",paraId:8,tocIndex:1},{value:"说明",paraId:8,tocIndex:1},{value:": 力导向布局的初始化布局，将先执行 preset 指定的布局，再进行力导向计算。由于力导向布局的结果非常依赖节点的初始位置，配置 preset 的可以给力导向布局一个好的初始化，让力导向算法更快收敛、效果更好。默认情况下，力导向的初始化为格子布局（grid）的结果",paraId:8,tocIndex:1},{value:"类型",paraId:9,tocIndex:2},{value:"： Number / Function",paraId:9,tocIndex:2},{value:"默认值",paraId:9,tocIndex:2},{value:"1",paraId:9,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"：false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:"：边长度",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"： Number / Function",paraId:10,tocIndex:3},{value:"默认值",paraId:10,tocIndex:3},{value:"：1000",paraId:10,tocIndex:3},{value:"是否必须",paraId:10,tocIndex:3},{value:"：false",paraId:10,tocIndex:3},{value:"说明",paraId:10,tocIndex:3},{value:"：节点作用力，正数代表节点之间的斥力作用，负数代表节点之间的引力作用（注意与 'force' 相反）",paraId:10,tocIndex:3},{value:"类型",paraId:11,tocIndex:4},{value:"：Number / Function",paraId:11,tocIndex:4},{value:"默认值",paraId:11,tocIndex:4},{value:"：200",paraId:11,tocIndex:4},{value:"是否必须",paraId:11,tocIndex:4},{value:"：false",paraId:11,tocIndex:4},{value:"说明",paraId:11,tocIndex:4},{value:"：边的作用力（引力）大小",paraId:11,tocIndex:4},{value:"类型",paraId:12,tocIndex:5},{value:"：Boolean",paraId:12,tocIndex:5},{value:"默认值",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"是否必须",paraId:12,tocIndex:5},{value:"：false",paraId:12,tocIndex:5},{value:"说明",paraId:12,tocIndex:5},{value:"：是否防止重叠，必须配合下面属性 ",paraId:12,tocIndex:5},{value:"nodeSize",paraId:12,tocIndex:5},{value:" 或节点数据中的 ",paraId:12,tocIndex:5},{value:"size",paraId:12,tocIndex:5},{value:" 属性，只有在数据中设置了 ",paraId:12,tocIndex:5},{value:"size",paraId:12,tocIndex:5},{value:" 或在该布局中配置了与当前图节点大小相同的 ",paraId:12,tocIndex:5},{value:"nodeSize",paraId:12,tocIndex:5},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:12,tocIndex:5},{value:"类型",paraId:13,tocIndex:6},{value:"： Number",paraId:13,tocIndex:6},{value:"默认值",paraId:13,tocIndex:6},{value:"：10",paraId:13,tocIndex:6},{value:"是否必须",paraId:13,tocIndex:6},{value:"：false",paraId:13,tocIndex:6},{value:"说明",paraId:13,tocIndex:6},{value:"：节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:13,tocIndex:6},{value:"size",paraId:13,tocIndex:6},{value:"，则默认大小为 ",paraId:13,tocIndex:6},{value:"10",paraId:13,tocIndex:6},{value:"类型",paraId:14,tocIndex:7},{value:": Number / Function",paraId:14,tocIndex:7},{value:"默认值",paraId:14,tocIndex:7},{value:": 0",paraId:14,tocIndex:7},{value:"是否必须",paraId:14,tocIndex:7},{value:": false ",paraId:14,tocIndex:7},{value:"示例",paraId:14,tocIndex:7},{value:": Example 1: 10 ",paraId:14,tocIndex:7},{value:"Example 2:",paraId:14,tocIndex:7},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:15,tocIndex:7},{value:"描述",paraId:16,tocIndex:7},{value:": ",paraId:16,tocIndex:7},{value:"preventOverlap",paraId:16,tocIndex:7},{value:" 为 ",paraId:16,tocIndex:7},{value:"true",paraId:16,tocIndex:7},{value:" 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:16,tocIndex:7},{value:"类型",paraId:17,tocIndex:8},{value:"：Number",paraId:17,tocIndex:8},{value:"默认值",paraId:17,tocIndex:8},{value:"：0.5",paraId:17,tocIndex:8},{value:"是否必须",paraId:17,tocIndex:8},{value:"：false",paraId:17,tocIndex:8},{value:"说明",paraId:17,tocIndex:8},{value:"：当一次迭代的平均移动长度小于该值时停止迭代。数字越小，布局越收敛，所用时间将越长",paraId:17,tocIndex:8},{value:"类型",paraId:18,tocIndex:9},{value:"：Number",paraId:18,tocIndex:9},{value:"默认值",paraId:18,tocIndex:9},{value:"：1000",paraId:18,tocIndex:9},{value:"是否必须",paraId:18,tocIndex:9},{value:"：false",paraId:18,tocIndex:9},{value:"说明",paraId:18,tocIndex:9},{value:"：最大迭代次数。当迭代次数超过该值，但平均移动长度仍然没有达到 minMovement，也将强制停止迭代",paraId:18,tocIndex:9},{value:"类型",paraId:19,tocIndex:10},{value:"：Number",paraId:19,tocIndex:10},{value:"默认值",paraId:19,tocIndex:10},{value:"：0.9",paraId:19,tocIndex:10},{value:"是否必须",paraId:19,tocIndex:10},{value:"：false",paraId:19,tocIndex:10},{value:"说明",paraId:19,tocIndex:10},{value:"：阻尼系数，取值范围 [0, 1]。数字越大，速度降低得越慢",paraId:19,tocIndex:10},{value:"类型",paraId:20,tocIndex:11},{value:"：Number",paraId:20,tocIndex:11},{value:"默认值",paraId:20,tocIndex:11},{value:"：1000",paraId:20,tocIndex:11},{value:"是否必须",paraId:20,tocIndex:11},{value:"：false",paraId:20,tocIndex:11},{value:"说明",paraId:20,tocIndex:11},{value:"：一次迭代的最大移动长度",paraId:20,tocIndex:11},{value:"类型",paraId:21,tocIndex:12},{value:"：Number",paraId:21,tocIndex:12},{value:"默认值",paraId:21,tocIndex:12},{value:"：0.005",paraId:21,tocIndex:12},{value:"是否必须",paraId:21,tocIndex:12},{value:"：false",paraId:21,tocIndex:12},{value:"说明",paraId:21,tocIndex:12},{value:"：库伦系数，斥力的一个系数，数字越大，节点之间的斥力越大",paraId:21,tocIndex:12},{value:"类型",paraId:22,tocIndex:13},{value:"：Function",paraId:22,tocIndex:13},{value:"默认值",paraId:22,tocIndex:13},{value:"：undefined",paraId:22,tocIndex:13},{value:"是否必须",paraId:22,tocIndex:13},{value:"：false",paraId:22,tocIndex:13},{value:"说明",paraId:22,tocIndex:13},{value:"：每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量。使用方法与 ",paraId:22,tocIndex:13},{value:"nodeSpacing",paraId:22,tocIndex:13},{value:" 类似，每个回调函数返回一个数值作为该节点的质量",paraId:22,tocIndex:13},{value:"类型",paraId:23,tocIndex:14},{value:"：Function",paraId:23,tocIndex:14},{value:"默认值",paraId:23,tocIndex:14},{value:"：undefined",paraId:23,tocIndex:14},{value:"是否必须",paraId:23,tocIndex:14},{value:"：false",paraId:23,tocIndex:14},{value:"说明",paraId:23,tocIndex:14},{value:"：每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力",paraId:23,tocIndex:14},{value:"示例",paraId:23,tocIndex:14},{value:":",paraId:23,tocIndex:14},{value:"(d, degree) => {\n  // d is a node, degree is the degree of the node\n  if (d.clusterId === 'c1') return [100, 100, 10]; // x, y, strength\n  if (degree === 0) return [250, 250, 15];\n  return [180, 180, 5]; // x, y, strength\n};\n",paraId:24,tocIndex:14},{value:"类型",paraId:25,tocIndex:15},{value:"：Number",paraId:25,tocIndex:15},{value:"默认值",paraId:25,tocIndex:15},{value:"：10",paraId:25,tocIndex:15},{value:"是否必须",paraId:25,tocIndex:15},{value:"：false",paraId:25,tocIndex:15},{value:"说明",paraId:25,tocIndex:15},{value:"：中心力大小，指所有节点被吸引到 ",paraId:25,tocIndex:15},{value:"center",paraId:25,tocIndex:15},{value:" 的力。数字越大，布局越紧凑",paraId:25,tocIndex:15},{value:"类型",paraId:26,tocIndex:16},{value:"：Function",paraId:26,tocIndex:16},{value:"默认值",paraId:26,tocIndex:16},{value:"：{}",paraId:26,tocIndex:16},{value:"是否必须",paraId:26,tocIndex:16},{value:"：false",paraId:26,tocIndex:16},{value:"说明",paraId:26,tocIndex:16},{value:"：每一次迭代的回调函数",paraId:26,tocIndex:16},{value:"类型",paraId:27,tocIndex:17},{value:"：Function",paraId:27,tocIndex:17},{value:"默认值",paraId:27,tocIndex:17},{value:"：{}",paraId:27,tocIndex:17},{value:"是否必须",paraId:27,tocIndex:17},{value:"：false",paraId:27,tocIndex:17},{value:"说明",paraId:27,tocIndex:17},{value:"：布局完成后的回调函数",paraId:27,tocIndex:17},{value:"类型",paraId:28,tocIndex:18},{value:": Boolean",paraId:28,tocIndex:18},{value:"默认值",paraId:28,tocIndex:18},{value:": false",paraId:28,tocIndex:18},{value:"是否必须",paraId:28,tocIndex:18},{value:": false",paraId:28,tocIndex:18},{value:"说明",paraId:28,tocIndex:18},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:28,tocIndex:18},{value:"⚠️ 注意:",paraId:28,tocIndex:18},{value:" ",paraId:28,tocIndex:18},{value:"workerEnabled: true",paraId:28,tocIndex:18},{value:" 时，不支持所有函数类型的参数。",paraId:28,tocIndex:18},{value:"类型",paraId:29,tocIndex:19},{value:": Boolean",paraId:29,tocIndex:19},{value:"默认值",paraId:29,tocIndex:19},{value:": false",paraId:29,tocIndex:19},{value:"是否必须",paraId:29,tocIndex:19},{value:": false",paraId:29,tocIndex:19},{value:"说明",paraId:29,tocIndex:19},{value:": 是否启用 GPU 并行计算。若用户的机器或浏览器不支持 GPU 计算，将会自动降级为 CPU 计算。自 G6 4.0 起支持，性能提升概览： ",paraId:29,tocIndex:19}]},87261:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Grid 布局是将所有节点通过某种指定属性排序后，整齐地放置在网格上。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'grid',\n    begin: [ 0, 0 ],          // 可选，\n    preventOverlap: true,     // 可选，必须配合 nodeSize\n    preventOverlapPdding: 20, // 可选\n    nodeSize: 30,             // 可选\n    condense: false,          // 可选\n    rows: 5,                  // 可选\n    cols: 5,                  // 可选\n    sortBy: 'degree'          // 可选\n    workerEnabled: true       // 可选，开启 web-worker\n  }\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：网格开始位置（左上角）",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"：Boolean",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：是否防止重叠，必须配合下面属性 ",paraId:3,tocIndex:1},{value:"nodeSize",paraId:3,tocIndex:1},{value:"，只有设置了与当前图节点大小相同的 ",paraId:3,tocIndex:1},{value:"nodeSize",paraId:3,tocIndex:1},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：30",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：节点大小（直径）。用于防止节点重叠时的碰撞检测",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:"：Number",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:"：10",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:"：false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:"：避免重叠时节点的间距 ",paraId:5,tocIndex:3},{value:"padding",paraId:5,tocIndex:3},{value:"。",paraId:5,tocIndex:3},{value:"preventOverlap",paraId:5,tocIndex:3},{value:" 为 ",paraId:5,tocIndex:3},{value:"true",paraId:5,tocIndex:3},{value:" 时生效",paraId:5,tocIndex:3},{value:"类型",paraId:6,tocIndex:4},{value:"： Boolean",paraId:6,tocIndex:4},{value:"默认值",paraId:6,tocIndex:4},{value:"：false",paraId:6,tocIndex:4},{value:"是否必须",paraId:6,tocIndex:4},{value:"：false",paraId:6,tocIndex:4},{value:"说明",paraId:6,tocIndex:4},{value:"：为 ",paraId:6,tocIndex:4},{value:"false",paraId:6,tocIndex:4},{value:" 时表示利用所有可用画布空间，为 ",paraId:6,tocIndex:4},{value:"true",paraId:6,tocIndex:4},{value:" 时表示利用最小的画布空间",paraId:6,tocIndex:4},{value:"类型",paraId:7,tocIndex:5},{value:"： Number",paraId:7,tocIndex:5},{value:"默认值",paraId:7,tocIndex:5},{value:"：undefined",paraId:7,tocIndex:5},{value:"是否必须",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"说明",paraId:7,tocIndex:5},{value:"：网格的行数，为 undefined 时算法根据节点数量、布局空间、",paraId:7,tocIndex:5},{value:"cols",paraId:7,tocIndex:5},{value:"（若指定）自动计算",paraId:7,tocIndex:5},{value:"类型",paraId:8,tocIndex:6},{value:"： Number",paraId:8,tocIndex:6},{value:"默认值",paraId:8,tocIndex:6},{value:"：undefined",paraId:8,tocIndex:6},{value:"是否必须",paraId:8,tocIndex:6},{value:"：false",paraId:8,tocIndex:6},{value:"说明",paraId:8,tocIndex:6},{value:"：网格的列数，为 undefined 时算法根据节点数量、布局空间、",paraId:8,tocIndex:6},{value:"rows",paraId:8,tocIndex:6},{value:"（若指定）自动计算",paraId:8,tocIndex:6},{value:"类型",paraId:9,tocIndex:7},{value:"： String",paraId:9,tocIndex:7},{value:"默认值",paraId:9,tocIndex:7},{value:"：undefined",paraId:9,tocIndex:7},{value:"是否必须",paraId:9,tocIndex:7},{value:"：false",paraId:9,tocIndex:7},{value:"说明",paraId:9,tocIndex:7},{value:"：指定排序的依据（节点属性名），数值越高则该节点被放置得越中心。若为 undefined，则会计算节点的度数，度数越高，节点将被放置得越中心",paraId:9,tocIndex:7},{value:"类型",paraId:10,tocIndex:8},{value:": Boolean",paraId:10,tocIndex:8},{value:"默认值",paraId:10,tocIndex:8},{value:": false",paraId:10,tocIndex:8},{value:"是否必须",paraId:10,tocIndex:8},{value:": false",paraId:10,tocIndex:8},{value:"说明",paraId:10,tocIndex:8},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:10,tocIndex:8},{value:"⚠️ 注意:",paraId:10,tocIndex:8},{value:" ",paraId:10,tocIndex:8},{value:"workerEnabled: true",paraId:10,tocIndex:8},{value:" 时，不支持所有函数类型的参数。",paraId:10,tocIndex:8}]},69779:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了以下内置布局算法。可以在",paraId:0,tocIndex:0},{value:"实例化图时配置",paraId:1,tocIndex:0},{value:"，或",paraId:0,tocIndex:0},{value:"独立使用",paraId:2,tocIndex:0},{value:"。当内置布局算法不满足需求时，还可以",paraId:0,tocIndex:0},{value:"自定义布局",paraId:3,tocIndex:0},{value:"。",paraId:0,tocIndex:0},{value:"注意，Graph 布局与 TreeGaph 布局相互不通用。",paraId:4,tocIndex:0},{value:"Random Layout",paraId:5,tocIndex:0},{value:"：随机布局；",paraId:6,tocIndex:0},{value:"GForce Layout",paraId:7,tocIndex:0},{value:"：G6 4.0 支持的经典力导向布局，支持 GPU 并行计算：",paraId:8,tocIndex:0},{value:"力导向布局：一个布局网络中，粒子与粒子之间具有引力和斥力，从初始的随机无序的布局不断演变，逐渐趋于平衡稳定的布局方式称之为力导向布局。适用于描述事物间关系，比如人物关系、计算机网络关系等。",paraId:9,tocIndex:0},{value:"Force Layout",paraId:10,tocIndex:0},{value:"：引用 d3 的经典力导向布局；",paraId:11,tocIndex:0},{value:"Force Atlas 2 Layout",paraId:12,tocIndex:0},{value:"：FA2 力导向布局，比 force 收敛地更好，更紧凑；",paraId:13,tocIndex:0},{value:"Circular Layout",paraId:14,tocIndex:0},{value:"：环形布局；",paraId:15,tocIndex:0},{value:"Radial Layout",paraId:16,tocIndex:0},{value:"：辐射状布局；",paraId:17,tocIndex:0},{value:"MDS Layout",paraId:18,tocIndex:0},{value:"：高维数据降维算法布局；",paraId:19,tocIndex:0},{value:"Fruchterman Layout",paraId:20,tocIndex:0},{value:"：Fruchterman 布局，一种力导布局；",paraId:21,tocIndex:0},{value:"Dagre Layout",paraId:22,tocIndex:0},{value:"：层次布局；",paraId:23,tocIndex:0},{value:"Concentric Layout",paraId:24,tocIndex:0},{value:"：同心圆布局，将重要（默认以度数为度量）的节点放置在布局中心；",paraId:25,tocIndex:0},{value:"Grid Layout",paraId:26,tocIndex:0},{value:"：格子布局，将节点有序（默认是数据顺序）排列在格子上；",paraId:27,tocIndex:0},{value:"Combo Force Layout",paraId:28,tocIndex:0},{value:"：*V3.5 新增。*适用于带有 combo 图的力导向布局。",paraId:29,tocIndex:0},{value:"Combo Combined Layout",paraId:30,tocIndex:0},{value:"：*V4.6 新增。*适用于带有 combo 的图，可自由组合内外布局，默认情况下可以有较好的效果，推荐有 combo 的图使用该布局。",paraId:31,tocIndex:0},{value:"在 G6 中使用布局，在实例化图时配置 ",paraId:32,tocIndex:1},{value:"layout",paraId:32,tocIndex:1},{value:" 属性。例如：",paraId:32,tocIndex:1},{value:"const graph = new G6.Graph({\n  // ...                      // 其他配置项\n  layout: {                // Object，可选，布局的方法及其配置项，默认为 random 布局。\n    type: 'force',\n    preventOverlap: true,\n    nodeSize: 30,\n    // workerEnabled: true, // 是否启用 webworker\n    // gpuEnabled: true // 是否使用 gpu 版本的布局算法，G6 4.0 支持，目前仅支持 gForce 及 fruchterman。若用户的机器或浏览器不支持 GPU 计算，将会自动降级为 CPU 计算\n    ...                    // 其他配置\n  }\n});\n",paraId:33,tocIndex:1},{value:"每种布局方法的配置项不尽相同，具体参见本目录下每种布局的 API。",paraId:34,tocIndex:1},{value:"当实例化图时没有配置 ",paraId:34,tocIndex:1},{value:"layout",paraId:34,tocIndex:1},{value:" 时：",paraId:34,tocIndex:1},{value:"若数据中节点有位置信息（",paraId:35,tocIndex:1},{value:"x",paraId:35,tocIndex:1},{value:" 和 ",paraId:35,tocIndex:1},{value:"y",paraId:35,tocIndex:1},{value:"），则按照数据的位置信息进行绘制；",paraId:35,tocIndex:1},{value:"若数据中节点没有位置信息，则默认使用 Random Layout 进行布局。",paraId:35,tocIndex:1},{value:"如果开启了 webworker，worker 使用的是 @antv/layout 线上的脚本，如果你的项目无法访问到线上资源，请保存 ",paraId:36,tocIndex:1},{value:"layout 脚本",paraId:36,tocIndex:1},{value:"，并放在可以访问到的地址上，将 layout 的 ",paraId:36,tocIndex:1},{value:"workerScriptURL",paraId:36,tocIndex:1},{value:" 配置为该地址即可。",paraId:36,tocIndex:1},{value:"以下方法为通过 ",paraId:37,tocIndex:2},{value:"const layout = new G6.Layout['layoutName']",paraId:37,tocIndex:2},{value:" 单独使用布局时，或自定义布局时可能需要复写的方法。如果上述两种情况，仅在实例化图时通过配置 ",paraId:37,tocIndex:2},{value:"layout",paraId:37,tocIndex:2},{value:" 使用内置布局方法时，以下方法由 G6 控制并调用，用户不需要了解。",paraId:37,tocIndex:2},{value:"初始化布局。",paraId:38,tocIndex:4},{value:"参数",paraId:39,tocIndex:4},{value:"名称",paraId:40,tocIndex:4},{value:"类型",paraId:40,tocIndex:4},{value:"是否必选",paraId:40,tocIndex:4},{value:"描述",paraId:40,tocIndex:4},{value:"data",paraId:40,tocIndex:4},{value:"object",paraId:40,tocIndex:4},{value:"true",paraId:40,tocIndex:4},{value:"布局中使用的数据",paraId:40,tocIndex:4},{value:"返回布局的默认参数。",paraId:41,tocIndex:5},{value:"返回值",paraId:42,tocIndex:5},{value:"名称",paraId:43,tocIndex:5},{value:"类型",paraId:43,tocIndex:5},{value:"是否必选",paraId:43,tocIndex:5},{value:"描述",paraId:43,tocIndex:5},{value:"cfg",paraId:43,tocIndex:5},{value:"object",paraId:43,tocIndex:5},{value:"true",paraId:43,tocIndex:5},{value:"布局的默认参数",paraId:43,tocIndex:5},{value:"执行布局算法。",paraId:44,tocIndex:7},{value:"根据传入的数据进行布局。",paraId:45,tocIndex:8},{value:"参数",paraId:46,tocIndex:8},{value:"名称",paraId:47,tocIndex:8},{value:"类型",paraId:47,tocIndex:8},{value:"是否必选",paraId:47,tocIndex:8},{value:"描述",paraId:47,tocIndex:8},{value:"data",paraId:47,tocIndex:8},{value:"object",paraId:47,tocIndex:8},{value:"true",paraId:47,tocIndex:8},{value:"布局中使用的数据",paraId:47,tocIndex:8},{value:"更新布局参数。",paraId:48,tocIndex:10},{value:"参数",paraId:49,tocIndex:10},{value:"名称",paraId:50,tocIndex:10},{value:"类型",paraId:50,tocIndex:10},{value:"是否必选",paraId:50,tocIndex:10},{value:"描述",paraId:50,tocIndex:10},{value:"cfg",paraId:50,tocIndex:10},{value:"object",paraId:50,tocIndex:10},{value:"true",paraId:50,tocIndex:10},{value:"新的布局配置",paraId:50,tocIndex:10},{value:"销毁布局。",paraId:51,tocIndex:12},{value:"图可视分析应用中，如何选择合适的布局让每次查询的数据都能够很清晰地展示是一个不小的挑战，虽然我们可以像 Gephi 一样，把布局的配置切换交给用户来做，让用户自己切换布局、调整参数来选择合适的布局，但这样的效率显然太低。为了彻底解决布局选择的问题，G6 提供了智能布局预测的能力，预测引擎会根据查询到的数据，推荐最适合的布局，用户直接使用推荐的布局即可。",paraId:52,tocIndex:14},{value:"智能布局是指在结合神经网络进行建模，通过大量的标注数据（标记布局分类）进行训练输出预测模型，业务场景中针对通过模型对真实的图数据进行预测，从而推荐出该数据最适合的布局分类的方法。",paraId:53,tocIndex:15},{value:"@antv/vis-predict-engine 定位为可视化预测引擎，短期内主要用于图布局的分类预测。常久来看，可视化预测引擎会支持布局配置参数预测、节点类别预测、chart 类别预测等。",paraId:54,tocIndex:16},{value:"G6 中图布局预测的整体流程如下图所示。",paraId:55,tocIndex:16},{value:"AntV 团队将图布局预测的能力封装成 NPM 包 @antv/vis-predict-engine，通过 predict 方法来预测提供的数据应该使用什么布局，基本用法如下。",paraId:56,tocIndex:17},{value:"import G6 from '@antv/g6'\nimport { GraphLayoutPredict } from '@antv/vis-predict-engine'\nconst data = {\n    nodes: [],\n  edges: []\n}\n// predictLayout 表示预测的布局，如 force 或 radial\n// confidence 表示预测的可信度\nconst { predictLayout, confidence } = await GraphLayoutPredict.predict(data);\nconst graph = new G6.Graph({\n  // 省略其他配置\n    layout: {\n    type: predictLayout\n  }\n})\n",paraId:57,tocIndex:17},{value:'如下图所示，在一份医疗健康图谱中，通过智能布局预测引擎得出 "Force" 的布局效果最佳，通过对比实验，也符合预期。',paraId:58,tocIndex:18},{value:"具体 Demo 参考这里：",paraId:59,tocIndex:19},{value:"AI 智能布局推荐 DEMO",paraId:60,tocIndex:19}]},77003:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"MDS 布局是高维数据降维算法布局，该算法全称  Multidimensional Scaling 。",paraId:0},{value:" ",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'mds',\n    workerEnabled: true, // 可选，开启 web-worker\n  },\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：50",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：边长度",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:": Boolean",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:": false",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:": false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:4,tocIndex:2},{value:"⚠️ 注意:",paraId:4,tocIndex:2},{value:" ",paraId:4,tocIndex:2},{value:"workerEnabled: true",paraId:4,tocIndex:2},{value:" 时，不支持所有函数类型的参数。",paraId:4,tocIndex:2}]},64451:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Radial 布局是将图布局成辐射状的布局方法。以一个 focusNode 为中心，其余节点按照与 focusNode 的度数关系排列在不同距离的环上。距离 focusNode 一度的节点布局在与其最近的第一个环上，距离 focusNode 二度的节点布局在第二个环上，以此类推。算法原文链接： ",paraId:0},{value:"More Flexible Radial Layout",paraId:0},{value:"。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'radial',\n    center: [ 200, 200 ],     // 可选，默认为图的中心\n    linkDistance: 50,         // 可选，边长\n    maxIteration: 1000,       // 可选\n    focusNode: 'node11',      // 可选\n    unitRadius: 100,          // 可选\n    preventOverlap: true,     // 可选，必须配合 nodeSize\n    nodeSize: 30,             // 可选\n    strictRadial: false       // 可选\n    workerEnabled: true       // 可选，开启 web-worker\n  }\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：50",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：边长度",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：1000",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：停止迭代到最大迭代数",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:"：String | Object",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:"：null",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:"：false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:"：辐射的中心点，默认为数据中第一个节点。可以传入节点 id 或节点本身",paraId:5,tocIndex:3},{value:"类型",paraId:6,tocIndex:4},{value:"：Number",paraId:6,tocIndex:4},{value:"默认值",paraId:6,tocIndex:4},{value:"：100",paraId:6,tocIndex:4},{value:"是否必须",paraId:6,tocIndex:4},{value:"：false",paraId:6,tocIndex:4},{value:"说明",paraId:6,tocIndex:4},{value:"：每一圈距离上一圈的距离。默认填充整个画布，即根据图的大小决定",paraId:6,tocIndex:4},{value:"类型",paraId:7,tocIndex:5},{value:"：Boolean",paraId:7,tocIndex:5},{value:"默认值",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"是否必须",paraId:7,tocIndex:5},{value:"：false",paraId:7,tocIndex:5},{value:"说明",paraId:7,tocIndex:5},{value:"：是否防止重叠，必须配合下面属性 ",paraId:7,tocIndex:5},{value:"nodeSize",paraId:7,tocIndex:5},{value:"，只有设置了与当前图节点大小相同的 ",paraId:7,tocIndex:5},{value:"nodeSize",paraId:7,tocIndex:5},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:7,tocIndex:5},{value:"类型",paraId:8,tocIndex:6},{value:"： Number",paraId:8,tocIndex:6},{value:"默认值",paraId:8,tocIndex:6},{value:"：10",paraId:8,tocIndex:6},{value:"是否必须",paraId:8,tocIndex:6},{value:"：false",paraId:8,tocIndex:6},{value:"说明",paraId:8,tocIndex:6},{value:"：节点大小（直径）。用于防止节点重叠时的碰撞检测",paraId:8,tocIndex:6},{value:"类型",paraId:9,tocIndex:7},{value:": Number / Function",paraId:9,tocIndex:7},{value:"默认值",paraId:9,tocIndex:7},{value:": 0",paraId:9,tocIndex:7},{value:"是否必须",paraId:9,tocIndex:7},{value:": false ",paraId:9,tocIndex:7},{value:"示例",paraId:9,tocIndex:7},{value:": Example 1: 10 ",paraId:9,tocIndex:7},{value:"Example 2:",paraId:9,tocIndex:7},{value:"(d) => {\n  // d is a node\n  if (d.id === 'node1') {\n    return 100;\n  }\n  return 10;\n};\n",paraId:10,tocIndex:7},{value:"描述",paraId:11,tocIndex:7},{value:": ",paraId:11,tocIndex:7},{value:"preventOverlap",paraId:11,tocIndex:7},{value:" 为 ",paraId:11,tocIndex:7},{value:"true",paraId:11,tocIndex:7},{value:" 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:11,tocIndex:7},{value:"类型",paraId:12,tocIndex:8},{value:"： Number",paraId:12,tocIndex:8},{value:"默认值",paraId:12,tocIndex:8},{value:"：200",paraId:12,tocIndex:8},{value:"是否必须",paraId:12,tocIndex:8},{value:"：false",paraId:12,tocIndex:8},{value:"说明",paraId:12,tocIndex:8},{value:"：防止重叠步骤的最大迭代次数",paraId:12,tocIndex:8},{value:"类型",paraId:13,tocIndex:9},{value:"： Boolean",paraId:13,tocIndex:9},{value:"默认值",paraId:13,tocIndex:9},{value:"：true",paraId:13,tocIndex:9},{value:"是否必须",paraId:13,tocIndex:9},{value:"：false",paraId:13,tocIndex:9},{value:"说明",paraId:13,tocIndex:9},{value:"：是否必须是严格的 radial 布局，及每一层的节点严格布局在一个环上。",paraId:13,tocIndex:9},{value:"preventOverlap",paraId:13,tocIndex:9},{value:" 为 ",paraId:13,tocIndex:9},{value:"true",paraId:13,tocIndex:9},{value:" 时生效。",paraId:13,tocIndex:9},{value:"当 ",paraId:14,tocIndex:9},{value:"preventOverlap",paraId:14,tocIndex:9},{value:" 为 ",paraId:14,tocIndex:9},{value:"true",paraId:14,tocIndex:9},{value:"，且 ",paraId:14,tocIndex:9},{value:"strictRadial",paraId:14,tocIndex:9},{value:" 为 ",paraId:14,tocIndex:9},{value:"false",paraId:14,tocIndex:9},{value:" 时，有重叠的节点严格沿着所在的环展开，但在一个环上若节点过多，可能无法完全避免节点重叠。",paraId:14,tocIndex:9},{value:"当 ",paraId:14,tocIndex:9},{value:"preventOverlap",paraId:14,tocIndex:9},{value:" 为 ",paraId:14,tocIndex:9},{value:"true",paraId:14,tocIndex:9},{value:"，且 ",paraId:14,tocIndex:9},{value:"strictRadial",paraId:14,tocIndex:9},{value:" 为 ",paraId:14,tocIndex:9},{value:"true",paraId:14,tocIndex:9},{value:"  时，允许同环上重叠的节点不严格沿着该环布局，可以在该环的前后偏移以避免重叠。",paraId:14,tocIndex:9},{value:"（左）preventOverlap = false。（中）preventOverlap = false，strictRadial = true。（右）preventOverlap = false，strictRadial = false。",paraId:15,tocIndex:9},{value:"类型",paraId:16,tocIndex:10},{value:": String",paraId:16,tocIndex:10},{value:"默认值",paraId:16,tocIndex:10},{value:": undefined",paraId:16,tocIndex:10},{value:"是否必须",paraId:16,tocIndex:10},{value:": false",paraId:16,tocIndex:10},{value:"说明",paraId:16,tocIndex:10},{value:": 同层节点布局后相距远近的依据。默认 ",paraId:16,tocIndex:10},{value:"undefined",paraId:16,tocIndex:10},{value:" ，表示根据数据的拓扑结构（节点间最短路径）排布，即关系越近/点对间最短路径越小的节点将会被尽可能排列在一起；",paraId:16,tocIndex:10},{value:"'data'",paraId:16,tocIndex:10},{value:" 表示按照节点在数据中的顺序排列，即在数据顺序上靠近的节点将会尽可能排列在一起；也可以指定为节点数据中的某个字段名，例如 ",paraId:16,tocIndex:10},{value:"'cluster'",paraId:16,tocIndex:10},{value:"、",paraId:16,tocIndex:10},{value:"'name'",paraId:16,tocIndex:10},{value:" 等（必须在数据中存在）",paraId:16,tocIndex:10},{value:"类型",paraId:17,tocIndex:11},{value:": Number",paraId:17,tocIndex:11},{value:"默认值",paraId:17,tocIndex:11},{value:": 10",paraId:17,tocIndex:11},{value:"是否必须",paraId:17,tocIndex:11},{value:": false",paraId:17,tocIndex:11},{value:"说明",paraId:17,tocIndex:11},{value:": 同层节点根据 ",paraId:17,tocIndex:11},{value:"sortBy",paraId:17,tocIndex:11},{value:" 排列的强度，数值越大，",paraId:17,tocIndex:11},{value:"sortBy",paraId:17,tocIndex:11},{value:" 指定的方式计算出距离越小的越靠近。",paraId:17,tocIndex:11},{value:"sortBy",paraId:17,tocIndex:11},{value:" 不为 ",paraId:17,tocIndex:11},{value:"undefined",paraId:17,tocIndex:11},{value:" 时生效",paraId:17,tocIndex:11},{value:"类型",paraId:18,tocIndex:12},{value:": Boolean",paraId:18,tocIndex:12},{value:"默认值",paraId:18,tocIndex:12},{value:": false",paraId:18,tocIndex:12},{value:"是否必须",paraId:18,tocIndex:12},{value:": false",paraId:18,tocIndex:12},{value:"说明",paraId:18,tocIndex:12},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:18,tocIndex:12},{value:"⚠️ 注意:",paraId:18,tocIndex:12},{value:" ",paraId:18,tocIndex:12},{value:"workerEnabled: true",paraId:18,tocIndex:12},{value:" 时，不支持所有函数类型的参数。",paraId:18,tocIndex:12}]},52922:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Random 布局是 G6 中的默认布局方法。当实例化图时没有指定布局方法，且数据中也不存在位置信息时，G6 将自动使用 Random 布局。",paraId:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 600,\n  layout: {\n    type: 'random',\n    width: 300,\n    height: 300,\n  },\n});\n",paraId:1},{value:"类型",paraId:2,tocIndex:0},{value:"： Array",paraId:2,tocIndex:0},{value:"示例",paraId:2,tocIndex:0},{value:"：[ 0, 0 ]",paraId:2,tocIndex:0},{value:"默认值",paraId:2,tocIndex:0},{value:"：图的中心",paraId:2,tocIndex:0},{value:"是否必须",paraId:2,tocIndex:0},{value:"：false",paraId:2,tocIndex:0},{value:"说明",paraId:2,tocIndex:0},{value:"：布局的中心",paraId:2,tocIndex:0},{value:"类型",paraId:3,tocIndex:1},{value:"： Number",paraId:3,tocIndex:1},{value:"默认值",paraId:3,tocIndex:1},{value:"：图的宽度",paraId:3,tocIndex:1},{value:"是否必须",paraId:3,tocIndex:1},{value:"：false",paraId:3,tocIndex:1},{value:"说明",paraId:3,tocIndex:1},{value:"：布局的宽度范围",paraId:3,tocIndex:1},{value:"类型",paraId:4,tocIndex:2},{value:"： Number",paraId:4,tocIndex:2},{value:"默认值",paraId:4,tocIndex:2},{value:"：图的高度",paraId:4,tocIndex:2},{value:"是否必须",paraId:4,tocIndex:2},{value:"：false",paraId:4,tocIndex:2},{value:"说明",paraId:4,tocIndex:2},{value:"：布局的高度范围",paraId:4,tocIndex:2},{value:"类型",paraId:5,tocIndex:3},{value:": Boolean",paraId:5,tocIndex:3},{value:"默认值",paraId:5,tocIndex:3},{value:": false",paraId:5,tocIndex:3},{value:"是否必须",paraId:5,tocIndex:3},{value:": false",paraId:5,tocIndex:3},{value:"说明",paraId:5,tocIndex:3},{value:": 是否启用 web-worker 以防布局计算时间过长阻塞页面交互。\n",paraId:5,tocIndex:3},{value:"⚠️ 注意:",paraId:5,tocIndex:3},{value:" ",paraId:5,tocIndex:3},{value:"workerEnabled: true",paraId:5,tocIndex:3},{value:" 时，不支持所有函数类型的参数。",paraId:5,tocIndex:3}]},34039:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本文介绍的相关方法是在自定义节点（registerNode）或自定义边（registerEdge）的过程中需要部分实现或复写的方法。",paraId:0},{value:"友情提示：",paraId:1},{value:" 以下属性和 API 方法，全部用于自定义节点和边时候使用，即作为 ",paraId:1},{value:"G6.registerNode",paraId:1},{value:" / ",paraId:1},{value:"G6.registerEdge",paraId:1},{value:" 的第二个参数中的方法。",paraId:1},{value:"本文介绍 G6 的自定义机制，包括自定义节点、自定义边、自定义 combo、自定义交互行为、自定义布局的相关方法。它们都被挂载在 G6 全局上，通过 ",paraId:2},{value:"G6.registerXXX",paraId:2},{value:" 进行调用。",paraId:2},{value:"当内置节点不满足需求时，可以通过 ",paraId:3,tocIndex:0},{value:"G6.registerNode(nodeName, options, extendedNodeName)",paraId:3,tocIndex:0},{value:" 方法自定义节点。",paraId:3,tocIndex:0},{value:"名称",paraId:4,tocIndex:1},{value:"类型",paraId:4,tocIndex:1},{value:"是否必选",paraId:4,tocIndex:1},{value:"描述",paraId:4,tocIndex:1},{value:"nodeName",paraId:4,tocIndex:1},{value:"String",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:"自定义节点名称，需保持唯一性。",paraId:4,tocIndex:1},{value:"options",paraId:4,tocIndex:1},{value:"Object",paraId:4,tocIndex:1},{value:"true",paraId:4,tocIndex:1},{value:"自定义节点时的配置项，配置项中包括完整的生命周期方法，具体请参考：",paraId:4,tocIndex:1},{value:"Shape Doc",paraId:5,tocIndex:1},{value:" 和 ",paraId:4,tocIndex:1},{value:"自定义节点与边 API",paraId:6,tocIndex:1},{value:"。",paraId:4,tocIndex:1},{value:"extendNodeName",paraId:4,tocIndex:1},{value:"String",paraId:4,tocIndex:1},{value:"false",paraId:4,tocIndex:1},{value:"自定义节点时可基于内置节点进行定义，该字段表示内置节点名称，所有内置节点请参考：",paraId:4,tocIndex:1},{value:"内置节点",paraId:7,tocIndex:1},{value:" 教程。",paraId:4,tocIndex:1},{value:"G6.registerNode(\n  'nodeName',\n  {\n    /**\n     * 绘制节点，包含文本\n     * @param  {Object} cfg 节点的配置项\n     * @param  {G.Group} group 图形分组，节点中的图形对象的容器\n     * @return {G.Shape} 绘制的图形，通过 node.get('keyShape') 可以获取到\n     */\n    draw(cfg, group) {},\n    /**\n     * 绘制后的附加操作，默认没有任何操作\n     * @param  {Object} cfg 节点的配置项\n     * @param  {G.Group} group 图形分组，节点中的图形对象的容器\n     */\n    afterDraw(cfg, group) {},\n    /**\n     * 更新节点，包含文本\n     * @override\n     * @param  {Object} cfg 节点的配置项\n     * @param  {Node} node 节点\n     */\n    update(cfg, node) {},\n    /**\n     * 更新节点后的操作，一般同 afterDraw 配合使用\n     * @override\n     * @param  {Object} cfg 节点的配置项\n     * @param  {Node} node 节点\n     */\n    afterUpdate(cfg, node) {},\n    /**\n     * 设置节点的状态，主要是交互状态，业务状态请在 draw 方法中实现\n     * 单图形的节点仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法\n     * @param  {String} name 状态名称\n     * @param  {Object} value 状态值\n     * @param  {Node} node 节点\n     */\n    setState(name, value, node) {},\n    /**\n     * 获取锚点（相关边的连入点）\n     * @param  {Object} cfg 节点的配置项\n     * @return {Array|null} 锚点（相关边的连入点）的数组,如果为 null，则没有锚点\n     */\n    getAnchorPoints(cfg) {},\n  },\n  'extendedNodeName',\n);\n",paraId:8,tocIndex:2},{value:"当内置的边不能满足需求时，可以通过 ",paraId:9,tocIndex:3},{value:"registerEdge(edgeName, options, extendedEdgeName)",paraId:9,tocIndex:3},{value:" 方法注册自定义的边。",paraId:9,tocIndex:3},{value:"名称",paraId:10,tocIndex:4},{value:"类型",paraId:10,tocIndex:4},{value:"是否必选",paraId:10,tocIndex:4},{value:"描述",paraId:10,tocIndex:4},{value:"edgeName",paraId:10,tocIndex:4},{value:"String",paraId:10,tocIndex:4},{value:"true",paraId:10,tocIndex:4},{value:"自定义边的名称",paraId:10,tocIndex:4},{value:"options",paraId:10,tocIndex:4},{value:"Object",paraId:10,tocIndex:4},{value:"true",paraId:10,tocIndex:4},{value:"自定义边时的配置项，配置项中包括完整的生命周期方法，具体请参考：",paraId:10,tocIndex:4},{value:"Shape Doc",paraId:11,tocIndex:4},{value:" 和 ",paraId:10,tocIndex:4},{value:"自定义节点与边 API",paraId:12,tocIndex:4},{value:"。",paraId:10,tocIndex:4},{value:"extendedEdgeName",paraId:10,tocIndex:4},{value:"String",paraId:10,tocIndex:4},{value:"false",paraId:10,tocIndex:4},{value:"自定义边时可基于内置边进行定义，该字段表示内置边的名称，所有内置边请参考：",paraId:10,tocIndex:4},{value:"内置边",paraId:13,tocIndex:4},{value:" 教程。",paraId:10,tocIndex:4},{value:"G6.registerEdge(\n  'edgeName',\n  {\n    /**\n     * 绘制边，包含文本\n     * @param  {Object} cfg 边的配置项\n     * @param  {G.Group} group 图形分组，边中的图形对象的容器\n     * @return {G.Shape} 绘制的图形，通过 node.get('keyShape') 可以获取到\n     */\n    draw(cfg, group) {},\n    /**\n     * 绘制后的附加操作，默认没有任何操作\n     * @param  {Object} cfg 边的配置项\n     * @param  {G.Group} group 图形分组，边中的图形对象的容器\n     */\n    afterDraw(cfg, group) {},\n    /**\n     * 更新边，包含文本\n     * @override\n     * @param  {Object} cfg 边的配置项\n     * @param  {Edge} edge 边\n     */\n    update(cfg, edge) {},\n    /**\n     * 更新边后的操作，一般同 afterDraw 配合使用\n     * @override\n     * @param  {Object} cfg 边的配置项\n     * @param  {Edge} edge 边\n     */\n    afterUpdate(cfg, edge) {},\n    /**\n     * 设置边的状态，主要是交互状态，业务状态请在 draw 方法中实现\n     * 单图形的边仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法\n     * @param  {String} name 状态名称\n     * @param  {Object} value 状态值\n     * @param  {Edge} edge 边\n     */\n    setState(name, value, edge) {},\n  },\n  'extendedEdgeName',\n);\n",paraId:14,tocIndex:5},{value:"当内置 Combo 不满足需求时，可以通过 ",paraId:15,tocIndex:6},{value:"G6.registerCombo(comboName, options, extendedComboName)",paraId:15,tocIndex:6},{value:" 方法自定义 Combo。",paraId:15,tocIndex:6},{value:"名称",paraId:16,tocIndex:7},{value:"类型",paraId:16,tocIndex:7},{value:"是否必选",paraId:16,tocIndex:7},{value:"描述",paraId:16,tocIndex:7},{value:"comboName",paraId:16,tocIndex:7},{value:"String",paraId:16,tocIndex:7},{value:"true",paraId:16,tocIndex:7},{value:"自定义 combo 的名称，需保持唯一性。",paraId:16,tocIndex:7},{value:"options",paraId:16,tocIndex:7},{value:"Object",paraId:16,tocIndex:7},{value:"true",paraId:16,tocIndex:7},{value:"自定义 combo 时的配置项，配置项中包括完整的生命周期方法，具体请参考：",paraId:16,tocIndex:7},{value:"Shape Doc",paraId:17,tocIndex:7},{value:" 和 ",paraId:16,tocIndex:7},{value:"自定义节点与边 API",paraId:18,tocIndex:7},{value:"。",paraId:16,tocIndex:7},{value:"extendedComboName",paraId:16,tocIndex:7},{value:"String",paraId:16,tocIndex:7},{value:"false",paraId:16,tocIndex:7},{value:"自定义节点时可基于内置 combo 进行定义，该字段表示内置 combo 名称，所有内置 Combo 请参考：",paraId:16,tocIndex:7},{value:"内置 Combo",paraId:19,tocIndex:7},{value:" 教程。",paraId:16,tocIndex:7},{value:"G6.registerCombo(\n  'comboName',\n  {\n    /**\n     * 绘制 combo，包含文本\n     * @param  {Object} cfg combo 的配置项\n     * @param  {G.Group} group 图形分组，combo 中的图形对象的容器\n     * @return {G.Shape} 绘制的图形，通过 combo.get('keyShape') 可以获取到\n     */\n    draw(cfg, group) {},\n    /**\n     * 绘制后的附加操作，默认没有任何操作\n     * @param  {Object} cfg combo 的配置项\n     * @param  {G.Group} group 图形分组，combo 中的图形对象的容器\n     */\n    afterDraw(cfg, group) {},\n    /**\n     * 更新 combo ，combo 文本\n     * @override\n     * @param  {Object} cfg combo 的配置项\n     * @param  {Combo} combo combo item\n     */\n    update(cfg, combo) {},\n    /**\n     * 更新 combo 后的操作，一般同 afterDraw 配合使用\n     * @override\n     * @param  {Object} cfg combo 的配置项\n     * @param  {Combo} combo combo item\n     */\n    afterUpdate(cfg, combo) {},\n    /**\n     * 设置 combo 的状态，主要是交互状态，业务状态请在 draw 方法中实现\n     * 单图形的 combo 仅考虑 selected、active 状态，有其他状态需求的用户自己复写这个方法\n     * @param  {String} name 状态名称\n     * @param  {Object} value 状态值\n     * @param  {Combo} combo combo item\n     */\n    setState(name, value, combo) {},\n    /**\n     * 获取锚点（相关边的连入点）\n     * @param  {Object} cfg combo 的配置项\n     * @return {Array|null} 锚点（相关边的连入点）的数组,如果为 null，则没有锚点\n     */\n    getAnchorPoints(cfg) {},\n  },\n  'extendedComboName',\n);\n",paraId:20,tocIndex:8},{value:"下面以注册边为例：",paraId:21,tocIndex:9},{value:"import G6 from '@antv/g6';\nG6.registerEdge(\n  'edgeName',\n  {\n    labelPosition: 'center',\n    labelAutoRotate: true,\n    draw(cfg, group) {\n      // 定义的其他方法，都可以在draw里面调用， 如 drawShape、drawLabel 等。\n      this.drawShape();\n      const labelStyle = this.getLabelStyle(cfg);\n      // ...\n    },\n    drawShape(cfg, group) {\n      //\n    },\n    getLabelStyle(cfg) {\n      // 根据业务返回 label 的样式\n      return {};\n    },\n    update(cfg, item) {\n      // 更新绘制的元素\n    },\n  },\n  'line',\n);\n",paraId:22,tocIndex:9},{value:"文本相对于图形的位置，默认值为 ",paraId:23,tocIndex:11},{value:"'center'",paraId:23,tocIndex:11},{value:"。",paraId:23,tocIndex:11},{value:"当使用 ",paraId:24,tocIndex:11},{value:"registerNode",paraId:24,tocIndex:11},{value:" 注册节点时，",paraId:24,tocIndex:11},{value:"labelPosition",paraId:24,tocIndex:11},{value:" 可选值包括：",paraId:24,tocIndex:11},{value:"'top'",paraId:24,tocIndex:11},{value:"、",paraId:24,tocIndex:11},{value:"'bottom'",paraId:24,tocIndex:11},{value:"、",paraId:24,tocIndex:11},{value:"'left'",paraId:24,tocIndex:11},{value:"、",paraId:24,tocIndex:11},{value:"'right'",paraId:24,tocIndex:11},{value:" 和 ",paraId:24,tocIndex:11},{value:"'center'",paraId:24,tocIndex:11},{value:"；",paraId:24,tocIndex:11},{value:"当使用 ",paraId:24,tocIndex:11},{value:"registerEdge",paraId:24,tocIndex:11},{value:" 注册边时，",paraId:24,tocIndex:11},{value:"labelPosition",paraId:24,tocIndex:11},{value:" 可选值包括：",paraId:24,tocIndex:11},{value:"'start'",paraId:24,tocIndex:11},{value:"、",paraId:24,tocIndex:11},{value:"'end'",paraId:24,tocIndex:11},{value:" 和 ",paraId:24,tocIndex:11},{value:"'center'",paraId:24,tocIndex:11},{value:"。",paraId:24,tocIndex:11},{value:"只有在 ",paraId:25,tocIndex:12},{value:"registerEdge",paraId:25,tocIndex:12},{value:" 时生效。",paraId:25,tocIndex:12},{value:"文本是否跟着线自动旋转，默认值为 ",paraId:26,tocIndex:12},{value:"false",paraId:26,tocIndex:12},{value:"。",paraId:26,tocIndex:12},{value:"提示：edge 特有。",paraId:27,tocIndex:12},{value:"绘制部分四个 API 的参数完全相同，参数说明部分参考 ",paraId:28,tocIndex:13},{value:"draw()",paraId:28,tocIndex:13},{value:" 方法。",paraId:28,tocIndex:13},{value:"绘制节点和边，包括节点和边上的文本，返回图形的 ",paraId:29,tocIndex:14},{value:"keyShape",paraId:29,tocIndex:14},{value:"。",paraId:29,tocIndex:14},{value:"参数",paraId:30,tocIndex:14},{value:"名称",paraId:31,tocIndex:14},{value:"类型",paraId:31,tocIndex:14},{value:"是否必选",paraId:31,tocIndex:14},{value:"描述",paraId:31,tocIndex:14},{value:"cfg",paraId:31,tocIndex:14},{value:"Object",paraId:31,tocIndex:14},{value:"true",paraId:31,tocIndex:14},{value:"节点或边的配置项",paraId:31,tocIndex:14},{value:"group",paraId:31,tocIndex:14},{value:"G.Group",paraId:31,tocIndex:14},{value:"true",paraId:31,tocIndex:14},{value:"节点或边的容器",paraId:31,tocIndex:14},{value:"绘制完成以后的操作，用户可继承现有的节点或边，在 ",paraId:32,tocIndex:15},{value:"afterDraw()",paraId:32,tocIndex:15},{value:" 方法中扩展图形或添加动画。可参考在 afterDraw 中添加动画的 ",paraId:32,tocIndex:15},{value:"demo",paraId:33,tocIndex:15},{value:"。图形动画 API 详见 G6 的渲染引擎 ",paraId:32,tocIndex:15},{value:"G 的动画相关 API",paraId:32,tocIndex:15},{value:"。",paraId:32,tocIndex:15},{value:"更新节点或边，包括节点或边上的文本。",paraId:34,tocIndex:17},{value:"参数",paraId:35,tocIndex:17},{value:"名称",paraId:36,tocIndex:17},{value:"类型",paraId:36,tocIndex:17},{value:"是否必选",paraId:36,tocIndex:17},{value:"描述",paraId:36,tocIndex:17},{value:"cfg",paraId:36,tocIndex:17},{value:"Object",paraId:36,tocIndex:17},{value:"true",paraId:36,tocIndex:17},{value:"节点或边的配置项",paraId:36,tocIndex:17},{value:"item",paraId:36,tocIndex:17},{value:"G6.Item",paraId:36,tocIndex:17},{value:"true",paraId:36,tocIndex:17},{value:"节点或边的实例",paraId:36,tocIndex:17},{value:"更新完以后的操作，如扩展图形或添加动画。可参考添加动画的 ",paraId:37,tocIndex:18},{value:"demo",paraId:38,tocIndex:18},{value:"。图形动画 API 详见 G6 的渲染引擎 ",paraId:37,tocIndex:18},{value:"G 的动画相关 API",paraId:37,tocIndex:18},{value:"。",paraId:37,tocIndex:18},{value:"是否允许更新。",paraId:39,tocIndex:19},{value:"参数",paraId:40,tocIndex:19},{value:"名称",paraId:41,tocIndex:19},{value:"类型",paraId:41,tocIndex:19},{value:"是否必选",paraId:41,tocIndex:19},{value:"描述",paraId:41,tocIndex:19},{value:"type",paraId:41,tocIndex:19},{value:"String",paraId:41,tocIndex:19},{value:"true",paraId:41,tocIndex:19},{value:"元素类型，",paraId:41,tocIndex:19},{value:"'node'",paraId:41,tocIndex:19},{value:" 或 ",paraId:41,tocIndex:19},{value:"'edge'",paraId:41,tocIndex:19},{value:"返回值",paraId:42,tocIndex:19},{value:"返回值类型：Boolean；",paraId:43,tocIndex:19},{value:"返回 ",paraId:43,tocIndex:19},{value:"true",paraId:43,tocIndex:19},{value:"，则允许更新，否则不允许更新。",paraId:43,tocIndex:19},{value:"用于响应外部对元素状态的改变。当外部调用 ",paraId:44,tocIndex:20},{value:"graph.setItemState(item, state, value)",paraId:45,tocIndex:20},{value:" 时，该函数作出相关响应。主要是交互状态，业务状态请在 ",paraId:44,tocIndex:20},{value:"draw()",paraId:44,tocIndex:20},{value:" 方法中实现。单图形的节点仅考虑 ",paraId:44,tocIndex:20},{value:"'selected'",paraId:44,tocIndex:20},{value:" 、",paraId:44,tocIndex:20},{value:"'active'",paraId:44,tocIndex:20},{value:" 状态，有其他状态需求的用户可以复写该方法。",paraId:44,tocIndex:20},{value:"参数",paraId:46,tocIndex:20},{value:"名称",paraId:47,tocIndex:20},{value:"类型",paraId:47,tocIndex:20},{value:"是否必选",paraId:47,tocIndex:20},{value:"描述",paraId:47,tocIndex:20},{value:"name",paraId:47,tocIndex:20},{value:"String",paraId:47,tocIndex:20},{value:"true",paraId:47,tocIndex:20},{value:"状态名称",paraId:47,tocIndex:20},{value:"value",paraId:47,tocIndex:20},{value:"Boolean",paraId:47,tocIndex:20},{value:"true",paraId:47,tocIndex:20},{value:"状态是否可用，为 ",paraId:47,tocIndex:20},{value:"true",paraId:47,tocIndex:20},{value:" 时可用，否则不可用",paraId:47,tocIndex:20},{value:"item",paraId:47,tocIndex:20},{value:"G6.Item",paraId:47,tocIndex:20},{value:"true",paraId:47,tocIndex:20},{value:"节点或边的实例",paraId:47,tocIndex:20}]},33707:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"当内置布局不满足需求时，可以通过 ",paraId:0,tocIndex:0},{value:"G6.registerLayout(layoutName, layout)",paraId:0,tocIndex:0},{value:" 方法自定义布局。",paraId:0,tocIndex:0},{value:"名称",paraId:1,tocIndex:1},{value:"类型",paraId:1,tocIndex:1},{value:"是否必选",paraId:1,tocIndex:1},{value:"描述",paraId:1,tocIndex:1},{value:"layoutName",paraId:1,tocIndex:1},{value:"String",paraId:1,tocIndex:1},{value:"true",paraId:1,tocIndex:1},{value:"自定义布局名称。",paraId:1,tocIndex:1},{value:"layout",paraId:1,tocIndex:1},{value:"Object",paraId:1,tocIndex:1},{value:"true",paraId:1,tocIndex:1},{value:"自定义布局的配置项，配置项中包括的方法及作用具体请参考：",paraId:1,tocIndex:1},{value:"Layout API",paraId:2,tocIndex:1},{value:"。",paraId:1,tocIndex:1},{value:"G6.registerLayout('layoutName', {\n  /**\n   * 定义自定义行为的默认参数，会与用户传入的参数进行合并\n   */\n  getDefaultCfg() {\n    return {};\n  },\n  /**\n   * 初始化\n   * @param {Object} data 数据\n   */\n  init(data) {\n    const self = this;\n    self.nodes = data.nodes;\n    self.edges = data.edges;\n  },\n  /**\n   * 执行布局\n   */\n  execute() {\n    // TODO\n  },\n  /**\n   * 根据传入的数据进行布局\n   * @param {Object} data 数据\n   */\n  layout(data) {\n    const self = this;\n    self.init(data);\n    self.execute();\n  },\n  /**\n   * 更新布局配置，但不执行布局\n   * @param {Object} cfg 需要更新的配置项\n   */\n  updateCfg(cfg) {\n    const self = this;\n    Util.mix(self, cfg);\n  },\n  /**\n   * 销毁\n   */\n  destroy() {\n    const self = this;\n    self.positions = null;\n    self.nodes = null;\n    self.edges = null;\n    self.destroyed = true;\n  },\n});\n",paraId:3,tocIndex:2},{value:"以下方法为自定义布局时可能需要复写的方法。如果非自定义，使用内置布局方法时，以下方法由 G6 控制并调用，用户不需要了解。",paraId:4,tocIndex:2},{value:"初始化布局。",paraId:5,tocIndex:4},{value:"参数",paraId:6,tocIndex:4},{value:"名称",paraId:7,tocIndex:4},{value:"类型",paraId:7,tocIndex:4},{value:"是否必选",paraId:7,tocIndex:4},{value:"描述",paraId:7,tocIndex:4},{value:"data",paraId:7,tocIndex:4},{value:"object",paraId:7,tocIndex:4},{value:"true",paraId:7,tocIndex:4},{value:"布局中使用的数据",paraId:7,tocIndex:4},{value:"返回布局的默认参数。",paraId:8,tocIndex:5},{value:"返回值",paraId:9,tocIndex:5},{value:"名称",paraId:10,tocIndex:5},{value:"类型",paraId:10,tocIndex:5},{value:"是否必选",paraId:10,tocIndex:5},{value:"描述",paraId:10,tocIndex:5},{value:"cfg",paraId:10,tocIndex:5},{value:"object",paraId:10,tocIndex:5},{value:"true",paraId:10,tocIndex:5},{value:"布局的默认参数",paraId:10,tocIndex:5},{value:"执行布局算法。",paraId:11,tocIndex:7},{value:"根据传入的数据进行布局。",paraId:12,tocIndex:8},{value:"参数",paraId:13,tocIndex:8},{value:"名称",paraId:14,tocIndex:8},{value:"类型",paraId:14,tocIndex:8},{value:"是否必选",paraId:14,tocIndex:8},{value:"描述",paraId:14,tocIndex:8},{value:"data",paraId:14,tocIndex:8},{value:"object",paraId:14,tocIndex:8},{value:"true",paraId:14,tocIndex:8},{value:"布局中使用的数据",paraId:14,tocIndex:8},{value:"更新布局参数。",paraId:15,tocIndex:10},{value:"参数",paraId:16,tocIndex:10},{value:"名称",paraId:17,tocIndex:10},{value:"类型",paraId:17,tocIndex:10},{value:"是否必选",paraId:17,tocIndex:10},{value:"描述",paraId:17,tocIndex:10},{value:"cfg",paraId:17,tocIndex:10},{value:"object",paraId:17,tocIndex:10},{value:"true",paraId:17,tocIndex:10},{value:"新的布局配置",paraId:17,tocIndex:10},{value:"销毁布局。",paraId:18,tocIndex:12}]},53723:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"设置或获取实例的绘图属性。",paraId:0,tocIndex:0},{value:"获取实例的属性值。",paraId:1,tocIndex:1},{value:"const width = shape.attr('width');\n",paraId:2,tocIndex:1},{value:"更新实例的单个绘图属性。",paraId:3,tocIndex:2},{value:"批量更新实例绘图属性。",paraId:4,tocIndex:3},{value:"rect.attr({\n  fill: '#999',\n  stroke: '#666'\n});\n",paraId:5,tocIndex:3},{value:"设置并返回裁剪对象。",paraId:6,tocIndex:4},{value:"clipCfg",paraId:7,tocIndex:4},{value:" 配置项",paraId:7,tocIndex:4},{value:"名称",paraId:8,tocIndex:4},{value:"含义",paraId:8,tocIndex:4},{value:"类型",paraId:8,tocIndex:4},{value:"备注",paraId:8,tocIndex:4},{value:"type",paraId:8,tocIndex:4},{value:"裁剪的图片形状",paraId:8,tocIndex:4},{value:"String",paraId:8,tocIndex:4},{value:"支持 ",paraId:8,tocIndex:4},{value:"'circle'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'rect'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'ellipse'",paraId:8,tocIndex:4},{value:"x",paraId:8,tocIndex:4},{value:"裁剪图形的 x 坐标",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"默认为 0，类型为 ",paraId:8,tocIndex:4},{value:"'circle'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'rect'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'ellipse'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"y",paraId:8,tocIndex:4},{value:"裁剪图形的 y 坐标",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"默认为 0，类型为 ",paraId:8,tocIndex:4},{value:"'circle'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'rect'",paraId:8,tocIndex:4},{value:"、",paraId:8,tocIndex:4},{value:"'ellipse'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"show",paraId:8,tocIndex:4},{value:"是否启用裁剪功能",paraId:8,tocIndex:4},{value:"Boolean",paraId:8,tocIndex:4},{value:"默认不裁剪，值为 ",paraId:8,tocIndex:4},{value:"false",paraId:8,tocIndex:4},{value:"r",paraId:8,tocIndex:4},{value:"剪裁圆形的半径",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"剪裁 type 为  ",paraId:8,tocIndex:4},{value:"'circle'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"width",paraId:8,tocIndex:4},{value:"剪裁矩形的宽度",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"剪裁 type 为 ",paraId:8,tocIndex:4},{value:"'rect'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"height",paraId:8,tocIndex:4},{value:"剪裁矩形的长度",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"剪裁 type 为 ",paraId:8,tocIndex:4},{value:"'rect'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"rx",paraId:8,tocIndex:4},{value:"剪裁椭圆的长轴半径",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"剪裁 type 为 ",paraId:8,tocIndex:4},{value:"'ellipse'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"ry",paraId:8,tocIndex:4},{value:"剪裁椭圆的短轴半径",paraId:8,tocIndex:4},{value:"Number",paraId:8,tocIndex:4},{value:"剪裁 type 为 ",paraId:8,tocIndex:4},{value:"'ellipse'",paraId:8,tocIndex:4},{value:" 时生效",paraId:8,tocIndex:4},{value:"用法",paraId:9,tocIndex:4},{value:"shape.setClip({\n  type: 'circle', // 支持 circle、rect、ellipse、Polygon 及自定义 path clip\n  attrs: {\n    r: 10,\n    x: 0,\n    y: 0,\n  },\n",paraId:10,tocIndex:4},{value:"获取裁剪对象。",paraId:11,tocIndex:5}]},7492:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图形是组成图上一个元素（节点/边）的基本单位。节点/边的 ",paraId:0},{value:"style",paraId:0},{value:" 属性即对应了各自 keyShape（关键图形）的图形属性。节点或边上标签 ",paraId:0},{value:"labelCfg",paraId:0},{value:" 中的 ",paraId:0},{value:"style",paraId:0},{value:" 属性对应了 text 图形的图形属性。除一些",paraId:0},{value:"通用属性",paraId:1},{value:"外，不同图形有各自的特殊属性。",paraId:0},{value:"group.addShape('rect', {\n  attrs: {\n    fill: 'red',\n    shadowOffsetX: 10,\n    shadowOffsetY: 10,\n    shadowColor: 'blue',\n    shadowBlur: 10,\n    opacity: 0.8,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:2},{value:"G6 支持以下图形：",paraId:3},{value:"circle",paraId:4},{value:"：圆；",paraId:5},{value:"rect",paraId:6},{value:"：矩形；",paraId:5},{value:"ellipse",paraId:7},{value:"：椭圆；",paraId:5},{value:"polygon",paraId:8},{value:"：多边形；",paraId:5},{value:"image",paraId:9},{value:"：图片；",paraId:5},{value:"marker",paraId:10},{value:"：标记；",paraId:5},{value:"path",paraId:11},{value:"：路径；",paraId:5},{value:"text",paraId:12},{value:"：文本；",paraId:5},{value:"dom(svg)",paraId:13},{value:"：DOM（图渲染方式 ",paraId:5},{value:"renderer",paraId:5},{value:" 为 ",paraId:5},{value:"'svg'",paraId:5},{value:" 时可用）。",paraId:5},{value:" ",paraId:14,tocIndex:1},{value:"String",paraId:14,tocIndex:1},{value:" ",paraId:14,tocIndex:1},{value:"required",paraId:14,tocIndex:1},{value:" ",paraId:14,tocIndex:1},{value:"图形名称标识，G6 3.3 版本以上必须配置。",paraId:15,tocIndex:1},{value:"且在统一自定义元素类型中，值必须唯一。",paraId:15,tocIndex:1},{value:" 否则可能导致图形样式更新与恢复的错误。",paraId:15,tocIndex:1},{value:" ",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:" ",paraId:16,tocIndex:2},{value:"optional",paraId:16,tocIndex:2},{value:" ",paraId:16,tocIndex:2},{value:"设置用于填充绘画的颜色(RGB 或 16 进制)、",paraId:17,tocIndex:2},{value:"渐变",paraId:18,tocIndex:2},{value:"或模式，对应 Canvas 属性 ",paraId:17,tocIndex:2},{value:"fillStyle",paraId:17,tocIndex:2},{value:" 。取值示例：",paraId:17,tocIndex:2},{value:"rgb(18, 150, 231)",paraId:17,tocIndex:2},{value:"，",paraId:17,tocIndex:2},{value:"#c193af",paraId:17,tocIndex:2},{value:"，",paraId:17,tocIndex:2},{value:"l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff",paraId:17,tocIndex:2},{value:"， ",paraId:17,tocIndex:2},{value:"r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff",paraId:17,tocIndex:2},{value:"。",paraId:17,tocIndex:2},{value:" ",paraId:19,tocIndex:3},{value:"String",paraId:19,tocIndex:3},{value:" ",paraId:19,tocIndex:3},{value:"optional",paraId:19,tocIndex:3},{value:" ",paraId:19,tocIndex:3},{value:"设置用于笔触的颜色(RGB 或 16 进制)、",paraId:20,tocIndex:3},{value:"渐变",paraId:21,tocIndex:3},{value:"或模式，对应 Canvas 属性 ",paraId:20,tocIndex:3},{value:"strokeStyle",paraId:20,tocIndex:3},{value:"。取值示例：",paraId:20,tocIndex:3},{value:"rgb(18, 150, 231)",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"#c193af",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff",paraId:20,tocIndex:3},{value:"， ",paraId:20,tocIndex:3},{value:"r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff",paraId:20,tocIndex:3},{value:"。",paraId:20,tocIndex:3},{value:" ",paraId:22,tocIndex:4},{value:"Number",paraId:22,tocIndex:4},{value:" ",paraId:22,tocIndex:4},{value:"optional",paraId:22,tocIndex:4},{value:" ",paraId:22,tocIndex:4},{value:"描边宽度。",paraId:23,tocIndex:4},{value:" ",paraId:24,tocIndex:5},{value:"Number | Number[]",paraId:24,tocIndex:5},{value:" ",paraId:24,tocIndex:5},{value:"optional",paraId:24,tocIndex:5},{value:" ",paraId:24,tocIndex:5},{value:"描边虚线，Number[] 类型中数组元素分别代表实、虚长度。",paraId:25,tocIndex:5},{value:" ",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:" ",paraId:26,tocIndex:6},{value:"optional",paraId:26,tocIndex:6},{value:" ",paraId:26,tocIndex:6},{value:"设置用于阴影的颜色。",paraId:27,tocIndex:6},{value:" ",paraId:28,tocIndex:7},{value:"Number",paraId:28,tocIndex:7},{value:" ",paraId:28,tocIndex:7},{value:"optional",paraId:28,tocIndex:7},{value:" ",paraId:28,tocIndex:7},{value:"设置用于阴影的模糊级别，数值越大，越模糊。",paraId:29,tocIndex:7},{value:" ",paraId:30,tocIndex:8},{value:"Number",paraId:30,tocIndex:8},{value:" ",paraId:30,tocIndex:8},{value:"optional",paraId:30,tocIndex:8},{value:" ",paraId:30,tocIndex:8},{value:"设置阴影距形状的水平距离。",paraId:31,tocIndex:8},{value:" ",paraId:32,tocIndex:9},{value:"Number",paraId:32,tocIndex:9},{value:" ",paraId:32,tocIndex:9},{value:"optional",paraId:32,tocIndex:9},{value:" ",paraId:32,tocIndex:9},{value:"设置阴影距形状的垂直距离。",paraId:33,tocIndex:9},{value:" ",paraId:34,tocIndex:10},{value:"Number",paraId:34,tocIndex:10},{value:" ",paraId:34,tocIndex:10},{value:"optional",paraId:34,tocIndex:10},{value:" ",paraId:34,tocIndex:10},{value:"设置绘图的当前 alpha 或透明值，范围 [0, 1]，对应 Canvas 属性 ",paraId:35,tocIndex:10},{value:"globalAlpha",paraId:35,tocIndex:10},{value:"。",paraId:35,tocIndex:10},{value:" ",paraId:36,tocIndex:11},{value:"Number",paraId:36,tocIndex:11},{value:" ",paraId:36,tocIndex:11},{value:"optional",paraId:36,tocIndex:11},{value:" ",paraId:36,tocIndex:11},{value:"设置填充的 alpha 或透明值，优先级高于 opacity，范围 [0, 1]。",paraId:37,tocIndex:11},{value:" ",paraId:38,tocIndex:12},{value:"Number",paraId:38,tocIndex:12},{value:" ",paraId:38,tocIndex:12},{value:"optional",paraId:38,tocIndex:12},{value:" ",paraId:38,tocIndex:12},{value:"设置描边的 alpha 或透明值，优先级高于 opacity，范围 [0, 1]。",paraId:39,tocIndex:12},{value:" ",paraId:40,tocIndex:13},{value:"String",paraId:40,tocIndex:13},{value:" ",paraId:40,tocIndex:13},{value:"optional",paraId:40,tocIndex:13},{value:" ",paraId:40,tocIndex:13},{value:"鼠标在该节点上时的鼠标样式，",paraId:41,tocIndex:13},{value:"CSS 的 cursor",paraId:41,tocIndex:13},{value:" 选项都支持。",paraId:41,tocIndex:13},{value:"group.addShape('circle', {\n  attrs: {\n    x: 100,\n    y: 100,\n    r: 50,\n    fill: 'blue',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'circle-shape',\n});\n",paraId:42,tocIndex:14},{value:" ",paraId:43,tocIndex:15},{value:"Number",paraId:43,tocIndex:15},{value:" ",paraId:43,tocIndex:15},{value:"optional",paraId:43,tocIndex:15},{value:" ",paraId:43,tocIndex:15},{value:"圆心的 x 坐标。",paraId:44,tocIndex:15},{value:" ",paraId:45,tocIndex:16},{value:"Number",paraId:45,tocIndex:16},{value:" ",paraId:45,tocIndex:16},{value:"optional",paraId:45,tocIndex:16},{value:" ",paraId:45,tocIndex:16},{value:"圆心的 y 坐标。",paraId:46,tocIndex:16},{value:" ",paraId:47,tocIndex:17},{value:"Number",paraId:47,tocIndex:17},{value:" ",paraId:47,tocIndex:17},{value:"optional",paraId:47,tocIndex:17},{value:" ",paraId:47,tocIndex:17},{value:"圆的半径。",paraId:48,tocIndex:17},{value:"group.addShape('ellipse', {\n  attrs: {\n    x: 100,\n    y: 100,\n    rx: 50,\n    ry: 50,\n    fill: 'blue',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'ellipse-shape',\n});\n",paraId:49,tocIndex:18},{value:" ",paraId:50,tocIndex:19},{value:"Number",paraId:50,tocIndex:19},{value:" ",paraId:50,tocIndex:19},{value:"optional",paraId:50,tocIndex:19},{value:" ",paraId:50,tocIndex:19},{value:"圆心的 x 坐标。",paraId:51,tocIndex:19},{value:" ",paraId:52,tocIndex:20},{value:"Number",paraId:52,tocIndex:20},{value:" ",paraId:52,tocIndex:20},{value:"optional",paraId:52,tocIndex:20},{value:" ",paraId:52,tocIndex:20},{value:"圆心的 y 坐标。",paraId:53,tocIndex:20},{value:" ",paraId:54,tocIndex:21},{value:"Number",paraId:54,tocIndex:21},{value:" ",paraId:54,tocIndex:21},{value:"optional",paraId:54,tocIndex:21},{value:" ",paraId:54,tocIndex:21},{value:"水平半径。",paraId:55,tocIndex:21},{value:" ",paraId:56,tocIndex:22},{value:"Number",paraId:56,tocIndex:22},{value:" ",paraId:56,tocIndex:22},{value:"optional",paraId:56,tocIndex:22},{value:" ",paraId:56,tocIndex:22},{value:"垂直半径。",paraId:57,tocIndex:22},{value:"group.addShape('image', {\n  attrs: {\n    x: 0,\n    y: 0,\n    img: 'https://g.alicdn.com/cm-design/arms-trace/1.0.155/styles/armsTrace/images/TAIR.png',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'image-shape',\n});\n",paraId:58,tocIndex:23},{value:" ",paraId:59,tocIndex:24},{value:"Number",paraId:59,tocIndex:24},{value:" ",paraId:59,tocIndex:24},{value:"optional",paraId:59,tocIndex:24},{value:" ",paraId:59,tocIndex:24},{value:"图片左上角的 x 坐标。",paraId:60,tocIndex:24},{value:" ",paraId:61,tocIndex:25},{value:"Number",paraId:61,tocIndex:25},{value:" ",paraId:61,tocIndex:25},{value:"optional",paraId:61,tocIndex:25},{value:" ",paraId:61,tocIndex:25},{value:"图片左上角的 y 坐标。",paraId:62,tocIndex:25},{value:" ",paraId:63,tocIndex:26},{value:"Number",paraId:63,tocIndex:26},{value:" ",paraId:63,tocIndex:26},{value:"optional",paraId:63,tocIndex:26},{value:" ",paraId:63,tocIndex:26},{value:"图片宽度。",paraId:64,tocIndex:26},{value:" ",paraId:65,tocIndex:27},{value:"Number",paraId:65,tocIndex:27},{value:" ",paraId:65,tocIndex:27},{value:"optional",paraId:65,tocIndex:27},{value:" ",paraId:65,tocIndex:27},{value:"图片高度。",paraId:66,tocIndex:27},{value:" ",paraId:67,tocIndex:28},{value:"String",paraId:67,tocIndex:28},{value:" ",paraId:67,tocIndex:28},{value:"optional",paraId:67,tocIndex:28},{value:" ",paraId:67,tocIndex:28},{value:"图片源，G6 支持多种格式的图片：url，ImageData，Image，canvas。",paraId:68,tocIndex:28},{value:"// 使用内置 symbol\ngroup.addShape('marker', {\n  attrs: {\n    x: 10,\n    y: 10,\n    r: 10,\n    symbol: 'triangle-down',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'marker-shape',\n});\n\n// 使用路径自定义 symbol\ngroup.addShape('marker', {\n  attrs: {\n    x: 10,\n    y: 10,\n    r: 10,\n    symbol: function (x, y, r) {\n      return [['M', x, y], ['L', x + r, y + r], ['L', x + r * 2, y], ['Z']];\n    },\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'marker-shape',\n});\n",paraId:69,tocIndex:29},{value:" ",paraId:70,tocIndex:30},{value:"Number",paraId:70,tocIndex:30},{value:" ",paraId:70,tocIndex:30},{value:"optional",paraId:70,tocIndex:30},{value:" ",paraId:70,tocIndex:30},{value:"标记图形左上角的 x 坐标。",paraId:71,tocIndex:30},{value:" ",paraId:72,tocIndex:31},{value:"Number",paraId:72,tocIndex:31},{value:" ",paraId:72,tocIndex:31},{value:"optional",paraId:72,tocIndex:31},{value:" ",paraId:72,tocIndex:31},{value:"标记图形左上角的 y 坐标。",paraId:73,tocIndex:31},{value:" ",paraId:74,tocIndex:32},{value:"Number",paraId:74,tocIndex:32},{value:" ",paraId:74,tocIndex:32},{value:"optional",paraId:74,tocIndex:32},{value:" ",paraId:74,tocIndex:32},{value:"形状半径。",paraId:75,tocIndex:32},{value:" ",paraId:76,tocIndex:33},{value:"String | Function",paraId:76,tocIndex:33},{value:" ",paraId:76,tocIndex:33},{value:"optional",paraId:76,tocIndex:33},{value:" ",paraId:76,tocIndex:33},{value:"指定形状。我们已经内置了一些常用形状，如圆形 ",paraId:77,tocIndex:33},{value:"'circle'",paraId:77,tocIndex:33},{value:"，矩形  ",paraId:77,tocIndex:33},{value:"'square'",paraId:77,tocIndex:33},{value:"，菱形  ",paraId:77,tocIndex:33},{value:"'diamond'",paraId:77,tocIndex:33},{value:"，三角形  ",paraId:77,tocIndex:33},{value:"'triangle'",paraId:77,tocIndex:33},{value:"，倒三角形 ",paraId:77,tocIndex:33},{value:"'triangle-down'",paraId:77,tocIndex:33},{value:"，这些内置形状只需要直接将响应 String 赋值给 symbol。也可以是自定义的 path 路径的函数。",paraId:77,tocIndex:33},{value:"group.addShape('polygon', {\n  attrs: {\n    points: [\n      [30, 30],\n      [40, 20],\n      [30, 50],\n      [60, 100],\n    ],\n    fill: 'red',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'polygon-shape',\n});\n",paraId:78,tocIndex:35},{value:" ",paraId:79,tocIndex:36},{value:"Array",paraId:79,tocIndex:36},{value:" ",paraId:79,tocIndex:36},{value:"optional",paraId:79,tocIndex:36},{value:" ",paraId:79,tocIndex:36},{value:"多边形的所有端点坐标。",paraId:80,tocIndex:36},{value:"group.addShape('rect', {\n  attrs: {\n    x: 150,\n    y: 150,\n    width: 150,\n    height: 150,\n    stroke: 'black',\n    radius: [2, 4],\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:81,tocIndex:37},{value:" ",paraId:82,tocIndex:38},{value:"Number",paraId:82,tocIndex:38},{value:" ",paraId:82,tocIndex:38},{value:"optional",paraId:82,tocIndex:38},{value:" ",paraId:82,tocIndex:38},{value:"矩形左上角的 x 坐标。",paraId:83,tocIndex:38},{value:" ",paraId:84,tocIndex:39},{value:"Number",paraId:84,tocIndex:39},{value:" ",paraId:84,tocIndex:39},{value:"optional",paraId:84,tocIndex:39},{value:" ",paraId:84,tocIndex:39},{value:"矩形左上角的 y 坐标。",paraId:85,tocIndex:39},{value:" ",paraId:86,tocIndex:40},{value:"Number",paraId:86,tocIndex:40},{value:" ",paraId:86,tocIndex:40},{value:"optional",paraId:86,tocIndex:40},{value:" ",paraId:86,tocIndex:40},{value:"矩形的宽度。",paraId:87,tocIndex:40},{value:" ",paraId:88,tocIndex:41},{value:"Number",paraId:88,tocIndex:41},{value:" ",paraId:88,tocIndex:41},{value:"optional",paraId:88,tocIndex:41},{value:" ",paraId:88,tocIndex:41},{value:"矩形的高度。",paraId:89,tocIndex:41},{value:" ",paraId:90,tocIndex:42},{value:"Number | Number[]",paraId:90,tocIndex:42},{value:" ",paraId:90,tocIndex:42},{value:"optional",paraId:90,tocIndex:42},{value:" ",paraId:90,tocIndex:42},{value:"定义圆角。支持整数或数组形式，分别对应左上、右上、右下、左下角的半径：",paraId:91,tocIndex:42},{value:"- radius 缩写为 1 或 [ 1 ] 相当于 [ 1, 1, 1, 1 ]",paraId:91,tocIndex:42},{value:"- radius 缩写为 [ 1, 2 ] 相当于 [ 1, 2, 1, 2 ]",paraId:91,tocIndex:42},{value:"- radius 缩写为 [ 1, 2, 3 ] 相当于 [ 1, 2, 3, 2 ]",paraId:91,tocIndex:42},{value:"。",paraId:91,tocIndex:42},{value:"⚠️ 注意:",paraId:92,tocIndex:43},{value:" 当边太细交互不易命中时，请设置 ",paraId:92,tocIndex:43},{value:"lineAppendWidth",paraId:92,tocIndex:43},{value:" 属性值。",paraId:92,tocIndex:43},{value:"group.addShape('path', {\n  attrs: {\n    startArrow: {\n      // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n      path: 'M 0,0 L 20,10 L 20,-10 Z',\n      // 箭头的偏移量，负值代表向 x 轴正方向移动\n      // d: -10,\n    },\n    endArrow: {\n      // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n      path: 'M 0,0 L 20,10 L 20,-10 Z',\n      // 箭头的偏移量，负值代表向 x 轴正方向移动\n      // d: -10,\n    },\n    path: [\n      ['M', 100, 100],\n      ['L', 200, 200],\n    ],\n    stroke: '#000',\n    lineWidth: 8,\n    lineAppendWidth: 5,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'path-shape',\n});\n",paraId:93,tocIndex:43},{value:" ",paraId:94,tocIndex:44},{value:"String | Array",paraId:94,tocIndex:44},{value:" ",paraId:94,tocIndex:44},{value:"optional",paraId:94,tocIndex:44},{value:" ",paraId:94,tocIndex:44},{value:"线条路径，可以是 String 形式，也可以是线段的数组。格式参考：",paraId:95,tocIndex:44},{value:"SVG path",paraId:95,tocIndex:44},{value:"。",paraId:95,tocIndex:44},{value:" ",paraId:96,tocIndex:45},{value:"Boolean | Object",paraId:96,tocIndex:45},{value:" ",paraId:96,tocIndex:45},{value:"optional",paraId:96,tocIndex:45},{value:" ",paraId:96,tocIndex:45},{value:"起始端的箭头，为 ",paraId:97,tocIndex:45},{value:"true",paraId:97,tocIndex:45},{value:" 时为默认的箭头效果，也可以是一个自定义箭头。",paraId:97,tocIndex:45},{value:" ",paraId:98,tocIndex:46},{value:"Boolean | Object",paraId:98,tocIndex:46},{value:" ",paraId:98,tocIndex:46},{value:"optional",paraId:98,tocIndex:46},{value:" ",paraId:98,tocIndex:46},{value:"末尾端的箭头，为 ",paraId:99,tocIndex:46},{value:"true",paraId:99,tocIndex:46},{value:" 时为默认的箭头效果，也可以是一个自定义箭头。",paraId:99,tocIndex:46},{value:" ",paraId:100,tocIndex:47},{value:"Number",paraId:100,tocIndex:47},{value:" ",paraId:100,tocIndex:47},{value:"optional",paraId:100,tocIndex:47},{value:" ",paraId:100,tocIndex:47},{value:"边的击中范围。提升边的击中范围，扩展响应范围，数值越大，响应范围越广。",paraId:101,tocIndex:47},{value:" ",paraId:102,tocIndex:48},{value:"String",paraId:102,tocIndex:48},{value:" ",paraId:102,tocIndex:48},{value:"optional",paraId:102,tocIndex:48},{value:" ",paraId:102,tocIndex:48},{value:"设置线条的结束端点样式。可选：",paraId:103,tocIndex:48},{value:" - ",paraId:103,tocIndex:48},{value:"'bevel'",paraId:103,tocIndex:48},{value:": 斜角 ",paraId:103,tocIndex:48},{value:" - ",paraId:103,tocIndex:48},{value:"'round'",paraId:103,tocIndex:48},{value:": 圆角 ",paraId:103,tocIndex:48},{value:" - ",paraId:103,tocIndex:48},{value:"'miter'",paraId:103,tocIndex:48},{value:": 尖角 (默认)。",paraId:103,tocIndex:48},{value:" ",paraId:104,tocIndex:49},{value:"String",paraId:104,tocIndex:49},{value:" ",paraId:104,tocIndex:49},{value:"optional",paraId:104,tocIndex:49},{value:" ",paraId:104,tocIndex:49},{value:"设置两条线相交时，所创建的拐角形状。可选：",paraId:105,tocIndex:49},{value:" - ",paraId:105,tocIndex:49},{value:"'bevel'",paraId:105,tocIndex:49},{value:": 斜角 ",paraId:105,tocIndex:49},{value:" - ",paraId:105,tocIndex:49},{value:"'round'",paraId:105,tocIndex:49},{value:": 圆角 ",paraId:105,tocIndex:49},{value:" - ",paraId:105,tocIndex:49},{value:"'miter'",paraId:105,tocIndex:49},{value:": 尖角 (默认)。",paraId:105,tocIndex:49},{value:" ",paraId:106,tocIndex:50},{value:"Number",paraId:106,tocIndex:50},{value:" ",paraId:106,tocIndex:50},{value:"optional",paraId:106,tocIndex:50},{value:" ",paraId:106,tocIndex:50},{value:"设置当前的线条宽度。",paraId:107,tocIndex:50},{value:" ",paraId:108,tocIndex:51},{value:"Number",paraId:108,tocIndex:51},{value:" ",paraId:108,tocIndex:51},{value:"optional",paraId:108,tocIndex:51},{value:" ",paraId:108,tocIndex:51},{value:"设置最大斜接长度。",paraId:109,tocIndex:51},{value:" ",paraId:110,tocIndex:52},{value:"Number | Number[]",paraId:110,tocIndex:52},{value:" ",paraId:110,tocIndex:52},{value:"optional",paraId:110,tocIndex:52},{value:" ",paraId:110,tocIndex:52},{value:"设置线的虚线样式，可以指定一个数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。可参考",paraId:111,tocIndex:52},{value:"setLineDash",paraId:111,tocIndex:52},{value:"。",paraId:111,tocIndex:52},{value:"group.addShape('text', {\n  attrs: {\n    text: 'test text',\n    fill: 'red',\n    fontWeight: 400,\n    shadowOffsetX: 10,\n    shadowOffsetY: 10,\n    shadowColor: 'blue',\n    shadowBlur: 10,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'text-shape',\n});\n",paraId:112,tocIndex:53},{value:" ",paraId:113,tocIndex:54},{value:"String",paraId:113,tocIndex:54},{value:" ",paraId:113,tocIndex:54},{value:"optional",paraId:113,tocIndex:54},{value:" ",paraId:113,tocIndex:54},{value:"文本文字内容。",paraId:114,tocIndex:54},{value:" ",paraId:115,tocIndex:55},{value:"String",paraId:115,tocIndex:55},{value:" ",paraId:115,tocIndex:55},{value:"optional",paraId:115,tocIndex:55},{value:" ",paraId:115,tocIndex:55},{value:"设置文本内容的当前对齐方式。支持的属性：",paraId:116,tocIndex:55},{value:"center",paraId:116,tocIndex:55},{value:" / ",paraId:116,tocIndex:55},{value:"end",paraId:116,tocIndex:55},{value:" / ",paraId:116,tocIndex:55},{value:"left",paraId:116,tocIndex:55},{value:" / ",paraId:116,tocIndex:55},{value:"right",paraId:116,tocIndex:55},{value:" / ",paraId:116,tocIndex:55},{value:"start",paraId:116,tocIndex:55},{value:"，默认值为 ",paraId:116,tocIndex:55},{value:"start",paraId:116,tocIndex:55},{value:"。",paraId:116,tocIndex:55},{value:" ",paraId:117,tocIndex:56},{value:"String",paraId:117,tocIndex:56},{value:" ",paraId:117,tocIndex:56},{value:"optional",paraId:117,tocIndex:56},{value:" ",paraId:117,tocIndex:56},{value:"设置在绘制文本时使用的当前文本基线。支持的属性:",paraId:118,tocIndex:56},{value:"top",paraId:118,tocIndex:56},{value:" / ",paraId:118,tocIndex:56},{value:"middle",paraId:118,tocIndex:56},{value:" / ",paraId:118,tocIndex:56},{value:"bottom",paraId:118,tocIndex:56},{value:"。默认值为 ",paraId:118,tocIndex:56},{value:"bottom",paraId:118,tocIndex:56},{value:"。",paraId:118,tocIndex:56},{value:" ",paraId:119,tocIndex:57},{value:"String",paraId:119,tocIndex:57},{value:" ",paraId:119,tocIndex:57},{value:"optional",paraId:119,tocIndex:57},{value:" ",paraId:119,tocIndex:57},{value:"字体样式。对应 ",paraId:120,tocIndex:57},{value:"font-style",paraId:120,tocIndex:57},{value:"。",paraId:120,tocIndex:57},{value:" ",paraId:121,tocIndex:58},{value:"String",paraId:121,tocIndex:58},{value:" ",paraId:121,tocIndex:58},{value:"optional",paraId:121,tocIndex:58},{value:" ",paraId:121,tocIndex:58},{value:"设置为小型大写字母字体。对应 ",paraId:122,tocIndex:58},{value:"font-variant",paraId:122,tocIndex:58},{value:"。",paraId:122,tocIndex:58},{value:" ",paraId:123,tocIndex:59},{value:"Number",paraId:123,tocIndex:59},{value:" ",paraId:123,tocIndex:59},{value:"optional",paraId:123,tocIndex:59},{value:" ",paraId:123,tocIndex:59},{value:"字体粗细。对应 ",paraId:124,tocIndex:59},{value:"font-weight",paraId:124,tocIndex:59},{value:"。",paraId:124,tocIndex:59},{value:" ",paraId:125,tocIndex:60},{value:"Number",paraId:125,tocIndex:60},{value:" ",paraId:125,tocIndex:60},{value:"optional",paraId:125,tocIndex:60},{value:" ",paraId:125,tocIndex:60},{value:"字体大小。对应 ",paraId:126,tocIndex:60},{value:"font-size",paraId:126,tocIndex:60},{value:"。",paraId:126,tocIndex:60},{value:" ",paraId:127,tocIndex:61},{value:"String",paraId:127,tocIndex:61},{value:" ",paraId:127,tocIndex:61},{value:"optional",paraId:127,tocIndex:61},{value:" ",paraId:127,tocIndex:61},{value:"字体系列。对应 ",paraId:128,tocIndex:61},{value:"font-family",paraId:128,tocIndex:61},{value:"。",paraId:128,tocIndex:61},{value:" ",paraId:129,tocIndex:62},{value:"Number",paraId:129,tocIndex:62},{value:" ",paraId:129,tocIndex:62},{value:"optional",paraId:129,tocIndex:62},{value:" ",paraId:129,tocIndex:62},{value:"行高。对应 ",paraId:130,tocIndex:62},{value:"line-height",paraId:130,tocIndex:62},{value:"。",paraId:130,tocIndex:62},{value:"仅在 Graph 的 ",paraId:131,tocIndex:63},{value:"renderer",paraId:131,tocIndex:63},{value:" 为 ",paraId:131,tocIndex:63},{value:"'svg'",paraId:131,tocIndex:63},{value:" 时可以使用。",paraId:131,tocIndex:63},{value:"⚠️ 注意:",paraId:132,tocIndex:63},{value:"只支持原生 HTML DOM，不支持各类 react、vue 组件；",paraId:133,tocIndex:63},{value:"使用 ",paraId:133,tocIndex:63},{value:"'dom'",paraId:133,tocIndex:63},{value:" 进行自定义的节点或边，不支持 G6 的交互事件，请使用原生 DOM 的交互事件；",paraId:133,tocIndex:63},{value:"在 Safari 中，若 dom 节点被设置了 ",paraId:133,tocIndex:63},{value:"position:relative",paraId:133,tocIndex:63},{value:"，将会导致渲染异常。该问题与 ",paraId:133,tocIndex:63},{value:"Safari 的 foreignObject bug",paraId:133,tocIndex:63},{value:" 有关。",paraId:133,tocIndex:63},{value:"Issus",paraId:133,tocIndex:63},{value:"。",paraId:133,tocIndex:63},{value:'group.addShape(\'dom\', {\n  attrs: {\n    width: cfg.size[0],\n    height: cfg.size[1],\n    // DOM\'s html\n    html: `\n    <div style="background-color: #fff; border: 2px solid #5B8FF9; border-radius: 5px; width: ${\n      cfg.size[0] - 5\n    }px; height: ${cfg.size[1] - 5}px; display: flex;">\n      <div style="height: 100%; width: 33%; background-color: #CDDDFD">\n        <img alt="img" style="line-height: 100%; padding-top: 6px; padding-left: 8px;" src="https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*Q_FQT6nwEC8AAAAAAAAAAABkARQnAQ" width="20" height="20" />  \n      </div>\n      <span style="margin:auto; padding:auto; color: #5B8FF9">${cfg.label}</span>\n    </div>\n      `,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: \'dom-shape\',\n  draggable: true,\n});\n',paraId:134,tocIndex:63},{value:" ",paraId:135,tocIndex:64},{value:"String",paraId:135,tocIndex:64},{value:" ",paraId:135,tocIndex:64},{value:"optional",paraId:135,tocIndex:64},{value:" ",paraId:135,tocIndex:64},{value:"DOM 的 HTML 值。",paraId:136,tocIndex:64}]},92739:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"紧凑盒树布局。这是树图的默认布局，其特点是布局时统合考虑每个树节点的包围盒，由经典的 ",paraId:0},{value:"Reingold–Tilford tidy 布局算法",paraId:0},{value:"演进而来，适合于脑图等应用场景。",paraId:0},{value:"类型",paraId:1,tocIndex:0},{value:"：String",paraId:1,tocIndex:0},{value:"可选值",paraId:1,tocIndex:0},{value:"：'LR' | 'RL' | 'TB' | 'BT' | 'H' | 'V'",paraId:1,tocIndex:0},{value:"默认值",paraId:1,tocIndex:0},{value:"：'LR'",paraId:1,tocIndex:0},{value:"是否必须",paraId:1,tocIndex:0},{value:"：false",paraId:1,tocIndex:0},{value:"说明",paraId:1,tocIndex:0},{value:"：树布局的方向，其他选项说明",paraId:1,tocIndex:0},{value:"TB —— 根节点在上，往下布局",paraId:2,tocIndex:0},{value:"BT —— 根节点在下，往上布局",paraId:3,tocIndex:0},{value:"LR —— 根节点在左，往右布局",paraId:4,tocIndex:0},{value:"RL —— 根节点在右，往左布局",paraId:5,tocIndex:0},{value:"H —— 根节点在中间，水平对称布局",paraId:6,tocIndex:0},{value:"V —— 根节点在中间，垂直对称布局",paraId:7,tocIndex:0},{value:"类型",paraId:8,tocIndex:1},{value:"：Function",paraId:8,tocIndex:1},{value:"示例",paraId:8,tocIndex:1},{value:"：",paraId:8,tocIndex:1},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'test-child-id') return 'right';\n  return 'left';\n};\n",paraId:9,tocIndex:1},{value:"默认值",paraId:10,tocIndex:1},{value:"：'right'",paraId:10,tocIndex:1},{value:"是否必须",paraId:10,tocIndex:1},{value:"：false",paraId:10,tocIndex:1},{value:"说明",paraId:10,tocIndex:1},{value:"：节点排布在根节点的左侧/右侧。若设置了该值，则所有节点会在根节点同一侧，即 direction = 'H' 不再起效。若该参数为回调函数，则可以指定每一个节点在根节点的左/右侧。",paraId:10,tocIndex:1},{value:"类型",paraId:11,tocIndex:2},{value:": Function",paraId:11,tocIndex:2},{value:"示例",paraId:11,tocIndex:2},{value:":",paraId:11,tocIndex:2},{value:"(d) => {\n  // d is a node\n  return d.id + '_node';\n};\n",paraId:12,tocIndex:2},{value:"是否必须",paraId:13,tocIndex:2},{value:": false",paraId:13,tocIndex:2},{value:"说明",paraId:13,tocIndex:2},{value:": 节点 id 的回调函数",paraId:13,tocIndex:2},{value:"类型",paraId:14,tocIndex:3},{value:"：Number | Function",paraId:14,tocIndex:3},{value:"示例",paraId:14,tocIndex:3},{value:"：",paraId:14,tocIndex:3},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:15,tocIndex:3},{value:"是否必须",paraId:16,tocIndex:3},{value:"：false",paraId:16,tocIndex:3},{value:"说明",paraId:16,tocIndex:3},{value:"：每个节点的宽度",paraId:16,tocIndex:3},{value:"类型",paraId:17,tocIndex:4},{value:"：Number | Function",paraId:17,tocIndex:4},{value:"示例",paraId:17,tocIndex:4},{value:"：",paraId:17,tocIndex:4},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:18,tocIndex:4},{value:"是否必须",paraId:19,tocIndex:4},{value:"：false",paraId:19,tocIndex:4},{value:"说明",paraId:19,tocIndex:4},{value:"：每个节点的高度",paraId:19,tocIndex:4},{value:"类型",paraId:20,tocIndex:5},{value:"：Number | Function",paraId:20,tocIndex:5},{value:"示例",paraId:20,tocIndex:5},{value:"：",paraId:20,tocIndex:5},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:21,tocIndex:5},{value:"默认值",paraId:22,tocIndex:5},{value:"：18",paraId:22,tocIndex:5},{value:"是否必须",paraId:22,tocIndex:5},{value:"：false",paraId:22,tocIndex:5},{value:"说明",paraId:22,tocIndex:5},{value:"：每个节点的水平间隙",paraId:22,tocIndex:5},{value:"类型",paraId:23,tocIndex:6},{value:"：Number | Function",paraId:23,tocIndex:6},{value:"示例",paraId:23,tocIndex:6},{value:"：",paraId:23,tocIndex:6},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:24,tocIndex:6},{value:"默认值",paraId:25,tocIndex:6},{value:"：18",paraId:25,tocIndex:6},{value:"是否必须",paraId:25,tocIndex:6},{value:"：false",paraId:25,tocIndex:6},{value:"说明",paraId:25,tocIndex:6},{value:"：每个节点的垂直间隙",paraId:25,tocIndex:6},{value:"类型",paraId:26,tocIndex:7},{value:"：Boolean",paraId:26,tocIndex:7},{value:"默认值",paraId:26,tocIndex:7},{value:"：false",paraId:26,tocIndex:7},{value:"是否必须",paraId:26,tocIndex:7},{value:"：false",paraId:26,tocIndex:7},{value:"说明",paraId:26,tocIndex:7},{value:"：是否按照辐射状布局。若 ",paraId:26,tocIndex:7},{value:"radial",paraId:26,tocIndex:7},{value:" 为 ",paraId:26,tocIndex:7},{value:"true",paraId:26,tocIndex:7},{value:"，建议 ",paraId:26,tocIndex:7},{value:"direction",paraId:26,tocIndex:7},{value:" 设置为 ",paraId:26,tocIndex:7},{value:"'LR'",paraId:26,tocIndex:7},{value:" 或 ",paraId:26,tocIndex:7},{value:"'RL'",paraId:26,tocIndex:7},{value:"：",paraId:26,tocIndex:7}]},32749:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"生态树",paraId:0},{value:"布局的特点是所有子节点布局在同一层级，不考虑节点大小，每个节点被当成 1px 处理。适用于表示层次聚类。",paraId:0},{value:"类型",paraId:1,tocIndex:0},{value:"：String",paraId:1,tocIndex:0},{value:"可选值",paraId:1,tocIndex:0},{value:"：'LR' | 'RL' | 'TB' | 'BT' | 'H' | 'V'",paraId:1,tocIndex:0},{value:"默认值",paraId:1,tocIndex:0},{value:"：'LR'",paraId:1,tocIndex:0},{value:"是否必须",paraId:1,tocIndex:0},{value:"：false",paraId:1,tocIndex:0},{value:"说明",paraId:1,tocIndex:0},{value:"：树布局的方向，默认为 ",paraId:1,tocIndex:0},{value:"'LR'",paraId:1,tocIndex:0},{value:"，其他选项说明",paraId:1,tocIndex:0},{value:"TB —— 根节点在上，往下布局",paraId:2,tocIndex:0},{value:"BT —— 根节点在下，往上布局",paraId:3,tocIndex:0},{value:"LR —— 根节点在左，往右布局",paraId:4,tocIndex:0},{value:"RL —— 根节点在右，往左布局",paraId:5,tocIndex:0},{value:"H —— 根节点在中间，水平对称布局",paraId:6,tocIndex:0},{value:"V —— 根节点在中间，垂直对称布局",paraId:7,tocIndex:0},{value:"类型",paraId:8,tocIndex:1},{value:"：Number",paraId:8,tocIndex:1},{value:"默认值",paraId:8,tocIndex:1},{value:"：0",paraId:8,tocIndex:1},{value:"是否必须",paraId:8,tocIndex:1},{value:"：false",paraId:8,tocIndex:1},{value:"说明",paraId:8,tocIndex:1},{value:"：节点间距",paraId:8,tocIndex:1},{value:"类型",paraId:9,tocIndex:2},{value:"：Number",paraId:9,tocIndex:2},{value:"默认值",paraId:9,tocIndex:2},{value:"：0",paraId:9,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"：false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:"：层与层之间的间距",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"：Boolean",paraId:10,tocIndex:3},{value:"默认值",paraId:10,tocIndex:3},{value:"：false",paraId:10,tocIndex:3},{value:"是否必须",paraId:10,tocIndex:3},{value:"：false",paraId:10,tocIndex:3},{value:"说明",paraId:10,tocIndex:3},{value:"：是否按照辐射状布局。若 ",paraId:10,tocIndex:3},{value:"radial",paraId:10,tocIndex:3},{value:" 为 ",paraId:10,tocIndex:3},{value:"true",paraId:10,tocIndex:3},{value:"，建议 ",paraId:10,tocIndex:3},{value:"direction",paraId:10,tocIndex:3},{value:" 设置为 ",paraId:10,tocIndex:3},{value:"'LR'",paraId:10,tocIndex:3},{value:" 或 ",paraId:10,tocIndex:3},{value:"'RL'",paraId:10,tocIndex:3},{value:"：",paraId:10,tocIndex:3}]},83597:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"与 ",paraId:0,tocIndex:0},{value:"Graph 的布局",paraId:1,tocIndex:0},{value:" 类似，G6 为树图 TreeGraph 提供了一些内置布局算法。可以在",paraId:0,tocIndex:0},{value:"实例化图时配置",paraId:2,tocIndex:0},{value:"。与 ",paraId:0,tocIndex:0},{value:"Graph 的布局",paraId:3,tocIndex:0},{value:" 不同的是：",paraId:0,tocIndex:0},{value:"实例化树图时必须通过配置 ",paraId:4,tocIndex:0},{value:"layout",paraId:4,tocIndex:0},{value:" 配置布局，而 Graph 不配置 ",paraId:4,tocIndex:0},{value:"layout",paraId:4,tocIndex:0},{value:" 时将会使用数据中的位置信息或随机布局；",paraId:4,tocIndex:0},{value:"树图布局不支持独立使用；",paraId:4,tocIndex:0},{value:"树图布局不支持自定义。",paraId:4,tocIndex:0},{value:"注意，Graph 布局与 TreeGaph 布局相互不通用。",paraId:5,tocIndex:0},{value:"G6 的内置树图布局有：",paraId:6,tocIndex:0},{value:"CompactBox 紧凑树布局",paraId:7,tocIndex:0},{value:"Dendrogram 生态树布局",paraId:8,tocIndex:0},{value:"Indented 缩进树布局",paraId:9,tocIndex:0},{value:"Mindmap 脑图树布局",paraId:10,tocIndex:0},{value:"const graph = new G6.TreeGraph({\n  // ...                      // 其他配置项\n  layout: {                // Object，对于 TreeGraph 为必须字段\n    type: 'dendrogram',\n    ...                    // 布局的其他配置\n  }\n});\n",paraId:11,tocIndex:1},{value:"每种布局方法的配置项不尽相同，具体参见本目录下每种布局的 API。",paraId:12,tocIndex:1},{value:"名称",paraId:13,tocIndex:2},{value:"类型",paraId:13,tocIndex:2},{value:"默认值",paraId:13,tocIndex:2},{value:"描述",paraId:13,tocIndex:2},{value:"type",paraId:13,tocIndex:2},{value:"String",paraId:13,tocIndex:2},{value:"dendrogram",paraId:13,tocIndex:2},{value:"布局类型，支持 dendrogram、compactBox、mindmap 和 indented。",paraId:13,tocIndex:2},{value:"excludeInvisibles",paraId:13,tocIndex:2},{value:"Boolean",paraId:13,tocIndex:2},{value:"false",paraId:13,tocIndex:2},{value:"v4.8.8 起支持。",paraId:13,tocIndex:2},{value:" 布局计算是否排除掉隐藏的节点，若配置为 true，则隐藏节点不参与布局计算。",paraId:13,tocIndex:2},{value:"direction",paraId:13,tocIndex:2},{value:"String",paraId:13,tocIndex:2},{value:"LR",paraId:13,tocIndex:2},{value:"布局方向，有  ",paraId:13,tocIndex:2},{value:"LR",paraId:13,tocIndex:2},{value:" , ",paraId:13,tocIndex:2},{value:"RL",paraId:13,tocIndex:2},{value:" , ",paraId:13,tocIndex:2},{value:"TB",paraId:13,tocIndex:2},{value:" , ",paraId:13,tocIndex:2},{value:"BT",paraId:13,tocIndex:2},{value:" , ",paraId:13,tocIndex:2},{value:"H",paraId:13,tocIndex:2},{value:" , ",paraId:13,tocIndex:2},{value:"V",paraId:13,tocIndex:2},{value:"  可选。",paraId:13,tocIndex:2},{value:"L：左；R：右；T：上；B：下；H：垂直；V：水平。",paraId:13,tocIndex:2},{value:"getChildren",paraId:13,tocIndex:2},{value:"Function",paraId:13,tocIndex:2},{value:"返回当前节点的所有子节点",paraId:13,tocIndex:2},{value:"⚠️ 注意:",paraId:14,tocIndex:2},{value:" 当 ",paraId:14,tocIndex:2},{value:"type='indented'",paraId:14,tocIndex:2},{value:" 时，",paraId:14,tocIndex:2},{value:"direction",paraId:14,tocIndex:2},{value:" 只能取 ",paraId:14,tocIndex:2},{value:"'LR'",paraId:14,tocIndex:2},{value:"、",paraId:14,tocIndex:2},{value:"'RL'",paraId:14,tocIndex:2},{value:" 和 ",paraId:14,tocIndex:2},{value:"'H'",paraId:14,tocIndex:2},{value:" 这三个值。",paraId:14,tocIndex:2}]},27572:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"缩进树布局。树节点的层级通过水平方向的缩进量来表示。每个元素会占一行/一列。常用场景是文件目录结构。",paraId:0},{value:"类型",paraId:1,tocIndex:0},{value:"：String",paraId:1,tocIndex:0},{value:"可选值",paraId:1,tocIndex:0},{value:"：'LR' | 'RL' | 'H'",paraId:1,tocIndex:0},{value:"默认值",paraId:1,tocIndex:0},{value:"：'LR'",paraId:1,tocIndex:0},{value:"是否必须",paraId:1,tocIndex:0},{value:"：false",paraId:1,tocIndex:0},{value:"说明",paraId:1,tocIndex:0},{value:"：树布局的方向，默认为 ",paraId:1,tocIndex:0},{value:"'LR'",paraId:1,tocIndex:0},{value:"，其他选项说明：",paraId:1,tocIndex:0},{value:"LR —— 根节点在左，往右布局（下图左）",paraId:2,tocIndex:0},{value:"RL —— 根节点在右，往左布局（下图中）",paraId:2,tocIndex:0},{value:"H —— 根节点在中间，水平对称布局（下图右）",paraId:2,tocIndex:0},{value:"（左）LR。（中）RL。（右）H。",paraId:3,tocIndex:0},{value:"类型",paraId:4,tocIndex:1},{value:"：Number | Function",paraId:4,tocIndex:1},{value:"默认值",paraId:4,tocIndex:1},{value:"：20",paraId:4,tocIndex:1},{value:"示例",paraId:4,tocIndex:1},{value:"：",paraId:4,tocIndex:1},{value:"(d) => {\n  // d 是一个节点\n  if (d.parent?.id === 'testId') return d.parent.x + 50;\n  return 100;\n};\n",paraId:5,tocIndex:1},{value:"是否必须",paraId:6,tocIndex:1},{value:"：false",paraId:6,tocIndex:1},{value:"说明",paraId:6,tocIndex:1},{value:"：类型为Number时，列间间距是固定值；类型为Function时，节点与根结点的间距是函数返回值。",paraId:6,tocIndex:1},{value:"类型",paraId:7,tocIndex:2},{value:"：Number | Function",paraId:7,tocIndex:2},{value:"示例",paraId:7,tocIndex:2},{value:"：",paraId:7,tocIndex:2},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:8,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"：false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:"：每个节点的宽度，",paraId:9,tocIndex:2},{value:"direction",paraId:9,tocIndex:2},{value:" 为 ",paraId:9,tocIndex:2},{value:"'H'",paraId:9,tocIndex:2},{value:" 时有效",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"：Number | Function",paraId:10,tocIndex:3},{value:"示例",paraId:10,tocIndex:3},{value:"：",paraId:10,tocIndex:3},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:11,tocIndex:3},{value:"是否必须",paraId:12,tocIndex:3},{value:"：false",paraId:12,tocIndex:3},{value:"说明",paraId:12,tocIndex:3},{value:"：每个节点的高度",paraId:12,tocIndex:3},{value:"类型",paraId:13,tocIndex:4},{value:"：Function",paraId:13,tocIndex:4},{value:"示例",paraId:13,tocIndex:4},{value:"：",paraId:13,tocIndex:4},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 'left';\n  return 'right';\n};\n",paraId:14,tocIndex:4},{value:"类型",paraId:15,tocIndex:5},{value:"：Boolean",paraId:15,tocIndex:5},{value:"是否必须",paraId:16,tocIndex:5},{value:"：false",paraId:16,tocIndex:5},{value:"说明",paraId:17,tocIndex:5},{value:"：每个节点的第一个自节点是否位于下一行。默认为 ",paraId:17,tocIndex:5},{value:"true",paraId:17,tocIndex:5},{value:"是否必须",paraId:18,tocIndex:5},{value:"：false",paraId:18,tocIndex:5},{value:"说明",paraId:18,tocIndex:5},{value:"：节点放置在根节点左侧或右侧的回调函数，仅对与根节点直接相连的节点有效，设置后将会影响被设置节点的所有子孙节点。",paraId:18,tocIndex:5}]},81198:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"深度相同的节点将会被放置在同一层，与 compactBox 不同的是，布局不会考虑节点的大小。",paraId:0},{value:"类型",paraId:1,tocIndex:0},{value:"：String",paraId:1,tocIndex:0},{value:"可选值",paraId:1,tocIndex:0},{value:"：'H' | 'V'",paraId:1,tocIndex:0},{value:"默认值",paraId:1,tocIndex:0},{value:"：'H'",paraId:1,tocIndex:0},{value:"是否必须",paraId:1,tocIndex:0},{value:"：false",paraId:1,tocIndex:0},{value:"说明",paraId:1,tocIndex:0},{value:"：树布局的方向，默认为 ",paraId:1,tocIndex:0},{value:"'H'",paraId:1,tocIndex:0},{value:"，其他选项说明",paraId:1,tocIndex:0},{value:"H：horizontal（水平）—— 根节点的子节点分成两部分横向放置在根节点左右两侧",paraId:2,tocIndex:0},{value:"V：vertical （竖直）—— 将根节点的所有孩子纵向排列",paraId:3,tocIndex:0},{value:"类型",paraId:4,tocIndex:1},{value:"：Number | Function",paraId:4,tocIndex:1},{value:"示例",paraId:4,tocIndex:1},{value:"：",paraId:4,tocIndex:1},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:5,tocIndex:1},{value:"是否必须",paraId:6,tocIndex:1},{value:"：false",paraId:6,tocIndex:1},{value:"说明",paraId:6,tocIndex:1},{value:"：每个节点的宽度",paraId:6,tocIndex:1},{value:"类型",paraId:7,tocIndex:2},{value:"：Number | Function",paraId:7,tocIndex:2},{value:"示例",paraId:7,tocIndex:2},{value:"：",paraId:7,tocIndex:2},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:8,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"：false",paraId:9,tocIndex:2},{value:"说明",paraId:9,tocIndex:2},{value:"：每个节点的高度",paraId:9,tocIndex:2},{value:"类型",paraId:10,tocIndex:3},{value:"：Number | Function",paraId:10,tocIndex:3},{value:"示例",paraId:10,tocIndex:3},{value:"：",paraId:10,tocIndex:3},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:11,tocIndex:3},{value:"默认值",paraId:12,tocIndex:3},{value:"：18",paraId:12,tocIndex:3},{value:"是否必须",paraId:12,tocIndex:3},{value:"：false",paraId:12,tocIndex:3},{value:"说明",paraId:12,tocIndex:3},{value:"：每个节点的水平间隙",paraId:12,tocIndex:3},{value:"类型",paraId:13,tocIndex:4},{value:"：Number | Function",paraId:13,tocIndex:4},{value:"示例",paraId:13,tocIndex:4},{value:"：",paraId:13,tocIndex:4},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'testId') return 50;\n  return 100;\n};\n",paraId:14,tocIndex:4},{value:"默认值",paraId:15,tocIndex:4},{value:"：18",paraId:15,tocIndex:4},{value:"是否必须",paraId:15,tocIndex:4},{value:"：false",paraId:15,tocIndex:4},{value:"说明",paraId:15,tocIndex:4},{value:"：每个节点的垂直间隙",paraId:15,tocIndex:4},{value:"类型",paraId:16,tocIndex:5},{value:"：Function",paraId:16,tocIndex:5},{value:"示例",paraId:16,tocIndex:5},{value:"：",paraId:16,tocIndex:5},{value:"(d) => {\n  // d 是一个节点\n  if (d.id === 'test-child-id') return 'right';\n  return 'left';\n};\n",paraId:17,tocIndex:5},{value:"默认值",paraId:18,tocIndex:5},{value:"：'right'",paraId:18,tocIndex:5},{value:"是否必须",paraId:18,tocIndex:5},{value:"：false",paraId:18,tocIndex:5},{value:"说明",paraId:18,tocIndex:5},{value:"：节点排布在根节点的左侧/右侧。若设置了该值，则所有节点会在根节点同一侧，即 direction = 'H' 不再起效。若该参数为回调函数，则可以指定每一个节点在根节点的左/右侧。",paraId:18,tocIndex:5}]},8008:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在指定的父节点下添加子树。",paraId:0,tocIndex:1},{value:"⚠️ 注意:",paraId:1,tocIndex:1},{value:" 将会直接使用 ",paraId:1,tocIndex:1},{value:"data",paraId:1,tocIndex:1},{value:" 对象作为新增节点/边的数据模型，G6 内部可能会对其增加或修改一些必要的字段。若不希望原始参数被修改，建议在使用深拷贝后的 ",paraId:1,tocIndex:1},{value:"data",paraId:1,tocIndex:1},{value:"。",paraId:1,tocIndex:1},{value:"参数",paraId:2,tocIndex:1},{value:"名称",paraId:3,tocIndex:1},{value:"类型",paraId:3,tocIndex:1},{value:"是否必选",paraId:3,tocIndex:1},{value:"描述",paraId:3,tocIndex:1},{value:"data",paraId:3,tocIndex:1},{value:"Object",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:"子树的数据",paraId:3,tocIndex:1},{value:"parent",paraId:3,tocIndex:1},{value:"Node",paraId:3,tocIndex:1},{value:"String",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:"用法",paraId:4,tocIndex:1},{value:"const data = {\n  id: 'sub1',\n  children: [\n    {\n      id: 'subTree1',\n      children: [...]\n    },\n    {\n      id: 'subTree2',\n      children: [...]\n    }\n  ]\n};\n\ntreeGraph.addChild(data, 'root')\n",paraId:5,tocIndex:1},{value:"更新数据，差量更新子树。data 是一个子树数据。若该子树的根节点不存在与当前树数据中，将该子树添加到 parentId 节点的子节点中。若该子树的根节点已经存在，则更新该子树数据。若希望更新或增加 parentId 节点下所有子节点，请使用 ",paraId:6,tocIndex:2},{value:"updateChildren",paraId:7,tocIndex:2},{value:"。二者区别图示如下： ",paraId:6,tocIndex:2},{value:" ",paraId:6,tocIndex:2},{value:"参数",paraId:8,tocIndex:2},{value:"名称",paraId:9,tocIndex:2},{value:"类型",paraId:9,tocIndex:2},{value:"是否必选",paraId:9,tocIndex:2},{value:"描述",paraId:9,tocIndex:2},{value:"data",paraId:9,tocIndex:2},{value:"TreeData",paraId:9,tocIndex:2},{value:"true",paraId:9,tocIndex:2},{value:"子树的数据",paraId:9,tocIndex:2},{value:"parentId",paraId:9,tocIndex:2},{value:"String",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"父节点 ID",paraId:9,tocIndex:2},{value:"⚠️ 注意:",paraId:10,tocIndex:2},{value:" 当 ",paraId:10,tocIndex:2},{value:"parentId",paraId:10,tocIndex:2},{value:" 参数为空时，则全量更新。",paraId:10,tocIndex:2},{value:"用法",paraId:11,tocIndex:2},{value:"const data = {\n  id: 'sub1',\n  children: [\n    {\n      id: 'subTree1',\n      children: [...]\n    },\n    {\n      id: 'subTree2',\n      children: [...]\n    }\n  ]\n};\n\ntreeGraph.updateChild(data, 'root')\n",paraId:12,tocIndex:2},{value:"更新数据，差量更新子树中的所有子节点。data 是一个子树数据数组。若希望更新或增加一个 parentId 节点的子节点，请使用 ",paraId:13,tocIndex:3},{value:"updateChild",paraId:14,tocIndex:3},{value:"。二者区别图示如下： ",paraId:13,tocIndex:3},{value:" ",paraId:13,tocIndex:3},{value:" ",paraId:13,tocIndex:3},{value:"参数",paraId:15,tocIndex:3},{value:"名称",paraId:16,tocIndex:3},{value:"类型",paraId:16,tocIndex:3},{value:"是否必选",paraId:16,tocIndex:3},{value:"描述",paraId:16,tocIndex:3},{value:"data",paraId:16,tocIndex:3},{value:"TreeData[]",paraId:16,tocIndex:3},{value:"true",paraId:16,tocIndex:3},{value:"子树的数据数组",paraId:16,tocIndex:3},{value:"parentId",paraId:16,tocIndex:3},{value:"String",paraId:16,tocIndex:3},{value:"true",paraId:16,tocIndex:3},{value:"父节点 ID",paraId:16,tocIndex:3},{value:"用法",paraId:17,tocIndex:3},{value:"const data = [\n  {\n    id: 'subTree1',\n    children: [...]\n  },\n  {\n    id: 'subTree2',\n    children: [...]\n  }\n];\n\ntreeGraph.updateChildren(data, 'root')\n",paraId:18,tocIndex:3},{value:"删除指定的子树。",paraId:19,tocIndex:4},{value:"参数",paraId:20,tocIndex:4},{value:"名称",paraId:21,tocIndex:4},{value:"类型",paraId:21,tocIndex:4},{value:"是否必选",paraId:21,tocIndex:4},{value:"描述",paraId:21,tocIndex:4},{value:"id",paraId:21,tocIndex:4},{value:"String",paraId:21,tocIndex:4},{value:"true",paraId:21,tocIndex:4},{value:"要删除的子树的 ID",paraId:21,tocIndex:4},{value:"用法",paraId:22,tocIndex:4},{value:"treeGraph.removeChild('sub');\n",paraId:23,tocIndex:4},{value:"更改并应用指定的布局。",paraId:24,tocIndex:6},{value:"参数",paraId:25,tocIndex:6},{value:"名称",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"是否必选",paraId:26,tocIndex:6},{value:"描述",paraId:26,tocIndex:6},{value:"layout",paraId:26,tocIndex:6},{value:"Object",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"指定的布局配置，如不传，则不做变更",paraId:26,tocIndex:6},{value:"用法",paraId:27,tocIndex:6},{value:"const layout = {\n  type: 'mindmap',\n  direction: 'H',\n  getSubTreeSep: () => 20,\n  getVGap: () => 25,\n  getHeight: () => 30,\n  getWidth: () => 30,\n};\ntreeGraph.changeLayout(layout);\n",paraId:28,tocIndex:6},{value:"数据变更后，重新布局，刷新视图，并更新到画布。v4.x 废弃了 ",paraId:29,tocIndex:7},{value:"refreshLayout",paraId:29,tocIndex:7},{value:"，请使用 ",paraId:29,tocIndex:7},{value:"layout",paraId:29,tocIndex:7},{value:" 替代。",paraId:29,tocIndex:7},{value:"参数",paraId:30,tocIndex:7},{value:"名称",paraId:31,tocIndex:7},{value:"类型",paraId:31,tocIndex:7},{value:"是否必选",paraId:31,tocIndex:7},{value:"描述",paraId:31,tocIndex:7},{value:"fitView",paraId:31,tocIndex:7},{value:"Boolean",paraId:31,tocIndex:7},{value:"false",paraId:31,tocIndex:7},{value:"更新布局后，是否需要自适应窗口",paraId:31,tocIndex:7},{value:"用法",paraId:32,tocIndex:7},{value:"treeGraph.layout(true);\n",paraId:33,tocIndex:7},{value:"根据指定的 ID 获取对应的源数据。",paraId:34,tocIndex:9},{value:"参数",paraId:35,tocIndex:9},{value:"名称",paraId:36,tocIndex:9},{value:"类型",paraId:36,tocIndex:9},{value:"是否必选",paraId:36,tocIndex:9},{value:"描述",paraId:36,tocIndex:9},{value:"id",paraId:36,tocIndex:9},{value:"String",paraId:36,tocIndex:9},{value:"true",paraId:36,tocIndex:9},{value:"指定的元素 ID",paraId:36,tocIndex:9},{value:"target",paraId:36,tocIndex:9},{value:"Object",paraId:36,tocIndex:9},{value:"false",paraId:36,tocIndex:9},{value:"从指定的节点开始查找，为空时从根节点开始查找",paraId:36,tocIndex:9},{value:"返回值",paraId:37,tocIndex:9},{value:"返回值类型：Object；",paraId:38,tocIndex:9},{value:"返回值为查找到的节点的源数据。",paraId:38,tocIndex:9},{value:"用法",paraId:39,tocIndex:9},{value:"const target = {\n\tid: 'sub1',\n  children: [...]\n}\n\n// 从 target 节点开始查找 sub1.1 节点\nconst subData = treeGraph.findDataById('sub1.1', target)\n\n// 从根节点开始查找 sub1.1 节点\nconst subData = treeGraph.findDataById('sub1.1')\n",paraId:40,tocIndex:9}]},64678:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在分析网络安全数据时，设备、事件、位置、IP、签名等之间的连接是发现异常、威胁和漏洞的关键。理解这些联系的最好方法就是把它们形象化。今天，在许多大型组织、金融机构和安全咨询服务中都有网络或 IT 的安全要求。这些组织需要保护自己免受如 zero-day 漏洞，DDoS 或网络钓鱼攻击之类漏洞的侵害。他们从服务器、路由器或应用程序日志和网络状态中收集数据，来检测可疑活动。图可视化可以一目了然地展示这些数据并检测可疑模式。通过对连接状态的可视化探索，可以更快速定位漏洞或攻击。 ",paraId:0,tocIndex:0},{value:" 详细案例请参考",paraId:0,tocIndex:0},{value:"《图可视化解决方案：云安全》",paraId:0,tocIndex:0},{value:"。",paraId:0,tocIndex:0},{value:"知识图谱（Knowledge Graph）是一种用图模型来描述知识和建模世界万物之间的关联关系的技术方法。知识图谱将信息中的知识或者数据加以关联，实现人类知识的描述及推理计算，并最终实现像人类一样对事物进行理解与解释，推动了从弱人工智能到强人工智能的发展。知识图谱由节点和边组成。节点可以是实体（如一个人、一个支付设备、一个企业等），也或是抽象的概念-本体类型（如人工智能、事物等）。边可以是本体类型之间的关系，也可以实体与实体之间的关系，如投资关系、支付关系等。图可视化可以更加清晰直观地描述这种结构化的关系，利于看清，是知识图谱领域的做图表示、图分析推理等重要基石。 ",paraId:1,tocIndex:1},{value:" 详细案例请参考",paraId:1,tocIndex:1},{value:"《图可视化解决方案：知识图谱》",paraId:1,tocIndex:1},{value:"。",paraId:1,tocIndex:1},{value:"随着互联网发展和数字化的进程，企业数据在规模上几何增长，越来越多的企业面临信用、合规、声誉、第三方等诸多风险，企业风险控制的需求甚至也扩大到了政府、专业机构等各类细分领域。如何结合各个细分领域、业务场景，利用数据可视化技术，帮助企业更清晰发现和识别风险，从而将数据变成实际可用的风控产品和服务，这是当下企业风控需要解决的一个问题。 ",paraId:2,tocIndex:2},{value:" 详细案例请参考",paraId:2,tocIndex:2},{value:"《图可视化解决方案：企业风控》",paraId:2,tocIndex:2},{value:"。",paraId:2,tocIndex:2},{value:"图数据库领域是最近几年大数据领域热度颇高的领域，从 DB Engines 的排名来看，自 2013 年开始，图数据库的发展就一骑绝尘。与传统关系型数据库不同，图数据技术主要关注数据间关系查询能力，是表示和查询关联关系的最佳方式。借助于图数据库技术:",paraId:3,tocIndex:3},{value:"可以快速从百亿级电商网络中匹配出刷单团伙；",paraId:4,tocIndex:3},{value:"可以快速构建出人与人的社交关系，分析特定用户的人际关系、关注度、转发量等；",paraId:4,tocIndex:3},{value:"把 IP、域名、主机等一些列实体构建成图，可以快速发现诸如木马网络的不安全因素，辅以图分析能力能够很容易对不安全因素进行追根溯源。 ",paraId:4,tocIndex:3},{value:" 详细案例请参考",paraId:4,tocIndex:3},{value:"《图可视化解决方案：图数据库》",paraId:4,tocIndex:3},{value:"。",paraId:4,tocIndex:3}]},55522:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"介绍一个图分析产品会有的常用组件，以及各组件的作用及用法。白皮书中组件相关内容点和边的基础样式是是所有图可视化的基石，要组成一个完成的图分析产品，还需要有各类组件来承担不同的功能。从体验设计的角度来看，常见的组件可分为如下几种类型：",paraId:0},{value:"基础组件：图例、工具栏、右键菜单、视图控制栏、系统日志等",paraId:1},{value:"条件输入：查询、筛选、搜索、画布设置等",paraId:1},{value:"信息输出：详情面板、气泡、Tooltip、画板信息等",paraId:1},{value:"高级功能：时间轴、快照画廊、分析报表等",paraId:1},{value:"在某些特殊场景下，也需要结合业务实际情况基于基础组件去升级优化，乃至基于产品独有的能力去设计全新的组件。在优化一个基础组件或设计全新的组件时，需要结合实际的功能需求，从使用场景、构成元素、常见类型、交互说明等几个角度完整的思考清楚。以 AntV 最新设计的两个组件为例：",paraId:2},{value:"时间轴 TimeBar",paraId:3},{value:"视图控制栏 View ToolBar",paraId:4},{value:"引用自白皮书内容-组件。交互组件，是指用户操作节点，操作边，操作画布，所需要的配套组件。比如 Hover 节点展示出提示框（Tooltip）；点击图例（Legend）对节点筛选；右键节点，弹出菜单（ContextMenu）；对画布进行 放大，缩小，全屏等一套操作工具栏（Toolbar），以及动态改变时间范围，影响画布展示（Timebar）",paraId:5,tocIndex:1},{value:"Legend 图例是一种常见的图分析配套组件，通常将节点 和 边 分类后进行染色，交互分析。其中点击图例，有两种逻辑，一种为 高亮逻辑，即高亮选中的图例所对应的节点，一种是过滤逻辑，即将未选中的节点从画布中过滤。",paraId:6,tocIndex:1},{value:"@antv/graphin-components 提供了 Legend 组件，如下图所示：",paraId:7,tocIndex:1},{value:"Tooltip 提示框是一种快速浏览信息的交互组件，常用于图的节点上，通过鼠标 Hover 产生一个提示框，鼠标移出节点则取消提示框，一般在快速查询信息的时候非常有帮助。",paraId:8,tocIndex:2},{value:"@antv/g6 提供了 tooltip 组件，如下图所示：",paraId:9,tocIndex:2},{value:"ContextMenu 是右键菜单，通常是对节点进行进一步操作的组件。例如：通过右键菜单实现节点的复制，删除，反选等等。同时，我们也可以对选择的节点发起新画布分析，或者进行打标，发起关系扩散，数据请求之类的高级自定义行为。图分析产品中的 右键菜单往往是和 浏览器网页 的右键菜单 交互与展示形式保持一致，但是也有特殊的形状类型，比如右键仪表盘菜单。",paraId:10,tocIndex:3},{value:"@antv/graphin-components 提供了 ContextMenu 组件，如下图所示： ",paraId:11,tocIndex:3},{value:" ",paraId:11,tocIndex:3},{value:"Toolbar 是提供 常见分析操作 的工具栏。内置了撤销重做（操作历史），鱼眼放大镜，画布缩放，全屏，节点聚焦，画布快照下载等等功能。",paraId:12,tocIndex:4},{value:"@antv/graphin-components 提供了 Toolbar 组件，如下图所示：",paraId:13,tocIndex:4},{value:"时间轴是一种针对时间序列的分析组件，根据时间日期的改变，画布的图也相应动态改变，一个功能完备的时间轴，可以配合播放、快进、后退等控制按钮组使用，为用户带来意想不到的分析效果",paraId:14,tocIndex:5},{value:"@antv/g6 提供了 Timebar 组件，如下图所示：",paraId:15,tocIndex:5},{value:"用户查询图数据的组件，一般由特定的 DSL 语言编辑器组成，例如 SQL、Gremlin、Cypher 等，在某些场景下，通过这个查询面板，可以让用户自主加载数据。",paraId:16,tocIndex:7},{value:"筛选面板是对图元素：节点与边的筛选，从而达到减少视觉干扰的效果。",paraId:17,tocIndex:8},{value:"在关系分析过程中，搜索面板可以辅助用户快速定位其需要关心节点、关联关系。减少用户读图时间。",paraId:18,tocIndex:9},{value:"在关系分析中，节点、边的属性信息量较大，很难把所有信息都在画布中呈现。除了关键属性信息，其他属性信息可以通过属性面板的交互方式呈现给用户",paraId:19,tocIndex:10},{value:"后分析组件：顾名思义是 画布分析后的分析组件。通常来讲，我们的图分析默认都是在画布区域分析，当一个图已经分析完毕，我们需要对分析结果进行增强，或者保存分享给其他人进行二次分析，这部分能力往往也是图分析产品所应该具备的系统能力。我们梳理出来 3 个后分析组件：注解组件，快照画廊，分析报表。",paraId:20,tocIndex:11},{value:"能够对画布的分析结果进行标注：可以使用圈选，拉索 对分析结果的图片进行区域内容选择，使用文本标注，标注内容可以按照时间轴存储。",paraId:21,tocIndex:12},{value:"技术上，社区有开源的 d3-annotation，可以轻松实现注解功能。下图是一个分组备注案例",paraId:22,tocIndex:12},{value:"快照画廊：是由一系列分析结果快照保存组成的事件长廊，我们形象称之为快照画廊：与传统单一的快照功能相比，快照画廊能够将片断的分析快照保存在系统上，以供分析师能够回看和二次分析。相比 Toolbar 工具栏里的“撤销回退”功能，快照画廊更佳可视化，与分析系统集成度更佳。",paraId:23,tocIndex:13},{value:"技术上，@antv/g6 提供 save image 功能，配合 gallery 功能特性。",paraId:24,tocIndex:13},{value:"一个中心明确，内容清晰的分析报表能够节省决策者读懂报表内容的时间。图分析报表除了能使用静态图片加内容注解方式的方式呈现给决策者之外，可以使用 IFrame 的方式内嵌的三方报表系统中，是分析结果具有一定的可交互性，从而帮助决策者更好的理解报表内容。",paraId:25,tocIndex:14},{value:"系统组件是指可视化分析系统中需要的一些组件，比如分析过程产生的日志（SystemLog），原始数据表格的展示（TableMode），以及画布的实时状态信息（CanvasInfo）和画布的用户设置项（CanvasSetting）",paraId:26,tocIndex:15},{value:"关系分析的分析过程是一个反复与后端系统进行交互的过程，一个设计完善、内容清晰的系统日志组件能够帮助用户迅速定位问题。",paraId:27,tocIndex:16},{value:"表格模式虽然不能直观展示图中关联关系，但是对于罗列点、边属性信息有较大优势，可以作为分析能力的一个补充。",paraId:28,tocIndex:17},{value:"画布设置，可以设置画布元素的颜色，大小，类型，从而达到最佳的展示效果。",paraId:29,tocIndex:18},{value:"统计画布的实时信息，比如统计当前画布的节点数量，边数量，在一些持续性布局中，比如力导，还可以提供布局时间与进度。在一些大图场景下，还需要监控浏览器的内存，网络等系统监控信息。",paraId:30,tocIndex:19}]},33618:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"时间轴组件基于普通缩略轴演变而来，它是有效展示动态时序数据、分析图数据的组件。该组件可以让用户快速、直观地观察事件序列以及它们之间的联系。用户可以播放时间来发现异常和探寻模式，推动调查并揭示数据中隐藏的故事。",paraId:0,tocIndex:0},{value:"如果需要观察一定时间内图数据的演变情况，分析变化趋势时，建议开启时间轴组件。例：在金融风控领域，保险公司和金融机构的反欺诈人员通过图可视化分析三个月内的案件情况，时间轴组件可以帮助快速分析可疑人脉、财务转账关系，定位嫌疑人。",paraId:1,tocIndex:1},{value:"该时间轴包括但不限于折线图、面积图、柱状图中的一种或多种组合用来表示某种数据属性趋势的时间轴组件，",paraId:2,tocIndex:3},{value:"查看演示 Demo",paraId:2,tocIndex:3},{value:"。",paraId:2,tocIndex:3},{value:"相对于趋势图时间轴而言，去掉了表示数据趋势的图表，使用更为简洁的线条来表示时间范围，",paraId:3,tocIndex:4},{value:"查看演示 Demo",paraId:3,tocIndex:4},{value:"。",paraId:3,tocIndex:4},{value:"指表示时间刻度的时间轴组件，",paraId:4,tocIndex:5},{value:"查看演示 Demo",paraId:4,tocIndex:5},{value:"。",paraId:4,tocIndex:5},{value:"时间轴组件主体分为三部分，2、3 部分需同时出现或隐藏。",paraId:5,tocIndex:6},{value:"缩略轴：可配置成趋势图时间轴、简版时间轴、时间刻度时间轴；",paraId:6,tocIndex:6},{value:"播放器：播放时间动画，可配置是否显示；",paraId:6,tocIndex:6},{value:"时间配置：可配置播放速度、是否只看单一时间点；",paraId:6,tocIndex:6},{value:"时间轴作为辅助组件，建议放在图形区下方。",paraId:7,tocIndex:7},{value:"支持拖拽、点击、平移改变时间范围。",paraId:8,tocIndex:9},{value:"简版时间轴、时间刻度时间轴交互操作同上。鼠标滚轮滚动时，左右平移已选定区间，暂不支持触控版操作。",paraId:9,tocIndex:9},{value:"轴上数值文本内置自动躲避规则。",paraId:10,tocIndex:9},{value:"播放器主要包括三部分，其中播放、暂停按钮动作及状态相互切换。",paraId:11,tocIndex:10},{value:"\n播放方式，分两种：\n- 累计时间段数据：开始时间不变，结束时间持续增加，适合查看从一个时间点开始，持续观察累计变化趋势；\n- 区间时间段数据：开始到结束时间的区间段固定不变，播放时该时间段水平移动，适合查看固定时间段内的数据变化趋势；\n",paraId:12},{value:"时间配置主要包括两部分，单一时间开关、播放速度设置。",paraId:13,tocIndex:11},{value:"单一时间开关，默认不开启。 ",paraId:14,tocIndex:11},{value:" ",paraId:14,tocIndex:11},{value:" ",paraId:14,tocIndex:11},{value:"播放速度设置，默认配速为最慢速 1，最大速为 5。支持滚轮（触控板）滑动切换配速，每次增减值为 1。 ",paraId:14,tocIndex:11},{value:" ",paraId:14,tocIndex:11}]},31360:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"\n视图控制栏是用户与数据进行交互的载体，当用户操作视图工具栏时，可对视图可视区间缩放、平移、对数据进行检索、过滤等。\n",paraId:0},{value:"以下两种情况，建议设计时开启视图控制栏。",paraId:1,tocIndex:1},{value:"数据绘制区域超过屏幕可视区域，为方便用户能以全局视角观察数据，建议开启视图控制栏。例：地图上的视图控制栏；",paraId:2,tocIndex:1},{value:"用户需要频繁与视图上的数据进行交互，比如放大、缩小视图空间，快速定位检索数据点等。例：公安通过关系网核查犯罪嫌疑人；",paraId:2,tocIndex:1},{value:"以下每组元素都为选配项",paraId:3,tocIndex:2},{value:"搜索；",paraId:4,tocIndex:2},{value:"画布控制按钮组：+、—、百分比、Mini Map 迷你视图（可选配）；",paraId:4,tocIndex:2},{value:"自定义组：可定制视图工具栏按钮，比如全屏、定位当前位置等操作。",paraId:4,tocIndex:2},{value:"z-index 层级：层级高于画布，但低于视图中的 Tooltip 提示信息组件；",paraId:5,tocIndex:4},{value:"水平边距：距两边边距均为 8 的倍数；",paraId:5,tocIndex:4},{value:"位置：视布局需要，八个方向均可配置。",paraId:5,tocIndex:4},{value:"键盘操作：输入后，enter 执行搜索操作，按键盘 esc 可退出搜索框，搜索恢复 normal 态。",paraId:6,tocIndex:6},{value:"点击“+”，0 以上默认增幅 25%，100% 以上默认增幅 50%，建议最大值 200%；",paraId:7,tocIndex:7},{value:"点击”—“，100%~200% 之间，默认降幅 50%，100% 以下默认降幅 25%，建议早小值 25%；",paraId:7,tocIndex:7},{value:"百分比字体：Roboto Condensed；",paraId:7,tocIndex:7},{value:"键盘操作：按 esc 可退出已激活的下拉框。",paraId:7,tocIndex:7},{value:"键盘操作：按 esc 可退出已显示的 Minimap。",paraId:8,tocIndex:8},{value:"建议视图控制栏按钮按照格式塔原理分组显示。",paraId:9,tocIndex:10},{value:"画布初始位置，建议符合从左至右，从上至下的阅读习惯，而不是一刀切显示视图的正中间。比如：",paraId:10,tocIndex:11},{value:"思维导图建议贴左，垂直居中；",paraId:11,tocIndex:11},{value:"关系图将起始节点居中显示；",paraId:11,tocIndex:11},{value:"DAG 流程图建议贴上，水平居中；",paraId:11,tocIndex:11},{value:"建议视图增快捷操作，提升使用效率",paraId:12,tocIndex:12},{value:"放大 +：Ctrl/⌘ + +",paraId:13,tocIndex:12},{value:"缩小 -：Ctrl/⌘ + —",paraId:13,tocIndex:12},{value:"100% 1:1 等比例显示：Ctrl/⌘ + 0",paraId:13,tocIndex:12},{value:"适应画布显示：Ctrl/⌘ + 1",paraId:13,tocIndex:12},{value:"建议补充移动端样式及交互；",paraId:14,tocIndex:13},{value:"补充 Dark Mode 模式。",paraId:14,tocIndex:13}]},20382:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在图可视化分析的实际场景中，往往会发现静态演示不足以满足我们的业务需求，这种情况在海量数据的情况下尤为显著。若将巨量的数据完整地排布到可视化空间中，会发现信息密度远远超过了人的可读范围（图 1.1）。在只需传达给观者大致感知与情绪冲击的场景，这样的方式是适用的，但要解决更具体的问题或获取更深度的洞察时，就变得举步维艰。",paraId:0,tocIndex:0},{value:"图 1.1 《人际关系星形图》（ Personal Friendster ） - Jeffrey Heer 2004 ",paraId:1,tocIndex:0},{value:" Personal Friendster 是 Vizster 在线社交网络可视化项目的一部分，加利福利亚大学伯克利分校的 Jeffrey 教授采集了自己在社交网络 Friendster 中的三度人际关系数据，通过力导向布局可视化了以自己为中心的 47471 人与 432430 段关系，该图颠覆了人的认知：仅仅三度关系，就能构建出如此庞大的社交网络。这是该项目希望达成的目标，但要在如此庞大的节点与边中去探索具体的人与关系，作为静态图无疑是不可能的。",paraId:1,tocIndex:0},{value:"为了使图能传达具体的信息，而不仅只是模糊的感知，需要将可视化空间中的图元数量限制在人肉眼可识别能力的范围内。并在下一步提供恰当的交互，来使用户渐进式地发现更丰富与多维的信息（图 1.2）。",paraId:2,tocIndex:0},{value:"图 1.2 GraphStudio - Alibaba Inc. ",paraId:3,tocIndex:0},{value:" 通过条件筛选、搜索、双击展开关系等等交互方式探索数据，令用户能够依照自己的分析目标去发现各个颗粒度的数据与关系",paraId:3,tocIndex:0},{value:'交互使被动的"看客"成为主动的"用户"，更好地参与了对数据的理解和分析。可视分析系统的目的往往不仅是向用户传递定制好的知识，而是还能提供一个工具或平台来帮助用户探索数据，得到结论。',paraId:4,tocIndex:0},{value:"目前在阿里和蚂蚁体系内，G6 广泛应用于金融风控、云安全、知识图谱、企业风控、图数据库等业务，其广泛的应用场景，也决定了其不仅要保证专业性与扩展性，也要保证普适性，无论是新手、中级用户、亦或是专家，都能高效且容易地使用产品。我们提供的交互规范中，通过简单的单击、双击、移动等操作就可以很轻松地对可视化内容进行探索，也支持高级操作，如快捷键等隐性操作，可以让专家用户的工作更加高效，以及可以进行更深维度的探索。",paraId:5,tocIndex:1},{value:"不同的业务场景具有不同的交互，但又有相通的交互部分。G6 依照目前的经验沉淀，将通用的部分作为全局交互以供自由配置，具备业务特性的部分则作为扩展模板以供参照使用。",paraId:6,tocIndex:1},{value:"通用交互，剥离了业务属性，是一套适应大部分关系图交互探索的基础工具箱，并将范围圈定在了基础键鼠操作内，令普通电脑用户也能迅速地利用其对数据进行探索",paraId:7,tocIndex:1},{value:"扩展交互，不一定适应所有的应用场景与业务属性，但承载了 G6 强大的扩展性与能力，其范围不受限制，既可以是普通的交互行为触发，也能被其他事件触发，亦或由实时的业务数据触发等，用户能通过这些交互对数据进行更深度更定制化的探索。",paraId:7,tocIndex:1},{value:"操作对象可以分为画布、节点、Combo、边和其他四部分，所有的交互根据不同的操作对象进行分类。",paraId:7,tocIndex:1},{value:"通用交互",paraId:8,tocIndex:3},{value:"触发",paraId:8,tocIndex:3},{value:"演示",paraId:8,tocIndex:3},{value:"缩放画布",paraId:8,tocIndex:3},{value:"🖱 鼠标：滚轮向上/向下 ",paraId:8,tocIndex:3},{value:" ⌨️ 键盘：「⌘(Ctrl)」+「+/-」 ",paraId:8,tocIndex:3},{value:" 💻 触控板：双指展开/合并",paraId:8,tocIndex:3},{value:"移动画布",paraId:8,tocIndex:3},{value:"🖱 鼠标：拖拽 ",paraId:8,tocIndex:3},{value:" 💻 触控板：双指移动 ",paraId:8,tocIndex:3},{value:" 🖱 键鼠：Space 键+拖拽（当与框选操作冲突时）",paraId:8,tocIndex:3},{value:"回到概览",paraId:8,tocIndex:3},{value:"⌨️ 键盘：「Ctrl/⌘」+「1」",paraId:8,tocIndex:3},{value:"扩展交互",paraId:9,tocIndex:4},{value:"触发",paraId:9,tocIndex:4},{value:"演示",paraId:9,tocIndex:4},{value:"鱼眼",paraId:9,tocIndex:4},{value:"🎚 专用控件",paraId:9,tocIndex:4},{value:"布局切换",paraId:9,tocIndex:4},{value:"🎚 专用控件",paraId:9,tocIndex:4},{value:"时序过滤",paraId:9,tocIndex:4},{value:"🎚 专用控件",paraId:9,tocIndex:4},{value:"边过滤",paraId:9,tocIndex:4},{value:"🎚 专用控件",paraId:9,tocIndex:4},{value:"缩略图",paraId:9,tocIndex:4},{value:"🎚 专用控件",paraId:9,tocIndex:4},{value:"通用交互",paraId:10,tocIndex:6},{value:"触发",paraId:10,tocIndex:6},{value:"演示",paraId:10,tocIndex:6},{value:"指向节点",paraId:10,tocIndex:6},{value:"🖱 鼠标：悬停",paraId:10,tocIndex:6},{value:"选中节点",paraId:10,tocIndex:6},{value:"🖱 鼠标：单击",paraId:10,tocIndex:6},{value:"探索节点",paraId:10,tocIndex:6},{value:"🖱 鼠标：双击 ",paraId:10,tocIndex:6},{value:" ⌨️ 键盘：Enter",paraId:10,tocIndex:6},{value:"取消选中",paraId:10,tocIndex:6},{value:"🖱 鼠标：单击空白区域 ",paraId:10,tocIndex:6},{value:" ⌨️ 键盘：Esc",paraId:10,tocIndex:6},{value:"扩展交互",paraId:11,tocIndex:7},{value:"触发",paraId:11,tocIndex:7},{value:"演示",paraId:11,tocIndex:7},{value:"多选节点",paraId:11,tocIndex:7},{value:"⌨️🖱 键鼠：Shift + 长按移动 ",paraId:11,tocIndex:7},{value:" ⌨️🖱 键鼠：Shift + 单击 ",paraId:11,tocIndex:7},{value:" 🖱 鼠标：长按移动（当与拖拽画布操作不冲突时） ",paraId:11,tocIndex:7},{value:" 🎚 控件：套索",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:"移动节点",paraId:11,tocIndex:7},{value:"🖱 鼠标：拖拽",paraId:11,tocIndex:7},{value:"改变节点层级",paraId:11,tocIndex:7},{value:"🖱 鼠标：拖拽",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:" ",paraId:11,tocIndex:7},{value:"高亮相邻节点",paraId:11,tocIndex:7},{value:"📃 事件：选中节点",paraId:11,tocIndex:7},{value:"高亮最短路径",paraId:11,tocIndex:7},{value:"🎚 专用控件",paraId:11,tocIndex:7},{value:"通用交互",paraId:12,tocIndex:9},{value:"触发",paraId:12,tocIndex:9},{value:"演示",paraId:12,tocIndex:9},{value:"指向边",paraId:12,tocIndex:9},{value:"🖱 鼠标：悬停",paraId:12,tocIndex:9},{value:"选中边",paraId:12,tocIndex:9},{value:"🖱 鼠标：单击",paraId:12,tocIndex:9},{value:"取消选中",paraId:12,tocIndex:9},{value:"🖱 鼠标：单击空白区域 ",paraId:12,tocIndex:9},{value:" 键盘：Esc",paraId:12,tocIndex:9},{value:"扩展交互",paraId:13,tocIndex:10},{value:"触发",paraId:13,tocIndex:10},{value:"演示",paraId:13,tocIndex:10},{value:"多选边",paraId:13,tocIndex:10},{value:"⌨️🖱 键鼠：Shift + 单击 ",paraId:13,tocIndex:10},{value:" ⌨️🖱 键鼠：Shift + 长按移动 ",paraId:13,tocIndex:10},{value:" 🖱 鼠标：长按移动（当与拖拽画布操作不冲突时）",paraId:13,tocIndex:10},{value:"通用交互",paraId:14,tocIndex:12},{value:"触发",paraId:14,tocIndex:12},{value:"演示",paraId:14,tocIndex:12},{value:"指向 Combo",paraId:14,tocIndex:12},{value:"🖱 鼠标：悬停",paraId:14,tocIndex:12},{value:"选中 Combo",paraId:14,tocIndex:12},{value:"🖱 鼠标：单击",paraId:14,tocIndex:12},{value:"展开/收起 Combo",paraId:14,tocIndex:12},{value:"🖱 鼠标：双击 ",paraId:14,tocIndex:12},{value:" 键盘：Enter ",paraId:14,tocIndex:12},{value:" 🎚 专用控件",paraId:14,tocIndex:12},{value:"取消选中 Combo",paraId:14,tocIndex:12},{value:"🖱 鼠标：单击空白区域 ",paraId:14,tocIndex:12},{value:" 键盘：Esc",paraId:14,tocIndex:12},{value:"扩展交互",paraId:15,tocIndex:13},{value:"触发",paraId:15,tocIndex:13},{value:"演示",paraId:15,tocIndex:13},{value:"多选 Combo",paraId:15,tocIndex:13},{value:"⌨️🖱 键鼠：Shift + 单击",paraId:15,tocIndex:13},{value:"移动 Combo",paraId:15,tocIndex:13},{value:"🖱 鼠标：拖拽",paraId:15,tocIndex:13},{value:"改变 Combo 层级",paraId:15,tocIndex:13},{value:"🖱 鼠标：拖拽",paraId:15,tocIndex:13},{value:"由于图可视化信息密度很大，设计者要在短时间内完成某个关系图的配置，或者阅读者需要在短时间内探索出数据关系的症结。这时操作效率就显得尤为重要，G6 现已内置如下常用快捷操作，如果不满足，你还可以定制自己的快捷键盘操作。",paraId:16,tocIndex:14},{value:"通用交互",paraId:17,tocIndex:14},{value:"触发",paraId:17,tocIndex:14},{value:"演示",paraId:17,tocIndex:14},{value:"撤销",paraId:17,tocIndex:14},{value:"⌨️ 键盘：「Ctrl/⌘」+「z」",paraId:17,tocIndex:14},{value:"重做",paraId:17,tocIndex:14},{value:"⌨️ 键盘：「Ctrl/⌘」+「Shift」+「z」",paraId:17,tocIndex:14},{value:"右键菜单",paraId:17,tocIndex:14},{value:"🖱 鼠标：右键单击",paraId:17,tocIndex:14},{value:" ",paraId:17,tocIndex:14},{value:" ",paraId:17,tocIndex:14},{value:"交互在数据可视化系统中解决的核心问题是",paraId:18,tocIndex:15},{value:"有限的可视化空间与数据过载之间的矛盾",paraId:18,tocIndex:15},{value:"，交互帮助拓展了可视化中信息表达的空间，并给用户提供在空间中探索数据的路径，这条路径如何修筑才能确保探索过程的通畅？通过对经典方法的发掘与在实际业务中的提炼，总结了两类交互模式以供参考：由表及里、以点及面。",paraId:18,tocIndex:15},{value:"Ben Shneiderman 于 1996 年提出可视化信息检索的箴言 ",paraId:19,tocIndex:16},{value:"Overview First, Zoom and Filter, Then Details-on-Demand",paraId:19,tocIndex:16},{value:"，它符合人类寻求信息的基本逻辑：先概览，然后局部，最后聚焦兴趣点进行探索，这是一个由表及里的过程。",paraId:19,tocIndex:16},{value:"得益于搜索等技术的成熟，可视分析系统已经能够快速定位到用户所关注的对象，特别是已经有明确的分析目标时，这类场景就不必要由整体顺着数据结构向下慢慢地探索，而更多的是基于所关注的对象去延伸与发现它周边的关系与详细信息。",paraId:20,tocIndex:17}]},63215:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图的构成元素包括节点（Node）、边（Edge）和组（Combo），这些基础元素是图的原子组成部分，设计者可根据特定业务场景变更节点、边、组的配色和组合形式，搭建更复杂的图可视分析应用。",paraId:0,tocIndex:0},{value:"节点是构成图的基本单位，一般表示某个实体。如社交网络数据中，一个人就是一个实体，用一个节点来表示。",paraId:1,tocIndex:2},{value:"根据业务场景需要，信息可视化呈现时：",paraId:2,tocIndex:3},{value:"节点可加标签、可不加标签；",paraId:3,tocIndex:3},{value:"节点可存在不同形状；",paraId:3,tocIndex:3},{value:"节点可加简短描述；",paraId:3,tocIndex:3},{value:"节点可展开下级信息。",paraId:3,tocIndex:3},{value:"点交互基础样式有以下 6 种：基础状态：Default-默认、Active-激活、Selected-选中、Disable-失效被动状态：Highlight-强化、Inactive-弱化（在交互场景中与 Default-默认 做出区分）",paraId:4,tocIndex:4},{value:"以力导向图布局和辐射布局为例",paraId:5,tocIndex:4},{value:"边（Edge）表示的是两个节点之间的关系。如社交网络数据中，我和你的关系，是朋友。",paraId:6,tocIndex:6},{value:"因图的类型众多，边的形态也相应有：",paraId:7,tocIndex:7},{value:"有向的（含箭头）、无向的（无箭头）；",paraId:8,tocIndex:7},{value:"加权的（含值）、无加权的（不含值）；",paraId:8,tocIndex:7},{value:"加标签、不加标签；",paraId:8,tocIndex:7},{value:"不同粗细代表节点流量。",paraId:8,tocIndex:7},{value:"边的交互基础样式跟节点同样有以下 6 种：Default、Active、Selected、Disable、Highlight、Inactive",paraId:9,tocIndex:8},{value:"在节点的交互样式引用图例中同样可看到边的运用效果",paraId:10,tocIndex:8},{value:"组合，又称为节点分组，用于管理一组相似的节点，如一组具有相同类型的节点，或位置上比较靠近的一组节点，可以将它们划分到同一个 Combo 中，可以有效降低视觉上的干扰。",paraId:11,tocIndex:10},{value:"G6 默认提供两种类型，使用带有不重叠约束的力导向图布局方法，可根据业务场景和布局需要选取合适的形状。",paraId:12,tocIndex:11},{value:"Circle 圆形",paraId:13,tocIndex:11},{value:"Rect 矩形",paraId:13,tocIndex:11},{value:"在 Combo 的具体运用中，会出现 Combo 未展开/已展开、一级 Combo 和二级 Combo 及更多级相结合的形式，上图仅为未展开、展开（共一级）、展开（共二级）形式",paraId:14,tocIndex:11},{value:"节点组合形式千变万化，按常见形态延伸相应的交互样式如下：",paraId:15,tocIndex:12},{value:"G6 在 AntV 的基础色彩体系的基础上，结合关系图表达的特点，精细化调整了颜色在数据维度上的衡量和线性感知。内置了一系列优美、和谐且满足无障碍设计原则的色板。包括：分类色板、邻近色板、发散色板、语义色板。默认情况下以蓝色为基础样式的案例色，也是 G6 的默认主色。",paraId:16,tocIndex:13},{value:"让颜色在图中能够达成在数据变化和人体感知上尽可能线性匹配，不同数值对应的颜色区分度要足够高，且在拥有分类色状态下依然感知均匀，一个连续数据集的所有数据点都具有同等的视觉重要性。",paraId:17,tocIndex:13},{value:"选择蓝色为基础样式的案例色，也是基础样式的默认色 /G6 的主色；灰色作为辅助色。",paraId:18,tocIndex:14},{value:"邻近色顺序色板，一般使用两个或以上个临近色调，通过明度和饱和度的逐步渐变，常用来区分有序数据优先级的高低、连续数据的大小或梯度变化。",paraId:19,tocIndex:16},{value:"根据数据语义特定管理约束，选择合理色调搭配，使连续变化的色调和明度，可产生更多色彩分级，表达更多的连续数值。",paraId:20,tocIndex:17},{value:"亮色色板选取单色顺序色板中的 1 号色作为起始色，相应临近色调 4 号色为中间色，以此类推，继中间色相应近色调 7 号色为结束色，借助色彩工具，在 CIELab 色彩空间下生成渐变色；",paraId:21,tocIndex:18},{value:"暗色色板同理，起始色为 2 号色，中间色为相应邻近色调 5 号色，结束色为中间色邻近色调的 8 号色；",paraId:21,tocIndex:18},{value:"保留未分段的色带，便于用户自由分段取数。",paraId:21,tocIndex:18},{value:"也称对比色渐变色板，一般是两种互补色（也可以是对比色）去展现数据从一个负向值到 0 点再到正向值的连续变化区间，显示相对立的两个值的大小关系。数据范围的两端同等强调中间值和极值，以表示断点(如零变化或平均值)周围与数据中特定有意义的中间值之间的差异。",paraId:22,tocIndex:20},{value:"关键断点应该采用中性颜色及与背景色对比度低，如浅灰色，端点应该采用和背景色对比度高的饱和颜色。一般来说是对称的，临界断点可以是平均值、中间值或零变化值。",paraId:23,tocIndex:21},{value:"选取分类色板中的对比色或互补色，其中 7 号色起始色和结束色，4 号色为过渡色，灰阶色的 1 号色作为中间色，在 CIELab 色彩空间下生成渐变色；",paraId:24,tocIndex:22},{value:"暗色色板同理，其中 8 号色起始色和结束色，5 号色为过渡色，灰阶色的 2 号色作为中间色；",paraId:24,tocIndex:22},{value:"保留未分段的色带，便于用户自由分段取数。",paraId:24,tocIndex:22},{value:"色彩在可视化中的使用，不仅是数据信息传递的可视化通道，同时也是更深一层的文化故事的载体，用于表达意义或情感。",paraId:25,tocIndex:24},{value:"重视用色习惯，遵循相关标准，色彩也不是都能寓意的，相当一部分图表色彩选择和感情因素无关，而是按照某种习惯来设定色彩，即所谓约定俗成，有的甚至形成来规范。",paraId:26,tocIndex:25},{value:"\n> 语义色板（部分）\n",paraId:27},{value:"更多色板介绍，详见 AntV 色板。",paraId:28,tocIndex:25},{value:"以圆形节点为例，根据点不同的信息展示形式，基础形状的大小有所不同，在图展示中需将图相关信息做最优展示。",paraId:29,tocIndex:27},{value:"\n> 圆形节点——文本置内型，节点直径大小建议为 60px，文本大小为 12px\n",paraId:27},{value:"\n> 圆形节点——文本非置内型，节点直径大小建议为 16px，文本大小为 12px\n",paraId:27},{value:"边的粗细：边在点默认大小场景下默认为 1px，通常根据视图大小变化等比例放大缩小。为保持信息有效可视，边最小为 1px，最大值为 12px。",paraId:30,tocIndex:28},{value:"Combo 的大小跟随内容，Node 与 Combo 之间的间隙最小为 Small = 8px。",paraId:31,tocIndex:29},{value:"数据集：又称为资料集、数据集合或资料集合，是一种由数据所组成的集合。连续数值：统计学概念,又称连续变量。指在一定区间内可以任意取值、数值是连续不断的、相邻两个数值可作无限分割(即可取无限个数值)的数据。断点：文中主要指数据集的中心值或参考值，例如零变化或平均值。端点：文中主要指数据集极端值，例如最大最小值。语义：文中主要指色彩心理学中色彩在客观上对人们对一种刺激和象征，它在主观上又是一种反应和行为。包含从知觉、感情而到记忆、思想、意志、象征等与色彩的因果关系。",paraId:32,tocIndex:30},{value:"当需要用颜色作为视觉通道时，数据性质可作为参考因素，选用色板的步骤大致如下图：",paraId:33,tocIndex:30}]},61422:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在「科学与复杂性」一文中，科学家 Warren Weaver 按学界面临问题的复杂性，将现代科学史划分为「简单问题、无序复杂问题、有序复杂问题」3 个阶段。20 世纪中叶之后，学界开始面临更多不稳定性、非线性和多元性的有序复杂问题，业界急需一种基于网络模型的分析探索工具，和思考方式。后来，以 柯尼斯堡七桥问题 基于图的拓扑结构被解决为起始点，图可视分析在越来越多的领域发挥作用，在互联网行业，随着大数据与 AI 技术发展，越来越多的业务场景用上了图可视分析，如社区结构分析、聚类、消息传播、节点分类、链接预测、图表示学习、图神经网络、网络演化等。",paraId:0,tocIndex:0},{value:"《Science of Complexity》 - Warren Weaver 1948",paraId:1,tocIndex:0},{value:"这些形形色色的图可视分析产品，对设计的需求越来越旺盛。设计在这一领域又能做什么？该如何设计一个复杂的图可视分析产品？图可视化的视觉和交互设计又有哪些值得注意和思考的点？AntV 设计小组把我们在这一领域的思考和沉淀总结成「G6 图可视化设计体系」，希望能给更多设计师在这一陌生的设计领域带来更多思考和帮助。",paraId:2,tocIndex:0},{value:"在阿里、蚂蚁集团，图可视分析广泛应用于云安全、知识图谱、企业风控、图数据库等不同的业务场景。抽象来看基本上有两种类型：",paraId:3,tocIndex:2},{value:"对现状的记录、阐明、揭示：如对机房安全，流量监控等现状的监控；",paraId:4,tocIndex:2},{value:"对现状的扩展、抽象（对未来的预测）：如基于人工智能的各类技术，对于图的预测和实时防控。",paraId:4,tocIndex:2},{value:"关系图种类划分，无论业界还是学界目前都没有一个统一的定论。基于 AntV 自身的业务，我们总结归纳出几种常见图的类型：关系图、流程图、DAG 图、血缘图、ER 图、树状图。每种图都有其自身的使用场景以及设计时需要考量的点。我们从图的基本介绍、特点、适用业务场景、设计指引几个方面提供了详细的介绍。",paraId:5,tocIndex:3},{value:"查看图的种类详细介绍和设计指引 >",paraId:6},{value:"设计师在面对一个关系图设计需求时，不仅需要设计一张图「看上去」如何，更需要考虑体验设计五要素的每一层。从了解业务和产品目标出发，洞察用户需求，同产品经理一起定义图分析产品的功能边界，再基于用户场景去构建产品的任务流程，信息框架和界面布局，最终再去打磨产品界面以及最重要的图本身的视觉和微交互设计。",paraId:7,tocIndex:4},{value:"名称",paraId:8,tocIndex:4},{value:"描述",paraId:8,tocIndex:4},{value:"表现层",paraId:8,tocIndex:4},{value:"视觉感知层：产品基础界面和图本身节点和边的视觉设计",paraId:8,tocIndex:4},{value:"框架层",paraId:8,tocIndex:4},{value:"界面布局：如画布、各类组件的布局关系和使用逻辑",paraId:8,tocIndex:4},{value:"结构层",paraId:8,tocIndex:4},{value:"流程、信息架构：确定产品中多个图分析模式如何整合为一体，各种功能的模块组合，信息框架的构建",paraId:8,tocIndex:4},{value:"范围层",paraId:8,tocIndex:4},{value:"功能/内容需求：定义产品图分析功能和呈现内容的边界",paraId:8,tocIndex:4},{value:"战略层",paraId:8,tocIndex:4},{value:"用户需求，业务目标，产品目标",paraId:8,tocIndex:4},{value:"从图分析的角度来看一个图分析产品通常会历经如下几个阶段，以将数据源转化为对用户有价值的信息。",paraId:9,tocIndex:5},{value:"引用自《图分析与可视化》",paraId:10,tocIndex:5},{value:"对应「五要素」中的范围层",paraId:11,tocIndex:6},{value:"按图产品探索分析场景的特性，我们将图分析产品的分析模式为",paraId:12,tocIndex:6},{value:"有明确目的",paraId:12,tocIndex:6},{value:"、",paraId:12,tocIndex:6},{value:"无明确目的",paraId:12,tocIndex:6},{value:"和",paraId:12,tocIndex:6},{value:"特殊场景",paraId:12,tocIndex:6},{value:"三种。不同的分析模式界面会有所不同，用户的使用流程也会有所差异。诚然，一个功能完备的图分析产品，3 种分析模式可能会同时具备，从而导致界面复杂度成倍的提升。需要设计师能够抽丝剥茧，知其所以然，理清楚每一种模式各自特点之后，再结合实际的用户场景，全盘考虑产品设计方案。",paraId:12,tocIndex:6},{value:"这类分析模式是有明确的分析或查询条件，这个条件的呈现形式可能是一个规则表达式，一段 Gremlin 或 GQL 的查询语句，或明确的起点和终点，甚至是直接查看某个节点或某条边的具体信息。常见的模式有：规则查询、Gremlin 查询、关联分析、筛选/搜索画布、查看详情等。这类模式下，通常需要通过搜索或在各种类型的输入面板中，输入查询语句、规则等明确的条件信息，来进行探查和分析。",paraId:13,tocIndex:7},{value:"无明确目的地探索是指基于已有数据内容，进行关系的 N 度扩展、下钻分析、子图探索、撤销回退等操作，来挖掘数据中的特性，发现价值或机会点的分析过程。",paraId:14,tocIndex:8},{value:"内置了 AI 算法能力的分析场景",paraId:15,tocIndex:9},{value:"这类分析场景通常需要借助内置的算法或规则推理能力来实现，从海量数据中快捷的挖掘出符合特定规则的目标节点和关系，常见的有：担保圈、实控人、最短路径等。",paraId:16,tocIndex:9},{value:"结合时间或地理信息的场景",paraId:17,tocIndex:9},{value:"在源数据中含有时间和地理维度的内容时，会出现结合时间或地理信息的分析场景。",paraId:18,tocIndex:9},{value:"对应「五要素」中的框架层",paraId:19,tocIndex:10},{value:"点和边的基础样式是所有图可视化的基石，要组成一个完整的图分析产品，还需要有各类组件来承担不同的功能。从体验设计的角度来看，常见的组件可分为如下几种类型：",paraId:20,tocIndex:10},{value:"基础组件：图例、工具栏、右键菜单、视图控制栏、系统日志等；",paraId:21,tocIndex:10},{value:"条件输入：查询、筛选、搜索、画布设置等；",paraId:21,tocIndex:10},{value:"信息输出：详情面板、气泡、Tooltip、画板信息等；",paraId:21,tocIndex:10},{value:"高级功能：时间轴、快照画廊、分析报表等。",paraId:21,tocIndex:10},{value:"查看 AntV 内置的各类组件 >",paraId:22},{value:"在某些特殊场景下，也需要结合业务实际情况基于基础组件去升级优化，乃至基于产品独有的能力去设计全新的组件。在优化一个基础组件或设计全新的组件时，需要结合实际的功能需求，从使用场景、构成元素、常见类型、交互说明等几个角度完整的思考清楚。以 AntV 最新设计的两个组件为例：",paraId:23},{value:"时间轴 TimeBar",paraId:24},{value:"视图控制栏 View ToolBar",paraId:25},{value:"一个完整的交互设计行为通常由触发器、规则和反馈组成。在图分析产品常见交互行为中，触发器通常是常见的鼠标、键盘、触控板；规则通常有节点双击时展开，单击时高亮等常见通用规则；而反馈则是各个交互的操作对象根据不同的「规则」所呈现出来的行为或样式表达，通常以各类视觉属性变化的形式出现。",paraId:26,tocIndex:11},{value:"查看图交互设计指引 >",paraId:27},{value:"按照交互事件是否全局或跨产品通用，将 G6 以及 Graphin 中的交互分为「通用」和「扩展」两类：",paraId:28,tocIndex:12},{value:"通用交互，剥离业务属性，是一套适应大部分关系图交互探索的基础工具箱，并将范围圈定在了基础键鼠操作内，令普通电脑用户也能迅速地利用其对数据进行探索；",paraId:29,tocIndex:12},{value:"扩展交互，不一定适应所有的应用场景与业务属性，但承载了 G6 强大的扩展性与能力，其范围不受限制，既可以是普通的交互行为触发，也能被其他事件触发，亦或由实时的业务数据触发等，用户能通过这些交互对数据进行更深度更定制化的探索。",paraId:29,tocIndex:12},{value:"「交互」能使用户从被动的「看客」成为主动的「探索分析者」，更好地参与对数据的理解和分析的过程。可视分析产品的目的也不仅是向用户传递定制好的知识，而是提供一个工具来帮助用户在海量数据中进行探索分析，并最终得到想要的结论。 一个完整地图分析产品必定是由诸多的基础交互事件按照不同的目的和使用场景组合在一起的，为了将各类复杂的交互事件抽丝剥茧，交互事件的操作对象通常有：画布、节点、Combo、边和其他。",paraId:30,tocIndex:13},{value:"对应「五要素」中的表现层",paraId:31,tocIndex:14},{value:"抛开图分析产品本身产品界面，",paraId:32,tocIndex:14},{value:"关系图的视觉设计本质上是把视觉属性和数据特性建立映射关系，形成特定的语义关联的过程",paraId:32,tocIndex:14},{value:"。好的视觉设计，能极大的提高关系图的信息传达效率，降低用户的认知成本。图最核心的元素就是点、边、以及点边上的文字标签，在考虑图的视觉设计时，需要将这些元素的组成元素拆解来看，单独设计，并全局考虑不同交互事件，数据属性和业务场景下的视觉展示需要和视觉属性的映射关系，以及不同元素的视觉属性整合到一起时的视觉表达。在可视化设计中常见的视觉属性有：形状、颜色、大小、方向、材质、明度，位置等。以最基础的形状和颜色的设计为引入进行详细介绍。",paraId:32,tocIndex:14},{value:"查看视觉设计指引 >",paraId:33},{value:"关系图的节点可根据业务实际场景需要，为表达特定的某类信息，可将节点定制为特殊样式，或将节点与常见的二维图表（如：环形图，玫瑰图等）结合，以展示更多信息，甚至在需要突出强调表达某种业务独有的属性和特点时，可尝试用 3D 图形来表达。",paraId:34,tocIndex:15},{value:"无论节点还是边，在设计时，都需要考虑在不同鼠标事件的情况下的视觉表现：",paraId:35,tocIndex:15},{value:"G6 在 AntV 的基础色彩体系的基础上，结合关系图表达的特点，精细化调整了颜色在数据维度上的衡量和线性感知。内置了一系列优美、和谐且满足无障碍设计原则的色板。包括：分类色板、邻近色板、发散色板、语义色板。默认情况下以蓝色为基础样式的案例色，也是 G6 的默认主色。",paraId:36,tocIndex:16},{value:"同时，我们还提供深、浅色两套主题样式，以满足不同的应用场景：",paraId:37,tocIndex:16},{value:"完整的关系图可视化视觉设计，不是单纯的将不同的视觉属性机械地叠加在一起。通常情况下，一个图分析产品中的视觉设计需要考虑的信息维度有：鼠标事件、数据特性、业务语义。最复杂的情况下，3 个维度的信息都需要综合考虑，比如：下图案例中的「类型 B」在「满足条件 A」的情况下，也需要考虑各种鼠标事件情况下的视觉展示情况。诚然不是所有业务都会遇到如此复杂的情况，在具体的业务场景中可结合用户场景以及交互事件的三要素「触发器+规则+反馈」，来综合判断和决策最适当的视觉表达形式。",paraId:38,tocIndex:17},{value:"信息维度",paraId:39,tocIndex:17},{value:"释义",paraId:39,tocIndex:17},{value:"样式示例",paraId:39,tocIndex:17},{value:"鼠标事件",paraId:39,tocIndex:17},{value:"常见的鼠标事件： Default、Active、Selected、Disable 等",paraId:39,tocIndex:17},{value:"数据特性",paraId:39,tocIndex:17},{value:"图数据本身固有的特性，如节点或边的数据类型",paraId:39,tocIndex:17},{value:"业务语义",paraId:39,tocIndex:17},{value:"符合某些规则的节点需要特殊样式强调高亮",paraId:39,tocIndex:17},{value:"每一个图产品项目都应该从要解决的问题出发，逐步导向深入的探索，设计一个完整的图分析产品其实就是不断解答探索图过程中遇到的问题的过程。换句话说，一个好的图分析场景的第一步就是「问对问题」。",paraId:40,tocIndex:19},{value:"在不同的视角和布局下，关系图会表现出不一样的模式和行为，呈现出的内容重点也不尽相同。",paraId:41,tocIndex:20},{value:"人一次性能接受到的信息量有限，考虑人对信息认知极限，克制地表达关系图中的细节信息，在合适的场景下表达适度的内容。建议遵循「渐进呈现」的原则，先概览，再放大过滤，最后看细节。常见的管理细节的方法有：",paraId:42,tocIndex:21},{value:"缩放：参考地图软件的缩放的效果，在不同的比例下呈现不同核心内容；",paraId:43,tocIndex:21},{value:"全局+细节：常见的形式有缩略图，在画布中查看细节内容时，同时能在缩略图中获取全局的信息；",paraId:43,tocIndex:21},{value:"焦点+背景：常见的形式有鱼眼、焦点聚焦等突出中心内容弱化周边节点的形式。",paraId:43,tocIndex:21},{value:"数据很少是静态的，某件事在某个时间点爆发或者持续间发生，关联的因子有多个，时间轴工具可以有效展示动态时序数据、分析图数据关联因子。G6 图可视化中已经提供了完整的「时间轴」组件。",paraId:44,tocIndex:22},{value:"图分析产品往往是非常重交互的场景，通常用户会在画布执行连续分析的动作或通过一连串的分析行为才拿到有效的结果信息，为了确保用户不错过有效的信息以及防止错误的操作，如误删了某些节点或边或扩展了太多节点，产品中需要提供操作可逆的机制，能够允许用户回退或重复上一步操作。",paraId:45,tocIndex:23},{value:"图分析产品的最终目的是让用户得到想要的「答案」，获取到有价值的信息，并以这些信息为基础去执行下一步动作，常见的有：下载/分享分析结果、将分析规则发布为在线服务或沉淀为探索分析模板、或直接将分析结果作为完整生产链路中的一环输入给下游环节。一言以蔽之，一个体验良好的图分析产品，必定能从「发问」到「行动」形成完整的产品体验闭环。",paraId:46,tocIndex:24},{value:"The Aesthetics of Graph Visualization - Chris Bennett, Jody Ryall, Leo Spalteholz and Amy Gooch1",paraId:47,tocIndex:25},{value:"图分析与可视化_在关联数据中发现商业机会 - Richard Brath/David Jonker",paraId:47,tocIndex:25},{value:"Visual Complexity_Mapping Patterns of Information - Manuel Lima",paraId:47,tocIndex:25},{value:"AntV 图可视分析解决方案",paraId:48,tocIndex:25},{value:"数据可视化 - 陈为 / 沈则潜",paraId:47,tocIndex:25}]},7916:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"AntV 的设计原则是基于 Ant Design 设计体系衍生的，它在遵循 Ant Design 设计价值观的同时，对数据可视化领域的进一步解读，如色板、字体的指引。",paraId:0},{value:"G6 作为 AntV 图可视化技术栈，在设计上依然遵循 AntV 的四条核心原则：准确、清晰、有效、美，这四条原则按重要等级先后排序，相辅相成且呈递进关系。",paraId:1},{value:"可视表达时不歪曲，不误导，不遗漏，精准如实反应数据的特征信息。",paraId:2,tocIndex:0},{value:"例如：关系图的箭头指向必须清晰、明确，否则在大数据展示时容易辨识不清。在图形上，我们对三角形进行一定的裁剪，让其像指南针一样有明确的指向性，比较下面两图，左侧的箭头能清晰辨别指向性，而右侧的箭头在识别时会有些困惑。",paraId:3,tocIndex:0},{value:"清晰包括两个层面，结构清晰 与 内容清晰。",paraId:4,tocIndex:1},{value:"结构清晰：数据可视化呈现的是一幅作品，它是制作者分析思路的呈现，其布局决定阅读者的浏览顺序。清晰的平面布局能很好的帮助阅读者获取信息。下图展现的是同一组数据下不同布局的关系图，例如环状布局可用于突出数据结构中的环；辐射状布局是辐射状树布局的扩展，可突出关注点与其他节点的最短路径关系；格子布局可以让图看起来十分规整，利于探索。",paraId:5,tocIndex:1},{value:"内容清晰：",paraId:6,tocIndex:1},{value:"不让用户带着疑惑看图是我们始终不变的追求。例如在 G6 中经常会出现成千上万个节点，为了让用户能对所有节点感受的更直观，我们设计了鱼眼功能，同时查看图的全貌和局部，可以清晰地描绘出焦点所在节点与其邻居之间的直接关系。",paraId:7,tocIndex:1},{value:"信息传达有重点，克制不冗余，避免信息过载，用最适量的数据-油墨比（Data-ink Ratio）表达对用户最有用的信息。",paraId:8,tocIndex:2},{value:"美是一种克制，合理利用视觉元素进行映射，运用格式塔原理对数据进行分组，既能帮助用户更快的获取信息，也能在一定程度上建立一种秩序美、规律美。",paraId:9,tocIndex:3}]},39956:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"流程图是表示算法、工作流或流程的一种框图表示，它以不同类型的框代表不同种类的步骤，每两个步骤之间则以箭头连接。这种表示方法便于说明解决已知问题的方法。",paraId:0,tocIndex:1},{value:"流程图背后可以概括了各节点类型、其内容及其他补充用的信息。在设计或者记录一些简单的步骤或程序都会用得上流程图。与其他图表一样，这种图表可以帮助可视化发生了什么事情，从而更易去理解中间的工序。虽然有很多𧗠生出来的版本，各目有各目的标示方式，它们大都都有以下 2 种的符号：",paraId:1,tocIndex:2},{value:"步骤：通常称作“活动”，常以长方形来表示；",paraId:2,tocIndex:2},{value:"决定：常以钻石形来表示。其他常用形状：",paraId:2,tocIndex:2},{value:"形状",paraId:3,tocIndex:2},{value:"名称",paraId:3,tocIndex:2},{value:"描述",paraId:3,tocIndex:2},{value:"起止符号",paraId:3,tocIndex:2},{value:"用来表示次要或程序的开始与完结。常以一个圆角长方形表示。通常里面会标上“开始”或“结束”或其他相关字眼，如“提交查询”或“接受产品”。",paraId:3,tocIndex:2},{value:"程序",paraId:3,tocIndex:2},{value:"以长方形来代表一系列程序去改变量值、形式、数据的位置。",paraId:3,tocIndex:2},{value:"决策判断",paraId:3,tocIndex:2},{value:"以一个菱形去显示一个条件进程，用来按情况去决定下一步走向。通常以“是/否”或“真/假”值去决定。",paraId:3,tocIndex:2},{value:"输入/输出",paraId:3,tocIndex:2},{value:"以平行四边形来据输入或输出的过程，即填入数据或显示工作结果的步骤。",paraId:3,tocIndex:2},{value:"已定义流程",paraId:3,tocIndex:2},{value:"用一个有 2 条左右垂直线长方型，来表示一个已在其他地方定义了的过程。",paraId:3,tocIndex:2},{value:"同页参考",paraId:3,tocIndex:2},{value:"用一个含有字母的小圆圈来连接目标流程画于同一页上。",paraId:3,tocIndex:2},{value:"换页参考",paraId:3,tocIndex:2},{value:"用一个倒画的屋型来表示目标流程画于另一页上。",paraId:3,tocIndex:2},{value:"流程图是流经一个系统的信息流、观点流或部件流的图形代表。在企业中，流程图主要用来说明某一过程。这种过程既可以是生产线上的工艺流程，也可以是完成一项任务必需的管理过程。典型场景：",paraId:4,tocIndex:3},{value:"组织结构图：组织结构图是把企业组织分成若干部分,并且标明各部分之间可能存在的各种关系。例如上下级领导关系(组织机构图)，物流关系，资金流关系和资料传递关系等；",paraId:5,tocIndex:3},{value:"BPMN：用于以业务流程模型详细说明各种业务流程；",paraId:5,tocIndex:3},{value:"UML：UML 立足于对事物的实体、性质、关系、结构、状态和动态变化过程的全程描述和反映；",paraId:5,tocIndex:3},{value:"EPC 事件过程线图：适合诸如 B2B、供应链流程管理、仓储物流管理等商业化业务流程。",paraId:5,tocIndex:3},{value:"流程图一般是用标准的符号绘制的，并非严格要求使用这些方框，圆圈，菱形或其它标准的符号来制作一个流程图，但是标准符号确实能更清晰地展示事件的类别。以下是大多数情况常用的一组标准符号",paraId:6,tocIndex:4},{value:"常用的流程图方向是从左到右或者从上到下：",paraId:6,tocIndex:4},{value:"上下流程图：上下流程图是最常见的一种流程图，它仅表示上一步与下一步的顺序关系；",paraId:6,tocIndex:4},{value:"矩阵流程图：矩阵流程图不仅表示下下关系，还可以看出某一过程的其他关系；",paraId:6,tocIndex:4},{value:"在标准流程图符号内简要说明符号代表的内容。必要时，你可以用注释符号更清晰地描述数据或计算步骤；",paraId:6,tocIndex:4},{value:"确保流程图有一个逻辑的起点和终点；",paraId:6,tocIndex:4},{value:"用简单的测试数据来测试流程图的有效性是非常有用的。",paraId:6,tocIndex:4},{value:"DAG 是 Directed Acyclic Graph 的缩写，即有向无环图，它是指图中一个点经过两种路线到达另一个点没有闭环。它原本是计算机领域一种常用数据结构，因为独特的拓扑结构所带来的优异特性，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景",paraId:7,tocIndex:6},{value:"DAG 相比于目前的公链技术，其实是图和链的区别，对于链而言，无法只处理一个局部，因为链的入度和出度只有一个，不能把链上的节点拆成好几个节点去处理，但是对于图却可以，因为图可以有多个出度，那么可以同时处理多个出度连接的节点。所以，它的特点是：",paraId:8,tocIndex:7},{value:"DAG 图可以有编辑态（拖拉拽画成一个图），也可是只读态（供阅读者查阅读）；",paraId:9,tocIndex:7},{value:"交易速度块，DAG 实现的局部处理和并行结算可以使得交易速度大幅度提升；",paraId:9,tocIndex:7},{value:"拓展性强，因为各个节点无需等待同步其他的节点的数据就可计算使得记账节点很容易答复延展，因此 DAG 很适用于物联网类项目；",paraId:9,tocIndex:7},{value:"作恶难度更大，相比于链式结构，在 DAG 中恶意修改的难度会大很多，因为 DAG 拥有着很多的出度和入度，假如要修改某一个节点，那么对应的出入度都要进行修改。",paraId:9,tocIndex:7},{value:"DAG 图常用来描述业务流程，典型场景：",paraId:10,tocIndex:8},{value:"人工智能产品，可以通过 DAG 图可以将一个复杂的人工智能实验流程给图形化出来，大大降低理解成本；",paraId:11,tocIndex:8},{value:"系统架构：表达一个系统架构各个层各个实例之间的关系，有明确的分层；",paraId:11,tocIndex:8},{value:"交易系统：表达资金、交易等流转情况。",paraId:11,tocIndex:8},{value:"一定有明确的方向，从上到下，从左到右等，不存在节点指向方向逆反；",paraId:12,tocIndex:10},{value:"一个节点可能会拆分出多个节点，前后存在包含、关联等关系；",paraId:12,tocIndex:10},{value:"除业务特性外，图没有唯一的开始结束节点。",paraId:12,tocIndex:10},{value:"Data Lineage 数据血统，也叫做 Data Provenance 数据起源或 Data Pedigree 数据谱系。任何的数据，从产生、ETL 处理、加工、融合、流转，到最终消亡，数据之间自然会形成一种关系。好比人类社会中的人际关系，类似的一种关系来表达数据之间的这种关系，称之为数据的血缘关系。",paraId:13,tocIndex:12},{value:"归属性：特定的数据归属特定的组织（或个人），数据具有归属性；",paraId:14,tocIndex:13},{value:"多源性：同一个数据可以有多个来源, 一个数据可以是多个数据经过加工而生成的，而且这种加工过程可以是多个；",paraId:14,tocIndex:13},{value:"可追溯性: 数据的血缘关系，体现了数据的生命周期，体现了数据从产生到消亡的整个过程，具备可追溯性；",paraId:14,tocIndex:13},{value:"层次性: 数据的血缘关系是有层次的。对数据的分类、归纳、总结等对数据进行的描述信息又形成了新的数据，不同程度的描述信息形成了数据的层次。",paraId:14,tocIndex:13},{value:"追踪数据溯源：当数据发生异常，帮助追踪到异常发生的原因，平时也能帮助我们追踪数据的来源，追踪数据处理过程；",paraId:15,tocIndex:14},{value:"评估数据价值：要对数据价值进行评估，就需要有依据，数据血缘关系，可以从#数据受众、数据更新量级、数据更新# 频次等方面给数据价值的评估提供依据；",paraId:15,tocIndex:14},{value:"数据质量评估：数据的血缘关系图上，可以方便的看到数据清洗的标准清单，这个清单反映了对数据质量的要求。",paraId:15,tocIndex:14},{value:"数据节点有三种类型：主节点，数据流出节点，数据流入节点；",paraId:16,tocIndex:16},{value:"主节点只有一个，一般位于整个图形的中间，是可视化图形的核心节点。图形展示的血缘关系就是此节点的血缘关系，其他与此节点无关的血缘关系都不在图形上展示，以保证图形的简单、清晰；",paraId:16,tocIndex:16},{value:"数据流入节点可以有多个，是主节点的父节点，表示数据来源；",paraId:16,tocIndex:16},{value:"数据流出节点也可以有多个，是主节点的子节点，表示数据的去向；包括一种特殊的节点，即终端节点，终端节点是一种特殊的数据流出节点，表示数据不再往下进行流转，这种数据一般用来做可视化展示；",paraId:16,tocIndex:16},{value:"流转线表现的是数据的流转路径，从左到右流转。数据流转线路从数据流入节点出来往主节点汇聚，又从主节点流出往数据流出节点扩散；",paraId:16,tocIndex:16},{value:"数据流转线路表现了三个维度的信息，分别是方向、数据更新量级、数据更新频次；",paraId:16,tocIndex:16},{value:"方向的表现方式，没有做特别的设计，默认从上到下流转；",paraId:16,tocIndex:16},{value:"数据更新的量级通过线条的粗细来表现。线条越粗表示数据量级越大，线条越细则表示数据量级越小；",paraId:16,tocIndex:16},{value:"数据更新的频次用线条中线段的长度来表现。线段越短表示更新频次越高，线段越长表示更新频次越底，一根实线则表示只流转一次。",paraId:16,tocIndex:16},{value:"关系图，又称关联图，是用来分析事物之间“原因与结果”、“目的与手段”等复杂关系的一种图表，它能够帮助人们从事物之间的逻辑关系中，寻找出解决问题的办法。关系图由圆圈(或方框)和箭头组成，其中圆圈中是文字说明部分箭头由原因指向结果，由手段指向目的。",paraId:17,tocIndex:18},{value:"图是一个高度抽象的模型，数据中的各种关系都能用图表示。图中的点和边，可以非常灵活，不局限于现实意义的实体。最直接能想到的当然是某个人可以是点，某个产品可以是点，它们之间的联系是边；除了点与点之间的联系外，还分为空间聚集的聚类，反应出不同团队、不同聚类之间的关系。",paraId:18,tocIndex:19},{value:"图分析的四种广泛使用的类型包括路径分析，连通性分析，社区分析和集中性分析：",paraId:19,tocIndex:20},{value:"路径分析：这种类型的分析可用于确定图中两个节点之间的最短距离。例如路线优化，特别适用于物流，供应和分销链以及智慧城市的交通优化；",paraId:20,tocIndex:20},{value:"连通性分析：这种类型的图形分析可用于确定诸如公用电网之类的网络中的弱点。它还可以比较跨网络的连接；",paraId:20,tocIndex:20},{value:"社区分析：基于距离和密度的分析用于查找社交网络中互动的人群；",paraId:20,tocIndex:20},{value:"集中度分析：这种分析类型能够识别相关性，例如在社交网络中找到最有影响力的人，或找到访问量最高的网页。",paraId:20,tocIndex:20},{value:"把对象变成点，点的大小、颜色可以是它的两个参数，",paraId:21,tocIndex:22},{value:"两个点之间的关系可以用连线来表示。连线分为无向（只是连接的导向，一些简单的关系很容易体现）和有向（复杂网络，连接+方向）。",paraId:21,tocIndex:22},{value:"线本身的方向代表了连接的关系同时线的粗线也可以表示线的连接强度",paraId:21,tocIndex:22},{value:"实体关系图也称 ER 模型（是指以实体、关系、属性三个基本概念概括数据的基本结构，从而描述静态数据结构的概念模型），全称为实体联系模型或实体关系模型，是概念数据模型的高层描述所使用的数据模型或模式图。",paraId:22,tocIndex:24},{value:"ER 图分为实体、属性、关系三个核心部分。",paraId:23,tocIndex:25},{value:"实体：即数据模型中的数据对象，例如人、学生、音乐都可以作为一个数据对象；",paraId:24,tocIndex:25},{value:"属性：即数据对象所具有的属性，例如学生具有姓名、学号、年级等属性；",paraId:24,tocIndex:25},{value:"关系：用来表现数据对象与数据对象之间的联系，例如学生的实体和成绩表的实体之间有一定的联系，每个学生都有自己的成绩表，这就是一种关系。",paraId:24,tocIndex:25},{value:"ER 图中关联关系有三种：",paraId:25,tocIndex:25},{value:"1 对 1（1:1） ：1 对 1 关系是指对于实体集 A 与实体集 B，A 中的每一个实体至多与 B 中一个实体有关系；反之，在实体集 B 中的每个实体至多与实体集 A 中一个实体有关系；",paraId:26,tocIndex:25},{value:"1 对多（1:N） ：1 对多关系是指实体集 A 与实体集 B 中至少有 N(N>0)个实体有关系；并且实体集 B 中每一个实体至多与实体集 A 中一个实体有关系；",paraId:26,tocIndex:25},{value:"多对多（M:N） ：多对多关系是指实体集 A 中的每一个实体与实体集 B 中至少有 M(M>0)个实体有关系，并且实体集 B 中的每一个实体与实体集 A 中的至少 N（N>0）个实体有关系。",paraId:26,tocIndex:25},{value:"一般在逻辑和物理数据库设计中使用，包括信息工程和空间建模。也可以用在两个或更多实体相互如何关联；",paraId:27,tocIndex:26},{value:"常用于信息系统设计中：在概念结构设计阶段用来描述信息需求或要存储在数据库中的信息类型，作为用户与分析员之间有效的交流工具；",paraId:28,tocIndex:26},{value:"描述感兴趣区域的任何本体：对使用的术语和它们的联系的概述和分类，用实体、联系和属性这三个概念来理解现实问题。",paraId:28,tocIndex:26},{value:"首先确定这个模块有哪几个核心的对象以及具体有哪些特征；其次思考这些对象之间的关系，如何相互转变；最后把他们用 ER 图的方法表述出来；",paraId:29,tocIndex:28},{value:"方形表示实体，一般是名词；菱形表示联系，一般是动词；椭圆表示属性，一般是名词；线表示联系；",paraId:29,tocIndex:28},{value:"尽量精简实体以及优化属性。",paraId:29,tocIndex:28}]},86197:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本文档仅对于 Angular 9 以上版本适用",paraId:0},{value:"如果你的项目是通过最新的 Angular CLI 创建，那么 G6 可以即开即用，不需要特殊设置。",paraId:1},{value:"如果你的项目是从老的 Angular 版本升级而来（比如我的是从 Angular 6 逐步升级），那么你大概会遇到问题。",paraId:2},{value:"如果你遇到类似下图的 ",paraId:3},{value:"cannot read property 'webpackChunkAlgorithm'",paraId:3},{value:" 错误\n",paraId:3},{value:"请参考 #2691(",paraId:4},{value:"https://github.com/antvis/G6/issues/2691",paraId:4},{value:") 中的解决方案。",paraId:4},{value:"在 Angular 中使用 G6，需要满足以下两点：",paraId:5},{value:"项目根目录下（与 package.json 同目录）需要有 ",paraId:6},{value:".browserslistrc",paraId:6},{value:" 文件，请注意 ",paraId:6},{value:"browserslist",paraId:6},{value:" 文件无效。",paraId:6},{value:"不开启IE支持。",paraId:6}]},49e3:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"具体参考：",paraId:0},{value:"#1260",paraId:0},{value:"当用户使用 rollup 打包 G6 3.3.x 版本时，会报以下错误：",paraId:1,tocIndex:0},{value:"error     Error: 'groupBy' is not exported by node_modules/_lodash@4.17.15@lodash/lodash.js\n    at error (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:5400:30)\n    at Module.error (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:9820:16)\n    at handleMissingExport (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:9721:28)\n    at Module.traceVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:10159:24)\n    at ModuleScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:8766:39)\n    at FunctionScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:3065:38)\n    at ChildScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:3065:38)\n    at FunctionScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:3065:38)\n    at ChildScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:3065:38)\n    at BlockScope.findVariable (/Users/gaoli/GitHub/GGEditor/node_modules/_rollup@1.31.1@rollup/dist/shared/node-entry.js:3065:38)\n",paraId:2,tocIndex:0},{value:"说明：3.2.x 版本不会出现这个问题。",paraId:3,tocIndex:0},{value:"添加 babel-plugin-lodash 插件，此插件会自动优化 lodash 的引用方式。",paraId:4,tocIndex:1},{value:"设置 @rollup/plugin-node-resolve 插件 browser 属性为 true，修复 G 当前的问题。",paraId:4,tocIndex:1}]},97668:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"使用最新版 G6，build 时候报如下错误：",paraId:0,tocIndex:0},{value:"参考 ",paraId:1,tocIndex:1},{value:"#issues 960",paraId:1,tocIndex:1},{value:"。",paraId:1,tocIndex:1}]},46200:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"如何设置节点或边的背景",paraId:0},{value:"如何更新节点或边的样式",paraId:1},{value:"如何更新文本样式",paraId:2},{value:"如何给元素设置渐变色",paraId:3},{value:"如何给元素设置纹理",paraId:4},{value:"如何设置 Edge 前置",paraId:5},{value:"两点之间存在多条边",paraId:6},{value:"React 中使用 G6",paraId:7},{value:"缩放画布时如何让 Tooltip、ContextMenu 自动缩放",paraId:8},{value:"为什么明明在图实例上配置了 ",paraId:9,tocIndex:0},{value:"fitView: true",paraId:9,tocIndex:0},{value:"，但却不生效？",paraId:9,tocIndex:0},{value:"fitView 不生效的原因可能是：",paraId:10,tocIndex:0},{value:"minZoom",paraId:11,tocIndex:0},{value:" 值不够小。如果你的图范围很大，要缩放到小于 ",paraId:11,tocIndex:0},{value:"minZoom",paraId:11,tocIndex:0},{value:" 的值才能完成适配，这种情况下缩放就会失败。图默认的 ",paraId:11,tocIndex:0},{value:"minZoom",paraId:11,tocIndex:0},{value:" 是 0.02。解决方案是在实例化图的时候将 ",paraId:11,tocIndex:0},{value:"minZoom",paraId:11,tocIndex:0},{value:" 设置一个很小的值；",paraId:11,tocIndex:0},{value:"如果使用的是 ",paraId:12,tocIndex:0},{value:"type: force",paraId:12,tocIndex:0},{value:" 布局，布局过程是实时渲染计算结果的，所以会出现模拟力相互作用的动画效果。这种情况下如果每一次渲染都进行 fitView，那么图可能就忽大忽小的，因此若配置了 fitView 那么 G6 会在布局结束的时候，进行一次图的适配。即动画结束时进行大小适配。而 force 在迭代的尾声接近收敛，节点移动的幅度很小，有时候看起来好像动画已经结束了却还没有适配，需要等它完全稳定下来才意味着布局结束，从而进行大小适配；",paraId:12,tocIndex:0},{value:"P.S. force 不支持无动画的布局，近期新增的 ",paraId:13,tocIndex:0},{value:"force2",paraId:13,tocIndex:0},{value:" 支持配置 ",paraId:13,tocIndex:0},{value:"animate",paraId:13,tocIndex:0},{value:" 来控制是否一边计算布局一边渲染，设置为 ",paraId:13,tocIndex:0},{value:"false",paraId:13,tocIndex:0},{value:"，且图实例配置了 ",paraId:13,tocIndex:0},{value:"fitView: true",paraId:13,tocIndex:0},{value:"，那么将布局完成后直接绘制出适配容器大小的图。",paraId:13,tocIndex:0},{value:"给到 graph 的 ",paraId:14,tocIndex:0},{value:"width",paraId:14,tocIndex:0},{value:" 或 ",paraId:14,tocIndex:0},{value:"height",paraId:14,tocIndex:0},{value:" 在图实例化时不准确，导致创建的画布大小不对。这很有可能出现在 React 初始化时，图的容器还没有渲染。如果需要图始终适配容器大小，可以监听容器的 ",paraId:14,tocIndex:0},{value:"width",paraId:14,tocIndex:0},{value:"、",paraId:14,tocIndex:0},{value:"height",paraId:14,tocIndex:0},{value:" 变化，进行 ",paraId:14,tocIndex:0},{value:"graph.changeSize",paraId:14,tocIndex:0},{value:" 和必要的 ",paraId:14,tocIndex:0},{value:"graph.fitView",paraId:14,tocIndex:0},{value:"。例如在用户拖拽浏览器改变大小时，使用 ",paraId:14,tocIndex:0},{value:"graph.changeSize",paraId:14,tocIndex:0},{value:":",paraId:14,tocIndex:0},{value:"if (typeof window !== 'undefined') {\n  window.onresize = () => {\n    if (!graph || graph.get('destroyed')) return;\n    if (!container || !container.scrollWidth || !container.scrollHeight) return;\n    graph.changeSize(container.scrollWidth, container.scrollHeight);\n  };\n}\n",paraId:15,tocIndex:0},{value:"G6 4.x 依赖的渲染引擎 @antv/g@4.x 版本支持了局部渲染，带了性能提升的同时，也带来了图形更新时可能存在渲染残影的问题。比如拖拽节点时，节点的文本会留下轨迹。由于目前 @antv/g 正在进行大版本的升级（到 5.x），可能不考虑在 4.x 彻底修复这个问题。当我们遇到这个问题的时候，考虑通过下面几种方法解决：",paraId:16,tocIndex:1},{value:"检查节点中的图形，包括文本图形，样式配置中是否存在非法值，例如 ",paraId:17,tocIndex:1},{value:"null",paraId:17,tocIndex:1},{value:"、",paraId:17,tocIndex:1},{value:"NaN",paraId:17,tocIndex:1},{value:" 等；",paraId:17,tocIndex:1},{value:"尽量使用整数作为数值型的样式值，例如 ",paraId:18,tocIndex:1},{value:"r",paraId:18,tocIndex:1},{value:"、",paraId:18,tocIndex:1},{value:"width",paraId:18,tocIndex:1},{value:"、",paraId:18,tocIndex:1},{value:"height",paraId:18,tocIndex:1},{value:"、",paraId:18,tocIndex:1},{value:"fontSize",paraId:18,tocIndex:1},{value:" 等；",paraId:18,tocIndex:1},{value:"使用浏览器字体作为 ",paraId:19,tocIndex:1},{value:"labelCfg.style.fontFamily",paraId:19,tocIndex:1},{value:" 或留下残影的文本图形的 ",paraId:19,tocIndex:1},{value:"fontFamily",paraId:19,tocIndex:1},{value:" 属性；",paraId:19,tocIndex:1},{value:"给文本增加白色描边，如：",paraId:20,tocIndex:1},{value:"// 节点/边/ combo 的文本配置\nlabelCfg: {\n  style: {\n    stroke: '#fff',\n    lineWidth: 4\n  }\n}\n// 自定义节点/边/ combo 中的文字图形\ngroup.addShape('text', {\n  attrs: {\n    // ... other attributes,\n    stroke: '#fff',\n    lineWidth: 4,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'text-shape'\n})\n",paraId:21,tocIndex:1},{value:"以上方法都不奏效，关闭局部渲染 ",paraId:22,tocIndex:1},{value:"graph.get('canvas').set('localRefresh', false)",paraId:22,tocIndex:1},{value:"。这个方法可能导致性能有所降低。",paraId:22,tocIndex:1},{value:"G6 的性能主要存在两个瓶颈：渲染、计算（例如布局计算）。G6 内部的代码在持续迭代性能优化，尽可能保持内置代码性能最优。有时候，可能是大家在使用 G6 实现自己的应用时，由于不熟悉或 G6 文档不够全面等问题，使得功能设计、写法问题、或 API 使用不太合理导致的表现出卡顿现象。请看专文",paraId:23,tocIndex:2},{value:"《从卡掉渣到满帧率需要几步？》",paraId:24,tocIndex:2},{value:"，介绍了一些 tips 来帮助你优化实现方式导致的性能问题。",paraId:23,tocIndex:2}]},89577:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在面对复杂数据的图可视分析，你的 G6 应用是否出现了卡顿、掉帧、不流畅现象？跟着本文的 tips 排查和优化，提升你的图可视化应用的性能。G6 的性能瓶颈主要在两个方面：渲染、计算。本小节介绍性能瓶颈的一些原理，对理论不感兴趣只想直接优化代码的小伙伴可以直接跳到",paraId:0,tocIndex:0},{value:"解决方案",paraId:1,tocIndex:0},{value:"章节",paraId:0,tocIndex:0},{value:"在渲染方面，性能主要取决于当前画布上形状元素的个数，e.g. 一个节点上有矩形、文本、图片三个图形，一条边上有路径、文本两个图形，那么一份 100 个节点、50 条边的图数据，将渲染出 100 * 3 + 50 * 2 = 400 个图形。然而，开发者常常自定义非常复杂的节点，一个节点上可能有 10～20 个图形，那么画布上的图形数量将陡增。因此，尽可能地减少不必要的图形绘制，是提升渲染性能的主要手段。",paraId:2,tocIndex:1},{value:"计算方面，主要包括节点布局计算、折线自动寻径算法等。",paraId:3,tocIndex:2},{value:"G6 内部代码，我们在持续迭代其性能。而基于 G6 的图应用，则需要应用的开发者关注实现方式，不合理的实现方式很可能导致性能的额外开销。",paraId:4,tocIndex:3},{value:"一般来说，我们应当根据浏览器中容器的大小设置图画布的大小，即在图实例上配置的 ",paraId:5,tocIndex:4},{value:"width",paraId:5,tocIndex:4},{value:" 与 ",paraId:5,tocIndex:4},{value:"height",paraId:5,tocIndex:4},{value:"。目前主流显示器的分辨率来看，浏览器中放置图的容器长一般都不会超过 2500，高一般不会超过 2000。之前曾经遇到过开发者将图的 ",paraId:5,tocIndex:4},{value:"width",paraId:5,tocIndex:4},{value:" 和 ",paraId:5,tocIndex:4},{value:"height",paraId:5,tocIndex:4},{value:" 设置到几万，这造成了 ",paraId:5,tocIndex:4},{value:"<canvas />",paraId:5,tocIndex:4},{value:" 标签的宽高非常大。这完全没有必要，因为大部分超出了浏览器视口。实际上，我们绘制的节点即使坐标达到了上万，我们仍然可以通过 ",paraId:5,tocIndex:4},{value:"drag-canvas",paraId:5,tocIndex:4},{value:"、",paraId:5,tocIndex:4},{value:"zoom-canvas",paraId:5,tocIndex:4},{value:" 等交互滚动查看，没有必要设置巨大的图宽高。",paraId:5,tocIndex:4},{value:"相比于 Canvas，可能部分开发者更熟悉 DOM/SVG 的定义，毕竟 SVG 渲染出来之后可以审查元素，更符合我们的日常调试习惯。比如当你在自定义节点中使用 ",paraId:6,tocIndex:5},{value:"group.addShape('dom', {...})",paraId:6,tocIndex:5},{value:" 这种 'dom' 图形时，就必须要使用 SVG 渲染，即在图实例上配置 ",paraId:6,tocIndex:5},{value:"renderer: 'svg'",paraId:6,tocIndex:5},{value:"。",paraId:6,tocIndex:5},{value:"但 SVG 的性能比 Canvas 差得多。",paraId:6,tocIndex:5},{value:" 在数据较大、节点比较复杂的情况下，我们强烈推荐你使用 Canvas 进行渲染。Canvas 定义图形的方式也非常灵活，完全可以覆盖 SVG 的能力，或任何看起来像 DOM 定义的卡片样式的节点。比如下面这两个例子，都是使用 Canvas 渲染和定义。\n",paraId:6,tocIndex:5},{value:"http://g6.antv.antgroup.com/examples/item/customNode/#card",paraId:7,tocIndex:5},{value:"http://g6.antv.antgroup.com/examples/item/customNode/#cardNode",paraId:7,tocIndex:5},{value:"回到 SVG 容易审查这个优势，虽然 Canvas 上没有办法审查每一个图形，但我们可以通过下面方式打印图形的属性，进行调试：",paraId:8,tocIndex:5},{value:"// 整个图\nconst graphGroup = graph.getGroup(); // 整个图的根图形分组\nconst graphGroups = graphGroup.get('children'); // 一般会有 -node -edge -delegate 几个分组\n\n// 单个节点（单个边/ combo 也类似）\nconst node = graph.findById('node1'); // 找到某个节点对象\nconst nodeShapeGroup = node.getContainer(); // 获取该节点的图形分组\nconst nodeShapes = nodeShapeGroup.get('children'); // 获取改节点中的所有图形\nconst keyShape = node.getKeyShape(); // 获取该节点的关键图形，keyShape 在 nodeShapes 中\nconst labelShape = nodeShapeGroup.find(ele => ele.get('name') === 'label-shape'); // 获取 name 为 'label-shape' 的图形（name 在 addShape 时指定）。labelShape 在 nodeShapes 中\nconsole.log(nodeShapes[0].attr(), keyShape.attr(), labelShape.attr()); // 获取并打印图形的属性\n",paraId:9,tocIndex:5},{value:"除了使用 Canvas 渲染，在定义如此复杂的节点时，同时建议尽可能控制图形的数量，见下文 ",paraId:10,tocIndex:5},{value:"减少自定义元素的图形数量",paraId:11,tocIndex:5},{value:" 一节。",paraId:10,tocIndex:5},{value:"图的渲染性能很大程度取决于画布上图形的数量。有时虽然数据层面只有 100 个节点，但由于自定义节点非常复杂，每个节点达到数十个图形，再加上复杂的自定义边，可能图上图形也能够达到上万。比如下面这个节点上有二十七个图形（因为节点带滚动，部分文字、锚点被隐藏）：\n",paraId:12,tocIndex:6},{value:"减少不必要的图形。例如，给矩形增加边框，不需要新增图形，只需要给矩形设置描边粗细 ",paraId:13,tocIndex:6},{value:"lineWidth",paraId:13,tocIndex:6},{value:" 和描边色 ",paraId:13,tocIndex:6},{value:"stroke",paraId:13,tocIndex:6},{value:" 即可。",paraId:13,tocIndex:6},{value:"默认看不见的图形，设置 ",paraId:13,tocIndex:6},{value:"visible: false",paraId:13,tocIndex:6},{value:"（而不是 ",paraId:13,tocIndex:6},{value:"opacity: 0",paraId:13,tocIndex:6},{value:"）进行隐藏。在自定义节点的 ",paraId:13,tocIndex:6},{value:"update",paraId:13,tocIndex:6},{value:" 方法或 ",paraId:13,tocIndex:6},{value:"draw",paraId:13,tocIndex:6},{value:" 方法中，根据情况再通过 ",paraId:13,tocIndex:6},{value:"shape.show()",paraId:13,tocIndex:6},{value:" 将其显示出来或 ",paraId:13,tocIndex:6},{value:"shape.hide()",paraId:13,tocIndex:6},{value:" 再次隐藏，e.g.",paraId:13,tocIndex:6},{value:"const circleShape = group.addShape('circle', {\n  attrs: {}, // 在 attrs 中设置 opacity: 0 也能达到看不见的目的，但实际上还是渲染了，更推荐使用 visible 控制\n  name: 'custom-circle', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  visible: false, // 默认隐藏。注意 visible 字段的位置。visible 为 false 时，图形不会被渲染\n});\ncircleShape.show(); // 显示\ncircleShape.hide(); // 隐藏\n",paraId:14,tocIndex:6},{value:"根据缩放等级，调整显示的图形。在小规模的图上，每个节点都有详细信息性能问题不大，且用户也许需要在每个节点上看到如此详细的信息。但在较大规模的图上，概览时用户更关心的是图的关系结构，此时我们应当考虑，根据情况调整自定义节点上图形的数量，隐藏不必要的信息。这样做一方面可以减小渲染的压力，另一方面可以让用户更高效地获得更清晰的信息。在官网案例",paraId:15,tocIndex:6},{value:"决策树",paraId:15,tocIndex:6},{value:"中，进行画布的缩放，可以看到详情（左）和缩略节点（右）的优雅切换。每个节点上图形显示的图形数量从 9 个（详细）降低到 2 个（缩略）。",paraId:15,tocIndex:6},{value:"初学者为了方便自定义节点/边/ combo，往往只定义 ",paraId:16,tocIndex:7},{value:"draw",paraId:16,tocIndex:7},{value:" 或 ",paraId:16,tocIndex:7},{value:"drawShape",paraId:16,tocIndex:7},{value:" 方法，我们也鼓励在小规模图上这样做，可以减少一些开发成本和学习成本。但这将带来额外的性能开销。以自定义节点为例，可能有以下几种情况：",paraId:16,tocIndex:7},{value:"G6.registerNode",paraId:17,tocIndex:7},{value:" 第三个参数没有传入被继承的节点类型名，且没有定义 ",paraId:17,tocIndex:7},{value:"update",paraId:17,tocIndex:7},{value:" 方法（或 ",paraId:17,tocIndex:7},{value:"update: undefined",paraId:17,tocIndex:7},{value:"），如下：",paraId:17,tocIndex:7},{value:"G6.registerNode('custom-node', {\n  draw: (cfg, group) => {},\n  update: undefined, // 或没有实现 update\n}); // 没有第三个参数\n",paraId:18,tocIndex:7},{value:"那么，这个自定义节点将不继承任何内置节点，也没有自己的 ",paraId:19,tocIndex:7},{value:"update",paraId:19,tocIndex:7},{value:" 方法。包括初次绘制，所有的更新，例如通过外部或外部调用的 ",paraId:19,tocIndex:7},{value:"graph.updateItem",paraId:19,tocIndex:7},{value:"、",paraId:19,tocIndex:7},{value:"node.refresh",paraId:19,tocIndex:7},{value:" 等方法，都将擦除该节点上的所有图形，并重新走一遍 ",paraId:19,tocIndex:7},{value:"draw",paraId:19,tocIndex:7},{value:" 方法。这也意味着这个节点上的所有图形将被销毁和重新实例化。这就带来了大量消耗。",paraId:19,tocIndex:7},{value:"G6.registerNode",paraId:20,tocIndex:7},{value:" 第三个参数指定了被继承的节点类型名，没有复写 ",paraId:20,tocIndex:7},{value:"update",paraId:20,tocIndex:7},{value:"，如下：",paraId:20,tocIndex:7},{value:"G6.registerNode('custom-node', {\n  draw: (cfg, group) => {},\n}, 'circle'); // 继承内置 circle 类型节点\n",paraId:21,tocIndex:7},{value:"此时，",paraId:22,tocIndex:7},{value:"custom-node",paraId:22,tocIndex:7},{value:" 将继承内置 ",paraId:22,tocIndex:7},{value:"circle",paraId:22,tocIndex:7},{value:" 类型节点的 ",paraId:22,tocIndex:7},{value:"update",paraId:22,tocIndex:7},{value:"、",paraId:22,tocIndex:7},{value:"setState",paraId:22,tocIndex:7},{value:" 等方法。有时，可能发现节点更新时，似乎有不符合预期的图形出现，这是由于 ",paraId:22,tocIndex:7},{value:"custom-node",paraId:22,tocIndex:7},{value:" 的 ",paraId:22,tocIndex:7},{value:"draw",paraId:22,tocIndex:7},{value:" 方法和 ",paraId:22,tocIndex:7},{value:"circle",paraId:22,tocIndex:7},{value:" 类型节点的 ",paraId:22,tocIndex:7},{value:"draw",paraId:22,tocIndex:7},{value:" 方法差异太大，以至于 ",paraId:22,tocIndex:7},{value:"circle",paraId:22,tocIndex:7},{value:" 类型节点按照自己在 ",paraId:22,tocIndex:7},{value:"draw",paraId:22,tocIndex:7},{value:" 方法中定义的图形进行更新，与 ",paraId:22,tocIndex:7},{value:"custom-node",paraId:22,tocIndex:7},{value:" 逻辑不匹配。解决这一问题最简单的方法就是将 ",paraId:22,tocIndex:7},{value:"update",paraId:22,tocIndex:7},{value:" 复写为 ",paraId:22,tocIndex:7},{value:"undefined",paraId:22,tocIndex:7},{value:"。此时，就带来了和第一种情况类似的、不实现 ",paraId:22,tocIndex:7},{value:"update",paraId:22,tocIndex:7},{value:" 方法的性能开销。",paraId:22,tocIndex:7},{value:"G6.registerNode",paraId:23,tocIndex:7},{value:" 第三个参数指定了被继承的节点类型名，复写 ",paraId:23,tocIndex:7},{value:"update: undefined",paraId:23,tocIndex:7},{value:"，如下：",paraId:23,tocIndex:7},{value:"G6.registerNode('custom-node', {\n  draw: (cfg, group) => {},\n  update: undefined, // 被复写\n}, 'circle'); // 继承内置 circle 类型节点\n",paraId:24,tocIndex:7},{value:"上面第二种情况所述的，更新时出现不符合预期的图形或样式问题在复写 ",paraId:25,tocIndex:7},{value:"update: undefined",paraId:25,tocIndex:7},{value:" 后应当不复存在。但带来了不实现 ",paraId:25,tocIndex:7},{value:"update",paraId:25,tocIndex:7},{value:" 方法的性能开销。即所有的更新，例如通过外部或外部调用的 ",paraId:25,tocIndex:7},{value:"graph.updateItem",paraId:25,tocIndex:7},{value:"、",paraId:25,tocIndex:7},{value:"node.refresh",paraId:25,tocIndex:7},{value:" 等方法，都将擦除该节点上的所有图形，并重新走一遍 ",paraId:25,tocIndex:7},{value:"draw",paraId:25,tocIndex:7},{value:" 方法。这也意味着这个节点上的所有图形将被销毁和重新实例化。",paraId:25,tocIndex:7},{value:"因此，为了更好的渲染性能，最合理的实现是充分利用节点的生命周期，在不同生命周期给出不同的增量逻辑。如下：",paraId:26,tocIndex:7},{value:"G6.registerNode('custom-node', {\n  draw: (cfg, group) => {\n    group.addShape('circle', {\n      attrs: {...}, // styles,\n      name: 'xxx' // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n    })\n    // ...\n  },\n  update: (cfg, group, item) => { // 根据 cfg，产生增量的响应\n    const someShape = group.find(ele => ele.get('name') === 'xxx'); // 拿到需要更新的图形\n    someShape.attr({ lineWidth: 2 }); // 修改图形样式\n    someShape.show(); // 控制显示和隐藏\n  },\n}, 'circle'); // 继承内置 circle 类型节点\n",paraId:27,tocIndex:7},{value:"当然，这要求开发者能够对节点上图形的更新有足够清晰管理逻辑。就像 React 的 ",paraId:28,tocIndex:7},{value:"componentDidMount",paraId:28,tocIndex:7},{value:"、",paraId:28,tocIndex:7},{value:"componentDidUpdate",paraId:28,tocIndex:7},{value:" 等生命周期函数一样，不同的 props 变更做出不同的响应。相信只要理解了这一原理，你也能轻松做到。",paraId:28,tocIndex:7},{value:"与其他类型的边不同，折线类型边(polyline)在未指定 ",paraId:29,tocIndex:8},{value:"controlPoints",paraId:29,tocIndex:8},{value:"（拐折点）时，将使用 A* 自动寻径算法，根据起点和终点的位置，自动计算折线弯折的位置。这一计算的复杂度较高，特别是在拖拽节点的过程中，相关的边需要实时根据最新的端点位置，频繁地计算 A* 算法。因此，当图上的 polyline 边比较多时，可能出现卡顿现象。根据你的实际情况，可以选择如下方法进行避免：",paraId:29,tocIndex:8},{value:"参考官网案例",paraId:30,tocIndex:8},{value:"自定义折线",paraId:30,tocIndex:8},{value:"。大部分情况下，折线两个弯折位置分别在两端点（下面例子的",paraId:30,tocIndex:8},{value:"startPoint",paraId:30,tocIndex:8},{value:"、",paraId:30,tocIndex:8},{value:"endPoint",paraId:30,tocIndex:8},{value:"）连线的 1/3 和 2/3 处，其实我们可以轻易计算出简单的折线路径。",paraId:30,tocIndex:8},{value:"[\n  ['M', startPoint.x, startPoint.y],\n  ['L', endPoint.x / 3 + (2 / 3) * startPoint.x, startPoint.y],\n  ['L', endPoint.x / 3 + (2 / 3) * startPoint.x, endPoint.y],\n  ['L', endPoint.x, endPoint.y],\n]\n",paraId:31,tocIndex:8},{value:"若你使用的布局算法是 ",paraId:32,tocIndex:8},{value:"dagre",paraId:32,tocIndex:8},{value:"，那么可以打开它的 ",paraId:32,tocIndex:8},{value:"controlPoints",paraId:32,tocIndex:8},{value:" 配置。",paraId:32,tocIndex:8},{value:"dagre",paraId:32,tocIndex:8},{value:" 算法将为 polyline 边计算控制点，有了控制点，polyline 将不再使用 A* 自动寻径算法，配置方法如下：",paraId:32,tocIndex:8},{value:"const graph = new Graph({\n  // ... 其他配置\n  layout: {\n    type: 'dagre',\n    controlPoints: true,\n    // ... 其他配置\n  }\n})\n",paraId:33,tocIndex:8},{value:"设置节点/边的状态样式、拖拽节点等，基本都是局部更新，即渲染器只会擦除更新前的“脏矩形”，绘制上更新后的图形。但平移画布、缩放画布，在 Canvas 层面上，实际上是整个画布的擦除和重绘，并且在平移/缩放的过程中，这一重绘是极其频繁地被执行的。因此在较大规模的图上，用户可能会明显感觉到平移、缩放画布时非常卡顿。内置的缩放画布 ",paraId:34,tocIndex:9},{value:"zoom-canvas",paraId:34,tocIndex:9},{value:" 和拖拽平移画布 ",paraId:34,tocIndex:9},{value:"drag-canvas",paraId:34,tocIndex:9},{value:" 交互支持配置项 ",paraId:34,tocIndex:9},{value:"enableOptimize",paraId:34,tocIndex:9},{value:"，设置为 ",paraId:34,tocIndex:9},{value:"true",paraId:34,tocIndex:9},{value:" 时，在拖拽/缩放过程中，非关键图形（即 ",paraId:34,tocIndex:9},{value:"G6.registerNode",paraId:34,tocIndex:9},{value:"、",paraId:34,tocIndex:9},{value:"G6.registerEdge",paraId:34,tocIndex:9},{value:"、",paraId:34,tocIndex:9},{value:"G6.registerCombo",paraId:34,tocIndex:9},{value:" 的 ",paraId:34,tocIndex:9},{value:"draw",paraId:34,tocIndex:9},{value:" 返回的图形）将会被隐藏。拖拽/缩放结束后，哪些临时被隐藏的图形将恢复显示。这样能够大大提升拖拽/缩放过程中的帧率。",paraId:34,tocIndex:9},{value:"默认情况下 ",paraId:35,tocIndex:9},{value:"enableOptimize",paraId:35,tocIndex:9},{value:" 是 ",paraId:35,tocIndex:9},{value:"false",paraId:35,tocIndex:9},{value:"，可以通过下面方式配置：",paraId:35,tocIndex:9},{value:"const graoh = new Graph({\n  // ...其他配置项\n  modes: {\n    default: [{\n      type: 'drag-canvas',\n      enableOptimize: true,\n      // ... 其他配置\n    }, {\n      type: 'zoom-canvas',\n      enableOptimize: true,\n      // ... 其他配置\n    }]\n  }\n})\n",paraId:36,tocIndex:9},{value:"G6 提供了多种布局算法，其中力导向布局还是受到大多数开发者的青睐。G6 的以下几种布局均是力导家族成员，但性能却有差异，我们更推荐使用近期新增的 ",paraId:37,tocIndex:10},{value:"force2",paraId:37,tocIndex:10},{value:" 算法：",paraId:37,tocIndex:10},{value:"force2：新增的力导算法，性能优秀，在经典力导向模型基础上，增加了更多关于向心力、聚类力的配置，可配置带动画或不带动画的布局 (",paraId:38,tocIndex:10},{value:"animate",paraId:38,tocIndex:10},{value:")；",paraId:38,tocIndex:10},{value:"force：引用自 d3 的力导向算法，暂不支持不带动画的布局；",paraId:38,tocIndex:10},{value:"forceAtlas2：区别于经典的力导向模型，效果更紧凑，性能一般，实现自论文 ",paraId:38,tocIndex:10},{value:"ForceAtlas2, a Continuous Graph Layout Algorithm forHandy Network Visualization Designed for the GephiSoftware",paraId:38,tocIndex:10},{value:"；",paraId:38,tocIndex:10},{value:"fruchterman：另一种力导向模型，倾向于六边形的分布，性能较差，实现自论文 ",paraId:38,tocIndex:10},{value:"Fruchterman–Reingold Hexagon Empowered NodeDeployment in Wireless Sensor Network Application",paraId:38,tocIndex:10},{value:"。",paraId:38,tocIndex:10},{value:"只有力导向家族的布局可以通过布局的 ",paraId:39,tocIndex:10},{value:"animate",paraId:39,tocIndex:10},{value:" 配置控制是否在计算过程中不断渲染，从而展现出类似“粒子碰撞”、“力相互作用”的动画效果。其他布局只能在完全计算完成之后进行绘制，在图实例上配置 ",paraId:39,tocIndex:10},{value:"animate: true",paraId:39,tocIndex:10},{value:" 可以为这一类静态的布局，或力导向家族配置 ",paraId:39,tocIndex:10},{value:"animate: false",paraId:39,tocIndex:10},{value:" 的情况下，布局完成之后进行节点位置的插值动画，移动到对应的位置上。",paraId:39,tocIndex:10},{value:"在数据量较小时，力导向家族无论是否开启布局的 ",paraId:40,tocIndex:10},{value:"animate",paraId:40,tocIndex:10},{value:"，效果均不错。在较大数据集上，若关闭 ",paraId:40,tocIndex:10},{value:"animate",paraId:40,tocIndex:10},{value:"，则可能需要较长时间等待布局完成后，画布才会更新。若打开 ",paraId:40,tocIndex:10},{value:"animate",paraId:40,tocIndex:10},{value:"，在动画中等待布局的完成，一般来说更容易为终端用户所接受。当然，也有可能出现布局的尾声，节点有“震荡”情况。建议在监听节点或画布的点击事件，在用户点击时，停止布局。",paraId:40,tocIndex:10},{value:"若干个元素的更新，更推荐使用 ",paraId:41,tocIndex:11},{value:"graph.updateItem",paraId:41,tocIndex:11},{value:" 分别更新；",paraId:41,tocIndex:11},{value:"新增若干个元素，更推荐使用 ",paraId:41,tocIndex:11},{value:"graph.addItem",paraId:41,tocIndex:11},{value:"。v4.6.6 起支持了 ",paraId:41,tocIndex:11},{value:"graph.addItems",paraId:41,tocIndex:11},{value:" 批量新增元素；",paraId:41,tocIndex:11},{value:"移除若干个元素，更推荐使用 ",paraId:41,tocIndex:11},{value:"graph.removeItem",paraId:41,tocIndex:11},{value:"；",paraId:41,tocIndex:11},{value:"大部分的数据变更，使用 ",paraId:41,tocIndex:11},{value:"graph.changeData",paraId:41,tocIndex:11},{value:"。该方法将做当前图数据和 changeData 传入的新数据的 diff，若发现 id 相同的元素，将进行新旧数据的融合。",paraId:41,tocIndex:11},{value:"Minimap 是 G6 的小地图插件，用作图的导览。它有三种类型：",paraId:42,tocIndex:12},{value:"'default'",paraId:42,tocIndex:12},{value:"、",paraId:42,tocIndex:12},{value:"'keyShape'",paraId:42,tocIndex:12},{value:"、",paraId:42,tocIndex:12},{value:"'delegate'",paraId:42,tocIndex:12},{value:"。",paraId:42,tocIndex:12},{value:"'default'",paraId:42,tocIndex:12},{value:" 模式下，主图上的所有内容将被完全拷贝一份到 Minimap 的画布上，在主图元素发生更新的时候，Minimap 的响应内容也需要重新拷贝，相当于两份图的开销，因此这种类型的 Minimap 性能最差。",paraId:42,tocIndex:12},{value:"'keyShape'",paraId:42,tocIndex:12},{value:" 模式下，Minimap 仅显示节点和边的主要图形、",paraId:42,tocIndex:12},{value:"'delegate'",paraId:42,tocIndex:12},{value:" 模式下，Minimap 仅显示代理图形（可通过 ",paraId:42,tocIndex:12},{value:"delegateStyle",paraId:42,tocIndex:12},{value:" 配置），这两种模式的 Minimap 画布内容较为简化，因此有更好的性能。在较大规模的图上，我们更推荐后面两种模式的 Minimap。",paraId:42,tocIndex:12},{value:"此外，考虑到 Minimap 一般比较小，元素比较多时，边比较细，在 Minimap 上也看不清。 v4.7.16 起，Minimap 支持了 ",paraId:43,tocIndex:12},{value:"hideEdge",paraId:43,tocIndex:12},{value:" 配置（默认为 ",paraId:43,tocIndex:12},{value:"false",paraId:43,tocIndex:12},{value:"），可设置为 ",paraId:43,tocIndex:12},{value:"true",paraId:43,tocIndex:12},{value:" 以隐藏 Minimap 上的边，从而更大程度地提升 Minimap 的性能。",paraId:43,tocIndex:12},{value:"动画的性能开销一般比较大，更建议动画使用在局部的状态响应时。例如 hover 节点时的呼吸效果、相关上下游的边流动效果等。并及时地停止动画。",paraId:44,tocIndex:13}]},76047:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本文将介绍如何在 IE 中使用 G6。",paraId:0},{value:"对于这类问题，我们在项目中只需要引入 ",paraId:1,tocIndex:0},{value:"babel-polyfill",paraId:1,tocIndex:0},{value:" 即可，具体使用方法如下：",paraId:1,tocIndex:0},{value:"在主入门文件中引入 ",paraId:2,tocIndex:0},{value:"babel-polyfill",paraId:2,tocIndex:0},{value:" ；",paraId:2,tocIndex:0},{value:"在 ",paraId:2,tocIndex:0},{value:"bable-loader",paraId:2,tocIndex:0},{value:" 中加入如下代码：",paraId:2,tocIndex:0},{value:"{\n    test: /\\.js$/,\n    loader: 'babel-loader',\n    include: [resolve('src'), resolve('node_modules/@antv/g6')]\n}\n",paraId:3,tocIndex:0},{value:"include",paraId:4,tocIndex:0},{value:" 表示哪些目录中的 .js 文件需要进行 babel-loader；exclude 表示哪些目录中的 .js 文件不要进行 babel-loader。",paraId:4,tocIndex:0},{value:"include",paraId:5,tocIndex:0},{value:" 中的内容请根据具体项目情况设置。",paraId:5,tocIndex:0},{value:"更详细的请参考：",paraId:6,tocIndex:0},{value:"https://blog.csdn.net/y491887095/article/details/81541502",paraId:6,tocIndex:0},{value:"。",paraId:6,tocIndex:0},{value:"另外，针对 @vue/cli、umi、create-react-app 搭建的项目给出一些解决方案，",paraId:7,tocIndex:0},{value:"务必确保在没有引入 G6 时你的项目可以正常运行在 IE 上",paraId:7,tocIndex:0},{value:"。",paraId:7,tocIndex:0},{value:"类似如下错误。 ",paraId:8,tocIndex:0},{value:"本 ",paraId:9,tocIndex:1},{value:"G6 Vue 案例",paraId:9,tocIndex:1},{value:" 是基于 @vue/cli(V: 4.0.5)，3.x 版本可能在写法上有些出入。@vue/cli 怎么解决依赖兼容性问题呢？",paraId:9,tocIndex:1},{value:"遇到问题首先查看 ",paraId:9,tocIndex:1},{value:"Vue 官网",paraId:9,tocIndex:1},{value:" 上有没有类似的教程，从官网上我们定位到浏览器兼容性，如下 ",paraId:9,tocIndex:1},{value:"从文章中我们貌似已经找到了问题的答案，我们需要新建 vue.config.js 文件（和 package.json 同一目录），在里面添加 ",paraId:10,tocIndex:1},{value:"transpileDependencies",paraId:10,tocIndex:1},{value:" 选项：",paraId:10,tocIndex:1},{value:"该选项默认值是 ",paraId:11,tocIndex:1},{value:"[]",paraId:11,tocIndex:1},{value:"，说明会忽略掉所有掉 node_modules 文件，不会对 node_modules 里面对文件做 Babel。我们需要做的就是把我们希望 Babel 的文件加入即可，代码如下。需要注意的是我们加入的依赖",paraId:11,tocIndex:1},{value:"不需要包含 node_modules ，用包名 @antv/g6",paraId:11,tocIndex:1},{value:"即可，因为 @vue/cli 会自动添加前缀 node_modules 。还需要注意  @antv/g6 必须和 package.json 里面的一致。安装依赖的时候首选 npm ，如果你用 yarn、cnpm 等安装，需要确保 node_modules 里面的包名没有被更改。",paraId:11,tocIndex:1},{value:"module.exports = {\n  transpileDependencies: ['@antv/g6'],\n};\n",paraId:12,tocIndex:1},{value:"好了，我们打开 IE11 看看结果吧。 ",paraId:13,tocIndex:1},{value:"最开始的那个报错解决了，但出现了新问题。先用 Chrome 浏览器看看，发现问题是一样的。添加完 ",paraId:14,tocIndex:1},{value:"transpileDependencies",paraId:14,tocIndex:1},{value:" 兼容性问题是没有了，但出了个新错误。再次查看官网，并没有相关文章，那就直接移步 issue 吧。经过一番查找，我们找到如下解决方案，在 babel.config.js 里面添加上 ",paraId:14,tocIndex:1},{value:'sourceType: "unambiguous"',paraId:14,tocIndex:1},{value:" ，具体含义可以官网查阅。",paraId:14,tocIndex:1},{value:"module.exports = {\n  sourceType: 'unambiguous',\n  presets: ['@vue/cli-plugin-babel/preset'],\n};\n",paraId:15,tocIndex:1},{value:"再次编译：",paraId:16,tocIndex:1},{value:"到此，完美解决问题。",paraId:17,tocIndex:1},{value:"如果你使用 create-react-app(V: 3.0.0) 初始化项目，那么恭喜你，create-react-app 已经内置了依赖兼容性的处理方案，你只需要配置项目自身的兼容性问题即可。配置有多种方式，可参考 ",paraId:18,tocIndex:2},{value:"这里",paraId:18,tocIndex:2},{value:" 。",paraId:18,tocIndex:2},{value:" ",paraId:18,tocIndex:2},{value:"也许你想看看内部是怎么处理的，可以执行 ",paraId:19,tocIndex:2},{value:"npm run eject",paraId:19,tocIndex:2},{value:" 或 ",paraId:19,tocIndex:2},{value:"yarn run eject",paraId:19,tocIndex:2},{value:" 以暴露 create-react-app 的内置配置。这个操作是不可逆的。内置配置如下： ",paraId:19,tocIndex:2},{value:"umi 不仅内置了依赖兼容性方案，而且配置简单，如果有任何问题，你可以在答疑群里面 @云谦 老师。",paraId:20,tocIndex:3},{value:"export default {\n  browserslist: ['> 1%', 'last 2 versions'],\n};\n",paraId:21,tocIndex:3}]},92304:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 3.3.0 支持三种构建产物：",paraId:0,tocIndex:0},{value:"lib：commonjs；",paraId:1,tocIndex:0},{value:"es：esm；",paraId:1,tocIndex:0},{value:"dist：umd。",paraId:1,tocIndex:0},{value:"import G6 from '@antv/g6'",paraId:2,tocIndex:0},{value:" 默认引用的是 lib 文件夹下的产物。",paraId:2,tocIndex:0},{value:"其中 esm 及 commonjs 构建产物不支持 webworker 布局。",paraId:3,tocIndex:0},{value:"如果要支持 webworker 布局，请引用 ",paraId:4,tocIndex:0},{value:"CDN",paraId:4,tocIndex:0},{value:" 上的文件。",paraId:4,tocIndex:0},{value:"不再在 G6 中 import @antv/util  后，又 export 一次，直接使用 @antv/util  相关方法；",paraId:5,tocIndex:1},{value:"移除了 util/layout 文件；\n",paraId:5,tocIndex:1},{value:"将 util/layout 中的 ",paraId:6,tocIndex:1},{value:"scaleMatrix",paraId:6,tocIndex:1},{value:"、",paraId:6,tocIndex:1},{value:"floydWarshall",paraId:6,tocIndex:1},{value:"、",paraId:6,tocIndex:1},{value:"getAdjMatrix",paraId:6,tocIndex:1},{value:" 方法移到了 util/math 文件中；",paraId:6,tocIndex:1},{value:"util/layout 中的 ",paraId:6,tocIndex:1},{value:"getEDistance",paraId:6,tocIndex:1},{value:" 方法与 util/math 中的 ",paraId:6,tocIndex:1},{value:"distance",paraId:6,tocIndex:1},{value:" 重复，统一使用 math 中的 ",paraId:6,tocIndex:1},{value:"distance",paraId:6,tocIndex:1},{value:" 方法；",paraId:6,tocIndex:1},{value:"删除了 util/layout 中的 ",paraId:6,tocIndex:1},{value:"mix",paraId:6,tocIndex:1},{value:"、",paraId:6,tocIndex:1},{value:"augment",paraId:6,tocIndex:1},{value:"、",paraId:6,tocIndex:1},{value:"isString",paraId:6,tocIndex:1},{value:" 三个方法，统一使用 @antv/util  中相关方法；",paraId:6,tocIndex:1},{value:"groupData",paraId:5,tocIndex:1},{value:" 改名为 ",paraId:5,tocIndex:1},{value:"group",paraId:5,tocIndex:1},{value:"；",paraId:5,tocIndex:1},{value:"util/group 中删除了 ",paraId:5,tocIndex:1},{value:"flatToTree",paraId:5,tocIndex:1},{value:" 和 ",paraId:5,tocIndex:1},{value:"addNodesToParentNode",paraId:5,tocIndex:1},{value:" 两个方法；",paraId:5,tocIndex:1},{value:"util/base 文件中删除了对 @antv/util 的依赖。",paraId:5,tocIndex:1},{value:"使用 G6 内置插件时不再需要引入其他包，引入 G6 后直接通过 ",paraId:7,tocIndex:2},{value:"G6.PluginName",paraId:7,tocIndex:2},{value:" 的方式获得。例如：",paraId:7,tocIndex:2},{value:'// <= G6 3.2\n// CDN 引入 G6 以及需要使用的插件\n<script src="https://gw.alipayobjects.com/os/antv/assets/lib/jquery-3.2.1.min.js"><\/script>\n<script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.1.0/build/minimap.js"><\/script>\n<script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.1.0/build/grid.js"><\/script>\n// 或 NPM 引入，需要引入 G6 及需要使用的插件\nimport G6, { Minimap, Grid } from \'@antv/G6\'\n\nconst minimap = new Minimap({\n\t//... configurations\n})\nconst grid = new Grid({\n\t//... configurations\n})\n\n\n// G6 4.x\n// CDN 引入，只需要引入 G6\n<script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script>\n\n// G6 3.x 引入地址\n// <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.5.10/dist/g6.min.js"><\/script>\n\n// 或 NPM 引入，只需要引入 G6\nimport G6 from \'@antv/G6\'\n\nconst minimap = new G6.Minimap({\n\t//... configurations\n})\n\nconst grid = new G6.Grid({\n\t//... configurations\n})\n\nconst graph = new G6.Graph({\n\t//... other configurations\n  plugins: [ minimap, grid ]\n});\n',paraId:8,tocIndex:2},{value:"G6 3.3 中，TreeGraph 的布局相关方法与 Graph 统一：",paraId:9,tocIndex:3},{value:"changeLayout",paraId:10,tocIndex:3},{value:" 修改为 ",paraId:10,tocIndex:3},{value:"updateLayout",paraId:10,tocIndex:3},{value:"；",paraId:10,tocIndex:3},{value:"refreshLayout",paraId:10,tocIndex:3},{value:" 修改为 ",paraId:10,tocIndex:3},{value:"layout",paraId:10,tocIndex:3},{value:"。",paraId:10,tocIndex:3},{value:"G6 3.2.x 及以下版本中动画的使用方式：",paraId:11,tocIndex:4},{value:"G6.registerEdge(\n  'loop-growth',\n  {\n    afterDraw(cfg, group) {\n      const shape = group.get('children')[0];\n      const length = shape.getTotalLength();\n      shape.animate(\n        {\n          onFrame(ratio) {\n            const startLen = ratio * length;\n            // 计算线的lineDash\n            const cfg = {\n              lineDash: [startLen, length - startLen],\n            };\n            return cfg;\n          },\n          repeat: true,\n        },\n        2000,\n      );\n    },\n  },\n  'loop',\n);\n",paraId:12,tocIndex:4},{value:"G6 3.3 版本中动画：",paraId:13,tocIndex:4},{value:"我们不再建议使用 3.2 中的调用方式，即包含复写 ",paraId:14,tocIndex:4},{value:"onFrame",paraId:14,tocIndex:4},{value:"。这一种调用方式将会被移除；",paraId:14,tocIndex:4},{value:"提供两种使用 ",paraId:14,tocIndex:4},{value:"animate",paraId:14,tocIndex:4},{value:" 的方式：\n",paraId:14,tocIndex:4},{value:"方式一：",paraId:15,tocIndex:4},{value:"animate(toAttrs, animateCfg)",paraId:15,tocIndex:4},{value:"。其中 ",paraId:15,tocIndex:4},{value:"toAttrs",paraId:15,tocIndex:4},{value:" 为动画的目标参数，",paraId:15,tocIndex:4},{value:"animateCfg",paraId:15,tocIndex:4},{value:" 为动画的配置。例如：",paraId:15,tocIndex:4},{value:"G6.registerEdge(\n  'widen-line',\n  {\n    afterDraw(cfg, group) {\n      const shape = group.get('children')[0];\n      const length = shape.getTotalLength();\n      shape.animate(\n        {\n          lineWidth: 10,\n        },\n        {\n          repeat: false,\n          duration: 500,\n        },\n      );\n    },\n  },\n  'single-edge',\n);\n",paraId:16,tocIndex:4},{value:"方式二：",paraId:17,tocIndex:4},{value:"animate(onFrame, animateCfg)",paraId:17,tocIndex:4},{value:"。其中 ",paraId:17,tocIndex:4},{value:"onFrame",paraId:17,tocIndex:4},{value:" 为每一帧的回调函数，",paraId:17,tocIndex:4},{value:"animateCfg",paraId:17,tocIndex:4},{value:" 为动画的配置。例如：",paraId:17,tocIndex:4},{value:"G6.registerEdge(\n  'loop-growth',\n  {\n    afterDraw(cfg, group) {\n      const shape = group.get('children')[0];\n      const length = shape.getTotalLength();\n      shape.animate(\n        (ratio) => {\n          const startLen = ratio * length;\n          // 计算线的lineDash\n          const cfg = {\n            lineDash: [startLen, length - startLen],\n          };\n          return cfg;\n        },\n        {\n          repeat: true,\n          duration: 2000,\n        },\n      );\n    },\n  },\n  'loop',\n);\n",paraId:18,tocIndex:4},{value:"G6 3.2.x 及以下版本中指定节点或边的图形类型时，可以通过在数据中单个配置、实例化图时全局配置、更新时动态配置等。例如：",paraId:19,tocIndex:5},{value:"// 在数据中单个配置\nconst data = {\n  nodes: [\n    {\n      id: 'node0',\n      type: 'circle',\n    },\n    {\n      id: 'node1',\n      type: 'rect',\n    },\n  ],\n  edges: [\n    {\n      id: 'edge0',\n      source: 'node0',\n      target: 'node1',\n      type: 'polyline',\n    },\n  ],\n};\n// 或在实例化图时全局配置\n",paraId:20,tocIndex:5},{value:"G6 3.3 将会使用 ",paraId:21,tocIndex:5},{value:"type",paraId:21,tocIndex:5},{value:" 字段替代 ",paraId:21,tocIndex:5},{value:"shape",paraId:21,tocIndex:5},{value:" 字段",paraId:21,tocIndex:5},{value:"（同时兼容 ",paraId:21,tocIndex:5},{value:"shape",paraId:21,tocIndex:5},{value:"，但 ",paraId:21,tocIndex:5},{value:"shape",paraId:21,tocIndex:5},{value:" 在以后的版本中将会被舍弃）。",paraId:21,tocIndex:5},{value:"G6 3.3 与 G6 3.2.x 的节点/边的 label 在相同的 fontSize 时，视觉上会有差别，但若二者都使用了默认字号（12），则二者视觉上相同。这是由于在 G6 3.2.x 及之前的版本中，底层渲染引擎在文字上做了额外的矩阵变换，这是不合理的。新版本修复了这一问题，目前的字号对应视觉样式是更合理、准确的。",paraId:22,tocIndex:6},{value:"G6 3.3 中，自定义节点/边时若不希望继承任何节点/边，则不需要为 ",paraId:23,tocIndex:8},{value:"registerNode",paraId:23,tocIndex:8},{value:" 或 ",paraId:23,tocIndex:8},{value:"registerEdge",paraId:23,tocIndex:8},{value:" 函数的第三个参数传递任何值。且",paraId:23,tocIndex:8},{value:"必须",paraId:23,tocIndex:8},{value:"重写 ",paraId:23,tocIndex:8},{value:"draw",paraId:23,tocIndex:8},{value:" 方法。",paraId:23,tocIndex:8},{value:"G6.registerEdge('customNode', {\n  draw(cfg, group) {\n    // ...\n    return keyShape;\n  },\n});\n",paraId:24,tocIndex:8},{value:"希望继承时，节点的基类为 ",paraId:25,tocIndex:8},{value:"'single-node'",paraId:25,tocIndex:8},{value:"，边的基类为 ",paraId:25,tocIndex:8},{value:"'single-edge'",paraId:25,tocIndex:8},{value:"。除了继承基类外，还可以继承其他内置节点或边。而在 G6 3.2 及之前的版本中节点和边的基类统一为 ",paraId:25,tocIndex:8},{value:"'single-shape'",paraId:25,tocIndex:8},{value:"。",paraId:25,tocIndex:8},{value:"G6 3.2 及之前的版本中，自定义节点/边时增加图形可以通过下面代码，不需要指定 ",paraId:26,tocIndex:9},{value:"name",paraId:26,tocIndex:9},{value:" 及 ",paraId:26,tocIndex:9},{value:"draggable",paraId:26,tocIndex:9},{value:" 属性：",paraId:26,tocIndex:9},{value:"G6.registerEdge('customNode', {\n  draw(cfg, group) {\n    const keyShape = group.addShape('rect', {\n      attrs: {\n        // ... 图形属性\n      },\n    });\n    const circle = group.addShape('circle', {\n      attrs: {\n        // ... 图形属性\n      },\n    });\n    return keyShape;\n  },\n});\n",paraId:27,tocIndex:9},{value:"G6 3.3 中，新增图形时建议指定 ",paraId:28,tocIndex:9},{value:"draggable",paraId:28,tocIndex:9},{value:"，必须指定 ",paraId:28,tocIndex:9},{value:"name",paraId:28,tocIndex:9},{value:"（",paraId:28,tocIndex:9},{value:"name",paraId:28,tocIndex:9},{value:" 值在同一元素类型中需要不唯一",paraId:28,tocIndex:9},{value:"）。若不添加，可能导致节点/边上的非 keyShape 图形不能响应部分事件。添加方式如下：",paraId:28,tocIndex:9},{value:"G6.registerEdge('customNode', {\n  draw(cfg, group) {\n    const keyShape = group.addShape('rect', {\n      attrs: {\n        // ... 图形属性\n      },\n      draggable: true, // Allow this shape to be dragged\n      name: 'key-shape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n    });\n    const circle = group.addShape('circle', {\n      attrs: {\n        // ... 图形属性\n      },\n      draggable: true, // Allow this shape to be dragged\n      name: 'circle-shape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n    });\n    return keyShape;\n  },\n});\n",paraId:29,tocIndex:9},{value:"G6 3.2 及之前版本中，marker 图形的半径是通过 ",paraId:30,tocIndex:10},{value:"r",paraId:30,tocIndex:10},{value:" 或 ",paraId:30,tocIndex:10},{value:"radius",paraId:30,tocIndex:10},{value:" 指定。",paraId:30,tocIndex:10},{value:"G6 3.3 中，marker 的图形半径只能通过 ",paraId:31,tocIndex:10},{value:"r",paraId:31,tocIndex:10},{value:" 指定。",paraId:31,tocIndex:10},{value:"例如：",paraId:32,tocIndex:10},{value:"// <= G6 3.2.x\nG6.registerEdge('customNode', {\n  draw(cfg, group) {\n    const marker = group.addShape('marker', {\n      attrs: {\n        // ... 其他图形属性\n        radius: cfg.size[0],\n      },\n      draggable: true,\n      name: 'marker-shape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n    });\n    return keyShape;\n  },\n});\n\n// <= G6 3.3\nG6.registerEdge('customNode', {\n  draw(cfg, group) {\n    const marker = group.addShape('marker', {\n      attrs: {\n        // ... 其他图形属性\n        r: cfg.size[0],\n      },\n      draggable: true,\n      name: 'marker-shape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n    });\n    return keyShape;\n  },\n});\n",paraId:33,tocIndex:10},{value:"G6 3.2.x 及之前的版本支持 fan 图形（使用方法如下），G6 3.3 不再支持。",paraId:34,tocIndex:11},{value:"// 如下图形 G6 3.3 不再支持\ngroup.addShape('fan', {\n  attrs: {\n    x: 50,\n    y: 50,\n    re: 40,\n    rs: 30,\n    startAngle: (1 / 2) * Math.PI,\n    endAngle: Math.PI,\n    clockwise: false,\n    fill: '#b7eb8f',\n  },\n  name: 'fan-shape' // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n});\n",paraId:35,tocIndex:11},{value:"在 G6 3.2 及之前的版本中，需要用户根据当前分辨率在实例化图时指定 ",paraId:36,tocIndex:12},{value:"pixelRatio",paraId:36,tocIndex:12},{value:"。",paraId:36,tocIndex:12},{value:"G6 3.3 中，",paraId:37,tocIndex:12},{value:"pixelRatio",paraId:37,tocIndex:12},{value:" 将被自动计算，不需要再由用户传递。",paraId:37,tocIndex:12},{value:"G6 3.2 中 ",paraId:38,tocIndex:13},{value:"brush-select",paraId:38,tocIndex:13},{value:" 与 ",paraId:38,tocIndex:13},{value:"click-select",paraId:38,tocIndex:13},{value:" 每次选取发生变化时，将会触发 ",paraId:38,tocIndex:13},{value:"nodeselectchange",paraId:38,tocIndex:13},{value:"。",paraId:38,tocIndex:13},{value:"brush-select",paraId:38,tocIndex:13},{value:" 的 ",paraId:38,tocIndex:13},{value:"nodeselectchange",paraId:38,tocIndex:13},{value:" 事件的回调参数含有两个字段：",paraId:38,tocIndex:13},{value:"targets",paraId:39,tocIndex:13},{value:"：当前被选中的所有节点与边。",paraId:39,tocIndex:13},{value:"{nodes: [...], edges: [...]}",paraId:39,tocIndex:13},{value:"select",paraId:39,tocIndex:13},{value:"：当前操作是选中还是取消。",paraId:39,tocIndex:13},{value:"true",paraId:39,tocIndex:13},{value:" | ",paraId:39,tocIndex:13},{value:"false",paraId:39,tocIndex:13},{value:"click-select",paraId:40,tocIndex:13},{value:"  的 ",paraId:40,tocIndex:13},{value:"nodeselectchange",paraId:40,tocIndex:13},{value:" 事件的回调参数含有两个字段：",paraId:40,tocIndex:13},{value:"target",paraId:41,tocIndex:13},{value:"：当前被操作的一个节点，可能是被选中，或取消选中",paraId:41,tocIndex:13},{value:"select",paraId:41,tocIndex:13},{value:"：当前操作是选中还是取消。",paraId:41,tocIndex:13},{value:"true",paraId:41,tocIndex:13},{value:" | ",paraId:41,tocIndex:13},{value:"false",paraId:41,tocIndex:13},{value:"G6 3.3 统一了这两个 behavior 的 ",paraId:42,tocIndex:13},{value:"nodeselectchange",paraId:42,tocIndex:13},{value:" 事件。使用  ",paraId:42,tocIndex:13},{value:"selectedItems",paraId:42,tocIndex:13},{value:" 替代 ",paraId:42,tocIndex:13},{value:"targets",paraId:42,tocIndex:13},{value:" 字段，表示当前被选中的所有元素。防止 ",paraId:42,tocIndex:13},{value:"targets",paraId:42,tocIndex:13},{value:" 的含义与 ",paraId:42,tocIndex:13},{value:"target",paraId:42,tocIndex:13},{value:" （当前被操作的节点，可能是被选中或被取消选中）混淆。",paraId:42,tocIndex:13},{value:"brush-select",paraId:42,tocIndex:13},{value:" 有两个字段：",paraId:42,tocIndex:13},{value:"selectedItems",paraId:43,tocIndex:13},{value:"：当前被选中的所有节点与边。",paraId:43,tocIndex:13},{value:"{nodes: [...], edges: [...]}",paraId:43,tocIndex:13},{value:"select",paraId:43,tocIndex:13},{value:"：当前操作是选中还是取消。true | false",paraId:43,tocIndex:13},{value:"click-select",paraId:44,tocIndex:13},{value:" 有两个字段：",paraId:44,tocIndex:13},{value:"target",paraId:45,tocIndex:13},{value:"：当前被操作的一个节点，可能是被选中，或取消选中",paraId:45,tocIndex:13},{value:"selectedItems",paraId:45,tocIndex:13},{value:"：当前被选中的所有节点与边。",paraId:45,tocIndex:13},{value:"{nodes: [...], edges: [...]}",paraId:45,tocIndex:13},{value:"select",paraId:45,tocIndex:13},{value:"：当前操作是选中还是取消。",paraId:45,tocIndex:13},{value:"true",paraId:45,tocIndex:13},{value:" | ",paraId:45,tocIndex:13},{value:"false",paraId:45,tocIndex:13},{value:"在 G6 3.2 及之前的版本中，可以在实例化图时为图指定渲染器，",paraId:46,tocIndex:14},{value:"renderer",paraId:46,tocIndex:14},{value:" 可选为 ",paraId:46,tocIndex:14},{value:"'canvas'",paraId:46,tocIndex:14},{value:" 或 ",paraId:46,tocIndex:14},{value:"'svg'",paraId:46,tocIndex:14},{value:"。",paraId:46,tocIndex:14},{value:"在 G6 3.3 中，我们致力于更好的 Canvas 版本，暂时不支持 SVG 方式渲染。",paraId:47,tocIndex:14},{value:"renderer",paraId:47,tocIndex:14},{value:" 参数不再起效。SVG 渲染在以后的版本中提供支持。",paraId:47,tocIndex:14}]},28184:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"感谢来自 GitHub 用户 @wooodchen 的解决方案",paraId:0},{value:"如果你在使用 Vite + G6 构建时遇到类似下图的错误\n",paraId:1},{value:"请参考 ",paraId:2},{value:"GitHub Issue #2961",paraId:2},{value:" 中的解决方案。",paraId:2},{value:"需要插件 ",paraId:3},{value:"rollup-plugin-node-rosolve",paraId:3},{value:" 和 ",paraId:3},{value:"rollup-plugin-commonjs",paraId:3},{value:"。虽然不能消除提示，但可以使用。\n在 ",paraId:3},{value:"vite.config.js",paraId:3},{value:" 中如下配置",paraId:3},{value:"import resolve from 'rollup-plugin-node-resolve'\nimport commonjs from 'rollup-plugin-commonjs'\n// ...\nexport default defineConfig({\n  plugin: [\n    ...,\n    resolve(),\n    commonjs(),\n    ...\n  ]\n})\n",paraId:4},{value:"#3284",paraId:5},{value:" 提出另一解决方案，供参考：",paraId:5},{value:"build: {\n  commonjsOptions: {\n    ignoreTryCatch: false,\n  },\n},\n",paraId:6}]},55777:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"当图中只有 Node 和 Edge 而不存在 Combo 时，所有 Edge 的「视觉层级 zIndex」默认低于所有的 Node。但增加嵌套的 Combo 后，元素间的视觉层级需要较复杂的规则定义，方能符合合理的逻辑。为了方便说明，我们用 z(X) 表示 X 元素的视觉层级值。",paraId:0,tocIndex:0},{value:"规则一：单层 Combo 中各元素层级关系是 z(Node) > z(Edge) > z(Combo)，如下所示：",paraId:1,tocIndex:0},{value:"z(a) = z(b) > z(e0) > z(Combo A)",paraId:2,tocIndex:0},{value:"规则一补充：假设 Combo A 内部的子元素包括子 Combo 及节点，且节点间存在边，则：z(子 Combo) > z(Node) > z(Edge) > z(Combo A 本身)，示例如下：",paraId:3,tocIndex:0},{value:"z(b1) = z(b2) > z(e2) > z(Combo B) > z(a1) = z(a2) > z(e1) > z(Combo A)",paraId:4,tocIndex:0},{value:"规则二：通过规则一，可以得到所有 Combo 及 Node 的视觉层级值。若存在某条边 E 的两个端点 a 与 b 来自不同的 Combo，已知 z(a) 与 z(b)，则 z(E) 为 max(z(a), z(b)) 所在 Combo 内边的层级，即：\n",paraId:5,tocIndex:0},{value:"当 z(a) > z(b) 时，z(E) 等于 a 所在 Combo 内边的层级；",paraId:6,tocIndex:0},{value:"当 z(a) <= z(b)，z(E) 等于 b 所在 Combo 内边的层级。",paraId:6,tocIndex:0},{value:"以下图为例，图中红色标注的边属于上述情况：",paraId:7,tocIndex:0},{value:"z(e4) = z(e2) z(e5) = z(e2) z(e6) = z(e1)=z(e3)",paraId:8,tocIndex:0},{value:"规则二补充：在上图的基础上，Combo B 收起后，如下左图；Combo A 收起后，如下右图。可以发现，在收缩一个 Combo 后，隐藏了与该 Combo 相关的节点及边，而增加了虚拟边来表示有外部元素连接到该 Combo 内的元素。",paraId:9,tocIndex:0},{value:"Combo 使用带有不重叠约束的力导型布局方法，Combo 布局分为以下三种情况：",paraId:10,tocIndex:1},{value:"布局最细粒度所有元素；",paraId:11,tocIndex:1},{value:"交互展开一个 Combo；",paraId:11,tocIndex:1},{value:"交互收起一个 Combo。",paraId:11,tocIndex:1},{value:"力导向布局的原则：所有点对之间存在斥力 ",paraId:12,tocIndex:1},{value:"Fr = k/r2",paraId:12,tocIndex:1},{value:"，边连接的点对之间存在引力 ",paraId:12,tocIndex:1},{value:"Fa = ks * r",paraId:12,tocIndex:1},{value:"，其中 ",paraId:12,tocIndex:1},{value:"r",paraId:12,tocIndex:1},{value:" 为两个节点之间的距离，",paraId:12,tocIndex:1},{value:"k",paraId:12,tocIndex:1},{value:" 与 ",paraId:12,tocIndex:1},{value:"ks",paraId:12,tocIndex:1},{value:" 为系数。",paraId:12,tocIndex:1},{value:"「跨组边」—— 边两端节点来自不同的 Combos，减弱其引力大小，即 ",paraId:13,tocIndex:2},{value:"m = f(c) < 1",paraId:13,tocIndex:2},{value:"。图中所有标出的边都为跨组边。跨越层数越多，减弱程度越高。如 ",paraId:13,tocIndex:2},{value:"e46",paraId:13,tocIndex:2},{value:"、",paraId:13,tocIndex:2},{value:"e23",paraId:13,tocIndex:2},{value:"、",paraId:13,tocIndex:2},{value:"e12",paraId:13,tocIndex:2},{value:"、",paraId:13,tocIndex:2},{value:"e15",paraId:13,tocIndex:2},{value:" 跨越了一层，",paraId:13,tocIndex:2},{value:"e34",paraId:13,tocIndex:2},{value:"、",paraId:13,tocIndex:2},{value:"e13",paraId:13,tocIndex:2},{value:" 跨越了两层。因此 ",paraId:13,tocIndex:2},{value:"f(c)",paraId:13,tocIndex:2},{value:" 是关于跨越层数(c)的函数，可以是 ",paraId:13,tocIndex:2},{value:"m = 1/c",paraId:13,tocIndex:2},{value:" 等；",paraId:13,tocIndex:2},{value:"「同组边」—— 边两端节点来自相同 Combo，则引力定义方式不变，即 ",paraId:13,tocIndex:2},{value:"m = f(c) = 1",paraId:13,tocIndex:2},{value:"。",paraId:13,tocIndex:2},{value:"为方便描述，我们为 Combo X 定义层级的高低值 ",paraId:14,tocIndex:3},{value:"P(X)",paraId:14,tocIndex:3},{value:"。如下图所示，A、B、C、D 四个组的层级高低：",paraId:14,tocIndex:3},{value:"P(A) > P(B) > P(C) > P(D)",paraId:14,tocIndex:3},{value:"；",paraId:14,tocIndex:3},{value:"每个 Combo 中有由分组内节点当前的平均位置中心发出的重力，该平均中心根据每次迭代的节点位置进行更新；",paraId:14,tocIndex:3},{value:"P(X)",paraId:14,tocIndex:3},{value:" 越小，其发出的重力 ",paraId:14,tocIndex:3},{value:"G(X)",paraId:14,tocIndex:3},{value:" 越大。例如 ",paraId:14,tocIndex:3},{value:"G(X) = 1/P(X)",paraId:14,tocIndex:3},{value:"；",paraId:14,tocIndex:3},{value:"有些节点可能受到多个重力。例如下图 6 号节点，受到了它上层红色 Combo C 的重力 ",paraId:14,tocIndex:3},{value:"G(C)",paraId:14,tocIndex:3},{value:"，绿色 Combo B 的重力 ",paraId:14,tocIndex:3},{value:"G(B)",paraId:14,tocIndex:3},{value:"，黄色 Combo A 的重力 ",paraId:14,tocIndex:3},{value:"G(A)",paraId:14,tocIndex:3},{value:"。",paraId:14,tocIndex:3},{value:"G(C) > G(B) > G(A)",paraId:14,tocIndex:3},{value:"。",paraId:14,tocIndex:3},{value:"每次迭代检测节点之间是否存在重叠：\n",paraId:15,tocIndex:4},{value:"若两个节点之间存在重叠，则为二者间的斥力乘以一个放大系数 ",paraId:16,tocIndex:4},{value:"R",paraId:16,tocIndex:4},{value:"，使之斥开。",paraId:16,tocIndex:4},{value:"每次迭代（或每 ",paraId:15,tocIndex:4},{value:"q",paraId:15,tocIndex:4},{value:" 次迭代）检测 Combo 之间是否存在重叠：\n",paraId:15,tocIndex:4},{value:"首先计算最小能够包围该组内元素的圆形或矩形（根据 Combo Type 决定）；",paraId:17,tocIndex:4},{value:"计算至上而下遍历，检测每个 Combo 内层级相同的子 Combos 是否存在重叠；",paraId:17,tocIndex:4},{value:"若存在重叠则加大该 Combo 的重力。",paraId:17,tocIndex:4},{value:"相同颜色的 border 代表了相同的层级，该图层级由高到低分别是：A > B > C > D",paraId:18,tocIndex:4}]},82940:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在 G6 中，实例化图时指定 ",paraId:0},{value:"container",paraId:0},{value:" 字段指定了画布 ",paraId:0},{value:"<Canvas></Canvas>",paraId:0},{value:" 标签的父容器。而 DOM 的坐标与真正绘制图形时的坐标并不是同一套坐标系，这可能会使得如下场景中用户指定坐标时产生困惑：",paraId:0},{value:"在画布上放置一个 ",paraId:1},{value:"position: absolute",paraId:1},{value:" 的 DOM 元素，如 tooltip、 menu 等时：\n",paraId:1},{value:"在鼠标点击画布上的位置放置；",paraId:2},{value:"鼠标点击节点时，在节点位置。上面问题在 graph 缩放、平移后更加凸显。下面，我们将深度解析这些坐标之间的关系。",paraId:2},{value:"首先，我们要知道 G6 中有三个坐标系：clientX/clientY、canvasX/canvasY、pointX/pointY。",paraId:3,tocIndex:0},{value:"相对于浏览器的坐标系，原点位于浏览器内容范围的左上角（坐标系位置不随滚动条变化）。如下两图中的 y 轴上页面滚动（y-scroll）位置不同，但 clientX/clientY 坐标系的原点都在左上角。因而 Container DOM 的左上角的 clientX/clientY 不同，左图 Container DOM 的左上角坐标为（100， 1000），右图 Container DOM 的左上角坐标为（100， 200）。",paraId:4,tocIndex:1},{value:"Container DOM 的自身坐标系。假设示例化图时设定 ",paraId:5,tocIndex:2},{value:"width",paraId:5,tocIndex:2},{value:" 与 ",paraId:5,tocIndex:2},{value:"height",paraId:5,tocIndex:2},{value:" 分别是 550 与 500:",paraId:5,tocIndex:2},{value:"const Graph = new G6.Graph({\n  container: 'container',\n  width: 550,\n  height: 500\n})\n",paraId:6,tocIndex:2},{value:"则下图 Container DOM 的宽高即为 550*500。canvasX/canvsY 的原点在 Container DOM 的左上角，Container DOM 右下角的 canvasX/canvasY 坐标为（550，500）。",paraId:7,tocIndex:2},{value:"以上两种坐标系均可理解为 DOM 相关的坐标，其取值均为整数。而在真正绘制图形时，图形是根据 pointX/pointY 定位的，即节点的 (x, y) 等都是与 pointX/pointY 坐标系相对应的。图的缩放、平移其实是整个 pointX/pointY 坐标系的缩放和平移。",paraId:8,tocIndex:3},{value:"上面描述比较抽象。下面我们通过具体例子，进一步了解三种坐标系的关系。",paraId:9,tocIndex:4},{value:"下面所有图中，灰色的坐标系表示 clientX/clientY，蓝色坐标系表示 canvasX/canvasY，红色坐标系表示 pointX/pointY。灰、蓝、红色的虚线以及数字均是相应坐标系的标注。",paraId:10,tocIndex:4},{value:"下图展示了当图没有缩放和平移，也就是说其变换矩阵 matrix 为单位矩阵时，三个坐标系的关系。可以看到 canvasX/canvasY 与 pointX/pointY 两个坐标系是完全重合的，坐标轴尺度、原点位置完全一致。如下图中树图根节点（黑点标注的）位置，其 canvasX/canvasY 和 pointX/pointY 坐标值是一样的。而 clientX/clientY 的原点在浏览器内容左上角，黑点的 clientX/clientY 则需要加上 Container DOM 的左边距和上边距。",paraId:11,tocIndex:5},{value:"图 1：图无变换时的三种坐标系。",paraId:12,tocIndex:5},{value:"当图被缩放：以 pointX/pointY 坐标系的原点为缩放中心，放大为原来的两倍，即图的变换矩阵 matrix 为：",paraId:13,tocIndex:6},{value:"matrix =\n  2 0 0\n  0 2 0\n  0 0 1\n",paraId:14,tocIndex:6},{value:"很容易想到，大部分图可能会超出 Container DOM。",paraId:15,tocIndex:6},{value:"事实上，在缩放时，是在缩放 pointX/pointY 的整个坐标系。由于这个例子中缩放中心是 pointX/pointY 坐标系的原点，缩放两倍即是 pointX/pointY 的 x 轴、y 轴的尺度变为原来的两倍。打个比方，我们把 pointX/pointY 的 x 轴、y 轴看作两根绳子，绳子上每隔 1cm 有标记 1、2、3、……这些标记就是 pointX/pointY 的坐标值，我们分别拽住绳子的一端，把它们分别沿正方向拉长一倍，那么相邻标记之间的距离变成了 2cm 。",paraId:16,tocIndex:6},{value:"canvasX/canvasY 和 clientX/clientY 坐标系不随图的变换而变化。换句话说，在这种情况下，canvasX/canvasY 的 (90, 0) 对应的 pointX/pointY 坐标为 (45, 0) ，canvasX/canvasY 的 (0, 250) 对应的 pointX/pointY 坐标为 (0, 125) 。而 clientX/clientY 仍然是 canvasX/canvasY 加上 Container DOM 的左/上边距。",paraId:17,tocIndex:6},{value:"图 2：图缩放变换时的三种坐标系。",paraId:18,tocIndex:6},{value:"可以看到上图中，图 1 中的树图根节点位置（黑点 A）的 canvasX/canvasY 和 clientX/clientY 坐标不变，仍然分别是 (90, 250) 和 (290, 350)。但由于 pointX/pointY 的坐标轴尺度发生了变化，所以它的 pointX/pointY 变为了 (45, 125)。而现在的根节点（黑点 B 标记）的绘制坐标不变，pointX/pointY 仍然是 (90, 250)，但黑点 B 对应的 canvasX/canvasY 和 clientX/clientY 分别变为了 (180, 500)，(380, 600)。",paraId:19,tocIndex:6},{value:"当图在上一节的基础上再进行平移：把图的左上角移动到 (50, 50) 的位置，即图的变换矩阵 matrix 为：",paraId:20,tocIndex:7},{value:"matrix =\n  2  0  0\n  0  2  0\n  50 50 1\n",paraId:21,tocIndex:7},{value:"很容易想到，大部分图可能会超出 Container DOM 且左上角为出现留白。",paraId:22,tocIndex:7},{value:"和上一节缩放相似，平移图其实是在平移 pointX/pointY 的整个坐标系。打个比方，我们把 pointX/pointY 的 x 轴、y 轴看作两根绳子，两根绳子一起向右平移 50，向下平移 50。",paraId:23,tocIndex:7},{value:"canvasX/canvasY 和 clientX/clientY 坐标系不随图的变换而变化。换句话说，在这种情况下，canvasX/canvasY 的 (90, 0) 对应的 pointX/pointY 坐标为 ((90-50)/2=20, 0) ，canvasX/canvasY 的 (0, 250) 对应的 pointX/pointY 坐标为 (0, (250-50)/2=100) 。而 clientX/clientY 仍然是 canvasX/canvasY 加上 Container DOM 的左/上边距。",paraId:24,tocIndex:7},{value:"图 3：图缩放+平移变换时的三种坐标系。",paraId:25,tocIndex:7},{value:"可以看到上图中，图 1 中的树图根节点位置（黑点 A）的 canvasX/canvasY 和 clientX/clientY 坐标不变，仍然分别是 (90, 250) 和 (290, 350)。但由于 pointX/pointY 的坐标轴尺度、原点发生了变化，所以它的 pointX/pointY 变为了 (20, 100)。而现在的根节点（黑点 B 标记）的绘制坐标不变，pointX/pointY 仍然是 (90, 250)，但黑点 B 对应的 canvasX/canvasY 和 clientX/clientY 分别变为了 (230, 550)，(430, 650)。",paraId:26,tocIndex:7},{value:"了解了三种坐标系的含义后，我们有时需要通过相互转换使用。首先，在 G6 的事件中，event 会包含当前鼠标操作位置的三种坐标值，它们的变量名与上述三种坐标系对应关系如下：",paraId:27,tocIndex:8},{value:"event.x, event.y => pointX/pointY；",paraId:28,tocIndex:8},{value:"event.canvasX, event.canvasY => canvasX/canvasY；",paraId:28,tocIndex:8},{value:"event.clientX, event.clientY => clientX/clientY。",paraId:28,tocIndex:8},{value:"可以发现后两者的名字是直接对应的，我们只需要注意 event 中的 x 和 y 对应的是 pointX/pointY 坐标系即可。",paraId:29,tocIndex:8},{value:"将 pointX/pointY 坐标系的坐标值转换为 canvasX/canvasY 的坐标值。",paraId:30,tocIndex:9},{value:"将 canvasX/canvasY 坐标系的坐标值转换为 pointX/pointY 的坐标值。",paraId:31,tocIndex:10},{value:"将 pointX/pointY 坐标系的坐标值转换为 clientX/clientY 的坐标值。",paraId:32,tocIndex:11},{value:"将 clientX/clientY 坐标系的坐标值转换为 pointX/pointY 的坐标值。",paraId:33,tocIndex:12},{value:"可以发现 G6 的上述四个 API 都是围绕 point，通过上面四个 API 可以进行组合从而使得 clientX/clientY 与 canvasX/canvasY 进行转换：",paraId:34,tocIndex:12},{value:"clientX/clientY 转 canvasX/canvasY：",paraId:35,tocIndex:12},{value:"const point = graph.getPointByClient(clientX, clientY)\nconst canvasXY = graph.getCanvasByPoint(point.x, point.y);\n",paraId:36,tocIndex:12},{value:"canvasX/canvasY 转 clientX/clientY：",paraId:37,tocIndex:12},{value:"const point = graph.getPointByCanvas(canvasX, canvasY)\nconst clientXY = graph.getClientByPoint(point.x, point.y);\n",paraId:38,tocIndex:12},{value:"本文开始时，我们提到了如下场景需要我们使用三种坐标系：",paraId:39,tocIndex:13},{value:"在画布上放置一个 ",paraId:40,tocIndex:13},{value:"position: absolute",paraId:40,tocIndex:13},{value:" 的悬浮 DOM 元素，如 tooltip、 menu 等时：",paraId:40,tocIndex:13},{value:"在鼠标点击画布上的位置放置；",paraId:41,tocIndex:13},{value:"鼠标点击节点时，在节点位置。",paraId:41,tocIndex:13},{value:"如果使用了错误的坐标系来给定悬浮 DOM 元素的位置，将会出现偏移，在图有缩放、平移等变化时，偏移更加严重。在了解如何使用坐标系给悬浮 DOM 定位前，我们先定义一个悬浮 DOM 元素：",paraId:42,tocIndex:13},{value:'  const floatDOM = createDom(`\n  <div id="test-dom" style="position: absolute; background: #f00; height: 100px; width: 200px">\n    floating dom\n  </div>\n  `);\n',paraId:43,tocIndex:13},{value:"不论上述哪一种情况，我们都推荐两种挂载这个悬浮 DOM 的方式：",paraId:44,tocIndex:13},{value:"方法一：挂载在 body 上：",paraId:45,tocIndex:13},{value:"document.body.appendChild(floatDOM);\n",paraId:46,tocIndex:13},{value:"方法二：挂载在 Container DOM 上，即与 canvas 标签同一父容器：",paraId:47,tocIndex:13},{value:"const container = document.getElementById('container') // 假设 Container DOM 的 id 为 container\ncontainer.appendChild(floatDOM);\n",paraId:48,tocIndex:13},{value:"众所周知，",paraId:49,tocIndex:14},{value:"position: absolute",paraId:49,tocIndex:14},{value:" 的 DOM 元素相对于父容器定位。若我们把悬浮 DOM 挂载在 body 上，它的父容器是 body，我们可以使用 ",paraId:49,tocIndex:14},{value:"clientX/clientY",paraId:49,tocIndex:14},{value:" 来指定它的 ",paraId:49,tocIndex:14},{value:"left/top",paraId:49,tocIndex:14},{value:"：",paraId:49,tocIndex:14},{value:"在点击画布的位置上放置 DOM：",paraId:50,tocIndex:14},{value:"graph.on('canvas:click', event => {\n    floatDOM.style.left = event.clientX;\n  floatDOM.style.top = event.clientY;\n});\n",paraId:51,tocIndex:14},{value:"在某个节点的位置上放置 DOM：",paraId:52,tocIndex:14},{value:"const node = graph.getNodes()[0];\nconst { x, y } = node.getModel(); // 获得该节点的位置，对应 pointX/pointY 坐标\nconst clientXY = graph.getClientByPoint(x, y);\nfloatDOM.style.left = clientXY.x;\nfloatDOM.style.top = clientXY.y;\n",paraId:53,tocIndex:14},{value:"若我们把悬浮 DOM 挂载在 Container DOM 上，它的父容器是 Container DOM，我们可以使用 ",paraId:54,tocIndex:15},{value:"canvasX/canvasY",paraId:54,tocIndex:15},{value:" 来指定它的 ",paraId:54,tocIndex:15},{value:"marginLeft/marginTop",paraId:54,tocIndex:15},{value:"：",paraId:54,tocIndex:15},{value:"在点击画布的位置上放置 DOM：",paraId:55,tocIndex:15},{value:"graph.on('canvas:click', event => {\n    floatDOM.style.marginLeft = event.canvasX;\n  floatDOM.style.marginTop = event.canvasY;\n});\n",paraId:56,tocIndex:15},{value:"在某个节点的位置上放置 DOM：",paraId:57,tocIndex:15},{value:"const node = graph.getNodes()[0];\nconst { x, y } = node.getModel(); // 获得该节点的位置，对应 pointX/pointY 坐标\nconst canvasXY = graph.getCanvasByPoint(x, y);\nfloatDOM.style.marginLeft = canvasXY.x;\nfloatDOM.style.marginTop = canvasXY.y;\n",paraId:58,tocIndex:15}]},76687:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 是一款纯 JavaScript 库，可与任何框架无缝结合，因此可以在各种前端框架（例如 React、Vue、Angular 等）中使用。我们提供了一个 G6 在 React 中使用的演示示例以供参考。",paraId:0,tocIndex:0},{value:"我们期待社区中有开发者能够提供 G6 在 Vue 和 Angular 中使用的示例，供其他开发者学习和参考，非常感谢！",paraId:1,tocIndex:0},{value:"在 Demo 中，我们以一个简单的流程图为例，实现如下的效果。",paraId:2,tocIndex:0},{value:"Demo 包括以下功能点：",paraId:3,tocIndex:1},{value:"自定义节点；",paraId:4,tocIndex:1},{value:"自定义边；",paraId:4,tocIndex:1},{value:"节点的 tooltip；",paraId:4,tocIndex:1},{value:"边的 tooltip；",paraId:4,tocIndex:1},{value:"节点上面弹出右键菜单；",paraId:4,tocIndex:1},{value:"tooltip 及 ContextMenu 如何渲染自定义的 React 组件。",paraId:4,tocIndex:1},{value:"import React, { useEffect } from 'react';\nimport { Graph } from '@antv/g6';\n\nconst data = {\n  nodes: [\n    { id: '1', label: '公司1' },\n    { id: '2', label: '公司2' },\n    // 节点数据 ...\n  ],\n  edges: [\n    {\n      source: '1',\n      target: '2',\n      data: { type: 'name1', amount: '100,000,000,00 元', date: '2019-08-03' },\n    },\n    // 边数据 ...\n  ],\n};\n\nexport default () => {\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const graphRef = React.useRef<Graph>();\n\n  useEffect(() => {\n    if (graphRef.current || !containerRef.current) return;\n\n    const graph = new Graph({\n      container: containerRef.current,\n      width: 1200,\n      height: 800,\n      modes: { default: ['drag-canvas'] },\n      layout: { type: 'dagre', direction: 'LR' },\n      defaultNode: {\n        type: 'node',\n        labelCfg: {\n          style: { fill: '#000000A6', fontSize: 10 },\n        },\n        style: { stroke: '#72CC4A', width: 150 },\n      },\n      defaultEdge: { type: 'polyline' },\n    });\n\n    // 绑定数据\n    graph.data(data);\n    // 渲染图\n    graph.render();\n\n    graphRef.current = graph;\n  }, []);\n\n  return <div ref={containerRef}></div>;\n};\n",paraId:5,tocIndex:1},{value:"节点和边的 tooltip、节点上的右键菜单，G6 中内置的很难满足样式上的需求，这个时候我们就可以通过渲染自定义的 React 组件来实现。Tooltip 和 ContextMenu 都是普通的 React 组件，样式完全由用户控制。交互过程中，在 G6 中需要做的事情就是确定何时渲染组件，以及渲染到何处。在 G6 中获取到是否渲染组件的标识值和渲染位置后，这些值就可以使用 React state 进行管理，后续的所有工作就全部由 React 负责了。",paraId:6,tocIndex:2},{value:"// 边 tooltip 坐标\nconst [showNodeTooltip, setShowNodeTooltip] = useState(false);\nconst [nodeTooltipX, setNodeToolTipX] = useState(0);\nconst [nodeTooltipY, setNodeToolTipY] = useState(0);\n\n// 监听 node 上面 mouse 事件\ngraph.on('node:mouseenter', (evt) => {\n  const { item } = evt;\n  const model = item.getModel();\n  const { x, y } = model;\n  const point = graph.getCanvasByPoint(x, y);\n\n  setNodeToolTipX(point.x - 75);\n  setNodeToolTipY(point.y + 15);\n  setShowNodeTooltip(true);\n});\n\n// 节点上面触发 mouseleave 事件后隐藏 tooltip 和 ContextMenu\ngraph.on('node:mouseleave', () => {\n  setShowNodeTooltip(false);\n});\n\nreturn <div ref={ref}>{showNodeTooltip && <NodeTooltips x={nodeTooltipX} y={nodeTooltipY} />}</div>;\n",paraId:7,tocIndex:2},{value:"完整的 Demo 源码请戳 「",paraId:8,tocIndex:2},{value:"这里",paraId:8,tocIndex:2},{value:"」。",paraId:8,tocIndex:2}]},85333:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"为什么使用 iconfont？  兼容性好、种类多、多色等。在此不做过多介绍，请直接移步 ",paraId:0,tocIndex:0},{value:"阿里巴巴-iconfont 平台",paraId:0,tocIndex:0},{value:"。",paraId:0,tocIndex:0},{value:"直接到 ",paraId:1,tocIndex:2},{value:"阿里巴巴字体图标库",paraId:1,tocIndex:2},{value:" 搜索下载即可，简要操作流程是：搜索图标（例如篮球）->  选择自己喜欢的图标添加入库  ->  点击页面右上角的购物车可以看到我们加入的图标 -> 添加至项目，如果没有项目到话可以新建一个  -> 在我到项目里面点击下载至本地 -> 解压。如果一切操作正常的话可以得到如下解压文件：",paraId:1,tocIndex:2},{value:" ",paraId:1,tocIndex:2},{value:"选中红色区域的所有文件（这里面很多文件是不需要的，为了方便起见，我们全部复制即可，不需要的也不会被打包），复制到项目里面，一般放在目录 'static/icons' 或者 'assets/icons' 下面，如果没有的话可以新建目录，当然你也可以放到任意你喜欢的位置，只要引入的时候路径对即可，到此 iconfont 引入完毕。",paraId:2,tocIndex:2},{value:"PS: 本案文件目录为 '/static/icons'。",paraId:3,tocIndex:2},{value:"多种引入方式，请移步",paraId:4,tocIndex:3},{value:"快速上手",paraId:5,tocIndex:3},{value:"。 ",paraId:4,tocIndex:3},{value:"PS: 本案例简单粗暴，通过 CDN 的方式引入。",paraId:4,tocIndex:3},{value:'<script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script>\n',paraId:6,tocIndex:3},{value:"引入方式可自行选择，下面为在 HTML 中引入的例子：",paraId:7,tocIndex:4},{value:"<style>\n  @import '/static/icons/iconfont.css';\n</style>\n",paraId:8,tocIndex:4},{value:"G6.registerNode('iconfont', {\n  draw(cfg, group) {\n    const { backgroundConfig: backgroundStyle, style, labelCfg: labelStyle } = cfg;\n\n    if (backgroundStyle) {\n      group.addShape('circle', {\n        attrs: {\n          x: 0,\n          y: 0,\n          r: cfg.size,\n          ...backgroundStyle,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'circle-shape',\n      });\n    }\n\n    const keyShape = group.addShape('text', {\n      attrs: {\n        x: 0,\n        y: 0,\n        fontFamily: 'iconfont', // 对应css里面的font-family: \"iconfont\";\n        textAlign: 'center',\n        textBaseline: 'middle',\n        text: cfg.text,\n        fontSize: cfg.size,\n        ...style,\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'text-shape1',\n    });\n    const labelY = backgroundStyle ? cfg.size * 2 : cfg.size;\n\n    group.addShape('text', {\n      attrs: {\n        x: 0,\n        y: labelY,\n        textAlign: 'center',\n        text: cfg.label,\n        ...labelStyle.style,\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'text-shape1',\n    });\n    return keyShape;\n  },\n});\n\nconst COLOR = '#40a9ff';\nconst graph = new G6.TreeGraph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  modes: {\n    default: ['collapse-expand', 'drag-canvas', 'drag-node'],\n  },\n  defaultNode: {\n    backgroundConfig: {\n      backgroundType: 'circle',\n      fill: COLOR,\n      stroke: 'LightSkyBlue',\n    },\n    type: 'iconfont',\n    size: 12,\n    style: {\n      fill: '#fff',\n    },\n    labelCfg: {\n      style: {\n        fill: COLOR,\n        fontSize: 12,\n      },\n    },\n  },\n  // 布局相关\n  layout: {\n    type: 'compactBox',\n    direction: 'LR',\n    getId(d) {\n      return d.id;\n    },\n    getHeight() {\n      return 16;\n    },\n    getWidth() {\n      return 16;\n    },\n    getVGap() {\n      return 20;\n    },\n    getHGap() {\n      return 60;\n    },\n  },\n});\n\ngraph.edge(({ target }) => {\n  const fill = target.get('model').backgroundConfig && target.get('model').backgroundConfig.fill;\n  return {\n    type: 'cubic-horizontal',\n    color: fill || COLOR,\n    label: target.get('model').relation || '',\n    labelCfg: {\n      style: {\n        fill: fill || COLOR,\n        fontSize: 12,\n      },\n    },\n  };\n});\n\nconst data = {\n  isRoot: true,\n  id: 'Root',\n  label: '可疑人员王**',\n  text: '\\ue6b2', // 对应iconfont.css 里面的content，注意加u，后面的自行修改一下。\n  style: {\n    fill: 'red',\n  },\n  labelCfg: {\n    style: {\n      fill: 'red',\n    },\n  },\n  backgroundConfig: null, // 自定义项，用于判读是否需要圆背景\n  size: 30,\n  children: [\n    {\n      id: 'SubTreeNode1',\n      label: '**网咖',\n      text: '&#xe605;',\n      relation: '上网',\n      children: [\n        {\n          id: 'SubTreeNode2',\n          label: '多伦多',\n          text: '&#xe64b;',\n        },\n        {\n          id: 'id1',\n          label: '小王',\n          text: '&#xe622;',\n          children: [\n            {\n              id: 'SubTreeNode1.2.1',\n              label: '182****2123',\n              text: '&#xe60d;',\n            },\n            {\n              id: 'SubTreeNode4',\n              label: '今晚在吗',\n              text: '&#xe629;',\n            },\n          ],\n        },\n      ],\n    },\n    {\n      id: 'SubTreeNode3',\n      label: 'subway',\n      text: '&#xe653;',\n      children: [\n        {\n          id: 'SubTreeNode3.1',\n          label: '王五',\n          text: '&#xe622;',\n        },\n        {\n          id: 'SubTreeNode3.2',\n          label: '张三',\n          text: '&#xe622;',\n        },\n      ],\n    },\n    {\n      id: 'SubTreeNode5',\n      label: '小花',\n      relation: '老婆',\n      text: '&#xe74b;',\n      backgroundConfig: {\n        fill: 'Coral',\n      },\n      style: {\n        fill: '#fff',\n      },\n      labelCfg: {\n        style: {\n          fill: 'Coral',\n        },\n      },\n      children: [\n        {\n          id: 'SubTreeNode1.2.1',\n          label: '182****2123',\n          text: '&#xe60d;',\n          relation: '通话',\n          backgroundConfig: {\n            fill: 'Coral',\n          },\n          style: {\n            fill: '#fff',\n          },\n          labelCfg: {\n            style: {\n              fill: 'Coral',\n            },\n          },\n        },\n        {\n          id: 'SubTreeNode3.3',\n          label: '凶器',\n          text: '&#xe673;',\n          relation: '指纹',\n          backgroundConfig: {\n            fill: 'Coral',\n          },\n          style: {\n            fill: '#fff',\n          },\n          labelCfg: {\n            style: {\n              fill: 'Coral',\n            },\n          },\n        },\n      ],\n    },\n    {\n      id: 'SubTreeNode6',\n      label: '马航37*',\n      relation: '乘坐',\n      text: '&#xe610;',\n    },\n  ],\n};\n\ngraph.data(data);\ngraph.render();\n",paraId:9,tocIndex:5},{value:"看了代码大家应该很清楚了，实质就是用了 text 图形，但有几个需要注意的地方：",paraId:10,tocIndex:6},{value:" ",paraId:10,tocIndex:6},{value:"1、text 的 ",paraId:10,tocIndex:6},{value:"fontFamily",paraId:10,tocIndex:6},{value:" 必须和 iconfont.css 里面的 ",paraId:10,tocIndex:6},{value:"font-family",paraId:10,tocIndex:6},{value:" 保持一致：",paraId:10,tocIndex:6},{value:" ",paraId:10,tocIndex:6},{value:"2、data 里面的 ",paraId:11,tocIndex:6},{value:"text",paraId:11,tocIndex:6},{value:" 使用的是 iconfont.css 里面的 ",paraId:11,tocIndex:6},{value:"content",paraId:11,tocIndex:6},{value:"，注意加 ",paraId:11,tocIndex:6},{value:"u",paraId:11,tocIndex:6},{value:" 。如有需要可自行复制。",paraId:11,tocIndex:6},{value:"3、若出现了第一次渲染 iconfont 错误（可能显示成一个方框），可以检查下是否已经加载字体文件",paraId:12,tocIndex:6},{value:"如果页面中没有使用字体图标的节点，字体文件是不会自动下载的，那么可以添加一个隐藏节点用以触发加载。如果已经加载，那么可以尝试以下代码刷新渲染。",paraId:13,tocIndex:6},{value:"// 在 graph.render() 之后调用以下语句：\nsetTimeout(() => {\n  graph.paint();\n}, 16);\n",paraId:14,tocIndex:6},{value:"我们可以将 unicode 的转化封装成函数使用。这里注意，手动拼接 unicode 是不行的（",paraId:15,tocIndex:7},{value:"\\\\u${icon.unicode}",paraId:15,tocIndex:7},{value:"）。这里采用 iconfont.json 中的 ",paraId:15,tocIndex:7},{value:"code_decimal",paraId:15,tocIndex:7},{value:" 进行转化。详细参考《",paraId:15,tocIndex:7},{value:"MDN String.fromCodePoint",paraId:15,tocIndex:7},{value:"》。",paraId:15,tocIndex:7},{value:"import fonts from '../fonts/iconfont.json';\n\nconst icons = fonts.glyphs.map((icon) => {\n  return {\n    name: icon.name,\n    unicode: String.fromCodePoint(icon.unicode_decimal), // `\\\\u${icon.unicode}`,\n  };\n});\nconst getIcon = (type: string) => {\n  const matchIcon = icons.find((icon) => {\n    return icon.name === type;\n  }) || { unicode: '', name: 'default' };\n  return matchIcon.unicode;\n};\n",paraId:16,tocIndex:7},{value:" {\n    type: 'text',\n    attrs: {\n        id: 'node-icon',\n        x: 0,\n        y: 0,\n        fontSize: iconSize,\n        fill: primaryColor,\n        text: getIcon('logo'), // logo 为 unicode 对应的 name\n        fontFamily: 'iconfont', // 对应 CSS 里面的 font-family: \"iconfont\";\n        textAlign: 'center',\n        textBaseline: 'middle',\n    },\n  }\n",paraId:17,tocIndex:8}]},72143:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本章以添加节点及在两个节点之间连线为例进行介绍 G6 中的交互。在阅读本章之前，需要先熟悉以下内容：",paraId:0},{value:"自定义交互行为 Behavior",paraId:1},{value:"；",paraId:2},{value:"交互模式 Mode",paraId:3},{value:"。",paraId:2},{value:"上图是本文要实现的最终效果。完整 demo 代码参见：",paraId:4},{value:"动态添加元素",paraId:4},{value:"。",paraId:4},{value:"左上方的下拉菜单中有三个选项，用于切换交互模式 mode：",paraId:4},{value:"选择 “Default” 按钮时，切换到 default 交互模式：拖拽节点时节点跟随鼠标移动；点击节点时选中该节点；",paraId:5},{value:"选择 “Add Node” 按钮时，切换到  addNode 交互模式：点击空白区域在点击处增加一个节点；点击节点时选中该节点；",paraId:5},{value:"选择 “Add Edge” 按钮时，切换到 addEdge 交互模式：依次点击两个节点将会在这两个节点之间添加一条边。",paraId:5},{value:"使用多个 mode 的原因",paraId:6},{value:"  相同的鼠标操作，在不同场景下有不同的含义。例如：",paraId:6},{value:"点击空白画布取消目前图上所有节点的选中状态、点击空白画布在响应位置添加节点，这两种需求都对应了用户点击画布空白处的操作；",paraId:7},{value:"点击选中、点击两个节点添加边都涉及到了鼠标在节点上的点击操作。",paraId:7},{value:"为了区分这些操作的含义，我们使用交互模式 mode 划分不同的场景。",paraId:8},{value:"下面 HTML 代码是本文的基础代码，后续功能将在这份代码中增量添加。下面代码定义了左上方的下拉菜单，以及后面将会用到图上的初始数据 ",paraId:9,tocIndex:0},{value:"data",paraId:9,tocIndex:0},{value:"。",paraId:9,tocIndex:0},{value:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>Interactively Add</title>\n  </head>\n  <body>\n    \x3c!-- 左上方的下拉菜单 --\x3e\n    <select id="selector">\n      <option value="default">默认</option>\n      <option value="addNode">添加节点</option>\n      <option value="addEdge">添加边</option>\n    </select>\n    <div id="mountNode"></div>\n    <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script>\n    <script>\n      // 初始数据\n      const data = {\n        nodes: [\n          {\n            id: \'node1\',\n            x: 100,\n            y: 200,\n          },\n          {\n            id: \'node2\',\n            x: 300,\n            y: 200,\n          },\n          {\n            id: \'node3\',\n            x: 300,\n            y: 300,\n          },\n        ],\n        edges: [\n          {\n            id: \'edge1\',\n            target: \'node2\',\n            source: \'node1\',\n          },\n        ],\n      };\n    <\/script>\n  </body>\n</html>\n',paraId:10,tocIndex:0},{value:"下面代码实例化了图，并配置了交互模式的集合 ",paraId:11,tocIndex:1},{value:"modes",paraId:11,tocIndex:1},{value:"，其中包括 ",paraId:11,tocIndex:1},{value:"default",paraId:11,tocIndex:1},{value:" 默认交互模式、",paraId:11,tocIndex:1},{value:"addNode",paraId:11,tocIndex:1},{value:" 增加节点交互模式、",paraId:11,tocIndex:1},{value:"addEdge",paraId:11,tocIndex:1},{value:" 增加边交互模式。每种交互模式中都包含了各自的交互行为，其中  ",paraId:11,tocIndex:1},{value:"'drag-node'",paraId:11,tocIndex:1},{value:"（拖拽节点） 和  ",paraId:11,tocIndex:1},{value:"'click-select'",paraId:11,tocIndex:1},{value:"（点击选中） 是 G6 内置的交互行为，",paraId:11,tocIndex:1},{value:"'click-add-node'",paraId:11,tocIndex:1},{value:"（点击空白画布添加节点） 和  ",paraId:11,tocIndex:1},{value:"'click-add-edge'",paraId:11,tocIndex:1},{value:"（点击两个节点添加边） 需要我们在后面进行自定义。",paraId:11,tocIndex:1},{value:"// const data = ...\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  // 交互模式集合\n  modes: {\n    // 默认交互模式\n    default: ['drag-node', 'click-select'],\n    // 增加节点交互模式\n    addNode: ['click-add-node', 'click-select'],\n    // 增加边交互模式\n    addEdge: ['click-add-edge', 'click-select'],\n  },\n  // 节点在不同状态下的样式集合\n  nodeStateStyles: {\n    // 节点在 selected 状态下的样式，对应内置的 click-select 行为\n    selected: {\n      stroke: '#666',\n      lineWidth: 2,\n      fill: 'steelblue'\n    }\n});\n\ngraph.data(data);\ngraph.render();\n\n// 监听左上角下拉菜单的变化，根据其变化切换图的交互模式\ndocument.getElementById('selector').addEventListener('change', e => {\n  const value = e.target.value;\n  // 切换交互模式\n  graph.setMode(value);\n});\n",paraId:12,tocIndex:1},{value:"在上面的例子中，当选中添加节点按钮时，会切换到 ",paraId:13,tocIndex:2},{value:"addNode",paraId:13,tocIndex:2},{value:" 的 Mode 上。",paraId:13,tocIndex:2},{value:"addNode",paraId:13,tocIndex:2},{value:" Mode 包含了 ",paraId:13,tocIndex:2},{value:"'click-add-node'",paraId:13,tocIndex:2},{value:", ",paraId:13,tocIndex:2},{value:"'click-select'",paraId:13,tocIndex:2},{value:" 两个 Behavior。",paraId:13,tocIndex:2},{value:"'click-add-node'",paraId:13,tocIndex:2},{value:" 实现了在点击空白画布时，在点击位置添加节点。这是通过使用 ",paraId:13,tocIndex:2},{value:"G6.registerBehavior",paraId:13,tocIndex:2},{value:" 自定义一个名为 ",paraId:13,tocIndex:2},{value:"'click-add-node'",paraId:13,tocIndex:2},{value:"（名字可以自由设定） 的 Behavior 实现的。",paraId:13,tocIndex:2},{value:"// 添加的节点数量，用于生成唯一 id\nlet addedNodeCount = 0;\n\n// 封装点击添加节点的交互\nG6.registerBehavior('click-add-node', {\n  // 设定该自定义行为需要监听的事件及其响应函数\n  getEvents() {\n    // 监听的事件为 canvas:click，响应函数是 onClick\n    return {\n      'canvas:click': 'onClick',\n    };\n  },\n  // 点击事件\n  onClick(ev) {\n    const graph = this.graph;\n    // 在图上新增一个节点\n    const node = this.graph.addItem('node', {\n      x: ev.canvasX,\n      y: ev.canvasY,\n      id: `node-${addedNodeCount}`, // 生成唯一的 id\n    });\n    addedNodeCount++;\n  },\n});\n",paraId:14,tocIndex:2},{value:"在上面的例子中，当需要在两个节点之间连线时，要先切换到添加边的 Mode 上。下面代码自定义了名为  ",paraId:15,tocIndex:3},{value:"'click-add-edge'",paraId:15,tocIndex:3},{value:"（名字可以自由设定）的 Behavior 实现两个节点之间连线。",paraId:15,tocIndex:3},{value:"// 封装点击添加边的交互\nG6.registerBehavior('click-add-edge', {\n  // 设定该自定义行为需要监听的事件及其响应函数\n  getEvents() {\n    return {\n      'node:click': 'onClick', // 监听事件 node:click，响应函数是 onClick\n      mousemove: 'onMousemove', // 监听事件 mousemove，响应函数是 onMousemove\n      'edge:click': 'onEdgeClick', // 监听事件 edge:click，响应函数是 onEdgeClick\n    };\n  },\n  // getEvents 中定义的 'node:click' 的响应函数\n  onClick(ev) {\n    const node = ev.item;\n    const graph = this.graph;\n    // 鼠标当前点击的节点的位置\n    const point = { x: ev.x, y: ev.y };\n    const model = node.getModel();\n    if (this.addingEdge && this.edge) {\n      graph.updateItem(this.edge, {\n        target: model.id,\n      });\n\n      this.edge = null;\n      this.addingEdge = false;\n    } else {\n      // 在图上新增一条边，结束点是鼠标当前点击的节点的位置\n      this.edge = graph.addItem('edge', {\n        source: model.id,\n        target: point,\n      });\n      this.addingEdge = true;\n    }\n  },\n  // getEvents 中定义的 mousemove 的响应函数\n  onMousemove(ev) {\n    // 鼠标的当前位置\n    const point = { x: ev.x, y: ev.y };\n    if (this.addingEdge && this.edge) {\n      // 更新边的结束点位置为当前鼠标位置\n      this.graph.updateItem(this.edge, {\n        target: point,\n      });\n    }\n  },\n  // getEvents 中定义的 'edge:click' 的响应函数\n  onEdgeClick(ev) {\n    const currentEdge = ev.item;\n    // 拖拽过程中，点击会点击到新增的边上\n    if (this.addingEdge && this.edge == currentEdge) {\n      graph.removeItem(this.edge);\n      this.edge = null;\n      this.addingEdge = false;\n    }\n  },\n});\n",paraId:16,tocIndex:3},{value:"完整 demo 代码参见：",paraId:17,tocIndex:4},{value:"动态添加元素",paraId:17,tocIndex:4},{value:"。",paraId:17,tocIndex:4}]},15884:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"⚠️ 注意:",paraId:0},{value:" 多值状态、互斥状态、设置子图形状态样式、修改状态样式配置在 V3.4 后支持。",paraId:0},{value:"元素（节点/边）的状态（state）用于反馈用户交互、数据变化。通过状态，可以将「交互/数据变化」与视图中「元素的样式变化」快速关联。最常见的例子：鼠标进入节点，该节点为 hover 状态，并被高亮；离开节点，该节点为非 hover 状态，并复原样式。",paraId:1,tocIndex:0},{value:"乍看之下，状态似乎很简单，但从目前业务痛点与经验来看，“状态”有许多隐藏的需求和复杂性。简单的实现方式，会造成易用性低下的问题。",paraId:2,tocIndex:0},{value:"要解决业务中常见的状态问题，并提供清晰明了、简单易用的方案必须要考虑以下问题：",paraId:3,tocIndex:1},{value:"简单快速地设置目标状态",paraId:4,tocIndex:1},{value:"：当一个节点或一条边上已经设置了大量不同状态后，要再设置一个新状态时，能够快速将之前所有状态清除；",paraId:4,tocIndex:1},{value:"状态多值",paraId:4,tocIndex:1},{value:"，即一个状态量存在多个不同的值，如节点代表人，有“健康”、“疑似”、“确诊”、“死亡”四种状态；",paraId:4,tocIndex:1},{value:"状态间互斥",paraId:4,tocIndex:1},{value:"：“健康”、“疑似”、“确诊”、“死亡”四种状态中，“死亡”与其他三种就是互斥的，不可能同时存在“健康”和“死亡”两种状态；",paraId:4,tocIndex:1},{value:"节点或边中所有元素的状态更新",paraId:4,tocIndex:1},{value:"：如一个由文本和圆组成的节点，状态变化时不仅能设置圆的样式，也可以设置文本的样式；",paraId:4,tocIndex:1},{value:"更新状态样式",paraId:4,tocIndex:1},{value:"，当更新节点的样式时，能够同时更新状态的样式。",paraId:4,tocIndex:1},{value:"为了解决以上问题，我们将 G6 的状态管理分为以下几层：",paraId:5,tocIndex:2},{value:"定义状态：统一的定义方式；",paraId:6,tocIndex:2},{value:"设置状态：",paraId:6,tocIndex:2},{value:"setItemState",paraId:6,tocIndex:2},{value:" 方法；",paraId:6,tocIndex:2},{value:"更新状态：",paraId:6,tocIndex:2},{value:"updateItem",paraId:6,tocIndex:2},{value:" 支持更新状态；",paraId:6,tocIndex:2},{value:"取消状态：",paraId:6,tocIndex:2},{value:"clearItemStates",paraId:6,tocIndex:2},{value:" 方法。",paraId:6,tocIndex:2},{value:"G6 中定义全局状态是在实例化 Graph 时通过 ",paraId:7,tocIndex:4},{value:"nodeStateStyles",paraId:7,tocIndex:4},{value:" 和 ",paraId:7,tocIndex:4},{value:"edgeStateStyles",paraId:7,tocIndex:4},{value:" 来定义。",paraId:7,tocIndex:4},{value:"const graph = new G6.Graph({\n  container,\n  width,\n  height,\n  nodeStateStyles: {\n    hover: {\n      fill: 'red',\n      'keyShape-name': {\n        fill: 'red',\n      },\n    },\n  },\n  edgeStateStyles: {},\n});\n",paraId:8,tocIndex:4},{value:"当设置 ",paraId:9,tocIndex:4},{value:"keyShape",paraId:10,tocIndex:4},{value:" 的状态时，可以直接在 ",paraId:9,tocIndex:4},{value:"nodeStateStyles",paraId:9,tocIndex:4},{value:" 或 ",paraId:9,tocIndex:4},{value:"edgeStateStyles",paraId:9,tocIndex:4},{value:" 中定义样式，或者将 keyShape 的 ",paraId:9,tocIndex:4},{value:"name",paraId:9,tocIndex:4},{value:" 属性值作为 key 定义样式，我们建议使用后者。",paraId:9,tocIndex:4},{value:"除过全局状态外，G6 也支持针对不同节点定义不同的状态，使用 ",paraId:11,tocIndex:5},{value:"graph.node(fn)",paraId:11,tocIndex:5},{value:" / ",paraId:11,tocIndex:5},{value:"graph.edge(fn)",paraId:11,tocIndex:5},{value:" 或在数据中设置 ",paraId:11,tocIndex:5},{value:"stateStyles",paraId:11,tocIndex:5},{value:" 即可。",paraId:11,tocIndex:5},{value:"graph.node((node) => {\n  return {\n    ...node,\n    stateStyles: {},\n  };\n});\n\nconst data = {\n  nodes: [\n    {\n      id: 'node',\n      stateStyles: {},\n    },\n  ],\n};\n",paraId:12,tocIndex:5},{value:"在 G6 中，通常一个节点在绘制层面上，有一个图形分组，该图形分组包含多个图形组成的。G6 3.3 之前的版本，仅支持设置 keyShape 的状态，如果要设置其他部分元素的状态，就需要在自定义元素时复写 ",paraId:13,tocIndex:6},{value:"setState",paraId:13,tocIndex:6},{value:" 方法，这意味着状态样式的管理完全需要自定义，用户写起来将会非常复杂。G6 3.4 版本中，我们支持了定义子元素的状态，从此再也不用去复写 ",paraId:13,tocIndex:6},{value:"setState",paraId:13,tocIndex:6},{value:" 方法了。",paraId:13,tocIndex:6},{value:"子元素状态也支持两种设置方式，为了演示方便，在这里我们只演示在在全局状态中定义子元素状态。",paraId:14,tocIndex:6},{value:"const graph = new G6.Graph({\n  container,\n  width,\n  height,\n  nodeStateStyles: {\n    selected: {\n      'sub-element': {\n        fill: 'green',\n      },\n      'text-element': {\n        stroke: 'red',\n      },\n    },\n  },\n  edgeStateStyles: {},\n});\n",paraId:15,tocIndex:6},{value:"在「定义状态」部分，我们建议在 ",paraId:16,tocIndex:6},{value:"nodeStateStyles",paraId:16,tocIndex:6},{value:"/",paraId:16,tocIndex:6},{value:"edgeStateStyles",paraId:16,tocIndex:6},{value:" 中定义状态时，使用 keyShape 的 ",paraId:16,tocIndex:6},{value:"name",paraId:16,tocIndex:6},{value:" 属性作为 key 值来定义状态样式，因为我们在定义子元素的状态时也采用同样的方式，结构上比较统一。",paraId:16,tocIndex:6},{value:"如上示例代码所示，我们定义了节点中 ",paraId:17,tocIndex:6},{value:"name",paraId:17,tocIndex:6},{value:" 属性值为 ",paraId:17,tocIndex:6},{value:"'sub-element'",paraId:17,tocIndex:6},{value:" 和 ",paraId:17,tocIndex:6},{value:"'text-element'",paraId:17,tocIndex:6},{value:" 两部分的样式，当我们通过 ",paraId:17,tocIndex:6},{value:"graph.setItemState(item, 'selected', true)",paraId:17,tocIndex:6},{value:" 设置指定 item 的状态时，子元素 ",paraId:17,tocIndex:6},{value:"'sub-element'",paraId:17,tocIndex:6},{value:" 和 ",paraId:17,tocIndex:6},{value:"'text-element'",paraId:17,tocIndex:6},{value:" 的样式也会同步更新。",paraId:17,tocIndex:6},{value:"// 执行下面语句以后，name 为 sub-element 和 name 为 text-element\n// 的元素填充色和描边色都会改变\ngraph.setItemState(item, 'selected', true);\n",paraId:18,tocIndex:6},{value:"另外，G6 也支持在使用 ",paraId:19,tocIndex:6},{value:"updateItem",paraId:19,tocIndex:6},{value:" 更新节点或边的时候定义状态。",paraId:19,tocIndex:6},{value:"⚠️ 注意: ",paraId:20,tocIndex:6},{value:"子图形状态样式仅限于指定节点/边的图形分组下平铺的图形，不支持嵌套图形分组下的图形。内置节点/边的图形分组内的图形均为平铺，在自定义节点时需要注意该规则。",paraId:21,tocIndex:6},{value:"G6 中状态支持多值和二值两种情况。",paraId:22,tocIndex:7},{value:"二值：值只能为 ",paraId:23,tocIndex:7},{value:"true",paraId:23,tocIndex:7},{value:" / ",paraId:23,tocIndex:7},{value:"false",paraId:23,tocIndex:7},{value:"，无其他选择，即要么有这个状态，要么没有；多值：如节点代表人，有“健康”、“疑似”、“确诊”、“死亡”四种状态。",paraId:23,tocIndex:7},{value:"二值状态一般常用于交互过程中，如 hover、selected 等状态，当节点被选中时，节点应用 selected 状态的样式，取消选中时，去掉 selected 状态的样式。",paraId:24,tocIndex:8},{value:"在 G6 中，使用 ",paraId:25,tocIndex:8},{value:"graph.setItemState(item, 'selected', true)",paraId:25,tocIndex:8},{value:" 来设置二值状态。",paraId:25,tocIndex:8},{value:"const graph = new G6.Graph({\n  //...\n  nodeStateStyles: {\n    selected: {\n      fill: 'red',\n    },\n  },\n});\n\ngraph.setItemState(item, 'selected', true);\n",paraId:26,tocIndex:8},{value:"除过像 hover、selected 这种交互状态外，还会存在很多的业务状态，如节点代表人，有“健康”、“疑似”、“确诊”、“死亡”四种状态，此时使用 ",paraId:27,tocIndex:9},{value:"true",paraId:27,tocIndex:9},{value:"/",paraId:27,tocIndex:9},{value:"false",paraId:27,tocIndex:9},{value:" 的形式就不能满足，需要支持单个状态可以有多个值的情况。",paraId:27,tocIndex:9},{value:"const graph = new Graph({\n  // ... 其他配置\n  // 节点在不同状态下的样式\n  nodeStateStyles: {\n    // 实现 bodyState 的【多值】【互斥】\n    'bodyState:healthy': {\n      // keyShape 该状态下的样式, 可以使用三种方式指定：\n      fill: 'green',\n    },\n    'bodyState:suspect': {},\n    'bodyState:ill': {},\n  },\n});\n\ngraph.setItemState(item, 'bodyState', 'healthy');\n",paraId:28,tocIndex:9},{value:"上面的多值状态，也很好地解决了状态互斥的问题，还以上面的 ",paraId:29,tocIndex:10},{value:"bodyState",paraId:29,tocIndex:10},{value:" 状态为例，该状态共有 ",paraId:29,tocIndex:10},{value:"healthy",paraId:29,tocIndex:10},{value:"、",paraId:29,tocIndex:10},{value:"dead",paraId:29,tocIndex:10},{value:"、",paraId:29,tocIndex:10},{value:"ill",paraId:29,tocIndex:10},{value:" 等值。",paraId:29,tocIndex:10},{value:"//【互斥】\ngraph.setItemState(item, 'bodyState', 'healthy');\n// 执行下面这句话 bodyState 将会被改变成 dead，\n// item.hasState('bodyState:healthy') 为 false\ngraph.setItemState(item, 'bodyState', 'dead');\n",paraId:30,tocIndex:10},{value:"执行上面的两句后， item 只会有 ",paraId:31,tocIndex:10},{value:"bodyState",paraId:31,tocIndex:10},{value:" 状态的 ",paraId:31,tocIndex:10},{value:"dead",paraId:31,tocIndex:10},{value:" 一个值，而二值状态不能解决这个问题。",paraId:31,tocIndex:10},{value:"graph.setItemState(item, 'select', true);\ngraph.setItemState(item, 'active', true);\n",paraId:32,tocIndex:10},{value:"执行上面的两句设置二值状态的语句后，item 具有 select 和 active 所有的属性值，不能满足互斥需求。",paraId:33,tocIndex:10},{value:"G6 3.3 及 以下的版本中，不支持修改状态样式的配置。",paraId:34,tocIndex:11},{value:"updateItem",paraId:34,tocIndex:11},{value:" 方法只能更新 keyShape 的默认样式。从 G6 3.4 版本开始，",paraId:34,tocIndex:11},{value:"updateItem",paraId:34,tocIndex:11},{value:" 支持更新 item 中所有子图形的默认样式和状态样式。",paraId:34,tocIndex:11},{value:"updateItem",paraId:35,tocIndex:12},{value:" 可用于更新 keyShape 以及其他子图形的默认样式。使用 ",paraId:35,tocIndex:12},{value:"updateItem",paraId:35,tocIndex:12},{value:" 更新子图形样式时，只需要在 ",paraId:35,tocIndex:12},{value:"style",paraId:35,tocIndex:12},{value:" 中以子图形的 ",paraId:35,tocIndex:12},{value:"name",paraId:35,tocIndex:12},{value:" 属性作为为 key 即可。",paraId:35,tocIndex:12},{value:"// 更新 item，除过更新 keyShape 外，还更新 name 值为 node-text 的图形\ngraph.updateItem(item, {\n  style: {\n    fill: 'green',\n    stroke: 'green',\n    opacity: 0.5,\n    'node-text': {\n      stroke: 'yellow',\n    },\n  },\n});\n",paraId:36,tocIndex:12},{value:"updateItem",paraId:37,tocIndex:13},{value:" 也支持更新 keyShape 与其他子图形的状态样式，使用 ",paraId:37,tocIndex:13},{value:"stateStyles",paraId:37,tocIndex:13},{value:" 属性。",paraId:37,tocIndex:13},{value:"graph.updateItem(item, {\n  style: {\n    stroke: 'green',\n    'node-text': {\n      stroke: 'yellow',\n    },\n  },\n  stateStyles: {\n    hover: {\n      opacity: 0.1,\n      'node-text': {\n        stroke: 'blue',\n      },\n    },\n  },\n});\ngraph.setItemState(item, 'hover', true);\n",paraId:38,tocIndex:13},{value:"使用 ",paraId:39,tocIndex:13},{value:"updateItem",paraId:39,tocIndex:13},{value:" 更新状态的样式时，会存在两种情况：",paraId:39,tocIndex:13},{value:"使用 ",paraId:40,tocIndex:13},{value:"updateItem",paraId:40,tocIndex:13},{value:" 更新时，item 已有指定状态，即 ",paraId:40,tocIndex:13},{value:"item.hasState('hover') === true",paraId:40,tocIndex:13},{value:"，此时状态值对应的属性会立即生效；",paraId:40,tocIndex:13},{value:"使用 ",paraId:40,tocIndex:13},{value:"updateItem",paraId:40,tocIndex:13},{value:" 更新时，item 没有指定的状态，即 ",paraId:40,tocIndex:13},{value:"item.hasState('hover') === false",paraId:40,tocIndex:13},{value:"，更新以后，当用户执行  ",paraId:40,tocIndex:13},{value:"graph.setItemState(item, 'hover', true)",paraId:40,tocIndex:13},{value:" 后，hover 状态的 ",paraId:40,tocIndex:13},{value:"stroke",paraId:40,tocIndex:13},{value:" 属性值为 ",paraId:40,tocIndex:13},{value:"updateItem",paraId:40,tocIndex:13},{value:" 时设置的值。",paraId:40,tocIndex:13},{value:"在 G6 中，我们建议使用 ",paraId:41,tocIndex:14},{value:"graph.clearItemStates",paraId:41,tocIndex:14},{value:"  来取消 ",paraId:41,tocIndex:14},{value:"graph.setItemState",paraId:41,tocIndex:14},{value:" 设置的状态，",paraId:41,tocIndex:14},{value:"graph.clearItemStates",paraId:41,tocIndex:14},{value:" 支持一次取消单个或多个状态。",paraId:41,tocIndex:14},{value:"graph.setItemState(item, 'bodyState', 'healthy');\ngraph.setItemState(item, 'selected', true);\ngraph.setItemState(item, 'active', true);\n\n// 取消单个状态\ngraph.clearItemStates(item, 'selected');\ngraph.clearItemStates(item, ['selected']);\n\n// 取消多个状态\ngraph.clearItemStates(item, ['bodyState:healthy', 'selected', 'active']);\n",paraId:42,tocIndex:14},{value:"以上就是 G6 中状态的定义、设置和取消的全过程，很清晰明了，但总感觉缺少了点什么，没错，想必聪明的你已经发现了，缺少了更新子元素及和 ",paraId:43,tocIndex:14},{value:"updateItem",paraId:43,tocIndex:14},{value:" 配合使用的方案。不要着急，接着放下看。",paraId:43,tocIndex:14},{value:"G6 中提供了 ",paraId:44,tocIndex:15},{value:"hasState",paraId:44,tocIndex:15},{value:" 方法用于判断元素是否有某种状态。但具体哪个状态的优先级高，哪个状态值应该覆盖其他的类似问题我们就没有再做任何限制，完全由业务用户控制，实现这种控制也非常简单，如一般情况下，鼠标 hover 到某个节点后，该节点会高亮，但希望当该节点处于 active 状态时，鼠标 hover 上去后也不要覆盖 active 的状态，即 active 优先级高于 hover。",paraId:44,tocIndex:15},{value:"// 设置节点处于 active 状态\ngraph.setItemState(item, 'active', true);\n\n// 鼠标 hover\nconst hasActived = item.hasState('active');\n\n// 当节点没有 active 时才设置 hover 状态\nif (!hasActived) {\n  graph.setItemState(item, 'hover', true);\n}\n",paraId:45,tocIndex:15}]},95968:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"大多数图数据在可视化时被展示成点-线图（Node-link Diagram）的形式。点-线图特别适用于如交通网络图一类的关系数据的展示，这种数据的节点通常带有地理位置信息，例如迁徙图、移民图、航线图等。",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:"（左）图 1. 法国航线图。（右）图 2. 美国航线图。",paraId:1,tocIndex:0},{value:"（左）图 3. 世界网络 IXP 对等图。（右）图 4. 美国移民图。",paraId:2,tocIndex:0},{value:"虽然点-线图提供了直观的可视化，但是当数据存在大量节点和边时，视觉混乱（Visual Clutter）很快成为严重的问题。点-线图中的视觉混乱通常是边缘拥塞的直接结果，而在如交通网络一类数据中，节点位置通常具有明确定义的含义，并不总是可以修改节点位置以减少视觉混乱，如图 1 ～ 4 四个例子。因此，学术界诸多研究者设计了各种通过优化边的方式减轻上述视觉混乱，其中边绑定（Edge Bundling）方法被广泛研究和应用。各种边绑定的方法总结在「",paraId:3,tocIndex:1},{value:"链接",paraId:3,tocIndex:1},{value:"」。",paraId:3,tocIndex:1},{value:"例如下面这一个复杂的美国航线数据集，节点代表美国城市，带有坐标和经纬度信息；一条边代表一条航线：",paraId:4,tocIndex:1},{value:'{\n  "nodes": [\n    {\n      "x": -922.24444,\n      "y": 347.29444,\n      "id": "0",\n      "lon": -92.224444,\n      "lat": 34.729444\n    },\n    {\n      "x": -922.24444,\n      "y": 347.29444,\n      "id": "1",\n      "lon": -92.224444,\n      "lat": 34.729444\n    }\n    // ... 其他节点\n  ],\n  "edges": [\n    {\n      "source": "0",\n      "target": "21",\n      "id": "e0"\n    },\n    {\n      "source": "2",\n      "target": "13",\n      "id": "e1"\n    }\n    // ... 其他边\n  ]\n}\n',paraId:5,tocIndex:1},{value:"如果使用 G6 简单地将节点和边渲染出来，将会得到如下结果： ",paraId:6,tocIndex:1},{value:" ",paraId:6,tocIndex:1},{value:"图 5. G6 渲染原始数据结果",paraId:7,tocIndex:1},{value:"我们发现简单地将该数据渲染后的结果航线纵横交错，穿梭在密集的城市当中，视觉上十分混乱，即难以看清细节，也不能发现航线的总体趋势。",paraId:8,tocIndex:1},{value:"我们希望可以通过边绑定的方法降低图 5 的视觉混乱，从而清晰图的整体走势、结构，突出航线频繁的城市，它们可能是重要的交通枢纽，并展示更多的统计信息，以便观察者进行分析。借助 G6，我们可以实现如下效果。通过边绑定，边的交错混乱情况被降低，颜色映射航班的飞行方向（出发（橙红色）与降落（青色））。节点大小表示到达与离开该城市的航班总数量，每个节点使用了饼图展示达到（橙红色）和离开（青色）航班的比例。并增加 hover 的交互，使用 tooltip 展示每个城市的经纬度。 ",paraId:9,tocIndex:2},{value:" ",paraId:9,tocIndex:2},{value:"期待效果图及 tooltip 效果。",paraId:10,tocIndex:2},{value:"首先，我们使用简单的 JS 根据数据统计每个节点的总度数（degree，即出入该城市的航线总数）、出度（outDegree，即飞出该城市的航线数）、入度（inDegree，即飞入该城市成航线数），为后续映射到节点上做好准备。",paraId:11,tocIndex:4},{value:"const nodes = data.nodes;\nconst edges = data.edges;\nnodes.forEach((n) => {\n  n.y = -n.y;\n  n.degree = 0;\n  n.inDegree = 0;\n  n.outDegree = 0;\n});\n// compute the degree of each node\nconst nodeIdMap = new Map();\nnodes.forEach((node) => {\n  nodeIdMap.set(node.id, node);\n});\nedges.forEach((e) => {\n  const source = nodeIdMap.get(e.source);\n  const target = nodeIdMap.get(e.target);\n  source.outDegree++;\n  target.inDegree++;\n  source.degree++;\n  target.degree++;\n});\nlet maxDegree = -9999,\n  minDegree = 9999;\nnodes.forEach((n) => {\n  if (maxDegree < n.degree) maxDegree = n.degree;\n  if (minDegree > n.degree) minDegree = n.degree;\n});\nconst sizeRange = [1, 20];\nconst degreeDataRange = [minDegree, maxDegree];\n// 将范围是 degreeDataRange 的 degree 属性映射到范围 sizeRange 上后，\n// 写入到 nodes 中元素的 ‘size’ 属性中\nscaleNodeProp(nodes, 'size', 'degree', degreeDataRange, sizeRange);\n",paraId:12,tocIndex:4},{value:"scaleNodeProp()",paraId:13,tocIndex:4},{value:" 方法将指定的节点属性 ",paraId:13,tocIndex:4},{value:"refPropName",paraId:13,tocIndex:4},{value:" 根据给定数值范围 ",paraId:13,tocIndex:4},{value:"outRange",paraId:13,tocIndex:4},{value:" 归一化，映射到另一个属性 ",paraId:13,tocIndex:4},{value:"propName",paraId:13,tocIndex:4},{value:" 上：",paraId:13,tocIndex:4},{value:"/**\n * 映射属性\n * @param  {array} nodes          对象数组\n * @param  {string} propName      写入的属性名称\n * @param  {string} refPropName   被归一化的属性名称\n * @param  {array} dataRange      被归一化的属性的值范围 [min, max]\n * @param  {array} outRange       写入的属性的值范围 [min, max]\n */\nfunction scaleNodeProp(nodes, propName, refPropName, dataRange, outRange) {\n  const outLength = outRange[1] - outRange[0];\n  const dataLength = dataRange[1] - dataRange[0];\n  nodes.forEach((n) => {\n    n[propName] = ((n[refPropName] - dataRange[0]) * outLength) / dataLength + outRange[0];\n  });\n}\n",paraId:14,tocIndex:4},{value:"通过上面两段代码，我们已经将归一化的度数映射到节点大小 ",paraId:15,tocIndex:4},{value:"size",paraId:15,tocIndex:4},{value:" 上。",paraId:15,tocIndex:4},{value:"G6 中提供的边绑定插件是基于 FEDB（",paraId:16,tocIndex:5},{value:"Force-Directed Edge Bundling for Graph Visualization",paraId:16,tocIndex:5},{value:"）一文的实现。可以通过调节参数调整边绑定的效果。",paraId:16,tocIndex:5},{value:"const edgeBundling = new Bundling({\n  bundleThreshold: 0.6, // 绑定的容忍度。数值越低，被绑定在一起的边相似度越高，即被绑在一起的边更少。\n  K: 100, // 绑定的强度\n});\n",paraId:17,tocIndex:5},{value:"在第一步中，我们已经为节点大小 size 映射了每个节点的总度数。为了更详细展示每个城市飞出和飞入航班的比例，我们希望在每个节点上显示一个类似于饼图的效果。例如",paraId:18,tocIndex:6},{value:" ，桔红色扇形代表飞入该城市的航班比例，青色代表飞出该城市的航班比例。G6 内置的 circle 、rect 等节点形状不能满足这一需求，但 G6 提供了节点的扩展机制，通过下面的代码片段，可以在 G6 中注册一个自定义的节点：",paraId:18,tocIndex:6},{value:"const lightBlue = 'rgb(119, 243, 252)';\nconst lightOrange = 'rgb(230, 100, 64)';\n\n// 注册自定义名为 pie-node 的节点类型\nG6.registerNode(\n  'pie-node',\n  {\n    drawShape: (cfg, group) => {\n      const radius = cfg.size / 2; // 节点半径\n      const inPercentage = cfg.inDegree / cfg.degree; // 入度占总度数的比例\n      const inAngle = inPercentage * Math.PI * 2; // 入度在饼图中的夹角大小\n      const outAngle = Math.PI * 2 - inAngle; // 出度在饼图中的夹角大小\n      const inArcEnd = [radius * Math.cos(inAngle), radius * Math.sin(inAngle)]; // 入度饼图弧结束位置\n      let isInBigArc = 1,\n        isOutBigArc = 0;\n      if (inAngle > Math.PI) {\n        isInBigArc = 0;\n        isOutBigArc = 1;\n      }\n      // 定义代表入度的扇形形状\n      const fanIn = group.addShape('path', {\n        attrs: {\n          path: [\n            ['M', radius, 0],\n            ['A', radius, radius, 0, isInBigArc, 0, inArcEnd[0], inArcEnd[1]],\n            ['L', 0, 0],\n            ['B'],\n          ],\n          lineWidth: 0,\n          fill: lightOrange,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'in-fan-shape',\n      });\n      // 定义代表出度的扇形形状\n      const fanOut = group.addShape('path', {\n        attrs: {\n          path: [\n            ['M', inArcEnd[0], inArcEnd[1]],\n            ['A', radius, radius, 0, isOutBigArc, 0, radius, 0],\n            ['L', 0, 0],\n            ['B'],\n          ],\n          lineWidth: 0,\n          fill: lightBlue,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'out-fan-shape',\n      });\n      // 返回 keyshape\n      return fanIn;\n    },\n  },\n  'single-node',\n);\n",paraId:19,tocIndex:6},{value:"这样，我们就在 G6 中注册了一个名为  pie-node 的节点类型。",paraId:20,tocIndex:6},{value:"在这一步中，我们在实例化图时，并为之指定边绑定插件、节点类型（刚才自定义的 pie-node）、节点样式、边样式（渐变色）。",paraId:21,tocIndex:7},{value:"const edgeBundling = new Bundling({\n  bundleThreshold: 0.6, // 绑定的容忍度。数值越低，被绑定在一起的边相似度越高，即被绑在一起的边更少。\n  K: 100, // 绑定的强度\n});\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 800,\n  plugins: [edgeBundling], // 加入插件\n  fitView: true,\n  defaultNode: {\n    size: 3,\n    color: 'steelblue',\n    fill: 'steelblue',\n  },\n  nodeStyle: {\n    default: {\n      lineWidth: 0,\n      fill: 'steelblue',\n    },\n  },\n  edgeStyle: {\n    default: {\n      lineWidth: 0.7,\n      strokeOpacity: 0.1, // 设置边透明度，在边聚集的部分透明度将会叠加，从而具备突出高密度区域的效果\n      stroke: 'l(0) 0:' + llightBlue16 + ' 1:' + llightOrange16,\n    },\n  },\n});\n",paraId:22,tocIndex:7},{value:"这里出发端的颜色为 ",paraId:23,tocIndex:7},{value:"llightBlue16",paraId:23,tocIndex:7},{value:"，结束端的颜色为 ",paraId:23,tocIndex:7},{value:"llightOrange16",paraId:23,tocIndex:7},{value:"：",paraId:23,tocIndex:7},{value:"const llightBlue16 = '#C8FDFC';\nconst llightOrange16 = '#FFAA86';\n",paraId:24,tocIndex:7},{value:"为了配合节点和边的颜色，这里将页面的 body 的颜色设置为黑色：",paraId:25,tocIndex:7},{value:"<style>\n  body {\n    background: rgb(0, 0, 0);\n  }\n</style>\n",paraId:26,tocIndex:7},{value:"有了 graph 实例和 edgeBundling 实例后，我们执行下面代码进行绑定操作和图的数据读入及渲染：",paraId:27,tocIndex:8},{value:"edgeBundling.bundling(data); // 执行插件的绑定操作\ngraph.data(data);\ngraph.render();\n",paraId:28,tocIndex:8},{value:"使用 tooltip，可以在鼠标 hover 到节点上时展示该节点的其他属性值。首先在 HTML 中设定 tooltip 的样式：",paraId:29,tocIndex:9},{value:"<style>\n  .g6-tooltip {\n    border: 1px solid #e2e2e2;\n    border-radius: 4px;\n    font-size: 12px;\n    color: #545454;\n    background-color: rgba(255, 255, 255, 0.9);\n    padding: 10px 8px;\n    box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n  }\n</style>\n",paraId:30,tocIndex:9},{value:"然后，在上一步实例化 ",paraId:31,tocIndex:9},{value:"graph",paraId:31,tocIndex:9},{value:" 时，增加一个名为 ",paraId:31,tocIndex:9},{value:"modes",paraId:31,tocIndex:9},{value:" 的配置项到参数中，如下写法启动了 ",paraId:31,tocIndex:9},{value:"drag-canvas",paraId:31,tocIndex:9},{value:" 画图拖动操作、",paraId:31,tocIndex:9},{value:"zoom-canvas",paraId:31,tocIndex:9},{value:" 画布放缩操作，以及 ",paraId:31,tocIndex:9},{value:"tooltip",paraId:31,tocIndex:9},{value:"，在  ",paraId:31,tocIndex:9},{value:"formatText",paraId:31,tocIndex:9},{value:" 函数中指定了 ",paraId:31,tocIndex:9},{value:"tooltip",paraId:31,tocIndex:9},{value:" 显示的文本内容：",paraId:31,tocIndex:9},{value:" modes: {\n   default: [ 'drag-canvas', 'zoom-canvas', {\n     type: 'tooltip',\n     formatText(model) {\n       const text = 'Longitude: ' + model.lon + '\\n Latitude: ' + model.lat;\n       return text;\n     },\n     shouldUpdate: e => {\n       return true;\n     }\n   }]\n }\n",paraId:32,tocIndex:9},{value:"这样，当鼠标移动到节点上时，带有经纬度信息的 ",paraId:33,tocIndex:9},{value:"tooltip",paraId:33,tocIndex:9},{value:" 将会出现：",paraId:33,tocIndex:9},{value:" ",paraId:33,tocIndex:9},{value:"tooltip",paraId:34,tocIndex:9},{value:"同时，可以拖拽和放缩画布： ",paraId:35,tocIndex:9},{value:"缩放和拖动画布",paraId:36,tocIndex:9},{value:"最终效果图。节点大小代表飞入及飞出该城市航线总数。节点饼图展示飞出与飞入航线比例统计信息（橙红色为飞入，青色为飞出）。边的渐变色代表航班的飞行方向。起始端：青色；结束端：橙红色。",paraId:37,tocIndex:10},{value:"最后，让我们一起分析如下的最终结果图给我们带来的信息：",paraId:38,tocIndex:10},{value:"大节点主要集中在中偏东部，根据其经纬度，可以推测这些城市有：亚特兰大、纽约、芝加哥、休斯顿、堪萨斯等，这些城市都是美国重要的交通枢纽；",paraId:39,tocIndex:10},{value:"美国东部的线桔红色居多，说明东部城市的飞入航班较多；",paraId:39,tocIndex:10},{value:"相反，西部城市的飞出航班较多；",paraId:39,tocIndex:10},{value:"整体飞行方向从东至西；",paraId:39,tocIndex:10},{value:"东部的航线也较之于西部更加密集、频繁；",paraId:39,tocIndex:10},{value:"西海岸由西雅图和波特兰飞往洛杉矶的航班较多。",paraId:39,tocIndex:10},{value:"上述发现很容易被解释：美国东部是美国的经济、政治集中区域。",paraId:40,tocIndex:10}]},8262:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"社交网络分析是图可视化中一个重要的应用场景。",paraId:0,tocIndex:0},{value:"随着社交网络越来越流行，人与人、人与组织之间的关系变得越来越复杂，使用传统的分析手段，已经很难满足我们的分析需求。在这种情况下，图分析及图可视化显得愈发重要。",paraId:0,tocIndex:0},{value:"基于 G6 实现一个图分析应用，模拟了一个关系分析场景，使用模拟数据，来展示在图分析应用中我们可以做的一些事情：",paraId:1,tocIndex:1},{value:"关系扩散；",paraId:2,tocIndex:1},{value:"关系预判；",paraId:2,tocIndex:1},{value:"关系聚合；",paraId:2,tocIndex:1},{value:"圈检测；",paraId:2,tocIndex:1},{value:"圈查询；",paraId:2,tocIndex:1},{value:"高效分析；\n",paraId:2,tocIndex:1},{value:"数据过滤；",paraId:3,tocIndex:1},{value:"实时标记；",paraId:3,tocIndex:1},{value:"隐藏 / 显示 Label；",paraId:3,tocIndex:1},{value:"隐藏 / 显示节点。",paraId:3,tocIndex:1},{value:"通过输入的方式查询到具体的个人后，可以针对个人做 1-6 度的关系扩散，也可以进一步分析与他相关的人或组织的关系。",paraId:4,tocIndex:2},{value:"适用场景：在社交网络中，通过 A 的一度关系可以查询到他的所有朋友，通过二度关系，可以查询到他的朋友的朋友，通过分析相关动态，可以了解到关于 A 的更多的信息。",paraId:5,tocIndex:2},{value:"在海量数据的社交网络中，人与人、人与组织之间会存在多种类型的关系。假设已知，如 A 是 B 的朋友，B 属于 og 组织。未知：C 与 D 是否也属于 og 组织；如果加入 C 和 D 点到当前图上，网络会如何变化；为 C 和 D 增加“预测”类型的关系，网络会如何变化。为了解这些未知的信息，我们使用关系预判功能。",paraId:6,tocIndex:3},{value:"适用场景：在社交网络中，为两个原本不相关的节点增加预测边，查看网络发生的变化，以确定该操作对图产生的效果。",paraId:7,tocIndex:3},{value:"A 和 B 之间可能会存在多个同事关系，如 A 和 B 在 company1 公司是同事，在 company2 公司也是同事，只是两条同事关系的时间戳不同。对于这种情况，我们没必要将全有的关系都绘制到页面上，可以将同类型的关系合并成一条关系，点击时再展开。",paraId:8,tocIndex:4},{value:"适用场景：为了降低视觉干扰，将多条同类型的关系合并成一条。",paraId:9,tocIndex:4},{value:"在社交网络数据中，假设我们已知朋友圈：A 是 B 的朋友，B 是 C 的朋友，C 又是 A 的朋友。此时，我们想知道 D 和 E 是否与我们已知的朋友圈相关。使用圈检测的功能，输入 D 或 E，若他们存在于已知的朋友圈中，则会被展示出来。",paraId:10,tocIndex:5},{value:"适用场景：检测用户是否存在于已知的朋友圈中。",paraId:11,tocIndex:5},{value:"对于已知的圈，我们可以查询每个圈中包含的节点，以及它们之间的关系。",paraId:12,tocIndex:6},{value:"适用场景：查询指定朋友圈中所有的用户以及用户之间的关系。",paraId:13,tocIndex:6},{value:"图分析应用中，为了提升分析的效率，我们提供了数据过滤、标记重点节点和边、隐藏 / 显示 Label 等辅助功能，可帮助用户更快更好地进行分析。",paraId:14,tocIndex:7},{value:"当画布上存在大量的节点及边时，想要进行高效分析是件很困难的事情，我们可以通过过滤的功能，将暂时不需要关注的类型的节点和边先隐藏起来，以便我们将精力放在重点的节点和边上面。",paraId:15,tocIndex:8},{value:"在分析过程中，将重点需要关注的节点和边进行标记，可以在复杂的网络关系中很清晰地呈现出我们需要重点关注的内容。",paraId:16,tocIndex:9},{value:"该功能尤其适用于探索特别复杂的网络中。",paraId:17,tocIndex:9},{value:"在分析过程中，我们可以选择性地隐藏不重要的节点及其相关边，方便我们将注意力集中在重点的节点上面。当分析完成以后，可以选择将隐藏的节点全部显示出来。",paraId:18,tocIndex:10},{value:"当边的数量特别大时，边上的 label 相互重叠，影响我们进一步的分析。此时，可以选择将边上的 label 隐藏。",paraId:19,tocIndex:11},{value:"本应用以模拟的社交网络数据为例，演示了使用 ",paraId:20,tocIndex:12},{value:"G6",paraId:20,tocIndex:12},{value:" 构建的一个图分析的应用。在实际的场景中，不局限于社交网络数据，任何重关系类的数据，都可使用图分析的技术进行分析，如风控、反洗钱、信用卡诈骗等金融领域；商品、商家及卖家等电商领域。",paraId:20,tocIndex:12},{value:"G6",paraId:20,tocIndex:12},{value:" 是一款开源的图可视化引擎，专注于关系数据的展示与分析，非常适合用于构建重型的图分析应用。",paraId:20,tocIndex:12},{value:"G6 官网：",paraId:21,tocIndex:13},{value:"https://g6.antv.antgroup.com/",paraId:21,tocIndex:13},{value:" ",paraId:21,tocIndex:13},{value:"G6 GitHub：",paraId:21,tocIndex:13},{value:"https://github.com/antvis/g6",paraId:21,tocIndex:13}]},95220:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"随着互联网业务不断快速发展，业务和应用系统、中间件及其之间的关系、依赖变得越来越复杂。不论是研发、测试还是架构、运维人员，对公司线上的应用、中间件等超级复杂关系的整体把控越来越无力维护。一旦线上出现问题，从故障发生到组织应急和应急的整个过程需要多方参与并使用多个系统工具和平台来回查询、不停同步信息。过程的多个阶段之间有断裂，影响面评估和变更追溯耗时较长，且对应急人员的要求有较高的门槛。整体故障应急缺乏高效的、系统的解决方案。例如，线上告警后不能快速定位影响面和变更源，很难准确进行决策，不能迅速最小化的处理线上故障。",paraId:0,tocIndex:0},{value:"基于这样的背景，我们尝试提一套应急方案可视化，解决应急过程中流程、影响面、应急预案等一系列应急决策辅助信息和手段，快速止血以减少和避免故障升级。",paraId:1,tocIndex:0},{value:"应急模式大图是应急模式进入后的主页面，大图应该包括的功能点有： ",paraId:2,tocIndex:2},{value:"1）本次发生异常的节点、与异常节点的有调用关系的其他节点，以及其调用关系链路展示； ",paraId:2,tocIndex:2},{value:"2）链路或者节点的一些备注信息展示； ",paraId:2,tocIndex:2},{value:"3）节点上有交互能力：比如 hover 或者 click 之后有详细信息展示； ",paraId:2,tocIndex:2},{value:"4）与左侧影响面中选择项联动展示大图； ",paraId:2,tocIndex:2},{value:"5）节点的展开菜单扩展； ",paraId:2,tocIndex:2},{value:"6）时序分析功能，时间轴，展示最近一小时每分钟的错误总数柱形图，点击柱形图表示选择某时间点，选择后可触发全部功能请求接口，刷新全部功能。",paraId:2,tocIndex:2},{value:"影响面的概念是指：每一次发生异常产生的影响。这个影响一方面体现在业务层面，是业务影响面；另一方面体现在更具体的前端页面上，叫前端影响面；体现在具体应用，是应用影响面。",paraId:3,tocIndex:3},{value:"影响面以悬浮面板的形式吸附在页面边缘（左侧），应该具有的功能有：",paraId:3,tocIndex:3},{value:"1）打开 / 收起影响面面板；",paraId:3,tocIndex:3},{value:"2）展示影响面列表信息；",paraId:3,tocIndex:3},{value:"3）切换业务影响面/前端影响面/应用影响面；",paraId:3,tocIndex:3},{value:"4）影响趋势图；",paraId:3,tocIndex:3},{value:"5）日志查看列表；",paraId:3,tocIndex:3},{value:"6）信息模块可折叠；",paraId:3,tocIndex:3},{value:"7）基础架构依赖。",paraId:3,tocIndex:3},{value:"执行操作面板的入口是：点击查看影响面列表中的详情。",paraId:4,tocIndex:4},{value:"执行操作含的功能有：",paraId:4,tocIndex:4},{value:"1）概要信息列表展示和操作功能；",paraId:4,tocIndex:4},{value:"2）应急辅助的列表展示以及操作功能（有弹出展示图标）；",paraId:4,tocIndex:4},{value:"3）打开 / 收起影响面面板；",paraId:4,tocIndex:4},{value:"4）信息模块可折叠。",paraId:4,tocIndex:4},{value:"在原有的 APP 详情页上有添加一些扩展功能：",paraId:5,tocIndex:5},{value:"1）日志展示；",paraId:5,tocIndex:5},{value:"2）应急辅助。",paraId:5,tocIndex:5},{value:"链接分享，分享的链接中带有时间参数，用以回到异常现场；",paraId:6,tocIndex:6},{value:"可以限流；",paraId:6,tocIndex:6},{value:"关键字高亮，使用正则去匹配部分关键字并处理待显示的 HTML 文本。",paraId:6,tocIndex:6},{value:"应急大图是一幅有状态的架构大图，主要目的是其一展示系统间关系，分析系统或接口间依赖，其二，除架构上的相关信息外，整个系统集群在某时刻的正常或异常状态的展示和分析，从运维的角度看则更具备意义。通过大图用户就能直观看到业务链路上那个节点出了问题。 ",paraId:7,tocIndex:8},{value:"我们提供了两种模式的应急大图：流量视角和链路视角。",paraId:7,tocIndex:8},{value:"流量视角的大家第一眼看起来会觉得很酷炫，但实际在应急工作中有太多的冗余信息，对快速把握问题的核心原因没有帮助，所以在应急工作台上大图的构建采用了更加清晰的链路视图。二者的核心数据是一致的，只是链路视图是将流量线做了合并。",paraId:8,tocIndex:8},{value:"实际上，一张图上某一时刻只能映射出实际系统某一刻的状态剖面。但问题的发生不是瞬时抖动的，而更像是湖面波澜起伏的湖水时高时低。想要了解任意时刻系统的状态，这个时候我们就需要借助时序分析的能力，这个就是通过下面时序分析的工具来实现的：",paraId:9,tocIndex:9},{value:" ",paraId:9,tocIndex:9},{value:"这个工具对时间的控制分为了三个层次：分 -> 小时 -> 天。用户通过日期选择控件在不同日期间切换，通过全天的时间轴分析 24 小时波动趋势，并选择具体时段确定要进行分析分钟级切面，最终通过选择具体切面来进行分析。",paraId:10,tocIndex:9},{value:"时序分析模块增加了时间轴，默认展示最近一小时每分钟的错误总数柱形图，点击柱形图表示选择某时间点，选择后可触发全部功能请求接口，刷新全部功能。",paraId:11,tocIndex:9},{value:"当选择出具体时间点后，页面中所有功能需要重新刷新。所以，选择时间的数据模型层在本页面模块相对全局的位置，而所有需要依据此数据而变化的子模块应该在生命周期中监听该数据。大图数据当然也需要在请求到新的数据后更新。",paraId:11,tocIndex:9},{value:"处理好以上细节后，我们的大图就有了一个非常强大的时序分析能力。",paraId:11,tocIndex:9},{value:"从体验上考虑，当我们处理应急工作时最想做到的是用户能够不依赖其他应用，直接在我们的图上能够找到问题最根本的原因。但是受限于目前图可视化的局限，目前所有的信息都收敛到一个“node”的色块上，能够映射上去的信息非常有限。所以，一个自然的思路是对节点表达能力进行扩展。",paraId:12,tocIndex:10},{value:"得益于 G6 的渲染能力，我们可以比较容易的在节点上扩展出我们想要的表达方式。通过下面的示例，可以看到 G6 的节点扩展能力是非常强悍的。",paraId:12,tocIndex:10},{value:"我们再来看看扩展后的交互能力：",paraId:13,tocIndex:10},{value:"接下来，我们将使用 G6 实现下面的功能：",paraId:14,tocIndex:10},{value:"有了这样的基础后，节点样式不局限于简单的几何形状，而是把具有代表意义的信息映射到节点上，从而使节点的形状一眼看上就能大致反应某节点的特点。这样在某些多个节点需要对比的场景下也是具有意义的。",paraId:15,tocIndex:10},{value:" ",paraId:15,tocIndex:10},{value:"本次应急工作台，先选用一小时内的错误量数据来扩展节点信息。具体方案是，将这些时序信息分布到原有节点的圆周上，信息值的大小用放射状的柱状图来映射。",paraId:15,tocIndex:10},{value:"\n  ",paraId:16},{value:"总体来讲，应急工作台深度聚焦业务场景，提供的功能齐备、逻辑合理、流程完整。未来可以深入的事情还有很多，比如，节点信息的扩展可以更加丰富，有更多更丰富的数据属性可以被映射到节点图形中；当前布局是基于 Dagre 的有向图层次布局，在布局复杂链路的时候可能还是存在不够清晰的情况；当前的应急工作台尽管基于此前的星云大图，但是却舍弃了节点在整个域架构中的“位置”信息。我们将持续深入优化这些问题。",paraId:17,tocIndex:12},{value:"源码：",paraId:18,tocIndex:13},{value:"https://github.com/scaletimes/g6-flow-demo",paraId:18,tocIndex:13},{value:" ",paraId:18,tocIndex:13},{value:"G6 官网：",paraId:18,tocIndex:13},{value:"https://g6.antv.antgroup.com/",paraId:18,tocIndex:13},{value:" ",paraId:18,tocIndex:13},{value:"G6 GitHub：",paraId:18,tocIndex:13},{value:"https://github.com/antvis/g6",paraId:18,tocIndex:13}]},35654:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在项目中引入 G6 有以下两种方式：NPM 引入；CDN 引入。",paraId:0,tocIndex:1},{value:"Step 1:",paraId:1,tocIndex:2},{value:" 使用命令行在项目目录下执行以下命令：",paraId:1,tocIndex:2},{value:" npm install --save @antv/g6\n",paraId:2,tocIndex:2},{value:"Step 2:",paraId:3,tocIndex:2},{value:" 在需要用的 G6 的 JS 文件中导入：",paraId:3,tocIndex:2},{value:"import G6 from '@antv/g6';\n",paraId:4,tocIndex:2},{value:'// version <= 3.2\n<script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-{$version}/build/g6.js"><\/script>\n\n// version >= 3.3\n<script src="https://gw.alipayobjects.com/os/lib/antv/g6/{$version}/dist/g6.min.js"><\/script>\n\n// version >= 4.0\n<script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script>\n\n',paraId:5,tocIndex:3},{value:"⚠️ 注意:",paraId:6,tocIndex:3},{value:"在  ",paraId:7,tocIndex:3},{value:"{$version}",paraId:7,tocIndex:3},{value:" 中填写版本号，例如  ",paraId:7,tocIndex:3},{value:"3.7.1",paraId:7,tocIndex:3},{value:"；",paraId:7,tocIndex:3},{value:"最新版可以在  ",paraId:7,tocIndex:3},{value:"NPM",paraId:7,tocIndex:3},{value:"  查看最新版本及版本号；",paraId:7,tocIndex:3},{value:"详情参考 Github 分支：",paraId:7,tocIndex:3},{value:"https://github.com/antvis/g6/tree/master",paraId:7,tocIndex:3},{value:"。",paraId:7,tocIndex:3},{value:"创建一个 G6 的关系图仅需要下面几个步骤：",paraId:8,tocIndex:4},{value:"创建关系图的 HTML 容器；",paraId:9,tocIndex:4},{value:"数据准备；",paraId:9,tocIndex:4},{value:"创建关系图；",paraId:9,tocIndex:4},{value:"配置数据源，渲染。",paraId:9,tocIndex:4},{value:"需要在 HTML 中创建一个用于容纳 G6 绘制的图的容器，通常为 ",paraId:10,tocIndex:5},{value:"div",paraId:10,tocIndex:5},{value:"  标签。G6 在绘制时会在该容器下追加 ",paraId:10,tocIndex:5},{value:"canvas",paraId:10,tocIndex:5},{value:" 标签，然后将图绘制在其中。",paraId:10,tocIndex:5},{value:'<div id="mountNode"></div>\n',paraId:11,tocIndex:5},{value:"引入 G6 的数据源为 JSON 格式的对象。该对象中需要有节点（",paraId:12,tocIndex:6},{value:"nodes",paraId:12,tocIndex:6},{value:"）和边（",paraId:12,tocIndex:6},{value:"edges",paraId:12,tocIndex:6},{value:"）字段，分别用数组表示：",paraId:12,tocIndex:6},{value:"const data = {\n  // 点集\n  nodes: [\n    {\n      id: 'node1', // String，该节点存在则必须，节点的唯一标识\n      x: 100, // Number，可选，节点位置的 x 值\n      y: 200, // Number，可选，节点位置的 y 值\n    },\n    {\n      id: 'node2', // String，该节点存在则必须，节点的唯一标识\n      x: 300, // Number，可选，节点位置的 x 值\n      y: 200, // Number，可选，节点位置的 y 值\n    },\n  ],\n  // 边集\n  edges: [\n    {\n      source: 'node1', // String，必须，起始点 id\n      target: 'node2', // String，必须，目标点 id\n    },\n  ],\n};\n",paraId:13,tocIndex:6},{value:"注意",paraId:14,tocIndex:6},{value:"nodes",paraId:15,tocIndex:6},{value:" 数组中包含节点对象。每个节点对象中唯一的、必要的 ",paraId:15,tocIndex:6},{value:"id",paraId:15,tocIndex:6},{value:" 以标识不同的节点，",paraId:15,tocIndex:6},{value:"x",paraId:15,tocIndex:6},{value:"、 ",paraId:15,tocIndex:6},{value:"y",paraId:15,tocIndex:6},{value:" 指定该节点的位置；",paraId:15,tocIndex:6},{value:"edges",paraId:15,tocIndex:6},{value:" 数组中包含边对象。",paraId:15,tocIndex:6},{value:"source",paraId:15,tocIndex:6},{value:" 和 ",paraId:15,tocIndex:6},{value:"target",paraId:15,tocIndex:6},{value:" 是每条边的必要属性，分别代表了该边的起始点 ",paraId:15,tocIndex:6},{value:"id",paraId:15,tocIndex:6},{value:" 与 目标点 ",paraId:15,tocIndex:6},{value:"id",paraId:15,tocIndex:6},{value:"。",paraId:15,tocIndex:6},{value:"点和边的其他属性参见链接：",paraId:15,tocIndex:6},{value:"内置节点",paraId:16,tocIndex:6},{value:" 和 ",paraId:15,tocIndex:6},{value:"内置边",paraId:17,tocIndex:6},{value:"。",paraId:15,tocIndex:6},{value:"创建关系图（实例化）时，至少需要为图设置容器、宽和高。",paraId:18,tocIndex:7},{value:"const graph = new G6.Graph({\n  container: 'mountNode', // String | HTMLElement，必须，在 Step 1 中创建的容器 id 或容器本身\n  width: 800, // Number，必须，图的宽度\n  height: 500, // Number，必须，图的高度\n});\n",paraId:19,tocIndex:7},{value:"graph.data(data); // 读取 Step 2 中的数据源到图上\ngraph.render(); // 渲染图\n",paraId:20,tocIndex:8},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    /* 图的画布容器 */\n    <div id=\"mountNode\"></div>\n\n    /* 引入 G6 */\n    <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script>\n\n    <script>\n      // 定义数据源\n      const data = {\n        // 点集\n        nodes: [\n          {\n            id: 'node1',\n            x: 100,\n            y: 200,\n          },\n          {\n            id: 'node2',\n            x: 300,\n            y: 200,\n          },\n        ],\n        // 边集\n        edges: [\n          // 表示一条从 node1 节点连接到 node2 节点的边\n          {\n            source: 'node1',\n            target: 'node2',\n          },\n        ],\n      };\n\n      // 创建 G6 图实例\n      const graph = new G6.Graph({\n        container: 'mountNode', // 指定图画布的容器 id，与第 9 行的容器对应\n        // 画布宽高\n        width: 800,\n        height: 500,\n      });\n      // 读取数据\n      graph.data(data);\n      // 渲染图\n      graph.render();\n    <\/script>\n  </body>\n</html>\n",paraId:21,tocIndex:10},{value:"如果你想在 React 中使用 G6 ，可以参考我们提供了的 React 中使用 G6 的 ",paraId:22,tocIndex:11},{value:"Demo",paraId:22,tocIndex:11},{value:"。",paraId:22,tocIndex:11},{value:"更多关于 React 中如何使用 G6，请参考 ",paraId:23,tocIndex:11},{value:"React 中使用 G6 的文档",paraId:24,tocIndex:11},{value:"。有任何问题都可以通过页面底部的钉钉交流群和我们沟通，也非常欢迎给我们提 issues 或 PR： ",paraId:23,tocIndex:11},{value:"https://github.com/antvis/g6/tree/master",paraId:23,tocIndex:11},{value:"。",paraId:23,tocIndex:11},{value:"本章仅仅介绍了如何安装以及最简单的场景，在 G6 Tutorial 中其他的章节中我们会教会你：",paraId:25,tocIndex:12},{value:"实例化图时的常见配置；",paraId:26,tocIndex:12},{value:"设置元素（节点/边）属性、样式；",paraId:26,tocIndex:12},{value:"设置布局；",paraId:26,tocIndex:12},{value:"增加交互；",paraId:26,tocIndex:12},{value:"增加动画；",paraId:26,tocIndex:12},{value:"使用辅助组件。",paraId:26,tocIndex:12},{value:"想了解更高阶的功能，请参见 ",paraId:27,tocIndex:12},{value:"G6 核心概念",paraId:28,tocIndex:12},{value:"，",paraId:27,tocIndex:12},{value:"G6 扩展阅读",paraId:29,tocIndex:12},{value:"。",paraId:27,tocIndex:12}]},26993:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:" ",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:"English Introduction",paraId:1},{value:"G6",paraId:2,tocIndex:0},{value:" 是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等图可视化的基础能力。旨在让关系变得透明，简单。让用户获得关系数据的 Insight。",paraId:2,tocIndex:0},{value:"基于 G6，用户可以快速搭建自己的 ",paraId:3,tocIndex:0},{value:"图分析",paraId:3,tocIndex:0},{value:" 或 ",paraId:3,tocIndex:0},{value:"图编辑",paraId:3,tocIndex:0},{value:" 应用。",paraId:3,tocIndex:0},{value:"如果您还没有使用过 G6， 建议通过 ",paraId:4,tocIndex:0},{value:"快速上手",paraId:5,tocIndex:0},{value:" 抢先体验 G6 的魅力。",paraId:4,tocIndex:0},{value:"强大的布局",paraId:6,tocIndex:0},{value:"强大的动画及交互",paraId:7,tocIndex:0},{value:"G6 作为一款专业的图可视化引擎，具有以下特性：",paraId:8,tocIndex:1},{value:"优秀的性能：支持大规模图数据的交互与探索；",paraId:9,tocIndex:1},{value:"丰富的元素：内置丰富的节点与边元素，自由配置，支持自定义；",paraId:9,tocIndex:1},{value:"可控的交互：内置 10+ 交互行为，支持自定义交互；",paraId:9,tocIndex:1},{value:"强大的布局：内置了 10+ 常用的图布局，支持自定义布局；",paraId:9,tocIndex:1},{value:"便捷的组件：优化内置组件功能及性能；",paraId:9,tocIndex:1},{value:"友好的体验：根据用户需求分层梳理文档，支持 TypeScript 类型推断。",paraId:9,tocIndex:1},{value:"除了默认好用、配置自由的内置功能，元素、交互、布局均具有高可扩展的自定义机制。",paraId:10,tocIndex:1},{value:"丰富的图元素",paraId:11,tocIndex:1},{value:"G6 入门教程",paraId:12,tocIndex:2},{value:"G6 核心概念",paraId:13,tocIndex:2},{value:"G6 扩展阅读",paraId:14,tocIndex:2},{value:"API",paraId:15,tocIndex:2},{value:"G6 Blog",paraId:16,tocIndex:2},{value:"// 定义数据源\nconst data = {\n  // 点集\n  nodes: [\n    {\n      id: 'node1',\n      x: 100,\n      y: 200,\n    },\n    {\n      id: 'node2',\n      x: 300,\n      y: 200,\n    },\n  ],\n  // 边集\n  edges: [\n    // 表示一条从 node1 节点连接到 node2 节点的边\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n  ],\n};\n\n// 创建 G6 图实例\nconst graph = new G6.Graph({\n  container: 'mountNode', // 指定图画布的容器 id\n  // 画布宽高\n  width: 800,\n  height: 500,\n});\n// 读取数据\ngraph.data(data);\n// 渲染图\ngraph.render();\n",paraId:17,tocIndex:3},{value:"更详细的内容请参考 ",paraId:18,tocIndex:3},{value:"快速上手",paraId:19,tocIndex:3},{value:" 文档。",paraId:18,tocIndex:3},{value:"官方独立产品：Graphin",paraId:20,tocIndex:4},{value:"Graphin 取名意为 Graph Insight（图的分析洞察），是一个基于 G6 封装的 React 组件库，专注在关系可视分析领域，简单高效，开箱即用。",paraId:21,tocIndex:4},{value:"github： ",paraId:22,tocIndex:4},{value:"https://github.com/antvis/Graphin",paraId:22,tocIndex:4},{value:"官网：",paraId:22,tocIndex:4},{value:"https://graphin.antv.vision",paraId:22,tocIndex:4},{value:"结合前端库的第三方实现：",paraId:23,tocIndex:4},{value:"基于 G6 和 React 的可视化流程编辑器 - Workflow Designer",paraId:24,tocIndex:4},{value:"；",paraId:24,tocIndex:4},{value:"基于 G6 和 Vue 的可视化编辑器",paraId:24,tocIndex:4},{value:"；",paraId:24,tocIndex:4},{value:"基于 G6 和 Vue 的可视化图形编辑器 - A visual graph editor based on G6 and Vue",paraId:24,tocIndex:4},{value:"；",paraId:24,tocIndex:4},{value:"基于 G6 和 React 实现的 ER 图编辑器",paraId:24,tocIndex:4},{value:"；",paraId:24,tocIndex:4},{value:"基于 G6 和 Angular 实现的编辑器",paraId:24,tocIndex:4},{value:"基于 G6 和 Vue 的流程图编辑器",paraId:24,tocIndex:4},{value:"欢迎各界 G6 使用者、图可视化爱好者加入 ",paraId:25,tocIndex:5},{value:"G6 图可视化交流群",paraId:25,tocIndex:5},{value:" 及 ",paraId:25,tocIndex:5},{value:"G6 图可视化交流二群",paraId:25,tocIndex:5},{value:"（钉钉群，使用钉钉扫一扫加入）讨论与交流。Graphin 的使用者，爱好者请加入 ",paraId:25,tocIndex:5},{value:"Graphin's Group Chat",paraId:25,tocIndex:5},{value:"G6 图可视化交流群",paraId:26,tocIndex:5},{value:" 已满员，该群会不定期移除不活跃的成员。",paraId:26,tocIndex:5},{value:"由于维护精力有限，",paraId:27,tocIndex:5},{value:"G6 图可视化交流群",paraId:27,tocIndex:5},{value:" 仅供社区同学相互交流，不进行答疑。欢迎对 G6 感兴趣的同学加入到答疑中来，非常感谢！",paraId:27,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"\n    ",paraId:28,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"\n    ",paraId:28,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"\n   ",paraId:28,tocIndex:5},{value:"\n  ",paraId:28,tocIndex:5},{value:"请让我们知道您要解决或贡献什么，所以在贡献之前请先提交 ",paraId:29,tocIndex:6},{value:"issues",paraId:29,tocIndex:6},{value:" 描述 bug 或建议。",paraId:29,tocIndex:6},{value:"MIT license",paraId:30,tocIndex:7},{value:"。",paraId:30,tocIndex:7}]},91703:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 中的动画分为两个层次：",paraId:0},{value:"全局动画：全局性的动画，图整体变化时的动画过渡；",paraId:1},{value:"元素（边和节点）动画：节点或边上的独立动画。",paraId:1},{value:"G6 的全局动画指通过图实例进行某些全局操作时，产生的动画效果。例如：",paraId:2,tocIndex:0},{value:"graph.updateLayout(cfg)",paraId:3,tocIndex:0},{value:" 布局的变化",paraId:3,tocIndex:0},{value:"graph.changeData()",paraId:3,tocIndex:0},{value:" 数据的变化",paraId:3,tocIndex:0},{value:"通过实例化图时配置 ",paraId:4,tocIndex:0},{value:"animate: true",paraId:4,tocIndex:0},{value:"，可以达到每次进行上述操作时，动画效果变化的目的。配合 ",paraId:4,tocIndex:0},{value:"animateCfg",paraId:4,tocIndex:0},{value:" 配置动画参数，",paraId:4,tocIndex:0},{value:"animateCfg",paraId:4,tocIndex:0},{value:" 具体配置参见 ",paraId:4,tocIndex:0},{value:"animateCfg",paraId:5,tocIndex:0},{value:"const graph = new G6.Graph({\n  // ...                   // 图的其他配置项\n  animate: true, // Boolean，切换布局时是否使用动画过度，默认为 false\n  animateCfg: {\n    duration: 500, // Number，一次动画的时长\n    easing: 'linearEasing', // String，动画函数\n  },\n});\n",paraId:6,tocIndex:0},{value:"由于 G6 的内置节点和边是没有动画的，需要实现节点和边上的动画需要通过",paraId:7,tocIndex:1},{value:"自定义节点",paraId:8,tocIndex:1},{value:"、",paraId:7,tocIndex:1},{value:"自定义边",paraId:9,tocIndex:1},{value:"时复写  ",paraId:7,tocIndex:1},{value:"afterDraw",paraId:7,tocIndex:1},{value:"  实现。",paraId:7,tocIndex:1},{value:"节点上的动画，即每一帧发生变化的是节点上的某一个图形。关于节点动画，以下面三个动画示例进行讲解：",paraId:10,tocIndex:2},{value:"节点上图形的动画（如下图左）；",paraId:11,tocIndex:2},{value:"增加带有动画的背景图形（如下图中）；",paraId:11,tocIndex:2},{value:"节点上部分图形的旋转动画（如下图右）。",paraId:11,tocIndex:2},{value:"以上三个动画节点的 demo 代码见： ",paraId:12,tocIndex:2},{value:"节点动画",paraId:12,tocIndex:2},{value:"。",paraId:12,tocIndex:2},{value:"本例实现节点放大缩小，通过  ",paraId:13,tocIndex:3},{value:"group.get('children')[0]",paraId:13,tocIndex:3},{value:" 找到需要更新的图形（这里找到该节点上第 0 个图形），然后调用该图形的 ",paraId:13,tocIndex:3},{value:"animate",paraId:13,tocIndex:3},{value:" 方法指定动画的参数及每一帧的变化（  第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:13,tocIndex:3},{value:"ratio",paraId:13,tocIndex:3},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:13,tocIndex:3},{value:"animateCfg",paraId:14,tocIndex:3},{value:"）。",paraId:13,tocIndex:3},{value:"// 放大、变小动画\nG6.registerNode(\n  'circle-animate',\n  {\n    afterDraw(cfg, group) {\n      // 获取该节点上的第一个图形\n      const shape = group.get('children')[0];\n      // 该图形的动画\n      shape.animate(\n        (ratio) => {\n          // 每一帧的操作，入参 ratio：这一帧的比例值（Number）。返回值：这一帧需要变化的参数集（Object）。\n          // 先变大、再变小\n          const diff = ratio <= 0.5 ? ratio * 10 : (1 - ratio) * 10;\n          let radius = cfg.size;\n          if (isNaN(radius)) radius = radius[0];\n          // 返回这一帧需要变化的参数集，这里只包含了半径\n          return {\n            r: radius / 2 + diff,\n          };\n        },\n        {\n          // 动画重复\n          repeat: true,\n          duration: 3000,\n          easing: 'easeCubic',\n        },\n      ); // 一次动画持续的时长为 3000，动画效果为 'easeCubic'\n    },\n  },\n  'circle',\n); // 该自定义节点继承了内置节点 'circle'，除了被复写的 afterDraw 方法外，其他按照 'circle' 里的函数执行。\n",paraId:15,tocIndex:3},{value:"在 ",paraId:16,tocIndex:4},{value:"afterDraw",paraId:16,tocIndex:4},{value:" 方法中为已有节点添加额外的 shape ，并为这些新增的图形设置动画。",paraId:16,tocIndex:4},{value:"本例在 ",paraId:17,tocIndex:4},{value:"afterDraw",paraId:17,tocIndex:4},{value:" 方法中，绘制了三个背景 circle ，分别使用不同的颜色填充，再调用 ",paraId:17,tocIndex:4},{value:"animate",paraId:17,tocIndex:4},{value:" 方法实现这三个 circle 逐渐变大、变淡的动画。本例中没有使用函数参数的形式，直接在 ",paraId:17,tocIndex:4},{value:"animate",paraId:17,tocIndex:4},{value:" 函数的第一个参数中设置每次动画结束时的最终目标样式，即半径增大 10，透明度降为 0.1。第二个参数设置动画的配置，动画参数的具体配置参见 ",paraId:17,tocIndex:4},{value:"animateCfg",paraId:18,tocIndex:4},{value:"。",paraId:17,tocIndex:4},{value:"G6.registerNode(\n  'background-animate',\n  {\n    afterDraw(cfg, group) {\n      let r = cfg.size / 2;\n      if (isNaN(r)) {\n        r = cfg.size[0] / 2;\n      }\n      // 第一个背景圆\n      const back1 = group.addShape('circle', {\n        zIndex: -3,\n        attrs: {\n          x: 0,\n          y: 0,\n          r,\n          fill: cfg.color,\n          opacity: 0.6,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'circle-shape1',\n      });\n      // 第二个背景圆\n      const back2 = group.addShape('circle', {\n        zIndex: -2,\n        attrs: {\n          x: 0,\n          y: 0,\n          r,\n          fill: 'blue', // 为了显示清晰，随意设置了颜色\n          opacity: 0.6,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'circle-shape2',\n      });\n      // 第三个背景圆\n      const back3 = group.addShape('circle', {\n        zIndex: -1,\n        attrs: {\n          x: 0,\n          y: 0,\n          r,\n          fill: 'green',\n          opacity: 0.6,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'circle-shape3',\n      });\n      group.sort(); // 排序，根据 zIndex 排序\n\n      // 第一个背景圆逐渐放大，并消失\n      back1.animate(\n        {\n          r: r + 10,\n          opacity: 0.1,\n        },\n        {\n          repeat: true, // 循环\n          duration: 3000,\n          easing: 'easeCubic',\n          delay: 0, // 无延迟\n        },\n      );\n\n      // 第二个背景圆逐渐放大，并消失\n      back2.animate(\n        {\n          r: r + 10,\n          opacity: 0.1,\n        },\n        {\n          repeat: true, // 循环\n          duration: 3000,\n          easing: 'easeCubic',\n          delay: 1000, // 1 秒延迟\n        },\n      ); // 1 秒延迟\n\n      // 第三个背景圆逐渐放大，并消失\n      back3.animate(\n        {\n          r: r + 10,\n          opacity: 0.1,\n        },\n        {\n          repeat: true, // 循环\n          duration: 3000,\n          easing: 'easeCubic',\n          delay: 2000, // 2 秒延迟\n        },\n      );\n    },\n  },\n  'circle',\n);\n",paraId:19,tocIndex:4},{value:"这一例也是在 ",paraId:20,tocIndex:5},{value:"afterDraw",paraId:20,tocIndex:5},{value:" 方法中为已有节点添加额外的 shape （本例中为 image），并为这些新增的图形设置旋转动画。旋转动画较为复杂，需要通过矩阵的操作实现。",paraId:20,tocIndex:5},{value:"animate",paraId:20,tocIndex:5},{value:" 函数的第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:20,tocIndex:5},{value:"ratio",paraId:20,tocIndex:5},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:20,tocIndex:5},{value:"animateCfg",paraId:21,tocIndex:5},{value:"。",paraId:20,tocIndex:5},{value:"G6.registerNode(\n  'inner-animate',\n  {\n    afterDraw(cfg, group) {\n      const size = cfg.size;\n      const width = size[0] - 12;\n      const height = size[1] - 12;\n      // 添加图片 shape\n      const image = group.addShape('image', {\n        attrs: {\n          x: -width / 2,\n          y: -height / 2,\n          width: width,\n          height: height,\n          img: cfg.img,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'image-shape',\n      });\n      // 该图片 shape 的动画\n      image.animate(\n        (ratio) => {\n          // 每一帧的操作，入参 ratio：这一帧的比例值（Number）。返回值：这一帧需要变化的参数集（Object）。\n          // 旋转通过矩阵来实现\n          // 当前矩阵\n          const matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          // 目标矩阵\n          const toMatrix = Util.transform(matrix, [['r', ratio * Math.PI * 2]]);\n          // 返回这一帧需要的参数集，本例中只有目标矩阵\n          return {\n            matrix: toMatrix,\n          };\n        },\n        {\n          repeat: true, // 动画重复\n          duration: 3000,\n          easing: 'easeCubic',\n        },\n      );\n    },\n  },\n  'rect',\n);\n",paraId:22,tocIndex:5},{value:"关于边动画，以下面三个动画示例进行讲解：",paraId:23,tocIndex:6},{value:"圆点在沿着线运动（下图左）；",paraId:24,tocIndex:6},{value:"虚线运动的效果（下图中，gif 图片的帧率问题导致看起来是静态的，可以访问下面的 demo 链接查看）；",paraId:24,tocIndex:6},{value:"线从无到有的效果（下图右）。",paraId:24,tocIndex:6},{value:"以上三个边动画的 demo 代码见：",paraId:25,tocIndex:6},{value:"边动画",paraId:25,tocIndex:6},{value:"。",paraId:25,tocIndex:6},{value:"本例通过在 ",paraId:26,tocIndex:7},{value:"afterDraw",paraId:26,tocIndex:7},{value:" 方法中为边增加了一个 circle 图形，该图形沿着线运动。沿着线运动的原理：设定每一帧中，该 circle 在线上的相对位置。",paraId:26,tocIndex:7},{value:"animate",paraId:26,tocIndex:7},{value:" 函数的第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:26,tocIndex:7},{value:"ratio",paraId:26,tocIndex:7},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:26,tocIndex:7},{value:"animateCfg",paraId:27,tocIndex:7},{value:"。",paraId:26,tocIndex:7},{value:"G6.registerEdge(\n  'circle-running',\n  {\n    afterDraw(cfg, group) {\n      // 获得当前边的第一个图形，这里是边本身的 path\n      const shape = group.get('children')[0];\n      // 边 path 的起点位置\n      const startPoint = shape.getPoint(0);\n\n      // 添加红色 circle 图形\n      const circle = group.addShape('circle', {\n        attrs: {\n          x: startPoint.x,\n          y: startPoint.y,\n          fill: 'red',\n          r: 3,\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'circle-shape',\n      });\n\n      // 对红色圆点添加动画\n      circle.animate(\n        (ratio) => {\n          // 每一帧的操作，入参 ratio：这一帧的比例值（Number）。返回值：这一帧需要变化的参数集（Object）。\n          // 根据比例值，获得在边 path 上对应比例的位置。\n          const tmpPoint = shape.getPoint(ratio);\n          // 返回需要变化的参数集，这里返回了位置 x 和 y\n          return {\n            x: tmpPoint.x,\n            y: tmpPoint.y,\n          };\n        },\n        {\n          repeat: true, // 动画重复\n          duration: 3000,\n        },\n      ); // 一次动画的时间长度\n    },\n  },\n  'cubic',\n); // 该自定义边继承内置三阶贝塞尔曲线 cubic\n",paraId:28,tocIndex:7},{value:"虚线运动的效果是通过计算线的 ",paraId:29,tocIndex:8},{value:"lineDash",paraId:29,tocIndex:8},{value:" ，并在每一帧中不断修改实现。",paraId:29,tocIndex:8},{value:"animate",paraId:29,tocIndex:8},{value:" 函数的第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:29,tocIndex:8},{value:"ratio",paraId:29,tocIndex:8},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:29,tocIndex:8},{value:"animateCfg",paraId:30,tocIndex:8},{value:"。",paraId:29,tocIndex:8},{value:"// lineDash 的差值，可以在后面提供 util 方法自动计算\nconst lineDash = [4, 2, 1, 2];\nG6.registerEdge(\n  'line-dash',\n  {\n    afterDraw(cfg, group) {\n      // 获得该边的第一个图形，这里是边的 path\n      const shape = group.get('children')[0];\n      let index = 0;\n      // 边 path 图形的动画\n      shape.animate(\n        () => {\n          index++;\n          if (index > 9) {\n            index = 0;\n          }\n          const res = {\n            lineDash,\n            lineDashOffset: -index,\n          };\n          // 返回需要修改的参数集，这里修改了 lineDash,lineDashOffset\n          return res;\n        },\n        {\n          repeat: true, // 动画重复\n          duration: 3000, // 一次动画的时长为 3000\n        },\n      );\n    },\n  },\n  'cubic',\n); // 该自定义边继承了内置三阶贝塞尔曲线边 cubic\n",paraId:31,tocIndex:8},{value:"线从无到有的动画效果，同样可以通过计算 ",paraId:32,tocIndex:9},{value:"lineDash",paraId:32,tocIndex:9},{value:" 来实现。",paraId:32,tocIndex:9},{value:"animate",paraId:32,tocIndex:9},{value:" 函数的第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:32,tocIndex:9},{value:"ratio",paraId:32,tocIndex:9},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:32,tocIndex:9},{value:"animateCfg",paraId:33,tocIndex:9},{value:"。",paraId:32,tocIndex:9},{value:"G6.registerEdge(\n  'line-growth',\n  {\n    afterDraw(cfg, group) {\n      const shape = group.get('children')[0];\n      const length = group.getTotalLength();\n      shape.animate(\n        (ratio) => {\n          const startLen = ratio * length;\n          // 计算 lineDash\n          const cfg = {\n            lineDash: [startLen, length - startLen],\n          };\n          return cfg;\n        },\n        {\n          repeat: true, // 是否重复执行\n          duration: 2000, // 一次动画持续时长\n        },\n      );\n    },\n  },\n  'cubic',\n); // 该自定义边继承了内置三阶贝塞尔曲线边 cubic\n",paraId:34,tocIndex:9},{value:"在交互的过程中也可以添加动画。如下图所示，当鼠标移到节点上时，所有与该节点相关联的边都展示虚线运动的动画。",paraId:35,tocIndex:10},{value:"上图完整 demo 即代码参见：",paraId:35,tocIndex:10},{value:"状态切换动画",paraId:35,tocIndex:10},{value:"。",paraId:35,tocIndex:10},{value:"这种动画涉及到了边的 ",paraId:36,tocIndex:10},{value:"状态",paraId:37,tocIndex:10},{value:"。在自定义边时复写 ",paraId:36,tocIndex:10},{value:"setState",paraId:36,tocIndex:10},{value:" 方法，可对边的各种状态进行监听。鼠标移动到节点上，相关边的某个状态被开启，",paraId:36,tocIndex:10},{value:"setState",paraId:36,tocIndex:10},{value:" 方法中监听到后开启动画效果。步骤如下：",paraId:36,tocIndex:10},{value:"自定义边中复写 ",paraId:38,tocIndex:10},{value:"setState",paraId:38,tocIndex:10},{value:" 方法监听该边的状态，以及某状态下的动画效果；",paraId:38,tocIndex:10},{value:"监听中间的节点的 ",paraId:38,tocIndex:10},{value:"mouseenter",paraId:38,tocIndex:10},{value:" 和 ",paraId:38,tocIndex:10},{value:"mouseleave",paraId:38,tocIndex:10},{value:" 事件，触发相关边的状态变化。",paraId:38,tocIndex:10},{value:"下面代码节选自 demo ",paraId:39,tocIndex:10},{value:"状态切换动画",paraId:39,tocIndex:10},{value:"，请注意省略了部分代码，只展示了交互相关以及边动画相关的代码。",paraId:39,tocIndex:10},{value:"animate",paraId:39,tocIndex:10},{value:" 函数的第一个参数是返回每一帧需要变化的参数集的函数，其参数 ",paraId:39,tocIndex:10},{value:"ratio",paraId:39,tocIndex:10},{value:" 是当前正在进行的一次动画的进度，范围 [0, 1]；第二个参数是动画的参数，动画参数的具体配置参见 ",paraId:39,tocIndex:10},{value:"animateCfg",paraId:40,tocIndex:10},{value:"。",paraId:39,tocIndex:10},{value:"// const data = ...\n// const graph = new G6.Graph({...});\n\nconst lineDash = [4, 2, 1, 2];\n\n// 注册名为 'can-running' 的边\nG6.registerEdge(\n  'can-running',\n  {\n    // 复写setState方法\n    setState(name, value, item) {\n      const shape = item.get('keyShape');\n      // 监听 running 状态\n      if (name === 'running') {\n        // running 状态为 true 时\n        if (value) {\n          let index = 0; // 边 path 图形的动画\n          shape.animate(\n            () => {\n              index++;\n              if (index > 9) {\n                index = 0;\n              }\n              const res = {\n                lineDash,\n                lineDashOffset: -index,\n              };\n              // 返回需要修改的参数集，这里修改了 lineDash,lineDashOffset\n              return res;\n            },\n            {\n              repeat: true, // 动画重复\n              duration: 3000, // 一次动画的时长为 3000\n            },\n          );\n        } else {\n          // running 状态为 false 时\n          // 结束动画\n          shape.stopAnimate();\n          // 清空 lineDash\n          shape.attr('lineDash', null);\n        }\n      }\n    },\n  },\n  'cubic-horizontal',\n); // 该自定义边继承了内置横向三阶贝塞尔曲线边 cubic-horizontal\n\n// 监听节点的 mouseenter 事件\ngraph.on('node:mouseenter', (ev) => {\n  // 获得当前鼠标操作的目标节点\n  const node = ev.item;\n  // 获得目标节点的所有相关边\n  const edges = node.getEdges();\n  // 将所有相关边的 running 状态置为 true，此时将会触发自定义节点的 setState 函数\n  edges.forEach((edge) => graph.setItemState(edge, 'running', true));\n});\n\n// 监听节点的 mouseleave 事件\ngraph.on('node:mouseleave', (ev) => {\n  // 获得当前鼠标操作的目标节点\n  const node = ev.item;\n  // 获得目标节点的所有相关边\n  const edges = node.getEdges();\n  // 将所有相关边的 running 状态置为 false，此时将会触发自定义节点的 setState 函数\n  edges.forEach((edge) => graph.setItemState(edge, 'running', false));\n});\n\n// graph.data(data);\n// graph.render();\n",paraId:41,tocIndex:10},{value:"   ",paraId:42,tocIndex:10},{value:"⚠️ 注意:",paraId:42,tocIndex:10},{value:" ",paraId:42,tocIndex:10},{value:"running",paraId:42,tocIndex:10},{value:" 为 ",paraId:42,tocIndex:10},{value:"false",paraId:42,tocIndex:10},{value:" 时，要停止动画，同时把 ",paraId:42,tocIndex:10},{value:"lineDash",paraId:42,tocIndex:10},{value:" 清空。",paraId:42,tocIndex:10},{value:"配置项",paraId:43,tocIndex:11},{value:"类型",paraId:43,tocIndex:11},{value:"默认值",paraId:43,tocIndex:11},{value:"描述",paraId:43,tocIndex:11},{value:"duration",paraId:43,tocIndex:11},{value:"Number",paraId:43,tocIndex:11},{value:"500",paraId:43,tocIndex:11},{value:"一次动画的时长",paraId:43,tocIndex:11},{value:"easing",paraId:43,tocIndex:11},{value:"boolean",paraId:43,tocIndex:11},{value:"'linearEasing'",paraId:43,tocIndex:11},{value:"动画函数，见 ",paraId:43,tocIndex:11},{value:"easing 函数",paraId:44,tocIndex:11},{value:"delay",paraId:43,tocIndex:11},{value:"Number",paraId:43,tocIndex:11},{value:"0",paraId:43,tocIndex:11},{value:"延迟一段时间后执行动画",paraId:43,tocIndex:11},{value:"repeat",paraId:43,tocIndex:11},{value:"boolean",paraId:43,tocIndex:11},{value:"false",paraId:43,tocIndex:11},{value:"是否重复执行动画",paraId:43,tocIndex:11},{value:"callback",paraId:43,tocIndex:11},{value:"Function",paraId:43,tocIndex:11},{value:"undefined",paraId:43,tocIndex:11},{value:"动画执行完时的回调函数",paraId:43,tocIndex:11},{value:"pauseCallback",paraId:43,tocIndex:11},{value:"Function",paraId:43,tocIndex:11},{value:"undefined",paraId:43,tocIndex:11},{value:"动画暂停时（",paraId:43,tocIndex:11},{value:"shape.pause()",paraId:43,tocIndex:11},{value:"）的回调函数",paraId:43,tocIndex:11},{value:"resumeCallback",paraId:43,tocIndex:11},{value:"Function",paraId:43,tocIndex:11},{value:"undefined",paraId:43,tocIndex:11},{value:"动画恢复时（",paraId:43,tocIndex:11},{value:"shape.resume()",paraId:43,tocIndex:11},{value:"）的回调函数",paraId:43,tocIndex:11},{value:"easing 函数是指动画的函数。例如线性插值、先快后慢等。",paraId:45,tocIndex:12},{value:"G6 支持所有 d3.js 中的动画函数。因此，上面代码中 ",paraId:45,tocIndex:12},{value:"animateCfg",paraId:45,tocIndex:12},{value:" 配置中的 String 类型的 ",paraId:45,tocIndex:12},{value:"easing",paraId:45,tocIndex:12},{value:" 可以取值有：",paraId:45,tocIndex:12},{value:"'easeLinear'",paraId:45,tocIndex:12},{value:" ，",paraId:45,tocIndex:12},{value:"'easePolyIn'",paraId:45,tocIndex:12},{value:" ，",paraId:45,tocIndex:12},{value:"'easePolyOut'",paraId:45,tocIndex:12},{value:" ， ",paraId:45,tocIndex:12},{value:"'easePolyInOut'",paraId:45,tocIndex:12},{value:" ，",paraId:45,tocIndex:12},{value:"'easeQuad'",paraId:45,tocIndex:12},{value:" ，",paraId:45,tocIndex:12},{value:"'easeQuadIn'",paraId:45,tocIndex:12},{value:" ，",paraId:45,tocIndex:12},{value:"'easeQuadOut'",paraId:45,tocIndex:12},{value:" ， ",paraId:45,tocIndex:12},{value:"'easeQuadInOut'",paraId:45,tocIndex:12},{value:" 。",paraId:45,tocIndex:12},{value:"更多取值及所有取值含义参见：",paraId:46,tocIndex:12},{value:"d3 Easings",paraId:46,tocIndex:12},{value:"。",paraId:46,tocIndex:12}]},43247:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供描边的",paraId:0},{value:"线性渐变",paraId:0},{value:"和填充的",paraId:0},{value:"环形渐变",paraId:0},{value:"两种形式。",paraId:0},{value:"说明：",paraId:1,tocIndex:1},{value:"l",paraId:1,tocIndex:1},{value:" 表示使用线性渐变，绿色的字体为可变量，由用户自己填写。",paraId:1,tocIndex:1},{value:"在",paraId:2,tocIndex:2},{value:"配置节点或边",paraId:3,tocIndex:2},{value:"的样式时，指定 ",paraId:2,tocIndex:2},{value:"stroke",paraId:2,tocIndex:2},{value:" 属性如下：",paraId:2,tocIndex:2},{value:"// 使用渐变色描边，渐变角度为 0，渐变的起始点颜色 #ffffff，中点的渐变色为 #7ec2f3，结束的渐变色为 #1890ff\n\nstroke: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff'\n",paraId:4,tocIndex:2},{value:"说明：r 表示使用放射状渐变，绿色的字体为可变量，由用户自己填写，开始圆的 x y r 值均为相对值，0 至 1 范围。",paraId:5,tocIndex:4},{value:"在",paraId:6,tocIndex:5},{value:"配置节点或边",paraId:7,tocIndex:5},{value:"的样式时，指定 ",paraId:6,tocIndex:5},{value:"fill",paraId:6,tocIndex:5},{value:" 属性如下：",paraId:6,tocIndex:5},{value:"// 使用渐变色填充，渐变起始圆的圆心坐标为被填充物体的包围盒中心点，半径为(包围盒对角线长度 / 2) 的 0.1 倍，渐变的起始点颜色 #ffffff，中点的渐变色为 #7ec2f3，结束的渐变色为 #1890ff\n\nfill: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff'\n",paraId:8,tocIndex:5}]},68718:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在 G6 3.4.4 以下的版本中，当我们想要给节点或边的 label 添加背景时，需要用户自己使用 ",paraId:0,tocIndex:0},{value:"group.addShape('rect', {})",paraId:0,tocIndex:0},{value:" 来实现，对 G6 不太熟悉的用户来说，处理起来可能比较麻烦，且实现方式不够友好。",paraId:0,tocIndex:0},{value:"在 G6 3.4.5 版本中，我们增加了配置项，用户可以直接通过以下配置为节点或边设置背景。",paraId:1,tocIndex:1},{value:"特别说明：",paraId:2,tocIndex:1},{value:" 该功能是由 GitHub 用户 @zhanba 贡献 ",paraId:2,tocIndex:1},{value:"feat: add label background",paraId:2,tocIndex:1},{value:" 。",paraId:2,tocIndex:1},{value:"const graph = new G6.Graph({\n  // ...\n  defaultNode: {\n    labelCfg: {\n      position: 'left',\n      style: {\n        background: {\n          fill: '#ffffff',\n          stroke: 'green',\n          padding: [3, 2, 3, 2],\n          radius: 2,\n          lineWidth: 3,\n        },\n      },\n    }\n  },\n  defaultEdge: {\n    labelCfg: {\n      autoRotate: true,\n      style: {\n        background: {\n          fill: '#ffffff',\n          stroke: '#000000',\n          padding: [2, 2, 2, 2],\n          radius: 2,\n        },\n      },\n    }\n  }\n})\n",paraId:3,tocIndex:1}]},46229:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 支持用特定的纹理填充图形。G6 支持的纹理内容可以直接是",paraId:0},{value:"图片",paraId:0},{value:"或者 ",paraId:0},{value:"Data URL",paraId:0},{value:"。",paraId:0},{value:"说明：",paraId:1},{value:"p",paraId:1},{value:" 表示使用纹理；绿色的字体为可变量，您可以修改它们以满足您的需求；",paraId:1},{value:"a",paraId:1},{value:" 表示纹理的重复方式，可选值如下：",paraId:1},{value:"a",paraId:2},{value:": 该模式在水平和垂直方向重复；",paraId:2},{value:"x",paraId:2},{value:": 该模式只在水平方向重复；",paraId:2},{value:"y",paraId:2},{value:": 该模式只在垂直方向重复；",paraId:2},{value:"n",paraId:2},{value:": 该模式只显示一次（不重复）。",paraId:2},{value:"在",paraId:3},{value:"配置节点或边",paraId:4},{value:"的样式时，指定 ",paraId:3},{value:"fill",paraId:3},{value:" 属性如下：",paraId:3},{value:"shape.attr('fill', 'p(a)https://gw.alipay.com/cube.png');\n",paraId:5}]},36547:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在 G6 中，可以通过以下三种方式更新文本样式。",paraId:0},{value:"实例化 Graph 时，可以通过在 ",paraId:1,tocIndex:0},{value:"defaultNode",paraId:1,tocIndex:0},{value:" 或 ",paraId:1,tocIndex:0},{value:"defaultEdge",paraId:1,tocIndex:0},{value:" 中指定 ",paraId:1,tocIndex:0},{value:"labelCfg",paraId:1,tocIndex:0},{value:" 属性修改文本的样式。这种方式指定了全局的文本样式。",paraId:1,tocIndex:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 800,\n  defaultNode: {\n    type: 'node',\n    labelCfg: {\n      style: {\n        fill: '#fff',\n        fontSize: 14,\n      },\n    },\n  },\n  defaultEdge: {\n    type: 'line-with-arrow',\n    labelCfg: {\n      style: {\n        fill: '#fff',\n        fontSize: 14,\n      },\n    },\n  },\n});\n",paraId:2,tocIndex:0},{value:"在数据中为每个节点和边指定 ",paraId:3,tocIndex:1},{value:"labelCfg",paraId:3,tocIndex:1},{value:" 可以达到为不同节点或边定制不同文本样式的目的。",paraId:3,tocIndex:1},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n      labelCfg: {\n        style: {\n          fill: '#fff',\n          fontSize: 12,\n        },\n      },\n    },\n  ],\n};\n",paraId:4,tocIndex:1},{value:"使用 ",paraId:5,tocIndex:2},{value:"update/updateItem",paraId:5,tocIndex:2},{value:" 更新节点或边时，也可以更新节点或边上的文本。该方法用于动态更新文本样式。",paraId:5,tocIndex:2},{value:"graph.updateItem(node, {\n  // 节点的样式\n  style: {\n    stroke: 'blue',\n  },\n  // 节点上文本的样式\n  labelCfg: {\n    style: {\n      fill: '#fff',\n      fontSize: 12,\n    },\n  },\n});\n",paraId:6,tocIndex:2},{value:"想知道文本都可以设置哪些属性，请参考 ",paraId:7,tocIndex:2},{value:"节点上的文本属性",paraId:8,tocIndex:2},{value:" 或 ",paraId:7,tocIndex:2},{value:"边上的文本属性",paraId:9,tocIndex:2},{value:"。",paraId:7,tocIndex:2}]},43211:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了圆  Circle Combo，其默认样式如下。标签文本位于圆形上方。 ",paraId:0},{value:"Demo",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置 Combo",paraId:2,tocIndex:0},{value:" 一节所示，配置 Combo 的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.combo(comboFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.combo(comboFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"parentId",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个 Combo 数据中外，其余的 ",paraId:4,tocIndex:0},{value:"Combo 的通用属性",paraId:5,tocIndex:0},{value:" 以及各个 Combo 类型的特有属性（见内置 Combo 类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"⚠️ 注意:",paraId:6,tocIndex:0},{value:" 使用 Combo 时，必须在示例化图时配置 ",paraId:6,tocIndex:0},{value:"groupByTypes",paraId:6,tocIndex:0},{value:" 设置为 ",paraId:6,tocIndex:0},{value:"false",paraId:6,tocIndex:0},{value:"，图中元素的视觉层级才能合理。",paraId:6,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:7,tocIndex:1},{value:"defaultCombo",paraId:7,tocIndex:1},{value:" 指定 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 为 ",paraId:7,tocIndex:1},{value:"'circle'",paraId:7,tocIndex:1},{value:"，即可使用 ",paraId:7,tocIndex:1},{value:"circle",paraId:7,tocIndex:1},{value:" Combo。",paraId:7,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    type: 'circle', // Combo 类型\n    // ... 其他配置\n  },\n});\n",paraId:8,tocIndex:1},{value:"如果需要使不同 Combo 有不同的配置，可以将配置写入到 Combo 数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:9,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [\n    ... // 边\n  ],\n  combos: [\n  {\n\t  id: 'combo1',\n    type: 'circle', // Combo 类型\n    ... // 其他配置\n  },\n    ... // 其他 Combo\n  ],\n}\n",paraId:10,tocIndex:2},{value:"Circle Combo 支持 ",paraId:11,tocIndex:3},{value:"Combo 通用配置",paraId:12,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:11,tocIndex:3},{value:"名称",paraId:13,tocIndex:3},{value:"含义",paraId:13,tocIndex:3},{value:"类型",paraId:13,tocIndex:3},{value:"备注",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:"圆的最小直径（非固定直径），渲染大小由子元素的大小与分布决定",paraId:13,tocIndex:3},{value:"number / number[]",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:" 为数组时，取第一个值",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:"固定该 Combo 的直径",paraId:13,tocIndex:3},{value:"number",paraId:13,tocIndex:3},{value:"不指定时 Combo 大小由内部元素的分布和大小来决定。若指定了 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 而没有指定 ",paraId:13,tocIndex:3},{value:"fixCollapseSize",paraId:13,tocIndex:3},{value:"，则即使该 Combo 在收起状态下仍然保持 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 指定的尺寸",paraId:13,tocIndex:3},{value:"fixCollapseSize",paraId:13,tocIndex:3},{value:"固定该 Combo 收起时的直径",paraId:13,tocIndex:3},{value:"number",paraId:13,tocIndex:3},{value:"不指定时，若未指定 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 则由 ",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:" 决定收起时的直径，否则统一为 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 直径 ｜",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:"circle 默认样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"参见下文 ",paraId:13,tocIndex:3},{value:"样式属性  style",paraId:14,tocIndex:3},{value:" 内容",paraId:13,tocIndex:3},{value:"label",paraId:13,tocIndex:3},{value:"标签文本内容",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"labelCfg",paraId:13,tocIndex:3},{value:"标签文本配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"参见下文 ",paraId:13,tocIndex:3},{value:"标签文本配置 labelCfg",paraId:15,tocIndex:3},{value:"stateStyles",paraId:13,tocIndex:3},{value:"各状态下的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"详见",paraId:13,tocIndex:3},{value:"配置状态样式",paraId:16,tocIndex:3},{value:"Object 类型。支持 ",paraId:17,tocIndex:4},{value:"Combo 通用样式",paraId:18,tocIndex:4},{value:"。通过 ",paraId:17,tocIndex:4},{value:"style",paraId:17,tocIndex:4},{value:" 配置来修改 Combo 的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:17,tocIndex:4},{value:"style",paraId:17,tocIndex:4},{value:"，使之达到如下图效果。",paraId:17,tocIndex:4},{value:" ",paraId:17,tocIndex:4},{value:"const data = {\n  combos: [\n    {\n      label: 'combo_circle',\n      type: 'circle',\n      label: 'Circle',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // type: 'circle',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:19,tocIndex:4},{value:"Object 类型。通过 ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:20,tocIndex:5},{value:"Combo 通用标签配置",paraId:21,tocIndex:5},{value:"。基于上面 ",paraId:20,tocIndex:5},{value:"样式属性 style",paraId:22,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:20,tocIndex:5},{value:"defaultCombo",paraId:20,tocIndex:5},{value:" 中增加了  ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:20,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // ... Combo 其他属性\n    labelCfg: {\n      position: 'left',\n      refX: 5,\n      style: {\n        fill: '#bae637',\n        fontSize: 15,\n        // ... 其他文本样式的配置\n      },\n    },\n  },\n});\n// ...\n",paraId:23,tocIndex:5}]},82701:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了矩形 Rect Combo，其默认样式如下。标签文本位于矩形内部左上方。",paraId:0},{value:"Demo",paraId:0},{value:" ",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置 Combo",paraId:2,tocIndex:0},{value:" 一节所示，配置 Combo 的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.combo(comboFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.combo(comboFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"parentId",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个 Combo 数据中外，其余的 ",paraId:4,tocIndex:0},{value:"Combo 的通用属性",paraId:5,tocIndex:0},{value:" 以及各个 Combo 类型的特有属性（见内置 Combo 类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"⚠️ 注意:",paraId:6,tocIndex:0},{value:" 使用 Combo 时，必须在示例化图时配置 ",paraId:6,tocIndex:0},{value:"groupByTypes",paraId:6,tocIndex:0},{value:" 设置为 ",paraId:6,tocIndex:0},{value:"false",paraId:6,tocIndex:0},{value:"，图中元素的视觉层级才能合理。",paraId:6,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:7,tocIndex:1},{value:"defaultCombo",paraId:7,tocIndex:1},{value:" 指定 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 为 ",paraId:7,tocIndex:1},{value:"'rect'",paraId:7,tocIndex:1},{value:"，即可使用 ",paraId:7,tocIndex:1},{value:"rect",paraId:7,tocIndex:1},{value:" Combo。",paraId:7,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    type: 'rect', // Combo 类型\n    // ... 其他配置\n  },\n});\n",paraId:8,tocIndex:1},{value:"如果需要使不同 Combo 有不同的配置，可以将配置写入到 Combo 数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:9,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [\n    ... // 边\n  ],\n  combos: [\n  {\n\t  id: 'combo1',\n    type: 'rect', // Combo 类型\n    ... // 其他配置\n  },\n    ... // 其他 Combo\n  ],\n}\n",paraId:10,tocIndex:2},{value:"Rect Combo 支持 ",paraId:11,tocIndex:3},{value:"Combo 通用配置",paraId:12,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:11,tocIndex:3},{value:"名称",paraId:13,tocIndex:3},{value:"含义",paraId:13,tocIndex:3},{value:"类型",paraId:13,tocIndex:3},{value:"备注",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:"矩形的最小长与宽（非固定大小）",paraId:13,tocIndex:3},{value:"number / number[]",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:" 为 Number 时，长宽相等",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:"固定该 Combo 的长与宽",paraId:13,tocIndex:3},{value:"number",paraId:13,tocIndex:3},{value:"不指定时 Combo 大小由内部元素的分布和大小来决定。若指定了 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 而没有指定 ",paraId:13,tocIndex:3},{value:"fixCollapseSize",paraId:13,tocIndex:3},{value:"，则即使该 Combo 在收起状态下仍然保持 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 指定的长与宽",paraId:13,tocIndex:3},{value:"fixCollapseSize",paraId:13,tocIndex:3},{value:"固定该 Combo 收起时的直径",paraId:13,tocIndex:3},{value:"number",paraId:13,tocIndex:3},{value:"不指定时，若未指定 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 则由 ",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:" 决定收起时的长与宽，否则统一为 ",paraId:13,tocIndex:3},{value:"fixSize",paraId:13,tocIndex:3},{value:" 长与宽 ｜",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:"rect 图形的默认样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"参见下文 ",paraId:13,tocIndex:3},{value:"样式属性  style",paraId:14,tocIndex:3},{value:" 内容",paraId:13,tocIndex:3},{value:"label",paraId:13,tocIndex:3},{value:"标签文本内容",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"labelCfg",paraId:13,tocIndex:3},{value:"标签文本配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"参见下文 ",paraId:13,tocIndex:3},{value:"标签文本配置 labelCfg",paraId:15,tocIndex:3},{value:"stateStyles",paraId:13,tocIndex:3},{value:"各状态下的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"详见",paraId:13,tocIndex:3},{value:"配置状态样式",paraId:16,tocIndex:3},{value:"Object 类型。支持 ",paraId:17,tocIndex:4},{value:"Combo 通用样式",paraId:18,tocIndex:4},{value:"。通过 ",paraId:17,tocIndex:4},{value:"style",paraId:17,tocIndex:4},{value:" 配置来修改 Combo 的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:17,tocIndex:4},{value:"style",paraId:17,tocIndex:4},{value:"，使之达到如下图效果。",paraId:17,tocIndex:4},{value:" ",paraId:17,tocIndex:4},{value:"const data = {\n  combos: [\n    {\n      label: 'combo_rect',\n      type: 'rect',\n      label: 'Rect',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // type: 'rect',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:19,tocIndex:4},{value:"Object 类型。通过 ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:20,tocIndex:5},{value:"Combo 通用标签配置",paraId:21,tocIndex:5},{value:"。",paraId:20,tocIndex:5},{value:"v4.7.17 及后续版本支持",paraId:20,tocIndex:5},{value:" 其中，rect 类型的 Combo 的 ",paraId:20,tocIndex:5},{value:"labelCfg.position",paraId:20,tocIndex:5},{value:" 额外支持 ",paraId:20,tocIndex:5},{value:"'top-center'",paraId:20,tocIndex:5},{value:"，表示将标签文本绘制在矩形 Combo 的上方中央。基于上面 ",paraId:20,tocIndex:5},{value:"样式属性 style",paraId:22,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:20,tocIndex:5},{value:"defaultCombo",paraId:20,tocIndex:5},{value:" 中增加了  ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:20,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // ... Combo 其他属性\n    labelCfg: {\n      position: 'bottom',\n      refX: -12,\n      style: {\n        fill: '#bae637',\n        fontSize: 15,\n        // ... 其他文本样式的配置\n      },\n    },\n  },\n});\n// ...\n",paraId:23,tocIndex:5}]},99006:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了一系列",paraId:0},{value:"内置 Combo",paraId:1},{value:"，包括 ",paraId:0},{value:"circle",paraId:2},{value:"、",paraId:0},{value:"rect",paraId:3},{value:"。若内置 Combo 无法满足需求，用户还可以通过 ",paraId:0},{value:"G6.registerCombo ('comboName', options, expendedComboName)",paraId:0},{value:" 进行",paraId:0},{value:"自定义扩展内置的 Combo",paraId:0},{value:"，方便用户开发更加定制化的 Combo，包括含有复杂图形的 Combo、复杂交互的 Combo、带有动画的 Combo 等。",paraId:0},{value:"在本章中，我们通过两个案例，讲解通过自定义扩展现有 Combo。",paraId:4},{value:"通过 ",paraId:5,tocIndex:0},{value:"图形 Shape",paraId:6,tocIndex:0},{value:" 章节的学习，我们应该已经知道了自定义 Combo 时需要满足以下两点：",paraId:5,tocIndex:0},{value:"控制 Combo 的生命周期；",paraId:7,tocIndex:0},{value:"解析用户输入的数据，在图形上展示。",paraId:7,tocIndex:0},{value:"在自定义扩展内置 'circle' 或 'rect' Combo 时，API 中可以复写的方法如下：",paraId:8,tocIndex:0},{value:"G6.registerCombo(\n  'comboName',\n  {\n    /**\n     * 绘制 Combo 中的图形。不需要为默认的 label 增加图形，父类方法会自动增加 label\n     * @param  {Object} cfg Combo 的配置项\n     * @param  {G.Group} group 图形分组，Combo 中的图形对象的容器\n     * @return {G.Shape} 返回一个绘制的图形作为 keyShape，通过 combo.get('keyShape') 可以获取。\n     * 关于 keyShape 可参考文档 核心概念-节点/边/Combo-图形 Shape 与 keyShape\n     */\n    drawShape(cfg, group) {},\n    /**\n     * 绘制后的附加操作，默认没有任何操作\n     * @param  {Object} cfg Combo 的配置项\n     * @param  {G.Group} group 图形分组，Combo 中的图形对象的容器\n     */\n    afterDraw(cfg, group) {},\n    /**\n     * 更新节点后的操作，新增的图形需要在这里控制其更新逻辑\n     * @override\n     * @param  {Object} cfg 节点的配置项\n     * @param  {Combo} combo 节点\n     */\n    afterUpdate(cfg, combo) {},\n    /**\n     * 响应 Combo 的状态变化。\n     * 在需要使用动画来响应状态变化时需要被复写，其他样式的响应参见下文提及的 [配置状态样式] 文档\n     * @param  {String} name 状态名称\n     * @param  {Object} value 状态值\n     * @param  {Combo} combo 节点\n     */\n    setState(name, value, combo) {},\n  },\n  // 被继承的 Combo 类型名，可选：'circle' 或 'rect'\n  extendedComboName,\n);\n",paraId:9,tocIndex:0},{value:"因 Combo 更新逻辑的特殊性（需要根据其子元素信息自动更新自身位置和大小），自定义 Combo 时，与自定义节点/边有所不同：",paraId:10,tocIndex:1},{value:"不建议“从无到有”地自定义 Combo，",paraId:11,tocIndex:1},{value:"推荐使用继承的方式",paraId:11,tocIndex:1},{value:"扩展内置的 'circle' 或 'rect' Combo；",paraId:11,tocIndex:1},{value:"在 ",paraId:11,tocIndex:1},{value:"drawShape",paraId:11,tocIndex:1},{value:" 方法中不需要为 label 增加图形，父类方法将会自动增加默认的 label，可以通过配置的方式指定 label 的位置和样式；",paraId:11,tocIndex:1},{value:"与自定义节点/边不同，这里",paraId:11,tocIndex:1},{value:"不建议复写 ",paraId:11,tocIndex:1},{value:"update",paraId:11,tocIndex:1},{value:" 和 ",paraId:11,tocIndex:1},{value:"draw",paraId:11,tocIndex:1},{value:" 方法",paraId:11,tocIndex:1},{value:"，否则会使 Combo 根据子元素更新的逻辑异常；",paraId:11,tocIndex:1},{value:"复写的 ",paraId:11,tocIndex:1},{value:"drawShape",paraId:11,tocIndex:1},{value:" 方法返回值与推荐继承内置的 'circle'、'rect' 的 keyShape 一致。即继承 'circle' 时，",paraId:11,tocIndex:1},{value:"drawShape",paraId:11,tocIndex:1},{value:" 方法应该返回一个 circle 图形；继承 'rect' 时，",paraId:11,tocIndex:1},{value:"drawShape",paraId:11,tocIndex:1},{value:" 方法应该返回一个 rect 图形；",paraId:11,tocIndex:1},{value:"除 keyShape 外，自定义新增的图形需要",paraId:11,tocIndex:1},{value:"在 ",paraId:11,tocIndex:1},{value:"afterUpdate",paraId:11,tocIndex:1},{value:" 中定义其位置更新逻辑",paraId:11,tocIndex:1},{value:"；",paraId:11,tocIndex:1},{value:"setState",paraId:11,tocIndex:1},{value:" 只有在需要使用动画来响应状态变化时需要被复写，一般的样式响应状态变化可以通过 ",paraId:11,tocIndex:1},{value:"配置状态样式",paraId:12,tocIndex:1},{value:" 实现。",paraId:11,tocIndex:1},{value:"Demo",paraId:13,tocIndex:2},{value:"。",paraId:13,tocIndex:2},{value:"首先，我们需要了解内置的 rect 类型的 Combo 内部的位置逻辑：",paraId:14,tocIndex:3},{value:"下图灰色虚线框内部是子元素的分布范围，其宽高分别为 innerWidth 和 innerHeight；",paraId:15,tocIndex:3},{value:"灰色虚线框上下左右可以配置 ",paraId:15,tocIndex:3},{value:"padding",paraId:15,tocIndex:3},{value:" 值，该 Combo 的 keyShape 真实绘制大小 width 与 height 是 innerWidth 和 innerHeight 加上了 padding 后的值；",paraId:15,tocIndex:3},{value:"一个 Combo 内部的图形以自身坐标系为参考，原点 (0, 0) 在灰色虚线框正中心；",paraId:15,tocIndex:3},{value:"padding 值的上与下、左与右可能不相等，这就导致了该矩形的左上角坐标不是简单的 (-width / 2, -height / 2)，而是通过如图标注的计算获得；",paraId:15,tocIndex:3},{value:"rect 类型 Combo 的 label 默认位于矩形内部左上角，上边距为 refY，左边距为 refX。label 的位置（",paraId:15,tocIndex:3},{value:"position",paraId:15,tocIndex:3},{value:"）、",paraId:15,tocIndex:3},{value:"refX",paraId:15,tocIndex:3},{value:"、",paraId:15,tocIndex:3},{value:"refY",paraId:15,tocIndex:3},{value:" 可以在使用该类型 Combo 时配置。",paraId:15,tocIndex:3},{value:"Rect Combo 位置说明图",paraId:16,tocIndex:3},{value:"现在，我们自己实现一个如下图所示的 Combo 类型（下图展示空 Combo）：",paraId:17,tocIndex:4},{value:"根据上述 ",paraId:18,tocIndex:4},{value:"内置 Rect Combo 位置逻辑详解",paraId:19,tocIndex:4},{value:"，在扩展 rect 类型 Combo 时需要注意复写方法中 ",paraId:18,tocIndex:4},{value:"x",paraId:18,tocIndex:4},{value:"、",paraId:18,tocIndex:4},{value:"y",paraId:18,tocIndex:4},{value:"、",paraId:18,tocIndex:4},{value:"width",paraId:18,tocIndex:4},{value:"、",paraId:18,tocIndex:4},{value:"height",paraId:18,tocIndex:4},{value:" 的设置",paraId:18,tocIndex:4},{value:"G6.registerCombo(\n  'cRect',\n  {\n    drawShape: function drawShape(cfg, group) {\n      const self = this;\n      // 获取配置中的 Combo 内边距\n      cfg.padding = cfg.padding || [50, 20, 20, 20];\n      // 获取样式配置，style.width 与 style.height 对应 rect Combo 位置说明图中的 width 与 height\n      const style = self.getShapeStyle(cfg);\n      // 绘制一个矩形作为 keyShape，与 'rect' Combo 的 keyShape 一致\n      const rect = group.addShape('rect', {\n        attrs: {\n          ...style,\n          x: -style.height / 2 - padding[0],\n          y:  -style.width / 2 - padding[3],\n          width: style.width,\n          height: style.height,\n        },\n        draggable: true,\n        name: 'combo-keyShape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n      // 增加右侧圆\n      group.addShape('circle', {\n        attrs: {\n          ...style,\n          fill: '#fff',\n          opacity: 1,\n          // cfg.style.width 与 cfg.style.heigth 对应 rect Combo 位置说明图中的 innerWdth 与 innerHeight\n          x: cfg.style.width / 2 + cfg.padding[1],\n          y: (cfg.padding[2] - cfg.padding[0]) / 2,\n          r: 5,\n        },\n        draggable: true,\n        name: 'combo-circle-shape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n      return rect;\n    },\n    // 定义新增的右侧圆的位置更新逻辑\n    afterUpdate: function afterUpdate(cfg, combo) {\n      const group = combo.get('group');\n      // 在该 Combo 的图形分组根据 name 找到右侧圆图形\n      const circle = group.find((ele) => ele.get('name') === 'combo-circle-shape');\n      // 更新右侧圆位置\n      circle.attr({\n        // cfg.style.width 与 cfg.style.heigth 对应 rect Combo 位置说明图中的 innerWdth 与 innerHeight\n        x: cfg.style.width / 2 + cfg.padding[1],\n        y: (cfg.padding[2] - cfg.padding[0]) / 2,\n      });\n    },\n  },\n  'rect',\n);\n",paraId:20,tocIndex:4},{value:"值得注意的是，G6 3.3 需要用户为自定义节点中的图形设置 ",paraId:21,tocIndex:4},{value:"name",paraId:21,tocIndex:4},{value:" 和 ",paraId:21,tocIndex:4},{value:"draggable",paraId:21,tocIndex:4},{value:"。",paraId:21,tocIndex:4},{value:"其中，",paraId:21,tocIndex:4},{value:"name",paraId:21,tocIndex:4},{value:" 的值必须在同一元素类型内唯一",paraId:21,tocIndex:4},{value:"。",paraId:21,tocIndex:4},{value:"draggable",paraId:21,tocIndex:4},{value:" 为 ",paraId:21,tocIndex:4},{value:"true",paraId:21,tocIndex:4},{value:" 是表示允许该图形响应鼠标的拖拽事件，只有 ",paraId:21,tocIndex:4},{value:"draggable: true",paraId:21,tocIndex:4},{value:" 时，图上的交互行为 ",paraId:21,tocIndex:4},{value:"'drag-combo'",paraId:21,tocIndex:4},{value:" 才能在该图形上生效。若上面代码仅在 keyShape 上设置了 ",paraId:21,tocIndex:4},{value:"draggable: true",paraId:21,tocIndex:4},{value:"，而右侧圆图形上没有设置，则鼠标拖拽只能在 keyShape 上响应。",paraId:21,tocIndex:4},{value:"现在，我们使用下面的代码使用 ",paraId:22,tocIndex:5},{value:"'cRect'",paraId:22,tocIndex:5},{value:" 类型的 Combo：",paraId:22,tocIndex:5},{value:"const data = {\n  nodes: [\n    { id: 'node1', x: 250, y: 100, comboId: 'combo1' },\n    { id: 'node2', x: 300, y: 100, comboId: 'combo1' },\n  ],\n  combos: [\n    { id: 'combo1', label: 'Combo 1', parentId: 'combo2' },\n    { id: 'combo2', label: 'Combo 2' },\n    { id: 'combo3', label: 'Combo 3' },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 800,\n  // 全局 Combo 配置\n  defaultCombo: {\n    // 指定 Combo 类型，也可以将 type 写到 combo 数据中\n    type: 'cRect',\n    // ... 此处可配置默认 Combo 的其他样式\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:23,tocIndex:5},{value:"Demo",paraId:24,tocIndex:6},{value:"。",paraId:24,tocIndex:6},{value:"如下面 Circle Combo 位置说明图所示，circle 类型的 Combo 内部的位置逻辑比 rect 类型简单，其 (x, y) 为圆心，",paraId:25,tocIndex:7},{value:"padding",paraId:25,tocIndex:7},{value:" 为一个数值：",paraId:25,tocIndex:7},{value:"下图灰色虚线圈内部是子元素的分布范围，其半径为 innerR；",paraId:26,tocIndex:7},{value:"与 rect 不同的是，灰色虚线圈的 ",paraId:26,tocIndex:7},{value:"padding",paraId:26,tocIndex:7},{value:" 是一个数值，即灰色虚线圈外围的 padding 是均匀的，该 Combo 的 keyShape 真实绘制半径 R = innerR + padding；",paraId:26,tocIndex:7},{value:"一个 Combo 内部的图形以自身坐标系为参考，原点 (0, 0) 在灰色虚线框正中心（由于 padding 是均匀的，所以原点也在 keyShape 正中心）；",paraId:26,tocIndex:7},{value:"circle 图形的 x 与 y 为其圆心 (0, 0)；",paraId:26,tocIndex:7},{value:"circle 类型 Combo 的 label 默认位于圆形外部正上方，距离圆形上边缘 refY。label 的位置（",paraId:26,tocIndex:7},{value:"position",paraId:26,tocIndex:7},{value:"）、",paraId:26,tocIndex:7},{value:"refX",paraId:26,tocIndex:7},{value:"、",paraId:26,tocIndex:7},{value:"refY",paraId:26,tocIndex:7},{value:" 可以在使用该类型 Combo 时配置。",paraId:26,tocIndex:7},{value:"Circle Combo 位置说明图",paraId:27,tocIndex:7},{value:"现在，我们自己实现一个如下图所示的 Combo 类型（下图展示空 Combo）：",paraId:28,tocIndex:8},{value:"// 定义下面需要使用的 symbol\nconst collapseIcon = (x, y, r) => {\n  return [\n    ['M', x - r, y],\n    ['a', r, r, 0, 1, 0, r * 2, 0],\n    ['a', r, r, 0, 1, 0, -r * 2, 0],\n    ['M', x - r + 4, y],\n    ['L', x - r + 2 * r - 4, y],\n  ];\n};\nconst expandIcon = (x, y, r) => {\n  return [\n    ['M', x - r, y],\n    ['a', r, r, 0, 1, 0, r * 2, 0],\n    ['a', r, r, 0, 1, 0, -r * 2, 0],\n    ['M', x - r + 4, y],\n    ['L', x - r + 2 * r - 4, y],\n    ['M', x - r + r, y - r + 4],\n    ['L', x, y + r - 4],\n  ];\n};\n\nG6.registerCombo(\n  'cCircle',\n  {\n    drawShape: function draw(cfg, group) {\n      const self = this;\n      // 获取样式配置，style.r 是加上了 padding 的半径\n      // 对应 Circle Combo 位置说明图中的 R\n      const style = self.getShapeStyle(cfg);\n      // 绘制一个 circle 作为 keyShape，与 'circle' Combo 的 keyShape 一致\n      const circle = group.addShape('circle', {\n        attrs: {\n          ...style,\n          x: 0,\n          y: 0,\n          r: style.r,\n        },\n        draggable: true,\n        name: 'combo-keyShape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n      // 增加下方 marker\n      const marker = group.addShape('marker', {\n        attrs: {\n          ...style,\n          fill: '#fff',\n          opacity: 1,\n          x: 0,\n          y: style.r,\n          r: 10,\n          symbol: collapseIcon,\n        },\n        draggable: true,\n        name: 'combo-marker-shape',// 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n\n      return circle;\n    },\n    // 定义新增的下方 marker 的位置更新逻辑\n    afterUpdate: function afterUpdate(cfg, combo) {\n      const self = this;\n      // 获取样式配置，style.r 是加上了 padding 的半径\n      // 对应 Circle Combo 位置说明图中的 R    const style = self.getShapeStyle(cfg);\n      const group = combo.get('group');\n      // 在该 Combo 的图形分组根据 name 找到下方 marker\n      const marker = group.find((ele) => ele.get('name') === 'combo-marker-shape');\n      // 更新 marker\n      marker.attr({\n        x: 0,\n        y: style.r,\n        // 数据中的 collapsed 代表该 Combo 是否是收缩状态，根据该字段更新 symbol\n        symbol: cfg.collapsed ? expandIcon : collapseIcon,\n      });\n    },\n  },\n  'circle',\n);\n",paraId:29,tocIndex:8},{value:"值得注意的是，G6 3.3 需要用户为自定义节点中的图形设置 ",paraId:30,tocIndex:8},{value:"name",paraId:30,tocIndex:8},{value:" 和 ",paraId:30,tocIndex:8},{value:"draggable",paraId:30,tocIndex:8},{value:"。",paraId:30,tocIndex:8},{value:"其中，",paraId:30,tocIndex:8},{value:"name",paraId:30,tocIndex:8},{value:" 的值必须在同一元素类型内唯一",paraId:30,tocIndex:8},{value:"。",paraId:30,tocIndex:8},{value:"draggable",paraId:30,tocIndex:8},{value:" 为 ",paraId:30,tocIndex:8},{value:"true",paraId:30,tocIndex:8},{value:" 是表示允许该图形响应鼠标的拖拽事件，只有 ",paraId:30,tocIndex:8},{value:"draggable: true",paraId:30,tocIndex:8},{value:" 时，图上的交互行为 ",paraId:30,tocIndex:8},{value:"'drag-combo'",paraId:30,tocIndex:8},{value:" 才能在该图形上生效。若上面代码仅在 keyShape 上设置了 ",paraId:30,tocIndex:8},{value:"draggable: true",paraId:30,tocIndex:8},{value:"，而右侧圆图形上没有设置，则鼠标拖拽只能在 keyShape 上响应。",paraId:30,tocIndex:8},{value:"现在，我们使用下面的代码使用 ",paraId:31,tocIndex:9},{value:"'cCircle'",paraId:31,tocIndex:9},{value:" 类型的 Combo：",paraId:31,tocIndex:9},{value:"const data = {\n  nodes: [\n    { id: 'node1', x: 250, y: 100, comboId: 'combo1' },\n    { id: 'node2', x: 300, y: 100, comboId: 'combo1' },\n  ],\n  combos: [\n    { id: 'combo1', label: 'Combo 1', parentId: 'combo2' },\n    { id: 'combo2', label: 'Combo 2' },\n    { id: 'combo3', label: 'Combo 3' },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 800,\n  // 全局 Combo 配置\n  defaultCombo: {\n    // 指定 Combo 类型，也可以将 type 写到 combo 数据中\n    type: 'cCircle',\n    labelCfg: {\n      refY: 2,\n    },\n    // ... 此处可配置默认 Combo 的其他样式\n  },\n  modes: {\n    default: [\n      // 配置展开/收缩 Combo 交互，双击 Combo 可以触发\n      // 将会修改响应 Combo 数据中的 collapsed 字段，从而标识该 Combo 是否处于收缩状态\n      'collapse-expand-combo',\n    ],\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:32,tocIndex:9},{value:"在上面代码中，实例化图时为图配置了 ",paraId:33,tocIndex:10},{value:"'collapse-expand-combo'",paraId:33,tocIndex:10},{value:" 交互，即双击 Combo 可以展开和收起。若我们希望在单击 Combo 下方的 marker 时，展开/收起 Combo，则可以去掉 ",paraId:33,tocIndex:10},{value:"'collapse-expand-combo'",paraId:33,tocIndex:10},{value:" 配置，并添加如下监听代码：",paraId:33,tocIndex:10},{value:"// collapse/expand when click the marker\ngraph.on('combo:click', (e) => {\n  if (e.target.get('name') === 'combo-marker-shape') {\n    // Collapse or expand the combo\n    graph.collapseExpandCombo(e.item);\n\n    if (graph.get('layout')) graph.layout();\n    // If there is a layout configured on the graph, relayout\n    else graph.refreshPositions(); // Refresh positions for items otherwise\n  }\n});\n",paraId:34,tocIndex:10}]},77986:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"V3.5 后支持的全新节点分组 Combo 机制。",paraId:0},{value:"原节点分组",paraId:1},{value:"即将废除。",paraId:0},{value:"对于熟悉图可视化类库的用户来说，节点分组是非常实用的一个功能。此前，G6 已经存在一个节点分组 Node Group 功能，但它的机制无法支持一些较复杂的功能，例如：带有节点分组的图布局、自定义 Combo、嵌套节点分组的均匀 padding、节点与分组的边、分组与分组的边、空的节点分组等。V3.5 推出了全新的节点分组 Combo 机制，能够支持所有常用功能，参考 ",paraId:2},{value:"Demo",paraId:2},{value:"。 ",paraId:2},{value:"G6 的内置 Combo 包括 circle 和 rect 两种类型，分别如下图所示。",paraId:3},{value:" ",paraId:3},{value:"本文将概述 G6 中的 Combo 的数据结构、各个内置 Combo 类型、内置 Combo 的通用属性、配置方法。各类型 Combo 详细配置项及配置方法见本目录下相应文档。",paraId:4},{value:"⚠️ 注意:",paraId:5},{value:" 使用 Combo 时，必须在示例化图时配置 ",paraId:5},{value:"groupByTypes",paraId:5},{value:" 设置为 ",paraId:5},{value:"false",paraId:5},{value:"，图中元素的视觉层级才能合理。",paraId:5},{value:"为保持 G6 源数据数据结构的稳定性，我们在原来的数据结构上做了如下修改：",paraId:6,tocIndex:0},{value:"新增 ",paraId:7,tocIndex:0},{value:"combos",paraId:7,tocIndex:0},{value:" 数组，用于定义图上所有的 Combo 及其配置。",paraId:7,tocIndex:0},{value:"combos",paraId:7,tocIndex:0},{value:" 数组中的一个数据项有如下属性：",paraId:7,tocIndex:0},{value:"属性名",paraId:8,tocIndex:0},{value:"类型",paraId:8,tocIndex:0},{value:"是否必须",paraId:8,tocIndex:0},{value:"示例",paraId:8,tocIndex:0},{value:"解释",paraId:8,tocIndex:0},{value:"id",paraId:8,tocIndex:0},{value:"string",paraId:8,tocIndex:0},{value:"true",paraId:8,tocIndex:0},{value:"'comboA'",paraId:8,tocIndex:0},{value:"一个 Combo 的唯一标识，",paraId:8,tocIndex:0},{value:"必须是 string 类型，必须唯一",paraId:8,tocIndex:0},{value:"parentId",paraId:8,tocIndex:0},{value:"string",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"'comboB'",paraId:8,tocIndex:0},{value:"该 Combo 的父 Combo 的 ID",paraId:8,tocIndex:0},{value:"padding",paraId:8,tocIndex:0},{value:"Number / Number[]",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"10 或 [ 10, 20, 10, 20 ]",paraId:8,tocIndex:0},{value:"该 Combo 内边距",paraId:8,tocIndex:0},{value:"size",paraId:8,tocIndex:0},{value:"number / number[]",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"10 或 [ 10, 20 ]",paraId:8,tocIndex:0},{value:"该 Combo 的最小尺寸（非固定尺寸），默认 'circle' 类型 Combo 的 size 为 20，'rect' 类型的为 [20, 5]",paraId:8,tocIndex:0},{value:"fixSize",paraId:8,tocIndex:0},{value:"number / number[]",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"10 或 [ 10, 20 ]",paraId:8,tocIndex:0},{value:"固定该 Combo 的尺寸，不指定时 Combo 大小由内部元素的分布和大小来决定。若指定了 fixSize 而没有指定 fixCollapseSize，则即使该 Combo 在收起状态下仍然保持 fixSize 指定的尺寸",paraId:8,tocIndex:0},{value:"fixCollapseSize",paraId:8,tocIndex:0},{value:"number / number[]",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"10 或 [ 10, 20 ]",paraId:8,tocIndex:0},{value:"固定该 Combo 收起时的尺寸，不指定时，若未指定 fixSize 则由 size 决定收起时的尺寸，否则统一为 fixSize 尺寸",paraId:8,tocIndex:0},{value:"label",paraId:8,tocIndex:0},{value:"string",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"'combo A'",paraId:8,tocIndex:0},{value:"该 Combo 的文本标签",paraId:8,tocIndex:0},{value:"style",paraId:8,tocIndex:0},{value:"Object",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"该 Combo 的样式配置项，详见",paraId:8,tocIndex:0},{value:"内置 Combo 配置文档",paraId:9,tocIndex:0},{value:"及各类型 Combo 的文档",paraId:8,tocIndex:0},{value:"labelCfg",paraId:8,tocIndex:0},{value:"Object",paraId:8,tocIndex:0},{value:"false",paraId:8,tocIndex:0},{value:"该 Combo 的文本标签样式配置项，详见",paraId:8,tocIndex:0},{value:"内置 Combo 配置文档",paraId:10,tocIndex:0},{value:"及各类型 Combo 的文档",paraId:8,tocIndex:0},{value:"combos",paraId:11,tocIndex:0},{value:" 数组中一个数据项的示例：",paraId:11,tocIndex:0},{value:"{\n  id: 'comboA',\n  label: 'A',\n  parentId: 'comboC'\n},\n",paraId:12,tocIndex:0},{value:"在 nodes 数组中的数据项内加入 ",paraId:13,tocIndex:0},{value:"comboId",paraId:13,tocIndex:0},{value:" 属性，表示该节点与某个 Combo 的从属关系。",paraId:13,tocIndex:0},{value:"{\n  nodes: [\n    {\n      id: 'node1',\n      comboId: 'comboA' // node1 属于 comboA\n    },\n    {\n      id: 'node2',\n      comboId: 'comboB' // node2 属于 comboB\n    },\n    {\n      id: 'node3' // node3 不属于任何 combo\n    },\n    // ...\n  ],\n  edges: [\n    // ...\n  ],\n  combos: [\n    { // 定义 comboA\n      id: 'comboA',\n      label: 'A',\n      parentId: 'comboC'\n    },\n    { // 定义 comboB\n      id: 'comboB',\n      parentId: 'comboB'\n    },\n    { // 定义 comboC，这是一个空的 combo\n      id: 'comboC'\n    },\n    // ...\n  ]\n}\n",paraId:14,tocIndex:0},{value:"下面表格中显示了内置的各类 Combo，同时对一些特殊的字段进行了说明：",paraId:15,tocIndex:1},{value:"名称",paraId:16,tocIndex:1},{value:"描述",paraId:16,tocIndex:1},{value:"默认示例",paraId:16,tocIndex:1},{value:"circle",paraId:16,tocIndex:1},{value:"圆形：",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"size",paraId:16,tocIndex:1},{value:" 是单个数字，表示直径",paraId:16,tocIndex:1},{value:"- 圆心位置对应 Combo 的位置",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"color",paraId:16,tocIndex:1},{value:" 字段默认在描边上生效",paraId:16,tocIndex:1},{value:"- 标签文本默认在 Combo 正上方",paraId:16,tocIndex:1},{value:"- 更多字段见 ",paraId:16,tocIndex:1},{value:"Circle",paraId:17,tocIndex:1},{value:" Combo 教程",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"Demo",paraId:16,tocIndex:1},{value:"rect",paraId:16,tocIndex:1},{value:"矩形：",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"size",paraId:16,tocIndex:1},{value:" 是数组，例如：[100, 50]",paraId:16,tocIndex:1},{value:"- 矩形的中心位置是 Combo 的位置，而不是左上角",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"color",paraId:16,tocIndex:1},{value:" 字段默认在描边上生效",paraId:16,tocIndex:1},{value:"- 标签文本默认在 Combo 左上角",paraId:16,tocIndex:1},{value:"- 更多字段见 ",paraId:16,tocIndex:1},{value:"Rect",paraId:18,tocIndex:1},{value:" Combo 教程",paraId:16,tocIndex:1},{value:"- ",paraId:16,tocIndex:1},{value:"Demo",paraId:16,tocIndex:1},{value:"所有内置的 Combo 支持的通用属性：",paraId:19,tocIndex:2},{value:"属性名",paraId:20,tocIndex:2},{value:"类型",paraId:20,tocIndex:2},{value:"是否必须",paraId:20,tocIndex:2},{value:"示例",paraId:20,tocIndex:2},{value:"说明",paraId:20,tocIndex:2},{value:"id",paraId:20,tocIndex:2},{value:"string",paraId:20,tocIndex:2},{value:"true",paraId:20,tocIndex:2},{value:"'comboA'",paraId:20,tocIndex:2},{value:"一个 Combo 的唯一标识，",paraId:20,tocIndex:2},{value:"必须是 string 类型，必须唯一",paraId:20,tocIndex:2},{value:"type",paraId:20,tocIndex:2},{value:"string",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"'rect'",paraId:20,tocIndex:2},{value:"指定该 Combo 的类型，可以是内置 Combo 的类型名，也可以是自定义 Combo 的类型名。默认是 ",paraId:20,tocIndex:2},{value:"'circle'",paraId:20,tocIndex:2},{value:"parentId",paraId:20,tocIndex:2},{value:"string",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"'comboB'",paraId:20,tocIndex:2},{value:"该 Combo 的父 Combo 的 ID",paraId:20,tocIndex:2},{value:"size",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"Number / Array",paraId:20,tocIndex:2},{value:"30 或 [30, 20]",paraId:20,tocIndex:2},{value:"Combo 的最小尺寸（非固定尺寸），默认 'circle' 类型 Combo 的 size 为 20，'rect' 类型的为 [20, 5]",paraId:20,tocIndex:2},{value:"fixSize",paraId:20,tocIndex:2},{value:"number / number[]",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"10 或 [ 10, 20 ]",paraId:20,tocIndex:2},{value:"固定该 Combo 的尺寸，不指定时 Combo 大小由内部元素的分布和大小来决定。若指定了 fixSize 而没有指定 fixCollapseSize，则即使该 Combo 在收起状态下仍然保持 fixSize 指定的尺寸",paraId:20,tocIndex:2},{value:"fixCollapseSize",paraId:20,tocIndex:2},{value:"number / number[]",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"10 或 [ 10, 20 ]",paraId:20,tocIndex:2},{value:"固定该 Combo 收起时的尺寸，不指定时，若未指定 fixSize 则由 size 决定收起时的尺寸，否则统一为 fixSize 尺寸 ｜",paraId:20,tocIndex:2},{value:"padding",paraId:20,tocIndex:2},{value:"Number / Number[]",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"10 或 [ 10, 20, 10, 20 ]",paraId:20,tocIndex:2},{value:"该 Combo 内边距，默认 'circle' 类型 Combo 的 padding 为 25，'rect' 类型的为 [25, 20, 15, 20]",paraId:20,tocIndex:2},{value:"style",paraId:20,tocIndex:2},{value:"Object",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"该 Combo 的样式配置项",paraId:20,tocIndex:2},{value:"label",paraId:20,tocIndex:2},{value:"string",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"'Combo A'",paraId:20,tocIndex:2},{value:"该 Combo 的文本标签",paraId:20,tocIndex:2},{value:"labelCfg",paraId:20,tocIndex:2},{value:"Object",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"该 Combo 的文本标签样式配置项",paraId:20,tocIndex:2},{value:"collapsed",paraId:20,tocIndex:2},{value:"Boolean",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"该 Combo 是否收起。在渲染前配置 collapsed: true 在 combo 数据中，初次渲染时将默认收起",paraId:20,tocIndex:2},{value:"collapsedSubstituteIcon",paraId:20,tocIndex:2},{value:"Object",paraId:20,tocIndex:2},{value:"false",paraId:20,tocIndex:2},{value:"{ show: true }",paraId:20,tocIndex:2},{value:"v4.6.8 起支持",paraId:20,tocIndex:2},{value:" 该 Combo 在收起状态下展示的图片",paraId:20,tocIndex:2},{value:"Object 类型。通过 ",paraId:21,tocIndex:3},{value:"style",paraId:21,tocIndex:3},{value:" 配置来修改 Combo 的填充色、边框颜色、阴影等属性。下表是 ",paraId:21,tocIndex:3},{value:"style",paraId:21,tocIndex:3},{value:" 对象中常用的配置项：",paraId:21,tocIndex:3},{value:"名称",paraId:22,tocIndex:3},{value:"是否必须",paraId:22,tocIndex:3},{value:"类型",paraId:22,tocIndex:3},{value:"备注",paraId:22,tocIndex:3},{value:"fill",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"Combo 填充色",paraId:22,tocIndex:3},{value:"stroke",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"Combo 的描边颜色",paraId:22,tocIndex:3},{value:"lineWidth",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"描边宽度",paraId:22,tocIndex:3},{value:"shadowColor",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"阴影颜色",paraId:22,tocIndex:3},{value:"shadowBlur",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"阴影范围",paraId:22,tocIndex:3},{value:"shadowOffsetX",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"阴影 x 方向偏移量",paraId:22,tocIndex:3},{value:"shadowOffsetY",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"阴影 y 方向偏移量",paraId:22,tocIndex:3},{value:"opacity",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"设置绘图的当前 alpha 或透明值",paraId:22,tocIndex:3},{value:"fillOpacity",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"设置填充的 alpha 或透明值",paraId:22,tocIndex:3},{value:"cursor",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"鼠标在该 Combo 上时的鼠标样式，",paraId:22,tocIndex:3},{value:"CSS 的 cursor",paraId:22,tocIndex:3},{value:" 选项都支持",paraId:22,tocIndex:3},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:23,tocIndex:3},{value:"style",paraId:23,tocIndex:3},{value:"：",paraId:23,tocIndex:3},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // ... 其他属性\n    style: {\n      fill: '#steelblue',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n      // ... 其他属性\n    },\n  },\n});\n",paraId:24,tocIndex:3},{value:"label",paraId:25,tocIndex:4},{value:" String 类型。标签文本的文字内容。",paraId:25,tocIndex:4},{value:"labelCfg",paraId:25,tocIndex:4},{value:" Object 类型。配置标签文本。下面是 ",paraId:25,tocIndex:4},{value:"labelCfg",paraId:25,tocIndex:4},{value:" 对象中的常用配置项：",paraId:25,tocIndex:4},{value:"名称",paraId:26,tocIndex:4},{value:"是否必须",paraId:26,tocIndex:4},{value:"类型",paraId:26,tocIndex:4},{value:"备注",paraId:26,tocIndex:4},{value:"position",paraId:26,tocIndex:4},{value:"false",paraId:26,tocIndex:4},{value:"String",paraId:26,tocIndex:4},{value:"文本相对于 Combo 的位置，目前支持的位置有:  ",paraId:26,tocIndex:4},{value:"'center'",paraId:26,tocIndex:4},{value:"，",paraId:26,tocIndex:4},{value:"'top'",paraId:26,tocIndex:4},{value:"，",paraId:26,tocIndex:4},{value:"'left'",paraId:26,tocIndex:4},{value:"，",paraId:26,tocIndex:4},{value:"'right'",paraId:26,tocIndex:4},{value:"，",paraId:26,tocIndex:4},{value:"'bottom'",paraId:26,tocIndex:4},{value:"。默认为 ",paraId:26,tocIndex:4},{value:"'top'",paraId:26,tocIndex:4},{value:"refX",paraId:26,tocIndex:4},{value:"false",paraId:26,tocIndex:4},{value:"Number",paraId:26,tocIndex:4},{value:"文本的偏移，在 x 方向上的偏移量",paraId:26,tocIndex:4},{value:"refY",paraId:26,tocIndex:4},{value:"false",paraId:26,tocIndex:4},{value:"Number",paraId:26,tocIndex:4},{value:"文本的偏移，在 y 方向上的偏移量",paraId:26,tocIndex:4},{value:"style",paraId:26,tocIndex:4},{value:"false",paraId:26,tocIndex:4},{value:"Object",paraId:26,tocIndex:4},{value:"标签的样式属性。",paraId:26,tocIndex:4},{value:"上表中的标签的样式属性 ",paraId:27,tocIndex:4},{value:"style",paraId:27,tocIndex:4},{value:" 的常用配置项如下：",paraId:27,tocIndex:4},{value:"名称",paraId:28,tocIndex:4},{value:"是否必须",paraId:28,tocIndex:4},{value:"类型",paraId:28,tocIndex:4},{value:"备注",paraId:28,tocIndex:4},{value:"fill",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"String",paraId:28,tocIndex:4},{value:"文本颜色",paraId:28,tocIndex:4},{value:"stroke",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"String",paraId:28,tocIndex:4},{value:"文本描边颜色",paraId:28,tocIndex:4},{value:"lineWidth",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"Number",paraId:28,tocIndex:4},{value:"文本描边粗细",paraId:28,tocIndex:4},{value:"opacity",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"Number",paraId:28,tocIndex:4},{value:"文本透明度",paraId:28,tocIndex:4},{value:"fontSize",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"Number",paraId:28,tocIndex:4},{value:"文本字体大小",paraId:28,tocIndex:4},{value:"fontFamily",paraId:28,tocIndex:4},{value:"false",paraId:28,tocIndex:4},{value:"String",paraId:28,tocIndex:4},{value:"文字字体",paraId:28,tocIndex:4},{value:"... Combo 标签与节点、边标签样式属性相同，统一整理在 ",paraId:28,tocIndex:4},{value:"Text 图形 API",paraId:29,tocIndex:4},{value:"下面代码演示在实例化图时全局配置方法中配置  ",paraId:30,tocIndex:4},{value:"label",paraId:30,tocIndex:4},{value:" 和  ",paraId:30,tocIndex:4},{value:"labelCfg",paraId:30,tocIndex:4},{value:"。",paraId:30,tocIndex:4},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // ... 其他属性\n    labelCfg: {\n      position: 'top',\n      offset: [10, 10, 10, 10],\n      style: {\n        fill: '#666',\n      },\n    },\n  },\n});\n",paraId:31,tocIndex:4},{value:"v4.6.8 起支持",paraId:32,tocIndex:5},{value:" Object 类型。通过 ",paraId:32,tocIndex:5},{value:"collapsedSubstituteIcon",paraId:32,tocIndex:5},{value:" 配置 Combo 在收起状态下，展示在中心的图片 Icon。下表是 ",paraId:32,tocIndex:5},{value:"collapsedSubstituteIcon",paraId:32,tocIndex:5},{value:" 对象中常用的配置项：",paraId:32,tocIndex:5},{value:"名称",paraId:33,tocIndex:5},{value:"是否必须",paraId:33,tocIndex:5},{value:"类型",paraId:33,tocIndex:5},{value:"备注",paraId:33,tocIndex:5},{value:"show",paraId:33,tocIndex:5},{value:"false",paraId:33,tocIndex:5},{value:"Boolean",paraId:33,tocIndex:5},{value:"是否展示，默认不展示",paraId:33,tocIndex:5},{value:"img",paraId:33,tocIndex:5},{value:"false",paraId:33,tocIndex:5},{value:"String",paraId:33,tocIndex:5},{value:"Icon 图片地址，默认为: ",paraId:33,tocIndex:5},{value:"width",paraId:33,tocIndex:5},{value:"false",paraId:33,tocIndex:5},{value:"Number",paraId:33,tocIndex:5},{value:"Icon 图片的宽度，不设置则将使用 Combo 收起时的宽度",paraId:33,tocIndex:5},{value:"height",paraId:33,tocIndex:5},{value:"false",paraId:33,tocIndex:5},{value:"Number",paraId:33,tocIndex:5},{value:"Icon 图片高度，不设置则将使用 Combo 收起时的高度",paraId:33,tocIndex:5},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:34,tocIndex:5},{value:"collapsedSubstituteIcon",paraId:34,tocIndex:5},{value:"：",paraId:34,tocIndex:5},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    // ... 其他属性\n    collapsedSubstituteIcon: {\n      show: true,\n      img: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*IEQFS5VtXX8AAAAAAAAAAABkARQnAQ',\n      // ... 其他属性\n    },\n  },\n});\n",paraId:35,tocIndex:5},{value:"配置 Combo 的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:36,tocIndex:6},{value:"graph.combo(comboFn)",paraId:36,tocIndex:6},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:36,tocIndex:6},{value:"使用 ",paraId:37,tocIndex:6},{value:"graph.combo(comboFn)",paraId:37,tocIndex:6},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:37,tocIndex:6},{value:"即有相同的配置项时，优先级高的方式将会覆盖优先级低的。",paraId:38,tocIndex:6},{value:"⚠️ 注意:",paraId:39,tocIndex:6},{value:" 除 ",paraId:39,tocIndex:6},{value:"id",paraId:39,tocIndex:6},{value:"、",paraId:39,tocIndex:6},{value:"parentId",paraId:39,tocIndex:6},{value:"、",paraId:39,tocIndex:6},{value:"label",paraId:39,tocIndex:6},{value:" 应当配置到每个 Combo 数据中外，其余的 ",paraId:39,tocIndex:6},{value:"Combo 的通用属性",paraId:40,tocIndex:6},{value:" 以及各个 Combo 类型的特有属性（见内置 Combo 类型）均支持三种配置方式。",paraId:39,tocIndex:6},{value:"用户在实例化 Graph 时候可以通过 ",paraId:41,tocIndex:7},{value:"defaultCombo",paraId:41,tocIndex:7},{value:" 配置 Combo ，这里的配置是全局的配置，将会在所有 Combo 上生效。",paraId:41,tocIndex:7},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  defaultCombo: {\n    type: 'circle',\n    // 其他配置\n  },\n});\n",paraId:42,tocIndex:7},{value:"如果需要为不同 Combo 进行不同的配置，可以将配置写入到 Combo 数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:43,tocIndex:8},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [\n    ... // 边\n  ],\n  combos: [{\n    id: 'combo0',\n    size: 100,\n    type: 'circle',\n    ...    // 其他属性\n    style: {\n      ...  // 样式属性，每种 Combo 的详细样式属性参见各类型 Combo 文档\n    }\n  },{\n    id: 'combo1',\n    size: [50, 100],\n    type: 'rect',\n    ...    // 其他属性\n    style: {\n      ...  // 样式属性，每种 Combo 的详细样式属性参见各类型 Combo 文档\n    }\n  },\n  // 其他 combo\n  ]\n}\n",paraId:44,tocIndex:8},{value:"该方法可以为不同 combo 进行不同的配置。",paraId:45,tocIndex:9},{value:"提示:",paraId:46,tocIndex:9},{value:"该方法必须",paraId:47,tocIndex:9},{value:"在 render 之前调用",paraId:47,tocIndex:9},{value:"，否则不起作用；",paraId:47,tocIndex:9},{value:"由于该方法优先级最高，将覆盖其他地方对 combo 的配置，这可能将造成一些其他配置不生效的疑惑；",paraId:47,tocIndex:9},{value:"该方法在增加元素、更新元素时会被调用，如果数据量大、每个 Combo 上需要更新的内容多时，可能会有性能问题。",paraId:47,tocIndex:9},{value:"// const data = ...\n// const graph = ...\ngraph.combo((combo) => {\n  return {\n    id: combo.id,\n    type: 'rect',\n    style: {\n      fill: 'blue',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:48,tocIndex:9},{value:"只是简单地将 Combo 渲染出来，并没有多大的实用价值，只有支持一系列的交互操作后，才能最大程度地体现 Combo 的价值。",paraId:49,tocIndex:10},{value:"在 G6 中，我们内置了 ",paraId:50,tocIndex:10},{value:"drag-combo",paraId:50,tocIndex:10},{value:"、",paraId:50,tocIndex:10},{value:"collapse-expand-combo",paraId:50,tocIndex:10},{value:"、",paraId:50,tocIndex:10},{value:"drag-node",paraId:50,tocIndex:10},{value:" 三个 ",paraId:50,tocIndex:10},{value:"Behavior",paraId:51,tocIndex:10},{value:"。",paraId:50,tocIndex:10},{value:"drag-combo",paraId:52,tocIndex:11},{value:" Behavior，支持拖动 Combo ，拖动 Combo 过程中，会动态改变 Combo 中节点和边的位置，在拖拽完成以后，保持 Combo 和节点的相对位置不变。还可以通过拖拽改变 Combo 的从属关系。",paraId:52,tocIndex:11},{value:"collapse-expand-combo",paraId:53,tocIndex:12},{value:" Behavior，支持双击 Combo 收起和展开 Combo ，收起 Combo 以后，隐藏 Combo 中的所有节点，外部节点和 Combo 中节点有连线的情况下，所有连接会连接到 Combo 上面。若图配置有布局且该 behavior 的 ",paraId:53,tocIndex:12},{value:"relayout",paraId:53,tocIndex:12},{value:" 配置项为 ",paraId:53,tocIndex:12},{value:"true",paraId:53,tocIndex:12},{value:"（默认为 ",paraId:53,tocIndex:12},{value:"true",paraId:53,tocIndex:12},{value:"），则该 behavior 被触发后会触发图的重新布局。若希望避免重新布局，可以配置 ",paraId:53,tocIndex:12},{value:"relayout",paraId:53,tocIndex:12},{value:" 为 ",paraId:53,tocIndex:12},{value:"false",paraId:53,tocIndex:12},{value:" ，或通过监听 combo 点击事件和 ",paraId:53,tocIndex:12},{value:"graph.collapseExpandCombo API",paraId:54,tocIndex:12},{value:" 控制收缩展开逻辑。",paraId:53,tocIndex:12},{value:"拖拽节点过程中，动态改变节点与父 Combo 的从属关系。",paraId:55,tocIndex:13},{value:"通过下面代码在实例化图时将三个 behavior 配置到图上即可使用上述交互：",paraId:56,tocIndex:14},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n  modes: {\n    default: ['drag-combo', 'collapse-expand-combo', 'drag-node'],\n  },\n});\n",paraId:57,tocIndex:14},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'Node1',\n      comboId: 'rect_combo',\n    },\n    {\n      id: 'node2',\n      label: 'Node 2',\n    },\n  ],\n  combos: [\n    {\n      id: 'circle_combo',\n      type: 'circle',\n      label: 'Circle',\n    },\n    {\n      id: 'rect_combo',\n      type: 'rect',\n      label: 'Rect',\n    },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1500,\n  height: 300,\n  // 必须将 groupByTypes 设置为 false，带有 combo 的图中元素的视觉层级才能合理\n  groupByTypes: false,\n});\ngraph.data(data);\ngraph.render();\n",paraId:58,tocIndex:15},{value:"显示结果： ",paraId:59,tocIndex:15},{value:" ",paraId:59,tocIndex:15},{value:"下面演示通过将配置写入数据的方式，调整 ",paraId:60,tocIndex:16},{value:"id",paraId:60,tocIndex:16},{value:" 为 ",paraId:60,tocIndex:16},{value:"'rect_combo'",paraId:60,tocIndex:16},{value:" 的文本位置、颜色、样式。将下面代码替换上面代码中 ",paraId:60,tocIndex:16},{value:"id",paraId:60,tocIndex:16},{value:" 为  ",paraId:60,tocIndex:16},{value:"'rect_combo'",paraId:60,tocIndex:16},{value:" 的 combo 数据即可生效。",paraId:60,tocIndex:16},{value:"{\n  id: 'rect_combo',\n  type: 'rect',\n  label: 'Rect Combo',\n  labelCfg: {\n    position: 'bottom',\n    refX: 5,\n    refY: -12,\n    style: {\n      fill: '#fff'\n    }\n  },\n  style: {\n    fill: '#fa8c16',\n    stroke: '#000',\n    lineWidth: 2\n  }\n}\n",paraId:61,tocIndex:16},{value:"风控、反洗钱、保险骗保、网络诈骗、信用卡诈骗等场景下团伙分析；",paraId:62,tocIndex:17},{value:"特征分析：同一个分组中的节点在某些特征上面比较相似；",paraId:62,tocIndex:17},{value:"整理节点：当类似的节点放到一个分组中，只渲染分组，不渲染节点，减少干扰元素。",paraId:62,tocIndex:17},{value:"状态 State",paraId:63,tocIndex:19},{value:" —— 交互过程中的样式变化；",paraId:64,tocIndex:19},{value:"轮廓包裹 Hull",paraId:65,tocIndex:19},{value:" —— 轮廓包裹分组。",paraId:64,tocIndex:19}]},42635:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"无论是内置边还是",paraId:0},{value:"自定义边",paraId:1},{value:"，都可以为其配置起始端箭头与结束端箭头。G6 中的箭头分为默认箭头、内置箭头、自定义箭头。",paraId:0},{value:" ",paraId:2},{value:"在边的样式属性 ",paraId:3,tocIndex:1},{value:"style",paraId:3,tocIndex:1},{value:" 中将 ",paraId:3,tocIndex:1},{value:"endArrow",paraId:3,tocIndex:1},{value:" 或 ",paraId:3,tocIndex:1},{value:"startArrow",paraId:3,tocIndex:1},{value:" 配置为 ",paraId:3,tocIndex:1},{value:"true",paraId:3,tocIndex:1},{value:" 即可：",paraId:3,tocIndex:1},{value:"style: {\n  endArrow: true,\n  startArrow: true\n}\n",paraId:4,tocIndex:1},{value:"v3.5.8 后支持。",paraId:5,tocIndex:2},{value:"名称",paraId:6,tocIndex:3},{value:"参数",paraId:6,tocIndex:3},{value:"使用方法",paraId:6,tocIndex:3},{value:"效果",paraId:6,tocIndex:3},{value:"triangle",paraId:6,tocIndex:3},{value:"依次为箭头宽度（默认 10）、长度（默认 15）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.triangle(10, 20, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"vee",paraId:6,tocIndex:3},{value:"依次为箭头宽度（默认 15）、长度（默认 20）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.vee(10, 20, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"circle",paraId:6,tocIndex:3},{value:"依次为箭头半径（默认 5）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.circle(10, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"diamond",paraId:6,tocIndex:3},{value:"依次为箭头宽度（默认 15）、长度（默认 15）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.diamond(10, 20, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"rect",paraId:6,tocIndex:3},{value:"依次为箭头宽度（默认 10）、长度（默认 10）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.rect(10, 20, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"triangleRect",paraId:6,tocIndex:3},{value:"依次为箭头三角形宽度（默认 15）、三角形长度（默认 15）、矩形宽度（默认 15）、矩形长度（默认 3）、三角形与矩形间距（默认为 5）、偏移量（默认为 0，与 ",paraId:6,tocIndex:3},{value:"d",paraId:6,tocIndex:3},{value:" 对应）",paraId:6,tocIndex:3},{value:"endArrow: {",paraId:6,tocIndex:3},{value:" path: G6.Arrow.triangleRect(15, 15, 15, 3, 5, 25),",paraId:6,tocIndex:3},{value:" d: 25",paraId:6,tocIndex:3},{value:"}",paraId:6,tocIndex:3},{value:"调用 ",paraId:7,tocIndex:4},{value:"G6.Arrow.arrowName",paraId:7,tocIndex:4},{value:" 配置边的样式属性 ",paraId:7,tocIndex:4},{value:"style",paraId:7,tocIndex:4},{value:" 中 ",paraId:7,tocIndex:4},{value:"endArrow",paraId:7,tocIndex:4},{value:" 或 ",paraId:7,tocIndex:4},{value:"startArrow",paraId:7,tocIndex:4},{value:" 的 ",paraId:7,tocIndex:4},{value:"path",paraId:7,tocIndex:4},{value:"：",paraId:7,tocIndex:4},{value:"style: {\n  endArrow: {\n    path: G6.Arrow.triangle(10, 20, 25), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n    d: 25\n  },\n  startArrow: {\n    path: G6.Arrow.vee(15, 20, 15), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n    d: 15\n  },\n}\n",paraId:8,tocIndex:4},{value:"参见高级指引 ",paraId:9,tocIndex:5},{value:"自定义箭头",paraId:10,tocIndex:5},{value:"。",paraId:9,tocIndex:5},{value:"只有内置箭头和自定义箭头可以配置样式。",paraId:11,tocIndex:6},{value:"名称",paraId:12,tocIndex:7},{value:"是否必须",paraId:12,tocIndex:7},{value:"类型",paraId:12,tocIndex:7},{value:"备注",paraId:12,tocIndex:7},{value:"fill",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"String",paraId:12,tocIndex:7},{value:"填充颜色，默认无填充",paraId:12,tocIndex:7},{value:"stroke",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"String",paraId:12,tocIndex:7},{value:"描边颜色，默认与边颜色相同",paraId:12,tocIndex:7},{value:"lineWidth",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Number",paraId:12,tocIndex:7},{value:"描边宽度，默认与边宽度相同",paraId:12,tocIndex:7},{value:"opacity",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Number",paraId:12,tocIndex:7},{value:"透明度",paraId:12,tocIndex:7},{value:"shadowColor",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"String",paraId:12,tocIndex:7},{value:"阴影颜色",paraId:12,tocIndex:7},{value:"shadowBlur",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Number",paraId:12,tocIndex:7},{value:"阴影模糊程度",paraId:12,tocIndex:7},{value:"shadowOffsetX",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Number",paraId:12,tocIndex:7},{value:"阴影 x 方向偏移量",paraId:12,tocIndex:7},{value:"shadowOffsetY",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Number",paraId:12,tocIndex:7},{value:"阴影 y 方向偏移量",paraId:12,tocIndex:7},{value:"lineDash",paraId:12,tocIndex:7},{value:"false",paraId:12,tocIndex:7},{value:"Array",paraId:12,tocIndex:7},{value:"描边的虚线样式，可以指定一个数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。",paraId:12,tocIndex:7},{value:"// 内置箭头\nstyle: {\n  endArrow: {\n    path: G6.Arrow.triangle(10, 20, 25), // 使用内置箭头路径函数，参数为箭头的 宽度、长度、偏移量（默认为 0，与 d 对应）\n    d: 25,\n    fill: '#f00',\n    stroke: '#0f0',\n    opacity: 0.5,\n    lineWidth: 3,\n    // ...\n  },\n}\n\n\n// 自定义箭头\nstyle: {\n  endArrow: {\n    path: 'M 0,0 L 20,10 L 20,-10 Z',\n    d: 5,\n    fill: '#f00',\n    stroke: '#0f0',\n    opacity: 0.5,\n    lineWidth: 3,\n    // ...\n  },\n}\n",paraId:13,tocIndex:8}]},9557:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了圆弧  arc  边，其默认样式如下。",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置边",paraId:2,tocIndex:0},{value:"  一节所示，配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:4,tocIndex:0},{value:"边的通用属性",paraId:5,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultEdge",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'arc'",paraId:6,tocIndex:1},{value:"，即可使用 arc  边。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'arc',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'arc',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"arc 边支持 ",paraId:10,tocIndex:3},{value:"边通用配置项",paraId:11,tocIndex:3},{value:"，以下表格对部分常用配置项进行说明。其中 ",paraId:10,tocIndex:3},{value:"curveOffset",paraId:10,tocIndex:3},{value:" 属性是 ",paraId:10,tocIndex:3},{value:"arc",paraId:10,tocIndex:3},{value:" 特有的属性，它控制了圆弧的大小以及弯曲的方向。",paraId:10,tocIndex:3},{value:"color: '#87e8de',\ncurveOffset: 20,  // 圆弧顶端距离两线中心位置的距离\nstyle: {\n  lineWidth: 2,\n  stroke: '#87e8de'\n},\nlabel: '边的标签文字',\nlabelCfg: {\n  refX: 10,  // 文本在 x 方向偏移量\n  refY: 10,  // 文本在 y 方向偏移量\n  style: {\n    fill: '#595959'\n  }\n}\n",paraId:12,tocIndex:3},{value:"名称",paraId:13,tocIndex:3},{value:"含义",paraId:13,tocIndex:3},{value:"类型",paraId:13,tocIndex:3},{value:"备注",paraId:13,tocIndex:3},{value:"color",paraId:13,tocIndex:3},{value:"边的颜色",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"优先级低于 ",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:" 中的 ",paraId:13,tocIndex:3},{value:"stroke",paraId:13,tocIndex:3},{value:"curveOffset",paraId:13,tocIndex:3},{value:"圆弧顶端距离两线中心位置的距离",paraId:13,tocIndex:3},{value:"Number",paraId:13,tocIndex:3},{value:"数值绝对值大小控制圆弧的大小，正负控制圆弧弯曲的方向，默认为 ",paraId:13,tocIndex:3},{value:"20",paraId:13,tocIndex:3},{value:"。arc 边特有",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:"边的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"Canvas 支持的属性",paraId:13,tocIndex:3},{value:"label",paraId:13,tocIndex:3},{value:"标签文本文字",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"labelCfg",paraId:13,tocIndex:3},{value:"标签文本配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"stateStyles",paraId:13,tocIndex:3},{value:"各状态下的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"详见",paraId:13,tocIndex:3},{value:"配置状态样式",paraId:14,tocIndex:3},{value:"curveOffset",paraId:15,tocIndex:4},{value:" 属性是 ",paraId:15,tocIndex:4},{value:"arc",paraId:15,tocIndex:4},{value:" 特有的属性，它控制了圆弧的大小以及弯曲的方向。下面代码演示在实例化图时全局配置方法中配置 ",paraId:15,tocIndex:4},{value:"curveOffset",paraId:15,tocIndex:4},{value:"。",paraId:15,tocIndex:4},{value:" ",paraId:15,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 200,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node1',\n      type: 'arc',\n      label: 'arc',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  linkCenter: true,\n  defaultEdge: {\n    // type: 'arc',  // 在数据中已经指定 type，这里无需再次指定\n    curveOffset: -80,\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:16,tocIndex:4},{value:"⚠️ 注意:",paraId:17,tocIndex:4},{value:" 上面代码使用了 graph 的配置项  ",paraId:17,tocIndex:4},{value:"linkCenter: true",paraId:17,tocIndex:4},{value:" 以设置 arc 边连入节点的中心，保证美观性。",paraId:17,tocIndex:4},{value:"Object 类型。配置项与 ",paraId:18,tocIndex:5},{value:"边通用样式属性",paraId:19,tocIndex:5},{value:" 相同。基于上面 ",paraId:18,tocIndex:5},{value:"特殊属性：弧度  curveOffset",paraId:20,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:18,tocIndex:5},{value:"defaultEdge",paraId:18,tocIndex:5},{value:" 中增加了  ",paraId:18,tocIndex:5},{value:"style",paraId:18,tocIndex:5},{value:"  配置项进行边的样式的配置，使之达到如下图效果。",paraId:18,tocIndex:5},{value:" ",paraId:18,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    style: {\n      stroke: '#088',\n      lineWidth: 3,\n    },\n  },\n});\n// ...\n",paraId:21,tocIndex:5},{value:"Object 类型。支持 ",paraId:22,tocIndex:6},{value:"边通用标签配置",paraId:23,tocIndex:6},{value:"。基于上面  ",paraId:22,tocIndex:6},{value:"弧度 curveOffset",paraId:24,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:22,tocIndex:6},{value:"defaultEdge",paraId:22,tocIndex:6},{value:" 中增加了  ",paraId:22,tocIndex:6},{value:"labelCfg",paraId:22,tocIndex:6},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:22,tocIndex:6},{value:" ",paraId:22,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      autoRotate: true,\n      refY: -30,\n      refX: 30,\n    },\n  },\n});\n// ...\n",paraId:25,tocIndex:6}]},74503:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了  cubic  边，其默认样式如下。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置边",paraId:2,tocIndex:0},{value:"  一节所示，配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:4,tocIndex:0},{value:"边的通用属性",paraId:5,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultEdge",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'cubic'",paraId:6,tocIndex:1},{value:"，即可使用 cubic  边。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'cubic',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'cubic',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"cubic 边支持 ",paraId:10,tocIndex:3},{value:"边通用配置项",paraId:11,tocIndex:3},{value:"，以下表格对部分常用配置项进行说明。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"color",paraId:12,tocIndex:3},{value:"边的颜色",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"优先级低于 ",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:" 中的 ",paraId:12,tocIndex:3},{value:"stroke",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"边的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本文字",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"controlPoints",paraId:12,tocIndex:3},{value:"控制点数组",paraId:12,tocIndex:3},{value:"Array",paraId:12,tocIndex:3},{value:"不指定时将会使用默认的控制点：曲线 1/3 和 2/3 处。示例：",paraId:12,tocIndex:3},{value:"[{ x: 10, y: 20 }, { x: 15, y: 30 }]",paraId:12,tocIndex:3},{value:"curveOffset",paraId:12,tocIndex:3},{value:"两个控制点距离两端点连线的距离，可理解为控制边的弯曲程度。为 Number 类型时两个控制点分别在连线两侧且与连线距离相等",paraId:12,tocIndex:3},{value:"Number / Number[]",paraId:12,tocIndex:3},{value:"cubic、quadratic、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有",paraId:12,tocIndex:3},{value:"minCurveOffset",paraId:12,tocIndex:3},{value:"两个控制点距离两端点连线的最小距离距离，可理解为控制边的弯曲程度，用于防止过于“平缓”的曲线，当 ",paraId:12,tocIndex:3},{value:"curveOffset",paraId:12,tocIndex:3},{value:" 未指定时生效。为 Number 类型时两个控制点分别在连线两侧且与连线距离相等",paraId:12,tocIndex:3},{value:"Number / Number[]",paraId:12,tocIndex:3},{value:"cubic-vertical、cubic-horizontal 边特有",paraId:12,tocIndex:3},{value:"curvePosition",paraId:12,tocIndex:3},{value:"两个控制点在两端点连线上的相对位置，范围 0 ～ 1",paraId:12,tocIndex:3},{value:"Number / Number[]",paraId:12,tocIndex:3},{value:"cubic、quadratic、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"Object 类型。配置项与 ",paraId:14,tocIndex:4},{value:"边通用样式属性",paraId:15,tocIndex:4},{value:" 相同。下面代码演示在实例化图时全局配置方法中配置 ",paraId:14,tocIndex:4},{value:"style",paraId:14,tocIndex:4},{value:"，以达到下图效果。",paraId:14,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 200,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node1',\n      type: 'cubic',\n      label: 'cubic',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // type: 'cubic',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      endArrow: true,\n      stroke: '#088',\n      lineWidth: 3,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:16,tocIndex:4},{value:"Object 类型。支持 ",paraId:17,tocIndex:5},{value:"边通用标签配置",paraId:18,tocIndex:5},{value:"。基于上面 ",paraId:17,tocIndex:5},{value:"样式属性 style",paraId:19,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:17,tocIndex:5},{value:"defaultEdge",paraId:17,tocIndex:5},{value:" 中增加了  ",paraId:17,tocIndex:5},{value:"labelCfg",paraId:17,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:17,tocIndex:5},{value:" ",paraId:17,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      autoRotate: true,\n      refY: 10,\n      refX: 40,\n    },\n  },\n});\n// ...\n",paraId:20,tocIndex:5}]},46413:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了直线 line  边，其默认样式如下。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置边",paraId:2,tocIndex:0},{value:"  一节所示，配置边的方式有两种：配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:4,tocIndex:0},{value:"边的通用属性",paraId:5,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultEdge",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'line'",paraId:6,tocIndex:1},{value:"，即可使用 line  边。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'line',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'line',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"line 边支持 ",paraId:10,tocIndex:3},{value:"边通用配置项",paraId:11,tocIndex:3},{value:"，以下表格对部分常用配置项进行说明。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"color",paraId:12,tocIndex:3},{value:"直线的颜色",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"优先级低于 ",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:" 中的 ",paraId:12,tocIndex:3},{value:"stroke",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"直线的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本文字",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"Object 类型。配置项与 ",paraId:14,tocIndex:4},{value:"边通用样式属性",paraId:15,tocIndex:4},{value:" 相同。下面代码演示在实例化图时全局配置方法中配置 ",paraId:14,tocIndex:4},{value:"style",paraId:14,tocIndex:4},{value:"，以达到下图效果。",paraId:14,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 100,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node1',\n      type: 'line',\n      label: 'line',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // type: 'line',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      stroke: 'steelblue',\n      lineWidth: 5,\n    },\n    labelCfg: {\n      position: 'end',\n      refY: -10,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:16,tocIndex:4},{value:"Object 类型。支持 ",paraId:17,tocIndex:5},{value:"边通用标签配置",paraId:18,tocIndex:5},{value:"。",paraId:17,tocIndex:5},{value:"基于上面 ",paraId:17,tocIndex:5},{value:"样式属性 style",paraId:19,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:17,tocIndex:5},{value:"defaultEdge",paraId:17,tocIndex:5},{value:" 中增加了  ",paraId:17,tocIndex:5},{value:"labelCfg",paraId:17,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:17,tocIndex:5},{value:" ",paraId:17,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      position: 'end',\n      refY: -10,\n    },\n  },\n});\n// ...\n",paraId:20,tocIndex:5}]},88628:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了折线 loop  边，其默认样式如下。",paraId:0},{value:" ",paraId:0},{value:"⚠️ 注意:",paraId:1},{value:" loop 边适用于自环边，即起始点与结束点为相同节点的边，在不同端点的边上适用 loop 边将会出现异常效果。 ",paraId:1},{value:" ",paraId:1},{value:"如 ",paraId:2,tocIndex:0},{value:"内置边",paraId:3,tocIndex:0},{value:"  一节所示，配置边的方式有两种：配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:2,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:2,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:2,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:4,tocIndex:0},{value:"⚠️ 注意:",paraId:5,tocIndex:0},{value:" 除 ",paraId:5,tocIndex:0},{value:"id",paraId:5,tocIndex:0},{value:"、",paraId:5,tocIndex:0},{value:"source",paraId:5,tocIndex:0},{value:"、",paraId:5,tocIndex:0},{value:"target",paraId:5,tocIndex:0},{value:"、",paraId:5,tocIndex:0},{value:"label",paraId:5,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:5,tocIndex:0},{value:"边的通用属性",paraId:6,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:5,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:7,tocIndex:1},{value:"defaultEdge",paraId:7,tocIndex:1},{value:" 指定 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 为 ",paraId:7,tocIndex:1},{value:"'loop'",paraId:7,tocIndex:1},{value:"，即可使用 ",paraId:7,tocIndex:1},{value:"loop",paraId:7,tocIndex:1},{value:"  边。需要注意的是，如果图上存在非自环边，loop 将会表现异常。因此不建议在存在非自环边的图上使用此全局配置方法。",paraId:7,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'loop',\n    // 其他配置\n  },\n});\n",paraId:8,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:9,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node0'\n    type: 'loop',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:10,tocIndex:2},{value:"自环是指连接单个节点自身的边，是一种边的特殊情况。支持 ",paraId:11,tocIndex:3},{value:"边通用配置项",paraId:12,tocIndex:3},{value:"，以下表格对部分常用配置项进行说明。在通用属性基础上，支持了特殊的配置 ",paraId:11,tocIndex:3},{value:"loopCfg",paraId:11,tocIndex:3},{value:"。",paraId:11,tocIndex:3},{value:"loop 边支持以下的配置项，对于 Object 类型的配置项将在后面有详细讲解：",paraId:13,tocIndex:3},{value:"名称",paraId:14,tocIndex:3},{value:"含义",paraId:14,tocIndex:3},{value:"类型",paraId:14,tocIndex:3},{value:"备注",paraId:14,tocIndex:3},{value:"color",paraId:14,tocIndex:3},{value:"边的颜色",paraId:14,tocIndex:3},{value:"String",paraId:14,tocIndex:3},{value:"优先级低于 style 中的 stroke",paraId:14,tocIndex:3},{value:"style",paraId:14,tocIndex:3},{value:"边的样式",paraId:14,tocIndex:3},{value:"Object",paraId:14,tocIndex:3},{value:"Canvas 支持的属性",paraId:14,tocIndex:3},{value:"style.endArrow",paraId:14,tocIndex:3},{value:"边结束端是否有箭头",paraId:14,tocIndex:3},{value:"Boolean",paraId:14,tocIndex:3},{value:"默认为 false",paraId:14,tocIndex:3},{value:"label",paraId:14,tocIndex:3},{value:"标签文本文字",paraId:14,tocIndex:3},{value:"String",paraId:14,tocIndex:3},{value:"labelCfg",paraId:14,tocIndex:3},{value:"标签文本配置项",paraId:14,tocIndex:3},{value:"Object",paraId:14,tocIndex:3},{value:"loopCfg",paraId:14,tocIndex:3},{value:"自环特殊配置",paraId:14,tocIndex:3},{value:"Object",paraId:14,tocIndex:3},{value:"Object 类型。配置项与 ",paraId:15,tocIndex:4},{value:"边通用样式属性",paraId:16,tocIndex:4},{value:" 相同。下面代码演示在实例化图时全局配置方法中配置 ",paraId:15,tocIndex:4},{value:"style",paraId:15,tocIndex:4},{value:"，以达到下图效果。",paraId:15,tocIndex:4},{value:" ",paraId:15,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node0',\n      type: 'loop',\n      label: 'loop',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // type: 'loop',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      endArrow: true,\n      stroke: '#088',\n      lineWidth: 3,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:17,tocIndex:4},{value:"Object 类型。支持 ",paraId:18,tocIndex:5},{value:"边通用标签配置",paraId:19,tocIndex:5},{value:"。基于上面 ",paraId:18,tocIndex:5},{value:"样式属性 style",paraId:20,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:18,tocIndex:5},{value:"defaultEdge",paraId:18,tocIndex:5},{value:" 中增加了  ",paraId:18,tocIndex:5},{value:"labelCfg",paraId:18,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:18,tocIndex:5},{value:" ",paraId:18,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      refY: -5,\n      refX: 30,\n    },\n  },\n});\n// ...\n",paraId:21,tocIndex:5},{value:"Object 类型。通过 ",paraId:22,tocIndex:6},{value:"loopCfg",paraId:22,tocIndex:6},{value:"  配置自环的方位、高度、顺逆时针、连接起始点位置。",paraId:22,tocIndex:6},{value:"position",paraId:23,tocIndex:6},{value:": 指定自环与节点的相对位置。默认为：",paraId:23,tocIndex:6},{value:"top",paraId:23,tocIndex:6},{value:"。支持的值有：",paraId:23,tocIndex:6},{value:"top",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"top-right",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"right",paraId:23,tocIndex:6},{value:",",paraId:23,tocIndex:6},{value:"bottom-right",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"bottom",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"bottom-left",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"left",paraId:23,tocIndex:6},{value:", ",paraId:23,tocIndex:6},{value:"top-left",paraId:23,tocIndex:6},{value:"dist",paraId:23,tocIndex:6},{value:": 从节点 keyShape 的边缘到自环最顶端的位置，用于指定自环的曲度，默认为节点的高度。",paraId:23,tocIndex:6},{value:"clockwise",paraId:23,tocIndex:6},{value:": 指定是否顺时针画环，默认为  ",paraId:23,tocIndex:6},{value:"true",paraId:23,tocIndex:6},{value:"。",paraId:23,tocIndex:6},{value:"pointPadding",paraId:23,tocIndex:6},{value:": 对于非圆形节点设置的连接点与节点中心坐标（",paraId:23,tocIndex:6},{value:"top-right",paraId:23,tocIndex:6},{value:"，",paraId:23,tocIndex:6},{value:"bottom-right",paraId:23,tocIndex:6},{value:",",paraId:23,tocIndex:6},{value:"top-left",paraId:23,tocIndex:6},{value:",",paraId:23,tocIndex:6},{value:"bottom-left",paraId:23,tocIndex:6},{value:"较特殊，为四个角坐标）在 x 轴或 y 轴方向的偏移量，默认为  ",paraId:23,tocIndex:6},{value:"节点宽高中最小值的1/4",paraId:23,tocIndex:6},{value:"，",paraId:23,tocIndex:6},{value:"v4.7.8 后支持",paraId:23,tocIndex:6},{value:"。",paraId:23,tocIndex:6},{value:"基于上面 ",paraId:24,tocIndex:6},{value:"样式属性 style",paraId:25,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:24,tocIndex:6},{value:"defaultEdge",paraId:24,tocIndex:6},{value:" 中增加了  ",paraId:24,tocIndex:6},{value:"loopCfg",paraId:24,tocIndex:6},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:24,tocIndex:6},{value:" ",paraId:24,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    loopCfg: {\n      position: 'left',\n      dist: 100,\n      clockwise: false,\n      pointPadding: 15,\n    },\n  },\n});\n// ...\n",paraId:26,tocIndex:6}]},96317:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了折线 polyline  边，其默认样式如下。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置边",paraId:2,tocIndex:0},{value:"  一节所示，配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:4,tocIndex:0},{value:"边的通用属性",paraId:5,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultEdge",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'polyline'",paraId:6,tocIndex:1},{value:"，即可使用 polyline  边。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'polyline',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'polyline',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"polyline 边支持 ",paraId:10,tocIndex:3},{value:"边通用配置项",paraId:11,tocIndex:3},{value:"，此外，polyline 额外支持 ",paraId:10,tocIndex:3},{value:"routeCfg",paraId:10,tocIndex:3},{value:" 配置，用以配置路由计算的参数。以下表格对部分常用配置项进行说明：",paraId:10,tocIndex:3},{value:"routeCfg: { // 路由计算参数，详见下面表格\n  gridSize: 10, // 指定精度\n  maxAllowedDirectionChange: Math.PI / 2, // 允许的最大转角，弧度制\n  obstacles: [graph.findById('node0'), graph.findById('node1')], // 需要躲避的障碍节点对象\n},\ncolor: '#87e8de',\nstyle: {\n  offset: 20,  // 拐弯处距离节点最小距离\n  radius: 10,  // 拐弯处的圆角弧度，若不设置则为直角\n  lineWidth: 2,\n  stroke: '#87e8de'\n},\nlabel: '边的标签文字',\nlabelCfg: {\n  refX: 10,  // 文本在 x 方向偏移量\n  refY: 10,  // 文本在 y 方向偏移量\n  style: {\n    fill: '#595959'\n  }\n}\n",paraId:12,tocIndex:3},{value:"名称",paraId:13,tocIndex:3},{value:"含义",paraId:13,tocIndex:3},{value:"类型",paraId:13,tocIndex:3},{value:"备注",paraId:13,tocIndex:3},{value:"color",paraId:13,tocIndex:3},{value:"边的颜色",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"优先级低于 style 中的 stroke",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:"边的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"Canvas 支持的属性",paraId:13,tocIndex:3},{value:"style.radius",paraId:13,tocIndex:3},{value:"拐弯处的圆角弧度",paraId:13,tocIndex:3},{value:"Number",paraId:13,tocIndex:3},{value:"若不设置则为直角，polyline 特有",paraId:13,tocIndex:3},{value:"style.offset",paraId:13,tocIndex:3},{value:"拐弯处距离节点最小距离",paraId:13,tocIndex:3},{value:"Number",paraId:13,tocIndex:3},{value:"默认为 5，polyline 特有",paraId:13,tocIndex:3},{value:"controlPoints",paraId:13,tocIndex:3},{value:"控制点数组",paraId:13,tocIndex:3},{value:"Array",paraId:13,tocIndex:3},{value:"不指定时根据 ",paraId:13,tocIndex:3},{value:"A* 算法",paraId:13,tocIndex:3},{value:"自动生成折线。若指定了，则按照 ",paraId:13,tocIndex:3},{value:"controlPoints",paraId:13,tocIndex:3},{value:" 指定的位置进行弯折。示例：",paraId:13,tocIndex:3},{value:"[{ x: 10, y: 20 }, { x: 20, y: 25 }, ...]",paraId:13,tocIndex:3},{value:"label",paraId:13,tocIndex:3},{value:"标签文本文字",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"labelCfg",paraId:13,tocIndex:3},{value:"标签文本配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"stateStyles",paraId:13,tocIndex:3},{value:"各状态下的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"详见",paraId:13,tocIndex:3},{value:"配置状态样式",paraId:14,tocIndex:3},{value:"routeCfg",paraId:13,tocIndex:3},{value:"路由计算参数",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"在数据中不存在 controlPoints 时生效，此时 polyline 将自动计算路径。具体字段见下面 routeCfg 章节",paraId:13,tocIndex:3},{value:"Object 类型， 在数据中不存在 controlPoints 时生效，此时 polyline 将自动计算路径。字段有：",paraId:15,tocIndex:4},{value:"名称",paraId:16,tocIndex:4},{value:"默认值",paraId:16,tocIndex:4},{value:"类型",paraId:16,tocIndex:4},{value:"备注",paraId:16,tocIndex:4},{value:"gridSize",paraId:16,tocIndex:4},{value:"10",paraId:16,tocIndex:4},{value:"number",paraId:16,tocIndex:4},{value:"计算折线的网格大小，值越小性能消耗越高",paraId:16,tocIndex:4},{value:"maxAllowedDirectionChange",paraId:16,tocIndex:4},{value:"Math.PI / 2",paraId:16,tocIndex:4},{value:"number",paraId:16,tocIndex:4},{value:"允许的最大转角角度，弧度制",paraId:16,tocIndex:4},{value:"obstacles",paraId:16,tocIndex:4},{value:"INode[]",paraId:16,tocIndex:4},{value:"[]",paraId:16,tocIndex:4},{value:"需要躲避的障碍节点对象",paraId:16,tocIndex:4},{value:"目前不支持自动躲避所有节点，只能通过例如 ",paraId:17,tocIndex:4},{value:"graph.updateItem(edge, { routeCfg: { obstacles: [graph.findById('node1', graph.findById('node2'))] } })",paraId:17,tocIndex:4},{value:" 的方式手动增加个别需要躲避的节点对象到边的配置中。类似 ER 图、图编辑的场景，推荐使用 @antv/x6，针对此类折线的避障有更好的支持，参考 demo ",paraId:17,tocIndex:4},{value:"智能路由",paraId:17,tocIndex:4},{value:"。",paraId:17,tocIndex:4},{value:"Object 类型。支持 ",paraId:18,tocIndex:5},{value:"边通用样式属性",paraId:19,tocIndex:5},{value:"。与其他类型的边不同的是，polyline 的 ",paraId:18,tocIndex:5},{value:"style",paraId:18,tocIndex:5},{value:"  含有两个特殊属性：",paraId:18,tocIndex:5},{value:"radius",paraId:20,tocIndex:5},{value:" ，弯折处的圆角半径，不设置则默认为直角；",paraId:20,tocIndex:5},{value:"offset",paraId:20,tocIndex:5},{value:" ，距离端点的最小距离，默认值为 5。",paraId:20,tocIndex:5},{value:"其它配置项与边的通用样式属性相同，见 ",paraId:21,tocIndex:5},{value:"内置边",paraId:22,tocIndex:5},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:21,tocIndex:5},{value:"style",paraId:21,tocIndex:5},{value:"，以达到下图效果。",paraId:21,tocIndex:5},{value:" ",paraId:21,tocIndex:5},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 200,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node1',\n      type: 'polyline',\n      label: 'polyline',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // type: 'polyline',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      radius: 10,\n      offset: 10,\n      stroke: 'steelblue',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:23,tocIndex:5},{value:"Object 类型。支持 ",paraId:24,tocIndex:6},{value:"边通用标签配置",paraId:25,tocIndex:6},{value:"。基于上面 ",paraId:24,tocIndex:6},{value:"样式属性 style",paraId:26,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:24,tocIndex:6},{value:"defaultEdge",paraId:24,tocIndex:6},{value:" 中增加了  ",paraId:24,tocIndex:6},{value:"labelCfg",paraId:24,tocIndex:6},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:24,tocIndex:6},{value:" ",paraId:24,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      refY: -10,\n      refX: 60,\n    },\n  },\n});\n// ...\n",paraId:27,tocIndex:6}]},36191:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了  quadratic  边，其默认样式如下。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置边",paraId:2,tocIndex:0},{value:"  一节所示，配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.edge(edgeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"source",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"target",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每条边数据中外，其余的 ",paraId:4,tocIndex:0},{value:"边的通用属性",paraId:5,tocIndex:0},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultEdge",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'quadratic'",paraId:6,tocIndex:1},{value:"，即可使用 quadratic  边。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'quadratic',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'quadratic',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"quadratic 边支持 ",paraId:10,tocIndex:3},{value:"边通用配置项",paraId:11,tocIndex:3},{value:"，以下表格对部分常用配置项进行说明。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"color",paraId:12,tocIndex:3},{value:"边的颜色",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"优先级低于 style 中的 stroke",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"边的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本文字",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"controlPoints",paraId:12,tocIndex:3},{value:"控制点数组",paraId:12,tocIndex:3},{value:"Array",paraId:12,tocIndex:3},{value:"不指定时将会使用默认的控制点：曲线中心附近。示例：",paraId:12,tocIndex:3},{value:"[{ x: 10, y: 20 }]",paraId:12,tocIndex:3},{value:"curveOffset",paraId:12,tocIndex:3},{value:"控制点距离两端点连线的距离，可理解为控制边的弯曲程度",paraId:12,tocIndex:3},{value:"Number / Number[]",paraId:12,tocIndex:3},{value:"cubic、horizontal、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有",paraId:12,tocIndex:3},{value:"curvePosition",paraId:12,tocIndex:3},{value:"控制点在两端点连线上的相对位置，范围 0 ～ 1",paraId:12,tocIndex:3},{value:"Number / Number[]",paraId:12,tocIndex:3},{value:"cubic、horizontal、cubic-vertical、cubic-horizontal 等贝塞尔曲线特有",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"Object 类型。配置项与 ",paraId:14,tocIndex:4},{value:"边通用样式属性",paraId:15,tocIndex:4},{value:" 相同。下面代码演示在实例化图时全局配置方法中配置 ",paraId:14,tocIndex:4},{value:"style",paraId:14,tocIndex:4},{value:"。",paraId:14,tocIndex:4},{value:" ",paraId:14,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 100,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      source: 'node0',\n      target: 'node1',\n      type: 'quadratic',\n      label: 'quadratic',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // type: 'quadratic',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      stroke: '#088',\n      endArrow: true,\n      lineWidth: 3,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:16,tocIndex:4},{value:"Object 类型。支持 ",paraId:17,tocIndex:5},{value:"边通用标签配置",paraId:18,tocIndex:5},{value:"。基于上面 ",paraId:17,tocIndex:5},{value:"样式属性 style",paraId:19,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:17,tocIndex:5},{value:"defaultEdge",paraId:17,tocIndex:5},{value:" 中增加了  ",paraId:17,tocIndex:5},{value:"labelCfg",paraId:17,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:17,tocIndex:5},{value:" ",paraId:17,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultEdge: {\n    // ... 其他配置\n    labelCfg: {\n      refY: 10,\n      refX: 40,\n    },\n  },\n});\n// ...\n",paraId:20,tocIndex:5}]},47954:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 除了提供丰富的 ",paraId:0},{value:"内置边",paraId:1},{value:"  外，还提供了自定义边的机制，方便用户开发更加定制化的边，包括含有复杂图形的边、复杂交互的边、带有动画的边等。",paraId:0},{value:"用户可以通过 ",paraId:2},{value:"G6.registerEdge(typeName: string, edgeDefinition: object, extendedEdgeType?: string)",paraId:2},{value:" 注册一个新的边类型，其中：",paraId:2},{value:"typeName",paraId:3},{value:"：该新边类型名称；",paraId:3},{value:"extendedEdgeType",paraId:3},{value:"：被继承的边类型，可以是内置边类型名，也可以是其他自定义边的类型名。",paraId:3},{value:"extendedEdgeType",paraId:3},{value:" 未指定时代表不继承其他类型的边；",paraId:3},{value:"edgeDefinition",paraId:3},{value:"：该新边类型的定义，其中必要函数详见 ",paraId:3},{value:"自定义机制 API",paraId:4},{value:"。当有 ",paraId:3},{value:"extendedEdgeType",paraId:3},{value:" 时，没被复写的函数将会继承 ",paraId:3},{value:"extendedEdgeType",paraId:3},{value:" 的定义。",paraId:3},{value:"需要注意的是",paraId:5},{value:"，自定义边/节点时，若给定了 ",paraId:5},{value:"extendedEdgeType",paraId:5},{value:"，如 ",paraId:5},{value:"draw",paraId:5},{value:"，",paraId:5},{value:"update",paraId:5},{value:"，",paraId:5},{value:"setState",paraId:5},{value:" 等必要的函数若不在 ",paraId:5},{value:"edgeDefinition",paraId:5},{value:" 中进行复写，将会继承 ",paraId:5},{value:"extendedEdgeType",paraId:5},{value:" 中的相关定义。常见问题：",paraId:5},{value:"Q：边/节点更新时，没有按照在 ",paraId:6},{value:"edgeDefinition",paraId:6},{value:" 中自定义实现的 ",paraId:6},{value:"draw",paraId:6},{value:" 或 ",paraId:6},{value:"drawShape",paraId:6},{value:" 逻辑更新。例如，有些图形没有被更新，增加了没有在 ",paraId:6},{value:"draw",paraId:6},{value:" 或 ",paraId:6},{value:"drawShape",paraId:6},{value:" 方法中定义的图形等。",paraId:6},{value:"A：由于继承了 ",paraId:6},{value:"extendedEdgeType",paraId:6},{value:"，且在 ",paraId:6},{value:"edgeDefinition",paraId:6},{value:" 中没有复写 ",paraId:6},{value:"update",paraId:6},{value:" 方法，导致边/节点更新时执行了 ",paraId:6},{value:"extendedEdgeType",paraId:6},{value:" 中的 ",paraId:6},{value:"update",paraId:6},{value:" 方法，从而与自定义的 ",paraId:6},{value:"draw",paraId:6},{value:" 或 ",paraId:6},{value:"drawShape",paraId:6},{value:" 有出入。可以通过复写 ",paraId:6},{value:"update",paraId:6},{value:" 方法为 ",paraId:6},{value:"undefined",paraId:6},{value:" 解决。当 ",paraId:6},{value:"update",paraId:6},{value:" 方法为 ",paraId:6},{value:"undefined",paraId:6},{value:" 时，边/节点的更新将会执行 ",paraId:6},{value:"draw",paraId:6},{value:" 或 ",paraId:6},{value:"drawShape",paraId:6},{value:" 进行重绘。",paraId:6},{value:"在本章中我们会通过四个案例，从简单到复杂讲解边的自定义：",paraId:7},{value:"1. 从无到有的定义边；",paraId:7},{value:"2. 扩展现有边；",paraId:7},{value:"3. 增加额外图形；",paraId:7},{value:"4. 边的交互样式；",paraId:7},{value:"5. 自定义带箭头的边。",paraId:7},{value:"我们来实现垂直的折线：",paraId:8,tocIndex:0},{value:"（左）直线边。（中）默认的折线边。（右）调整了节点的锚点（连入点）后的折线边。",paraId:9,tocIndex:0},{value:"G6.registerEdge('hvh', {\n  draw(cfg, group) {\n    const startPoint = cfg.startPoint;\n    const endPoint = cfg.endPoint;\n    const shape = group.addShape('path', {\n      attrs: {\n        stroke: '#333',\n        path: [\n          ['M', startPoint.x, startPoint.y],\n          ['L', endPoint.x / 3 + (2 / 3) * startPoint.x, startPoint.y], // 三分之一处\n          ['L', endPoint.x / 3 + (2 / 3) * startPoint.x, endPoint.y], // 三分之二处\n          ['L', endPoint.x, endPoint.y],\n        ],\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'path-shape',\n    });\n    return shape;\n  },\n});\n",paraId:10,tocIndex:1},{value:"上面自定义边中的 ",paraId:11,tocIndex:1},{value:"startPoint",paraId:11,tocIndex:1},{value:" 和 ",paraId:11,tocIndex:1},{value:"endPoint",paraId:11,tocIndex:1},{value:" 分别是是边两端与起始节点和结束节点的交点；",paraId:11,tocIndex:1},{value:"可以通过修改节点的锚点（边连入点）来改变 ",paraId:11,tocIndex:1},{value:"startPoint",paraId:11,tocIndex:1},{value:" 和 ",paraId:11,tocIndex:1},{value:"endPoint",paraId:11,tocIndex:1},{value:" 的位置。",paraId:11,tocIndex:1},{value:"通过以下的数据，使用自定义的 hvh 边，就可以实现上图最右边的效果。",paraId:12,tocIndex:2},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      x: 100,\n      y: 200,\n      anchorPoints: [\n        [0, 0.5],\n        [1, 0.5],\n      ],\n    },\n    {\n      id: 'node2',\n      x: 200,\n      y: 100,\n      anchorPoints: [\n        [0, 0.5],\n        [1, 0.5],\n      ],\n    },\n    {\n      id: 'node3',\n      x: 200,\n      y: 300,\n      anchorPoints: [\n        [0, 0.5],\n        [1, 0.5],\n      ],\n    },\n  ],\n  edges: [\n    {\n      id: 'edge1',\n      target: 'node2',\n      source: 'node1',\n      type: 'hvh',\n    },\n    {\n      id: 'edge2',\n      target: 'node3',\n      source: 'node1',\n      type: 'hvh',\n    },\n  ],\n};\n",paraId:13,tocIndex:2},{value:"通过 ",paraId:14,tocIndex:3},{value:"afterDraw",paraId:14,tocIndex:3},{value:" 接口给现有的曲线增加动画。",paraId:14,tocIndex:3},{value:"G6.registerEdge(\n  'line-growth',\n  {\n    afterDraw(cfg, group) {\n      const shape = group.get('children')[0];\n      const length = shape.getTotalLength();\n      shape.animate(\n        (ratio) => {\n          const startLen = ratio * length;\n          const cfg = {\n            lineDash: [startLen, length - startLen],\n          };\n          return cfg;\n        },\n        {\n          repeat: true,\n          duration: 2000,\n        },\n      );\n    },\n  },\n  'cubic',\n);\n",paraId:15,tocIndex:3},{value:"通过实现 ",paraId:16,tocIndex:4},{value:"afterDraw",paraId:16,tocIndex:4},{value:" 增加额外图形，为找到边的主要图形 ",paraId:16,tocIndex:4},{value:"path",paraId:16,tocIndex:4},{value:" 上的某个点，可以使用 ",paraId:16,tocIndex:4},{value:"shape.getPoint(ratio)",paraId:16,tocIndex:4},{value:" 获得。",paraId:16,tocIndex:4},{value:"G6.registerEdge(\n  'mid-point-edge',\n  {\n    afterDraw(cfg, group) {\n      // 获取图形组中的第一个图形，在这里就是边的路径图形\n      const shape = group.get('children')[0];\n      // 获取路径图形的中点坐标\n      const midPoint = shape.getPoint(0.5);\n      // 在中点增加一个矩形，注意矩形的原点在其左上角\n      group.addShape('rect', {\n        attrs: {\n          width: 10,\n          height: 10,\n          fill: '#f00',\n          // x 和 y 分别减去 width / 2 与 height / 2，使矩形中心在 midPoint 上\n          x: midPoint.x - 5,\n          y: midPoint.y - 5,\n        },\n        name: 'mid-point-edge-rect', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n    },\n    update: undefined,\n  },\n  'cubic',\n);\n",paraId:17,tocIndex:4},{value:"以点击选中、鼠标 hover 到边为示例，实现如下需求：",paraId:18,tocIndex:5},{value:"点击边时边变粗，再点击变成细；",paraId:19,tocIndex:5},{value:"鼠标移动上去变成红色，离开变成 ",paraId:19,tocIndex:5},{value:"'#333'",paraId:19,tocIndex:5},{value:" 。",paraId:19,tocIndex:5},{value:"效果如下图所示。",paraId:20,tocIndex:5},{value:"⚠️注意:",paraId:21},{value:"边过细时点击很难被击中，可以设置  ",paraId:22,tocIndex:5},{value:"lineAppendWidth",paraId:22,tocIndex:5},{value:"  来提升击中范围。",paraId:22,tocIndex:5},{value:"// 基于 line 扩展出新的边\nG6.registerEdge(\n  'custom-edge',\n  {\n    // 响应状态变化\n    setState(name, value, item) {\n      const group = item.getContainer();\n      const shape = group.get('children')[0]; // 顺序根据 draw 时确定\n      if (name === 'active') {\n        if (value) {\n          shape.attr('stroke', 'red');\n        } else {\n          shape.attr('stroke', '#333');\n        }\n      }\n      if (name === 'selected') {\n        if (value) {\n          shape.attr('lineWidth', 3);\n        } else {\n          shape.attr('lineWidth', 2);\n        }\n      }\n    },\n  },\n  'line',\n);\n\n// 点击时选中，再点击时取消\ngraph.on('edge:click', (ev) => {\n  const edge = ev.item;\n  graph.setItemState(edge, 'selected', !edge.hasState('selected')); // 切换选中\n});\n\ngraph.on('edge:mouseenter', (ev) => {\n  const edge = ev.item;\n  graph.setItemState(edge, 'active', true);\n});\n\ngraph.on('edge:mouseleave', (ev) => {\n  const edge = ev.item;\n  graph.setItemState(edge, 'active', false);\n});\n",paraId:23,tocIndex:5},{value:"G6（v3.5.8 及后续版本）为内置边、自定义边提供了",paraId:24,tocIndex:6},{value:"默认箭头和内置箭头",paraId:25,tocIndex:6},{value:"。很多时候，G6 提供的箭头并不能满足业务上的需求，这个时候，就需要我们自定义箭头。",paraId:24,tocIndex:6},{value:"（左）G6 内置箭头。（右）自定义边带有自定义箭头。",paraId:26,tocIndex:6},{value:"⚠️ 注意:",paraId:27,tocIndex:6},{value:" G6 3.4.1 后的自定义箭头坐标系有所变化。如下图所示，左图为 G6 3.4.1 之前版本的演示，右图为 G6 3.4.1 及之后版本的演示。箭头由指向 x 轴负方向更正为指向 x 轴正方向。同时，偏移量 ",paraId:27,tocIndex:6},{value:"d",paraId:27,tocIndex:6},{value:" 的方向也发生响应变化。不变的是，自定义箭头本身坐标系的原点都与相应边 / path 的端点重合，且自定义箭头的斜率与相应边 / path 端点处的微分斜率相同。",paraId:27,tocIndex:6},{value:"（左）v3.4.1 之前的自定义箭头坐标系演示。（右）v3.4.1 及之后版本的自定义箭头坐标系演示。",paraId:28,tocIndex:6},{value:"G6 中有三种途径在边上配置自定义箭头：",paraId:29,tocIndex:6},{value:"配置自定义箭头到边的全局配置中；",paraId:30,tocIndex:6},{value:"在数据中为单条边配置；",paraId:30,tocIndex:6},{value:"在自定义边中配置。",paraId:30,tocIndex:6},{value:"const graph = new Graph({\n  // ... 图的其他配置项\n  defaultEdge: {\n    style: {\n      endArrow: {\n        // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n        path: 'M 0,0 L 20,10 L 20,-10 Z',\n        // 箭头的偏移量，负值代表向 x 轴正方向移动\n        // d: -10,\n        // v3.4.1 后支持各样式属性\n        fill: '#333',\n        stroke: '#666',\n        opacity: 0.8,\n        // ...\n      },\n    },\n  },\n});\n",paraId:31,tocIndex:7},{value:"const data = {\n  nodes: [\n    { id: 'node1' },\n    { id: 'node2' },\n    // ... 其他节点\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n      style: {\n        endArrow: {\n          // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n          path: 'M 0,0 L 20,10 L 20,-10 Z',\n          // 箭头的偏移量，负值代表向 x 轴正方向移动\n          // d: -10,\n          // v3.4.1 后支持各样式属性\n          fill: '#333',\n          stroke: '#666',\n          opacity: 0.8,\n          // ...\n        },\n      },\n    },\n    //... 其他边\n  ],\n};\n",paraId:32,tocIndex:8},{value:"// 使用方法二：自定义边，并带有自定义箭头\nG6.registerEdge('line-arrow', {\n  draw(cfg, group) {\n    const { startPoint, endPoint } = cfg;\n    const keyShape = group.addShape('path', {\n      attrs: {\n        path: [\n          ['M', startPoint.x, startPoint.y],\n          ['L', endPoint.x, endPoint.y],\n        ],\n        stroke: 'steelblue',\n        lineWidth: 3,\n        startArrow: {\n          // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n          path: 'M 0,0 L 20,10 L 20,-10 Z',\n          // 箭头的偏移量，负值代表向 x 轴正方向移动\n          // d: -10,\n          // v3.4.1 后支持各样式属性\n          fill: '#333',\n          stroke: '#666',\n          opacity: 0.8,\n          // ...\n        },\n        endArrow: {\n          // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n          path: 'M 0,0 L 20,10 L 20,-10 Z',\n          // 箭头的偏移量，负值代表向 x 轴正方向移动\n          // d: -10,\n          // v3.4.1 后支持各样式属性\n          fill: '#333',\n          stroke: '#666',\n          opacity: 0.8,\n          // ...\n        },\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'path-shape',\n    });\n    return keyShape;\n  },\n});\n",paraId:33,tocIndex:9}]},45651:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了 9 种内置边：",paraId:0},{value:"line：直线，不支持控制点；",paraId:1},{value:"polyline：折线，支持多个控制点；",paraId:1},{value:"arc：圆弧线；",paraId:1},{value:"quadratic：二阶贝塞尔曲线；",paraId:1},{value:"cubic：三阶贝塞尔曲线；",paraId:1},{value:"cubic-vertical：垂直方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点；",paraId:1},{value:"cubic-horizontal：水平方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点；",paraId:1},{value:"loop：自环。",paraId:1},{value:"这些内置边的默认样式分别如下图所示。",paraId:2},{value:" ",paraId:2},{value:"本文将概述 G6 中的各个内置边类型、内置边的通用属性、配置方法。各类型边详细配置项及配置方法见本目录下相应文档。",paraId:3},{value:"下面表格中显示了内置的各类边，同时对一些特殊的字段进行了说明：",paraId:4,tocIndex:0},{value:"名称",paraId:5,tocIndex:0},{value:"描述",paraId:5,tocIndex:0},{value:"line",paraId:5,tocIndex:0},{value:"连接两个节点的直线：",paraId:5,tocIndex:0},{value:"- ",paraId:5,tocIndex:0},{value:"controlPoints",paraId:5,tocIndex:0},{value:" 不生效",paraId:5,tocIndex:0},{value:"- 更多配置详见 line 边的配置",paraId:5,tocIndex:0},{value:"polyline",paraId:5,tocIndex:0},{value:"多段线段构成的折线，连接两个端点：",paraId:5,tocIndex:0},{value:"- ",paraId:5,tocIndex:0},{value:"controlPoints",paraId:5,tocIndex:0},{value:" 表示所有线段的拐点，不指定时根据 ",paraId:5,tocIndex:0},{value:"A* 算法",paraId:5,tocIndex:0},{value:"自动生成折线",paraId:5,tocIndex:0},{value:"- 更多配置详见 polyline 边的配置",paraId:5,tocIndex:0},{value:"arc",paraId:5,tocIndex:0},{value:"连接两个节点的一段圆弧：",paraId:5,tocIndex:0},{value:"- ",paraId:5,tocIndex:0},{value:"controlPoints",paraId:5,tocIndex:0},{value:" 不生效",paraId:5,tocIndex:0},{value:"- 使用 curveOffset 指定弧的弯曲程度，其正负影响弧弯曲的方向",paraId:5,tocIndex:0},{value:"- 更多配置详见 arc 边的配置",paraId:5,tocIndex:0},{value:"quadratic",paraId:5,tocIndex:0},{value:"只有一个控制点的曲线：",paraId:5,tocIndex:0},{value:"- ",paraId:5,tocIndex:0},{value:"controlPoints",paraId:5,tocIndex:0},{value:" 不指定时，会默认线的一半处弯曲",paraId:5,tocIndex:0},{value:"- 更多配置详见 quadratic 边的配置",paraId:5,tocIndex:0},{value:"cubic",paraId:5,tocIndex:0},{value:"有两个控制点的曲线：",paraId:5,tocIndex:0},{value:"- ",paraId:5,tocIndex:0},{value:"controlPoints",paraId:5,tocIndex:0},{value:" 不指定时，会默认线的 1/3, 2/3 处弯曲",paraId:5,tocIndex:0},{value:"- 更多配置详见 cubic 边的配置",paraId:5,tocIndex:0},{value:"cubic-vertical",paraId:5,tocIndex:0},{value:"垂直方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点",paraId:5,tocIndex:0},{value:"cubic-horizontal",paraId:5,tocIndex:0},{value:"水平方向的三阶贝塞尔曲线，不考虑用户从外部传入的控制点",paraId:5,tocIndex:0},{value:"loop",paraId:5,tocIndex:0},{value:"自环。更多配置详见 loop 边的配置",paraId:5,tocIndex:0},{value:"所有内置的边支持的通用属性：",paraId:6,tocIndex:1},{value:"名称",paraId:7,tocIndex:1},{value:"是否必须",paraId:7,tocIndex:1},{value:"类型",paraId:7,tocIndex:1},{value:"备注",paraId:7,tocIndex:1},{value:"id",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"边唯一 ID，",paraId:7,tocIndex:1},{value:"必须",paraId:7,tocIndex:1},{value:"是唯一的 string",paraId:7,tocIndex:1},{value:"source",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"起始点 id",paraId:7,tocIndex:1},{value:"target",paraId:7,tocIndex:1},{value:"true",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"结束点 id",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"指定边的类型，可以是内置边的类型名称，也可以是自定义边的名称。默认为 ",paraId:7,tocIndex:1},{value:"'line'",paraId:7,tocIndex:1},{value:"sourceAnchor",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"Number",paraId:7,tocIndex:1},{value:"边的起始节点上的锚点的索引值",paraId:7,tocIndex:1},{value:"targetAnchor",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"Number",paraId:7,tocIndex:1},{value:"边的终止节点上的锚点的索引值",paraId:7,tocIndex:1},{value:"style",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"Object",paraId:7,tocIndex:1},{value:"边的样式属性",paraId:7,tocIndex:1},{value:"label",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"String",paraId:7,tocIndex:1},{value:"文本文字，如果没有则不会显示",paraId:7,tocIndex:1},{value:"labelCfg",paraId:7,tocIndex:1},{value:"false",paraId:7,tocIndex:1},{value:"Object",paraId:7,tocIndex:1},{value:"文本配置项",paraId:7,tocIndex:1},{value:"Object 类型。通过 ",paraId:8,tocIndex:2},{value:"style",paraId:8,tocIndex:2},{value:" 配置来修改边的颜色、线宽等属性。下表是 ",paraId:8,tocIndex:2},{value:"style",paraId:8,tocIndex:2},{value:" 对象中常用的配置项：",paraId:8,tocIndex:2},{value:"名称",paraId:9,tocIndex:2},{value:"是否必须",paraId:9,tocIndex:2},{value:"类型",paraId:9,tocIndex:2},{value:"备注",paraId:9,tocIndex:2},{value:"stroke",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"String",paraId:9,tocIndex:2},{value:"边的颜色",paraId:9,tocIndex:2},{value:"lineWidth",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"边宽度",paraId:9,tocIndex:2},{value:"lineAppendWidth",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"边响应鼠标事件时的检测宽度，当 ",paraId:9,tocIndex:2},{value:"lineWidth",paraId:9,tocIndex:2},{value:" 太小而不易选中时，可以通过该参数提升击中范围",paraId:9,tocIndex:2},{value:"endArrow",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Boolean / Object",paraId:9,tocIndex:2},{value:"为 ",paraId:9,tocIndex:2},{value:"true",paraId:9,tocIndex:2},{value:" 时在边的结束端绘制默认箭头，为 ",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:" 时不绘制结束端箭头；也可以使用",paraId:9,tocIndex:2},{value:"内置箭头配置",paraId:10,tocIndex:2},{value:"，例如：",paraId:9,tocIndex:2},{value:"endArrow: {",paraId:9,tocIndex:2},{value:" path: G6.Arrow.vee(10, 20, 10), // 内置箭头，参数为箭头宽度、长度、偏移量 d（默认为 0）",paraId:9,tocIndex:2},{value:" d: 10 // 偏移量",paraId:9,tocIndex:2},{value:"} ；或通过 path 自定义的箭头，例如：",paraId:9,tocIndex:2},{value:"endArrow: {",paraId:9,tocIndex:2},{value:" path: 'M 0,0 L 20,10 L 20,-10 Z', // 自定义箭头路径",paraId:9,tocIndex:2},{value:" d: -2 // 偏移量",paraId:9,tocIndex:2},{value:"}",paraId:9,tocIndex:2},{value:"startArrow",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Boolean / Object",paraId:9,tocIndex:2},{value:"为 ",paraId:9,tocIndex:2},{value:"true",paraId:9,tocIndex:2},{value:" 时在边的开始端绘制默认箭头，为 ",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:" 时不绘制结束端箭头；也可以使用",paraId:9,tocIndex:2},{value:"内置箭头配置",paraId:11,tocIndex:2},{value:"，例如：",paraId:9,tocIndex:2},{value:"startArrow: {",paraId:9,tocIndex:2},{value:" path: G6.Arrow.vee(10, 20, 10), // 内置箭头，参数为箭头宽度、长度、偏移量 d（默认为 0）",paraId:9,tocIndex:2},{value:" d: 10 // 偏移量",paraId:9,tocIndex:2},{value:"} ；或通过 path 自定义的箭头，例如：",paraId:9,tocIndex:2},{value:"startArrow: {",paraId:9,tocIndex:2},{value:" path: 'M 0,0 L 20,10 L 20,-10 Z', // 自定义箭头路径",paraId:9,tocIndex:2},{value:" d: -2 // 偏移量",paraId:9,tocIndex:2},{value:"}",paraId:9,tocIndex:2},{value:"strokeOpacity",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"边透明度",paraId:9,tocIndex:2},{value:"shadowColor",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"String",paraId:9,tocIndex:2},{value:"阴影颜色",paraId:9,tocIndex:2},{value:"shadowBlur",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"阴影模糊程度",paraId:9,tocIndex:2},{value:"shadowOffsetX",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"阴影 x 方向偏移量",paraId:9,tocIndex:2},{value:"shadowOffsetY",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Number",paraId:9,tocIndex:2},{value:"阴影 y 方向偏移量",paraId:9,tocIndex:2},{value:"lineDash",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"Array",paraId:9,tocIndex:2},{value:"设置线的虚线样式，可以指定一个数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。",paraId:9,tocIndex:2},{value:"cursor",paraId:9,tocIndex:2},{value:"false",paraId:9,tocIndex:2},{value:"String",paraId:9,tocIndex:2},{value:"鼠标在该边上时的鼠标样式，",paraId:9,tocIndex:2},{value:"CSS 的 cursor",paraId:9,tocIndex:2},{value:" 选项都支持",paraId:9,tocIndex:2},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:12,tocIndex:2},{value:"style",paraId:12,tocIndex:2},{value:"：",paraId:12,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // ... 其他属性\n    style: {\n      stroke: '#eaff8f',\n      lineWidth: 5,\n      // ... 其他样式属性\n    },\n  },\n});\n",paraId:13,tocIndex:2},{value:"label",paraId:14,tocIndex:3},{value:" String 类型。标签文本的文字内容。",paraId:14,tocIndex:3},{value:"labelCfg",paraId:14,tocIndex:3},{value:" Object 类型。配置标签文本。下面是 ",paraId:14,tocIndex:3},{value:"labelCfg",paraId:14,tocIndex:3},{value:" 对象中的常用配置项：",paraId:14,tocIndex:3},{value:"名称",paraId:15,tocIndex:3},{value:"是否必须",paraId:15,tocIndex:3},{value:"类型",paraId:15,tocIndex:3},{value:"备注",paraId:15,tocIndex:3},{value:"refX",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"Number",paraId:15,tocIndex:3},{value:"标签在 x 方向的偏移量",paraId:15,tocIndex:3},{value:"refY",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"Number",paraId:15,tocIndex:3},{value:"标签在 y 方向的偏移量",paraId:15,tocIndex:3},{value:"position",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"String",paraId:15,tocIndex:3},{value:"文本相对于边的位置，目前支持的位置有：",paraId:15,tocIndex:3},{value:"'start'",paraId:15,tocIndex:3},{value:"，",paraId:15,tocIndex:3},{value:"'middle'",paraId:15,tocIndex:3},{value:"，",paraId:15,tocIndex:3},{value:"'end'",paraId:15,tocIndex:3},{value:"。默认为",paraId:15,tocIndex:3},{value:"'middle'",paraId:15,tocIndex:3},{value:"。",paraId:15,tocIndex:3},{value:"autoRotate",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"Boolean",paraId:15,tocIndex:3},{value:"标签文字是否跟随边旋转，默认 ",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"style",paraId:15,tocIndex:3},{value:"false",paraId:15,tocIndex:3},{value:"Object",paraId:15,tocIndex:3},{value:"标签的样式属性",paraId:15,tocIndex:3},{value:"上表中的标签的样式属性 ",paraId:16,tocIndex:3},{value:"style",paraId:16,tocIndex:3},{value:" 的常用配置项如下：",paraId:16,tocIndex:3},{value:"名称",paraId:17,tocIndex:3},{value:"是否必须",paraId:17,tocIndex:3},{value:"类型",paraId:17,tocIndex:3},{value:"备注",paraId:17,tocIndex:3},{value:"fill",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"String",paraId:17,tocIndex:3},{value:"文本颜色",paraId:17,tocIndex:3},{value:"stroke",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"String",paraId:17,tocIndex:3},{value:"文本描边颜色",paraId:17,tocIndex:3},{value:"lineWidth",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"Number",paraId:17,tocIndex:3},{value:"文本描边粗细",paraId:17,tocIndex:3},{value:"opacity",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"Number",paraId:17,tocIndex:3},{value:"文本透明度",paraId:17,tocIndex:3},{value:"fontFamily",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"String",paraId:17,tocIndex:3},{value:"文本字体",paraId:17,tocIndex:3},{value:"fontSize",paraId:17,tocIndex:3},{value:"false",paraId:17,tocIndex:3},{value:"Number",paraId:17,tocIndex:3},{value:"文本字体大小",paraId:17,tocIndex:3},{value:"... 节点标签与边标签样式属性相同，统一整理在 ",paraId:17,tocIndex:3},{value:"Text 图形 API",paraId:18,tocIndex:3},{value:"下面代码演示在实例化图时全局配置方法中配置  ",paraId:19,tocIndex:3},{value:"label",paraId:19,tocIndex:3},{value:" 和  ",paraId:19,tocIndex:3},{value:"labelCfg",paraId:19,tocIndex:3},{value:"。",paraId:19,tocIndex:3},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    // ... 其他属性\n    label: 'edge-label',\n    labelCfg: {\n      refY: -10,\n      refX: 60,\n    },\n  },\n});\n",paraId:20,tocIndex:3},{value:"配置边的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:21,tocIndex:4},{value:"graph.edge(edgeFn)",paraId:21,tocIndex:4},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:21,tocIndex:4},{value:"使用 graph.edge(edgeFn) 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:22,tocIndex:4},{value:"即有相同的配置项时，优先级高的方式将会覆盖优先级低的。",paraId:23,tocIndex:4},{value:"⚠️ 注意:",paraId:24,tocIndex:4},{value:" 除 ",paraId:24,tocIndex:4},{value:"id",paraId:24,tocIndex:4},{value:"、",paraId:24,tocIndex:4},{value:"source",paraId:24,tocIndex:4},{value:"、",paraId:24,tocIndex:4},{value:"target",paraId:24,tocIndex:4},{value:"、",paraId:24,tocIndex:4},{value:"label",paraId:24,tocIndex:4},{value:" 应当配置到每条边数据中外，其余的 ",paraId:24,tocIndex:4},{value:"边的通用属性",paraId:25,tocIndex:4},{value:" 以及各个边类型的特有属性（见内置边类型）均支持三种配置方式。",paraId:24,tocIndex:4},{value:"用户在实例化 Graph 时候可以通过 ",paraId:26,tocIndex:5},{value:"defaultEdge",paraId:26,tocIndex:5},{value:"  配置边，这里的配置是全局的配置，将会在所有边上生效。",paraId:26,tocIndex:5},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultEdge: {\n    type: 'line',\n    // ... 其他配置\n  },\n});\n",paraId:27,tocIndex:5},{value:"如果需要使不同边有不同的配置，可以将配置写入到边数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:28,tocIndex:6},{value:"const data = {\n  nodes: [\n    ... // 节点\n  ],\n  edges: [{\n    source: 'node0',\n    target: 'node1'\n    type: 'polyline',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },{\n    source: 'node1',\n    target: 'node2'\n    type: 'cubic',\n    ... // 其他配置\n    style: {\n      ...  // 样式属性，每种边的详细样式属性参见各边文档\n    }\n  },\n    ... // 其他边\n  ]\n}\n",paraId:29,tocIndex:6},{value:"该方法可以为不同边进行不同的配置。",paraId:30,tocIndex:7},{value:"提示：",paraId:30,tocIndex:7},{value:"该方法必须",paraId:31,tocIndex:7},{value:"在 render 之前调用",paraId:31,tocIndex:7},{value:"，否则不起作用；",paraId:31,tocIndex:7},{value:"由于该方法优先级最高，将覆盖其他地方对边的配置，这可能将造成一些其他配置不生效的疑惑；",paraId:31,tocIndex:7},{value:"该方法在增加元素、更新元素时会被调用，如果数据量大、每条边上需要更新的内容多时，可能会有性能问题。",paraId:31,tocIndex:7},{value:"// const data = ...\n// const graph = ...\ngraph.edge((edge) => {\n  return {\n    id: edge.id,\n    type: 'polyline',\n    style: {\n      fill: 'steelblue',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:32,tocIndex:7},{value:"const data = {\n  nodes: [\n    { id: '1', x: 50, y: 50, size: 20 },\n    { id: '2', x: 150, y: 50, size: 20 },\n    { id: '3', x: 200, y: 50, size: 20 },\n    { id: '4', x: 300, y: 130, size: 20 },\n    { id: '5', x: 350, y: 50, size: 20 },\n    { id: '6', x: 450, y: 50, size: 20 },\n    { id: '7', x: 500, y: 50, size: 20 },\n    { id: '8', x: 600, y: 50, size: 20 },\n    { id: '9', x: 650, y: 50, size: 20 },\n    { id: '10', x: 750, y: 50, size: 20 },\n    { id: '11', x: 800, y: 50, size: 20 },\n    { id: '12', x: 900, y: 150, size: 20 },\n    { id: '13', x: 950, y: 50, size: 20 },\n    { id: '14', x: 1050, y: 150, size: 20 },\n    { id: '15', x: 1100, y: 50, size: 20 },\n  ],\n  edges: [\n    { source: '1', target: '2', type: 'line', label: 'line' },\n    { source: '3', target: '4', type: 'polyline', label: 'polyline' },\n    { source: '5', target: '6', type: 'arc', label: 'arc' },\n    { source: '7', target: '8', type: 'quadratic', label: 'quadratic' },\n    { source: '9', target: '10', type: 'cubic', label: 'cubic' },\n    { source: '11', target: '12', type: 'cubic-vertical', label: 'cubic-vertical' },\n    { source: '13', target: '14', type: 'cubic-horizontal', label: 'cubic-horizontal' },\n    { source: '15', target: '15', type: 'loop', label: 'loop' },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1500,\n  height: 300,\n  linkCenter: true, // 使边连入节点的中心\n});\ngraph.data(data);\ngraph.render();\n",paraId:33,tocIndex:8},{value:"显示结果：",paraId:34,tocIndex:8},{value:" ",paraId:34,tocIndex:8},{value:"可以在边上添加文本，修改边的样式。下面演示将配置写入数据的方式配置边。使用下面代码替换上面代码中的 9-10、11-12 两条边数据，修改这两条边的样式和其文本。",paraId:35,tocIndex:9},{value:"// 使 9-10 的 cubic 边文本下移 15 像素\n{\n  source: '9',\n  target: '10',\n  type: 'cubic',\n  label: 'cubic',\n  labelCfg: {\n    refY: -15 // refY 默认是顺时针方向向下，所以需要设置负值\n  }\n},\n// 设置 11-12 的 cubic-vertical 边的颜色、虚线、粗细，并设置文本样式、随边旋转\n{\n  source: '11',\n  target: '12',\n  type: 'cubic-vertical',\n  color: '#722ed1',     // 边颜色\n  size: 5,              // 边粗细\n  style: {\n    lineDash: [2, 2]    // 虚线边\n  },\n  label: 'cubic-vertical',\n  labelCfg: {\n    position: 'center', // 其实默认就是 center，这里写出来便于理解\n    autoRotate: true,   // 使文本随边旋转\n    style: {\n      stroke: 'white',  // 给文本添加白边和白色背景\n      lineWidth: 5,     // 文本白边粗细\n      fill: '#722ed1',  // 文本颜色\n    }\n  }\n}\n",paraId:36,tocIndex:9},{value:"状态 State",paraId:37,tocIndex:10},{value:" —— 交互过程中的样式变化。",paraId:38,tocIndex:10}]},86476:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"使用下面六个函数可以实现节点、边、Combo 的显示/隐藏：",paraId:0,tocIndex:0},{value:"// 显示节点实例 nodeItem，该节点的 visible 属性值在该方法调用后被置为 true\nnodeItem.show();\n\n// 隐藏节点实例 nodeItem，该节点的 visible 属性值在该方法调用后被置为 false\nnodeItem.hide();\n\n// 显示边实例 edgeItem，该边的 visible 属性值在该方法调用后被置为 true\nedgeItem.show();\n\n// 隐藏边实例 edgeItem，该边的 visible 属性值在该方法调用后被置为 false\nedgeItem.hide();\n\n// 显示边实例 comboItem，该 Combo 的 visible 属性值在该方法调用后被置为 true\ncomboItem.show();\n\n// 隐藏边实例 comboItem，该 Combo 的 visible 属性值在该方法调用后被置为 false\ncomboItem.hide();\n",paraId:1,tocIndex:0},{value:"该示例摘取了元素显示/隐藏的相关操作部分，通过鼠标监听对节点、边、画布的点击事件，显示和隐藏元素：",paraId:2,tocIndex:1},{value:"// 鼠标点击节点，隐藏该节点\ngraph.on('node:click', (ev) => {\n  const node = ev.item;\n  console.log('before hide(), the nodevisible = ', node.get('visible'));\n  node.hide();\n  console.log('after hide(), the node visible = ', node.get('visible'));\n});\n\n// 鼠标点击边，隐藏该边\ngraph.on('edge:click', (ev) => {\n  const edge = ev.item;\n  console.log('before hide(), the edge visible = ', edge.get('visible'));\n  edge.hide();\n  console.log('after hide(), the edge visible = ', edge.get('visible'));\n});\n\n// 鼠标点击画布，显示所有节点和边\ngraph.on('canvas:click', (ev) => {\n  const nodes = graph.getNodes();\n  const edges = graph.getEdges();\n  nodes.forEach((node) => {\n    node.show();\n  });\n  edges.forEach((edge) => {\n    edge.show();\n  });\n});\n",paraId:3,tocIndex:1}]},49272:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"节点与边在视觉上的层级涉及到了它们相对应的 ",paraId:0},{value:"图形分组 Group",paraId:1},{value:"。本文提到的所有分组 Group 都为 G6 的图形分组 Group，而非 G6 的  ",paraId:0},{value:"节点分组 Combo",paraId:2},{value:"，其区别在 ",paraId:0},{value:"图形分组 Group",paraId:3},{value:"  中说明。",paraId:0},{value:"在 ",paraId:4},{value:"图形分组 Group",paraId:5},{value:" 中我们提到：在 G6 中，Graph 的一个实例中的所有节点属于同一个变量名为 ",paraId:4},{value:"nodeGroup",paraId:4},{value:" 的 group，所有的边属于同一个变量名为 ",paraId:4},{value:"edgeGroup",paraId:4},{value:" 的 group。节点 group 在视觉上的层级（zIndex）高于边 group，即所有节点会绘制在所有边的上层。",paraId:4},{value:"但有时，我们需要让边在视觉上在节点上层。例如，高亮节点及其相关边和邻居、高亮一条边等。可以通过配合图实例的配置项  ",paraId:6},{value:"groupByTypes",paraId:6},{value:" 以及节点和边的 ",paraId:6},{value:"toFront()",paraId:6},{value:" 与 ",paraId:6},{value:"toBack()",paraId:6},{value:" 函数实现。为实现如下效果：鼠标进入节点时，提升相关边以及邻居节点的层级；离开节点时恢复；鼠标进入边时，提升边及其两端点的层级；离开边时恢复。",paraId:6},{value:"Demo 完整代码",paraId:6},{value:"。",paraId:6},{value:"要实现上图效果，需要以下步骤：",paraId:7},{value:"Step 1：实例化图时配置 ",paraId:8},{value:"groupByTypes",paraId:8},{value:" 为 ",paraId:8},{value:"false",paraId:8},{value:"；",paraId:8},{value:"Step 2：将节点放置在边上层；",paraId:8},{value:"Step 3：监听鼠标事件并改变目标元素层级。",paraId:8},{value:"下面代码完成了引入 G6、数据设置、实例化图、渲染图的命令等。后文将修改下面这份代码中以达到上图高亮效果。",paraId:9,tocIndex:0},{value:"// 数据源\nconst data = {\n  nodes: [\n    {\n      id: 'node0',\n      x: 100,\n      y: 100,\n      size: 20,\n    },\n    {\n      id: 'node1',\n      x: 200,\n      y: 200,\n      size: 20,\n    },\n    {\n      id: 'node2',\n      x: 150,\n      y: 150,\n      size: 20,\n    },\n    {\n      id: 'node3',\n      x: 150,\n      y: 250,\n      size: 20,\n    },\n    {\n      id: 'node4',\n      x: 150,\n      y: 200,\n      size: 20,\n    },\n  ],\n  edges: [\n    {\n      id: 'edge0',\n      source: 'node0',\n      target: 'node1',\n    },\n    {\n      id: 'edge1',\n      source: 'node2',\n      target: 'node3',\n    },\n  ],\n};\n\n// 实例化图\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  // 为方便演示，加粗边\n  defaultEdge: {\n    style: {\n      lineWidth: 2,\n    },\n  },\n});\n\n// 读取数据\ngraph.data(data);\n// 渲染图\ngraph.render();\n",paraId:10,tocIndex:0},{value:"groupByTypes",paraId:11,tocIndex:1},{value:" 是图的一个配置项，当其为默认值 ",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:" 时，所有节点在一个名为 ",paraId:11,tocIndex:1},{value:"nodeGroup",paraId:11,tocIndex:1},{value:" 的分组，所有边在另一个名为 ",paraId:11,tocIndex:1},{value:"edgeGroup",paraId:11,tocIndex:1},{value:" 的分组，且 ",paraId:11,tocIndex:1},{value:"nodeGroup",paraId:11,tocIndex:1},{value:" 在 ",paraId:11,tocIndex:1},{value:"edgeGroup",paraId:11,tocIndex:1},{value:" 上层。将其设置为 ",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:" 后，将不存在 ",paraId:11,tocIndex:1},{value:"nodeGroup",paraId:11,tocIndex:1},{value:" 和 ",paraId:11,tocIndex:1},{value:"edgeGroup",paraId:11,tocIndex:1},{value:"，所有节点和边在同一个分组，它们的层级根据生成的顺序决定。",paraId:11,tocIndex:1},{value:"名称",paraId:12,tocIndex:2},{value:"类型",paraId:12,tocIndex:2},{value:"默认值",paraId:12,tocIndex:2},{value:"描述",paraId:12,tocIndex:2},{value:"groupByTypes",paraId:12,tocIndex:2},{value:"Boolean",paraId:12,tocIndex:2},{value:"true",paraId:12,tocIndex:2},{value:"各种元素是否在一个分组内，决定节点和边的层级问题，默认情况下所有的节点在一个分组中，所有的边在一个分组中，当这个参数为 ",paraId:12,tocIndex:2},{value:"false",paraId:12,tocIndex:2},{value:" 时，节点和边的层级根据生成的顺序确定。",paraId:12,tocIndex:2},{value:"更改 前提代码 中实例化图部分代码，添加 ",paraId:13,tocIndex:3},{value:"groupByTypes",paraId:13,tocIndex:3},{value:" 配置项，并设置为 ",paraId:13,tocIndex:3},{value:"false",paraId:13,tocIndex:3},{value:"：",paraId:13,tocIndex:3},{value:"const graph = new G6.Graph({\n  // ...  // 其他配置\n  groupByTypes: false,\n});\n",paraId:14,tocIndex:3},{value:"此时，将会得到如下效果：",paraId:15,tocIndex:3},{value:"上一步结果中节点在边的下层不符合常规，是由于 ",paraId:16,tocIndex:4},{value:"groupByTypes",paraId:16,tocIndex:4},{value:" 为 ",paraId:16,tocIndex:4},{value:"false",paraId:16,tocIndex:4},{value:" 时，节点和边的层级根据生成的顺序确定，而边的生成顺序在节点之后，因此所有边被绘制到了节点上方。为了使图符合常规——节点在上层，边在下层，可以在 ",paraId:16,tocIndex:4},{value:"graph.render()",paraId:16,tocIndex:4},{value:" 之后将所有的节点通过 ",paraId:16,tocIndex:4},{value:"toFront()",paraId:16,tocIndex:4},{value:" 函数提前。",paraId:16,tocIndex:4},{value:"// 将节点实例 nodeItem 提前到其父级 group 的最前面\nnodeItem.toFront();\n// 将节点实例 nodeItem 放置到其父级 group 的最后面\nnodeItem.toBack();\n// 将边实例 edgeItem 提前到其父级 group 的最前面\nedgeItem.toFront();\n// 将边实例 edgeItem 放置到其父级 group 的最后面\nedgeItem.toBack();\n",paraId:17,tocIndex:5},{value:"// const graph = ...\ngraph.data(data);\ngraph.render();\n// 获取图上的所有节点实例\nconst nodes = graph.getNodes();\n// 遍历节点实例，将所有节点提前。\nnodes.forEach((node) => {\n  node.toFront();\n});\n",paraId:18,tocIndex:6},{value:"这样，所有节点被绘制在边上层：",paraId:19,tocIndex:6},{value:"在效果图中，鼠标进入节点时，相关边和节点的层级被提升到最上层，鼠标离开节点使恢复。边同理。这一步将实现这一交互效果。",paraId:20,tocIndex:7},{value:"使用下面四个函数监听鼠标的进入、离开元素的事件：",paraId:21,tocIndex:8},{value:"// 鼠标进入节点事件\ngraph.on('node:mouseenter', (ev) => {\n  // ...\n});\n\n// 鼠标离开节点事件\ngraph.on('node:mouseleave', (ev) => {\n  // ...\n});\n\n// 鼠标进入边事件\ngraph.on('edge:mouseenter', (ev) => {\n  // ...\n});\n\n// 鼠标离开边事件\ngraph.on('edge:mouseleave', (ev) => {\n  // ...\n});\n",paraId:22,tocIndex:8},{value:"// 鼠标进入节点事件\ngraph.on('edge:mouseenter', (ev) => {\n  // 获得鼠标当前目标边\n  const edge = ev.item;\n  // 该边的起始点\n  const source = edge.getSource();\n  // 该边的结束点\n  const target = edge.getTarget();\n  // 先将边提前，再将端点提前。这样该边两个端点还是在该边上层，较符合常规。\n  edge.toFront();\n  source.toFront();\n  target.toFront();\n});\n\ngraph.on('edge:mouseleave', (ev) => {\n  // 获得图上所有边实例\n  const edges = graph.getEdges();\n  // 遍历边，将所有边的层级放置在后方，以恢复原样\n  edges.forEach((edge) => {\n    edge.toBack();\n  });\n});\n\ngraph.on('node:mouseenter', (ev) => {\n  // 获得鼠标当前目标节点\n  const node = ev.item;\n  // 获取该节点的所有相关边\n  const edges = node.getEdges();\n  // 遍历相关边，将所有相关边提前，再将相关边的两个端点提前，以保证相关边的端点在边的上方常规效果\n  edges.forEach((edge) => {\n    edge.toFront();\n    edge.getSource().toFront();\n    edge.getTarget().toFront();\n  });\n});\n\ngraph.on('node:mouseleave', (ev) => {\n  // 获得图上所有边实例\n  const edges = graph.getEdges();\n  // 遍历边，将所有边的层级放置在后方，以恢复原样\n  edges.forEach((edge) => {\n    edge.toBack();\n  });\n});\n",paraId:23,tocIndex:9}]},52944:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 3.1.4 版本中新增了 ",paraId:0},{value:"lock()",paraId:0},{value:"、",paraId:0},{value:"unlock()",paraId:0},{value:" 和 ",paraId:0},{value:"hasLocked()",paraId:0},{value:" 三个 API，方便用户锁定某个节点。默认情况下，当锁定某个节点后，拖动节点时锁定的节点不会有任何反应，但拖动画布和缩放画布时，仍然会对锁定的节点有影响，如果不想让锁定的节点收到拖动画布和缩放画布的影响，可以通过",paraId:0},{value:"自定义 Behavior",paraId:1},{value:" 的方式来实现。",paraId:0},{value:"G6 内置的 ",paraId:2,tocIndex:0},{value:"drag-canvas",paraId:2,tocIndex:0},{value:" 不区分节点是否锁定，全部一视同仁。绝大数情况下，这种行为是完全没问题的，但某些业务可能会要求锁定的节点，拖动画布时也不能移动，对于这种情况，可以通过重新定义拖动画布的 Behavior 来实现。",paraId:2,tocIndex:0},{value:"import G6 from '@antv/g6';\nconst Util = G6.Util;\nconst abs = Math.abs;\nconst DRAG_OFFSET = 10;\nconst body = document.body;\nconst ALLOW_EVENTS = [16, 17, 18];\n\nG6.registerBehavior('drag-canvas-exclude-lockedNode', {\n  getDefaultCfg() {\n    return {\n      direction: 'both',\n    };\n  },\n  getEvents() {\n    return {\n      'canvas:mousedown': 'onMouseDown',\n      'canvas:mousemove': 'onMouseMove',\n      'canvas:mouseup': 'onMouseUp',\n      'canvas:click': 'onMouseUp',\n      'canvas:mouseleave': 'onOutOfRange',\n      keyup: 'onKeyUp',\n      keydown: 'onKeyDown',\n    };\n  },\n  updateViewport(e) {\n    const origin = this.origin;\n    const clientX = +e.clientX;\n    const clientY = +e.clientY;\n    if (isNaN(clientX) || isNaN(clientY)) {\n      return;\n    }\n    let dx = clientX - origin.x;\n    let dy = clientY - origin.y;\n    if (this.get('direction') === 'x') {\n      dy = 0;\n    } else if (this.get('direction') === 'y') {\n      dx = 0;\n    }\n    this.origin = {\n      x: clientX,\n      y: clientY,\n    };\n    // 和内置 drag-canvas 不同的地方是在这里\n    const lockedNodes = this.graph.findAll('node', (node) => !node.hasLocked());\n    lockedNodes.forEach((node) => {\n      node.get('group').translate(dx, dy);\n    });\n  },\n  onMouseDown(e) {\n    if (this.keydown) {\n      return;\n    }\n\n    this.origin = { x: e.clientX, y: e.clientY };\n    this.dragging = false;\n  },\n  onMouseMove(e) {\n    if (this.keydown) {\n      return;\n    }\n\n    e = Util.cloneEvent(e);\n    const graph = this.graph;\n    if (!this.origin) {\n      return;\n    }\n    if (this.origin && !this.dragging) {\n      if (abs(this.origin.x - e.clientX) + abs(this.origin.y - e.clientY) < DRAG_OFFSET) {\n        return;\n      }\n      if (this.shouldBegin(e, this)) {\n        e.type = 'dragstart';\n        graph.emit('canvas:dragstart', e);\n        this.dragging = true;\n      }\n    }\n    if (this.dragging) {\n      e.type = 'drag';\n      graph.emit('canvas:drag', e);\n    }\n    if (this.shouldUpdate(e, this)) {\n      this.updateViewport(e);\n    }\n  },\n  onMouseUp(e) {\n    if (this.keydown) {\n      return;\n    }\n\n    if (!this.dragging) {\n      this.origin = null;\n      return;\n    }\n    e = Util.cloneEvent(e);\n    const graph = this.graph;\n    if (this.shouldEnd(e, this)) {\n      this.updateViewport(e);\n    }\n    e.type = 'dragend';\n    graph.emit('canvas:dragend', e);\n    this.endDrag();\n  },\n  endDrag() {\n    if (this.dragging) {\n      this.origin = null;\n      this.dragging = false;\n      // 终止时需要判断此时是否在监听画布外的 mouseup 事件，若有则解绑\n      const fn = this.fn;\n      if (fn) {\n        body.removeEventListener('mouseup', fn, false);\n        this.fn = null;\n      }\n    }\n  },\n  // 若在拖拽时，鼠标移出画布区域，此时放开鼠标无法终止 drag 行为。在画布外监听 mouseup 事件，放开则终止\n  onOutOfRange(e) {\n    if (this.dragging) {\n      const self = this;\n      const canvasElement = self.graph.get('canvas').get('el');\n      const fn = (ev) => {\n        if (ev.target !== canvasElement) {\n          self.onMouseUp(e);\n        }\n      };\n      this.fn = fn;\n      body.addEventListener('mouseup', fn, false);\n    }\n  },\n  onKeyDown(e) {\n    const code = e.keyCode || e.which;\n    if (!code) {\n      return;\n    }\n    if (ALLOW_EVENTS.indexOf(code) > -1) {\n      this.keydown = true;\n    } else {\n      this.keydown = false;\n    }\n  },\n  onKeyUp() {\n    this.keydown = false;\n  },\n});\n",paraId:3,tocIndex:0},{value:"默认情况下，G6 内置的 ",paraId:4,tocIndex:1},{value:"zoom-canvas",paraId:4,tocIndex:1},{value:" 在缩放画布时候也会对锁定的节点缩放，如果缩放过程中不需要操作锁定的节点，则可以通过下面的方式来实现。",paraId:4,tocIndex:1},{value:"const DELTA = 0.05;\n\nG6.registerBehavior('zoom-canvas-exclude-lockedNode', {\n  getDefaultCfg() {\n    return {\n      sensitivity: 2,\n      minZoom: 0.1,\n      maxZoom: 10,\n    };\n  },\n  getEvents() {\n    return {\n      wheel: 'onWheel',\n    };\n  },\n  onWheel(e) {\n    e.preventDefault();\n    if (!this.shouldUpdate(e, this)) {\n      return;\n    }\n    const graph = this.graph;\n    const canvas = graph.get('canvas');\n    const point = canvas.getPointByClient(e.clientX, e.clientY);\n    const sensitivity = this.get('sensitivity');\n    let ratio = graph.getZoom();\n    // 兼容 IE、Firefox 及 Chrome\n    if (e.wheelDelta < 0) {\n      ratio = 1 - DELTA * sensitivity;\n    } else {\n      ratio = 1 + DELTA * sensitivity;\n    }\n    const zoom = ratio * graph.getZoom();\n    if (zoom > this.get('maxZoom') || zoom < this.get('minZoom')) {\n      return;\n    }\n    graph.zoom(ratio, { x: point.x, y: point.y });\n    const lockedNodes = this.graph.findAll('node', (node) => !node.hasLocked());\n    lockedNodes.forEach((node) => {\n      const matrix = Util.clone(node.get('group').getMatrix());\n      const center = node.getModel();\n      matrix = Util.transform(matrix, [\n        ['t', -center.x, -center.y],\n        ['s', 1 / ratio, 1 / ratio],\n        ['t', center.x, center.y],\n      ]);\n      node.get('group').setMatrix(matrix);\n    });\n    graph.emit('wheelzoom', e);\n  },\n});\n",paraId:5,tocIndex:1}]},90334:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"有如下的一份数据，如何使用 ",paraId:0,tocIndex:0},{value:"G6",paraId:0,tocIndex:0},{value:" 让两个节点之间显示多条边？",paraId:0,tocIndex:0},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      x: 100,\n      y: 150,\n      label: 'node1',\n    },\n    {\n      id: 'node2',\n      x: 300,\n      y: 150,\n      label: 'node2',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n    {\n      source: 'node2',\n      target: 'node1',\n    },\n  ],\n};\n",paraId:1,tocIndex:0},{value:"由于默认的边形状是直线，使用直线绘制同样两个端点之间的多条边时，会出现重叠的情况。因此我们使用以下代码将边绘制为二阶贝塞尔曲线 ",paraId:2,tocIndex:0},{value:"'quadratic'",paraId:2,tocIndex:0},{value:"。",paraId:2,tocIndex:0},{value:"const graph = new G6.Graph({\n  container: GRAPH_CONTAINER,\n  width: 500,\n  height: 500,\n  defaultNode: {\n    style: {\n      fill: '#DEE9FF',\n      stroke: '#5B8FF9',\n    },\n    labelCfg: {\n      style: {\n        fontSize: 12,\n      },\n    },\n  },\n  defaultEdge: {\n    type: 'quadratic', // 指定边的形状为二阶贝塞尔曲线\n    style: {\n      stroke: '#e2e2e2',\n    },\n  },\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:3,tocIndex:0},{value:"结果如下：",paraId:4,tocIndex:0},{value:"如果两个节点之间需要显示 3 条、4 条甚至更多条边，该怎么做呢？",paraId:5,tocIndex:0},{value:"我们把数据改成下面这样试试：",paraId:6,tocIndex:0},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      x: 100,\n      y: 150,\n      label: 'node1',\n    },\n    {\n      id: 'node2',\n      x: 300,\n      y: 150,\n      label: 'node2',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n    },\n    {\n      source: 'node2',\n      target: 'node1',\n    },\n    {\n      source: 'node2',\n      target: 'node1',\n    },\n  ],\n};\n",paraId:7,tocIndex:0},{value:"结果发现并不对。",paraId:8,tocIndex:0},{value:"参考 ",paraId:9,tocIndex:2},{value:"Demo",paraId:10,tocIndex:2},{value:"，使用 util 方法  ",paraId:9,tocIndex:2},{value:"processParallelEdges",paraId:9,tocIndex:2},{value:"。",paraId:9,tocIndex:2},{value:"这个时候，需要借助 G6 的 ",paraId:11,tocIndex:3},{value:"自定义边",paraId:12,tocIndex:3},{value:" 功能。",paraId:11,tocIndex:3},{value:"有了这个黑科技，什么样的需求，那还不是分分钟的事。",paraId:13,tocIndex:3},{value:"在使用「自定义边」前，需要明确两件事：",paraId:14,tocIndex:3},{value:"需要有个标识来区分两个节点之间是否超过一条同方向边",paraId:15,tocIndex:3},{value:"；",paraId:15,tocIndex:3},{value:"需要有一个值控制边的弯曲度，以防边重叠",paraId:15,tocIndex:3},{value:"。",paraId:15,tocIndex:3},{value:"因此，我们在每条边的数据中添加一个 ",paraId:16,tocIndex:3},{value:"edgeType",paraId:16,tocIndex:3},{value:" 属性以区分不同的边。有了这个约定以后，就可以开始动手撸码了。",paraId:16,tocIndex:3},{value:"完善的自定义边的代码如下。",paraId:17,tocIndex:3},{value:"至此，我们实现了让两个节点之间展示多条边的功能。",paraId:18,tocIndex:3}]},88471:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了三种修改节点样式的方法。",paraId:0},{value:"实例化 Graph 时，可以通过在 ",paraId:1,tocIndex:0},{value:"defaultNode",paraId:1,tocIndex:0},{value:" 或 ",paraId:1,tocIndex:0},{value:"defaultEdge",paraId:1,tocIndex:0},{value:" 中指定  ",paraId:1,tocIndex:0},{value:"style",paraId:1,tocIndex:0},{value:" 分别配置全局节点和全局边的样式属性。",paraId:1,tocIndex:0},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1000,\n  height: 800,\n  defaultNode: {\n    type: 'circle',\n    style: {\n      fill: '#fff',\n      fontSize: 14,\n    },\n  },\n  defaultEdge: {\n    type: 'line-with-arrow',\n    style: {\n      fill: '#fff',\n      fontSize: 14,\n    },\n  },\n});\n",paraId:2,tocIndex:0},{value:"这种方式可以在数据中为不同的节点和边指定不同的样式。",paraId:3,tocIndex:1},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n      style: {\n        fill: '#fff',\n        fontSize: 12,\n      },\n    },\n  ],\n};\n",paraId:4,tocIndex:1},{value:"使用 ",paraId:5,tocIndex:2},{value:"update",paraId:5,tocIndex:2},{value:" / ",paraId:5,tocIndex:2},{value:"updateItem",paraId:5,tocIndex:2},{value:" 更新节点或边。此方法用于动态更新节点或边的 ",paraId:5,tocIndex:2},{value:"keyShape",paraId:6,tocIndex:2},{value:"。",paraId:5,tocIndex:2},{value:"graph.updateItem(node, {\n  // 节点的样式\n  style: {\n    stroke: 'blue',\n  },\n});\n",paraId:7,tocIndex:2},{value:"想要知道节点都支持哪些属性样式，请参考 ",paraId:8,tocIndex:2},{value:"节点样式属性",paraId:9,tocIndex:2},{value:"。",paraId:8,tocIndex:2}]},34087:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"节点的连接点 anchorPoint 指的是边连入节点的相对位置，即节点与其相关边的交点位置。anchorPoints 是一个二维数组，每一项表示一个连接点的位置，在一个",paraId:0},{value:"图形 Shape",paraId:1},{value:" 中，连接点的位置如下图所示，x 和 y 方向上范围都是 [0, 1]：",paraId:0},{value:" ",paraId:0},{value:"节点中有了 anchorPoints 之后，相关边可以分别选择连入起始点、结束点的哪一个 anchorPoint。当需要在节点之间连多条线时，这种机制能够使边的连入更美观。",paraId:2},{value:"边可以通过指定 ",paraId:3},{value:"sourceAnchor",paraId:3},{value:" 和 ",paraId:3},{value:"targetAnchor",paraId:3},{value:"  分别选择起始点、结束点的 anchorPoint。",paraId:3},{value:"sourceAnchor",paraId:3},{value:" 和 ",paraId:3},{value:"targetAnchor",paraId:3},{value:" 取的值是相对应节点上 anchorPoints 数组的索引值。",paraId:3},{value:"下面数据演示了如何在节点上配置连接点、在边上指定连接点：",paraId:4},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      label: 'node1',\n      x: 100,\n      y: 200,\n      // 该节点可选的连接点集合，该点有两个可选的连接点\n      anchorPoints: [\n        [0, 1],\n        [0.5, 1],\n      ],\n      type: 'rect',\n    },\n    {\n      id: 'node2',\n      label: 'node2',\n      x: 300,\n      y: 400,\n      // 该节点可选的连接点集合，该点有两个可选的连接点\n      anchorPoints: [\n        [0.5, 0],\n        [1, 0.5],\n      ],\n      type: 'rect',\n    },\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n      // 该边连入 source 点的第 0 个 anchorPoint，\n      sourceAnchor: 0,\n      // 该边连入 target 点的第 0 个 anchorPoint，\n      targetAnchor: 0,\n      style: {\n        endArrow: true,\n      },\n    },\n    {\n      source: 'node2',\n      target: 'node1',\n      // 该边连入 source 点的第 1 个 anchorPoint，\n      sourceAnchor: 1,\n      // 该边连入 source 点的第 1 个 anchorPoint，\n      targetAnchor: 1,\n      style: {\n        endArrow: true,\n      },\n    },\n  ],\n};\n",paraId:5}]},16378:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了圆  Circle 节点，其默认样式如下。标签文本位于圆形中央。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置节点",paraId:2,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.node(nodeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.node(nodeFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:0},{value:"节点的通用属性",paraId:5,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultNode",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'circle'",paraId:6,tocIndex:1},{value:"，即可使用 ",paraId:6,tocIndex:1},{value:"circle",paraId:6,tocIndex:1},{value:" 节点。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'circle', // 节点类型\n    // ... 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n  {\n\t  id: 'node0',\n    type: 'circle', // 节点类型\n    ... // 其他配置\n  },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"circle 节点支持 ",paraId:10,tocIndex:3},{value:"节点通用配置",paraId:11,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"圆的直径",paraId:12,tocIndex:3},{value:"Number / Array",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:" 为数组时，取第一个值",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"circle 默认样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本内容",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"linkPoints",paraId:12,tocIndex:3},{value:"视觉上的",paraId:12,tocIndex:3},{value:"四个锚点",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示，应与 ",paraId:12,tocIndex:3},{value:"anchorPoints",paraId:14,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:3},{value:"linkPoints",paraId:15,tocIndex:3},{value:"icon",paraId:12,tocIndex:3},{value:"圆上 icon 配置",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示 icon",paraId:12,tocIndex:3},{value:"Object 类型。支持 ",paraId:16,tocIndex:4},{value:"节点通用样式",paraId:17,tocIndex:4},{value:"。通过 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:"，使之达到如下图效果。",paraId:16,tocIndex:4},{value:" ",paraId:16,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'circle',\n      label: 'circle',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'circle',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:4},{value:"Object 类型。通过 ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:19,tocIndex:5},{value:"节点通用标签配置",paraId:20,tocIndex:5},{value:"。基于上面 ",paraId:19,tocIndex:5},{value:"样式属性 style",paraId:21,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:19,tocIndex:5},{value:"defaultNode",paraId:19,tocIndex:5},{value:" 中增加了  ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:19,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      position: 'bottom',\n      offset: 10,\n      style: {\n        // ... 文本样式的配置\n      },\n    },\n  },\n});\n// ...\n",paraId:22,tocIndex:5},{value:"Object 类型。可以指定节点周围「上、下、左、右」四个方向上的四个小圆点。",paraId:23,tocIndex:6},{value:"⚠️ 注意:",paraId:24,tocIndex:6},{value:" 区分于 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:"： ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:24,tocIndex:6},{value:"数组",paraId:24,tocIndex:6},{value:"」，见 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:"；而 ",paraId:24,tocIndex:6},{value:"linkPoints",paraId:24,tocIndex:6},{value:" 仅是指定是否「",paraId:24,tocIndex:6},{value:"绘制",paraId:24,tocIndex:6},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:24,tocIndex:6},{value:"名称",paraId:26,tocIndex:6},{value:"含义",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"备注",paraId:26,tocIndex:6},{value:"top",paraId:26,tocIndex:6},{value:"是否显示上部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"bottom",paraId:26,tocIndex:6},{value:"是否显示底部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"left",paraId:26,tocIndex:6},{value:"是否显示左侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"right",paraId:26,tocIndex:6},{value:"是否显示右侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"size",paraId:26,tocIndex:6},{value:"圆点的大小",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"3",paraId:26,tocIndex:6},{value:"fill",paraId:26,tocIndex:6},{value:"圆点的填充色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"stroke",paraId:26,tocIndex:6},{value:"圆点的描边颜色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"lineWidth",paraId:26,tocIndex:6},{value:"圆点描边的宽度",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"1",paraId:26,tocIndex:6},{value:"基于上面 ",paraId:27,tocIndex:6},{value:"样式属性 style",paraId:28,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:27,tocIndex:6},{value:"defaultNode",paraId:27,tocIndex:6},{value:" 中增加了  ",paraId:27,tocIndex:6},{value:"linkPoints",paraId:27,tocIndex:6},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:27,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      fill: '#fff',\n      size: 5,\n    },\n  },\n});\n// ...\n",paraId:29,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:30,tocIndex:7},{value:"icon",paraId:30,tocIndex:7},{value:"，可以在节点上显示小图标。",paraId:30,tocIndex:7},{value:"名称",paraId:31,tocIndex:7},{value:"含义",paraId:31,tocIndex:7},{value:"类型",paraId:31,tocIndex:7},{value:"备注",paraId:31,tocIndex:7},{value:"show",paraId:31,tocIndex:7},{value:"是否显示 icon",paraId:31,tocIndex:7},{value:"Boolean",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"false",paraId:31,tocIndex:7},{value:"，不显示",paraId:31,tocIndex:7},{value:"width",paraId:31,tocIndex:7},{value:"icon 的宽度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"height",paraId:31,tocIndex:7},{value:"icon 的高度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"img",paraId:31,tocIndex:7},{value:"icon 的地址或 base64",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用图片作为 icon",paraId:31,tocIndex:7},{value:"text",paraId:31,tocIndex:7},{value:"icon 的 iconfont",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用 iconfont 作为 icon",paraId:31,tocIndex:7},{value:"基于上面 ",paraId:32,tocIndex:7},{value:"样式属性 style",paraId:33,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:32,tocIndex:7},{value:"defaultNode",paraId:32,tocIndex:7},{value:" 中增加了 ",paraId:32,tocIndex:7},{value:"icon",paraId:32,tocIndex:7},{value:"  配置项进行图标的配置，使之达到如下图效果。",paraId:32,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    icon: {\n      show: true,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n      width: 25,\n      height: 25,\n    },\n  },\n});\n// ...\n",paraId:34,tocIndex:7}]},25541:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了菱形  Diamond  节点，其默认样式如下。标签文本位于菱形中央。",paraId:0,tocIndex:0},{value:" ",paraId:0,tocIndex:0},{value:"如 ",paraId:1,tocIndex:1},{value:"内置节点",paraId:2,tocIndex:1},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:1},{value:"graph.node(nodeFn)",paraId:1,tocIndex:1},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:1},{value:"使用 ",paraId:3,tocIndex:1},{value:"graph.node(nodeFn)",paraId:3,tocIndex:1},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:1},{value:"⚠️ 注意:",paraId:4,tocIndex:1},{value:" 除 ",paraId:4,tocIndex:1},{value:"id",paraId:4,tocIndex:1},{value:"、",paraId:4,tocIndex:1},{value:"label",paraId:4,tocIndex:1},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:1},{value:"节点的通用属性",paraId:5,tocIndex:1},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:1},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:2},{value:"defaultNode",paraId:6,tocIndex:2},{value:" 指定 ",paraId:6,tocIndex:2},{value:"type",paraId:6,tocIndex:2},{value:" 为 ",paraId:6,tocIndex:2},{value:"'diamond'",paraId:6,tocIndex:2},{value:"，即可使用 ",paraId:6,tocIndex:2},{value:"diamond",paraId:6,tocIndex:2},{value:" 节点。",paraId:6,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'diamond',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:2},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:3},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'diamond',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:3},{value:"Diamond 节点支持 ",paraId:10,tocIndex:4},{value:"节点通用配置",paraId:11,tocIndex:4},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:4},{value:"名称",paraId:12,tocIndex:4},{value:"含义",paraId:12,tocIndex:4},{value:"类型",paraId:12,tocIndex:4},{value:"备注",paraId:12,tocIndex:4},{value:"size",paraId:12,tocIndex:4},{value:"菱形的宽高",paraId:12,tocIndex:4},{value:"Number / Array",paraId:12,tocIndex:4},{value:"size 为一个数值时，宽高相同",paraId:12,tocIndex:4},{value:"style",paraId:12,tocIndex:4},{value:"diamond 默认样式",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"Canvas 支持的属性",paraId:12,tocIndex:4},{value:"label",paraId:12,tocIndex:4},{value:"标签文本内容",paraId:12,tocIndex:4},{value:"String",paraId:12,tocIndex:4},{value:"labelCfg",paraId:12,tocIndex:4},{value:"标签文本配置项",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"stateStyles",paraId:12,tocIndex:4},{value:"各状态下的样式",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"详见",paraId:12,tocIndex:4},{value:"配置状态样式",paraId:13,tocIndex:4},{value:"linkPoints",paraId:12,tocIndex:4},{value:"视觉上的",paraId:12,tocIndex:4},{value:"四个锚点",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"默认不显示，应与 ",paraId:12,tocIndex:4},{value:"anchorPoints",paraId:14,tocIndex:4},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:4},{value:"linkPoints",paraId:15,tocIndex:4},{value:"icon",paraId:12,tocIndex:4},{value:"菱形上 icon 配置",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"默认不显示 icon",paraId:12,tocIndex:4},{value:"Object 类型。支持 ",paraId:16,tocIndex:5},{value:"节点通用样式",paraId:17,tocIndex:5},{value:"。通过 ",paraId:16,tocIndex:5},{value:"style",paraId:16,tocIndex:5},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:5},{value:"style",paraId:16,tocIndex:5},{value:"，使之达到如下图效果。",paraId:16,tocIndex:5},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'diamond',\n      label: 'diamond',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'diamond', // 数据中已指定 type，这里无需再次指定\n    size: [200, 80],\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:5},{value:"Object 类型。通过 ",paraId:19,tocIndex:6},{value:"labelCfg",paraId:19,tocIndex:6},{value:" 配置标签文本。支持 ",paraId:19,tocIndex:6},{value:"节点通用标签配置",paraId:20,tocIndex:6},{value:"。基于上面 ",paraId:19,tocIndex:6},{value:"样式属性 style",paraId:21,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:19,tocIndex:6},{value:"defaultNode",paraId:19,tocIndex:6},{value:" 中增加了  ",paraId:19,tocIndex:6},{value:"labelCfg",paraId:19,tocIndex:6},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:19,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n      position: 'bottom',\n    },\n  },\n});\n// ...\n",paraId:22,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:23,tocIndex:7},{value:"linkPoints",paraId:23,tocIndex:7},{value:" ，可以指定菱形周围「上、下、左、右」四个小圆点。",paraId:23,tocIndex:7},{value:"⚠️ 注意:",paraId:24,tocIndex:7},{value:" 区分于 ",paraId:24,tocIndex:7},{value:"anchorPoints",paraId:24,tocIndex:7},{value:"： ",paraId:24,tocIndex:7},{value:"anchorPoints",paraId:24,tocIndex:7},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:24,tocIndex:7},{value:"数组",paraId:24,tocIndex:7},{value:"」，见 ",paraId:24,tocIndex:7},{value:"anchorPoints",paraId:25,tocIndex:7},{value:"；而 ",paraId:24,tocIndex:7},{value:"linkPoints",paraId:24,tocIndex:7},{value:" 仅是指定是否「",paraId:24,tocIndex:7},{value:"绘制",paraId:24,tocIndex:7},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:24,tocIndex:7},{value:"名称",paraId:26,tocIndex:7},{value:"含义",paraId:26,tocIndex:7},{value:"类型",paraId:26,tocIndex:7},{value:"备注",paraId:26,tocIndex:7},{value:"top",paraId:26,tocIndex:7},{value:"是否显示上部的圆点",paraId:26,tocIndex:7},{value:"Boolean",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"false",paraId:26,tocIndex:7},{value:"bottom",paraId:26,tocIndex:7},{value:"是否显示底部的圆点",paraId:26,tocIndex:7},{value:"Boolean",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"false",paraId:26,tocIndex:7},{value:"left",paraId:26,tocIndex:7},{value:"是否显示左侧的圆点",paraId:26,tocIndex:7},{value:"Boolean",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"false",paraId:26,tocIndex:7},{value:"right",paraId:26,tocIndex:7},{value:"是否显示右侧的圆点",paraId:26,tocIndex:7},{value:"Boolean",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"false",paraId:26,tocIndex:7},{value:"size",paraId:26,tocIndex:7},{value:"圆点的大小",paraId:26,tocIndex:7},{value:"Number",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"3",paraId:26,tocIndex:7},{value:"fill",paraId:26,tocIndex:7},{value:"圆点的填充色",paraId:26,tocIndex:7},{value:"String",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"'#72CC4A'",paraId:26,tocIndex:7},{value:"stroke",paraId:26,tocIndex:7},{value:"圆点的边框颜色",paraId:26,tocIndex:7},{value:"String",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"'#72CC4A'",paraId:26,tocIndex:7},{value:"lineWidth",paraId:26,tocIndex:7},{value:"圆点边框的宽度",paraId:26,tocIndex:7},{value:"Number",paraId:26,tocIndex:7},{value:"默认为 ",paraId:26,tocIndex:7},{value:"1",paraId:26,tocIndex:7},{value:"基于上面 ",paraId:27,tocIndex:7},{value:"样式属性 style",paraId:28,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:27,tocIndex:7},{value:"defaultNode",paraId:27,tocIndex:7},{value:" 中增加了  ",paraId:27,tocIndex:7},{value:"linkPoints",paraId:27,tocIndex:7},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:27,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      size: 5,\n      fill: '#fff',\n    },\n  },\n});\n// ...\n",paraId:29,tocIndex:7},{value:"Object 类型。通过配置 ",paraId:30,tocIndex:8},{value:"icon",paraId:30,tocIndex:8},{value:"，可以在圆上显示小图标。",paraId:30,tocIndex:8},{value:"名称",paraId:31,tocIndex:8},{value:"含义",paraId:31,tocIndex:8},{value:"类型",paraId:31,tocIndex:8},{value:"备注",paraId:31,tocIndex:8},{value:"show",paraId:31,tocIndex:8},{value:"是否显示 icon",paraId:31,tocIndex:8},{value:"Boolean",paraId:31,tocIndex:8},{value:"默认为 ",paraId:31,tocIndex:8},{value:"false",paraId:31,tocIndex:8},{value:"，不显示",paraId:31,tocIndex:8},{value:"width",paraId:31,tocIndex:8},{value:"icon 的宽度",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"默认为 ",paraId:31,tocIndex:8},{value:"16",paraId:31,tocIndex:8},{value:"height",paraId:31,tocIndex:8},{value:"icon 的高度",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"默认为 ",paraId:31,tocIndex:8},{value:"16",paraId:31,tocIndex:8},{value:"img",paraId:31,tocIndex:8},{value:"icon 的地址或 base64",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"若配置则表示使用图片作为 icon",paraId:31,tocIndex:8},{value:"text",paraId:31,tocIndex:8},{value:"icon 的 iconfont",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"若配置则表示使用 iconfont 作为 icon",paraId:31,tocIndex:8},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:32,tocIndex:8},{value:"icon",paraId:32,tocIndex:8},{value:"。",paraId:32,tocIndex:8},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    icon: {\n      show: true,\n      width: 25,\n      height: 25,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n    },\n  },\n});\n// ...\n",paraId:33,tocIndex:8}]},87673:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了甜甜圈  Donut 节点，其默认样式如下。标签文本位于圆形中央，圆形周围根据给定字段的占比绘制甜甜圈统计图。",paraId:0},{value:" ",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置节点",paraId:2,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.node(nodeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.node(nodeFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:0},{value:"节点的通用属性",paraId:5,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultNode",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'donut'",paraId:6,tocIndex:1},{value:"，并为 donut 节点配置 ",paraId:6,tocIndex:1},{value:"donutAttrs",paraId:6,tocIndex:1},{value:" 指定参与统计的字段（需要包含两个及以上合法字段，合法是指每个字段格式为 ",paraId:6,tocIndex:1},{value:"[key: string]: number",paraId:6,tocIndex:1},{value:"），即可使用 ",paraId:6,tocIndex:1},{value:"donut",paraId:6,tocIndex:1},{value:" 节点。若 ",paraId:6,tocIndex:1},{value:"donutAttrs",paraId:6,tocIndex:1},{value:" 未指定，或 ",paraId:6,tocIndex:1},{value:"donutAttrs",paraId:6,tocIndex:1},{value:" 中的合法字段数少于 2，则该节点将被显示为 circle 节点。甜甜圈图的颜色将会使用默认色板，若需自定义，则传入 ",paraId:6,tocIndex:1},{value:"donutColorMap",paraId:6,tocIndex:1},{value:" 字段。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'donut', // 节点类型\n    donutAttrs: {  // 甜甜圈字段，每个字段必须为 [key: string]: number\n      prop1: 10,\n      prop2: 20,\n      prop3: 25,\n      prop5: 10,\n      prop6: 20,\n    },\n    // donutColorMap: { // 甜甜圈颜色映射，字段名与 donutAttrs 中的字段名对应。不指定则使用默认色板\n    //   prop1: '#8eaade',\n    //   prop2: '#55a9f2',\n    //   prop3: '#0d47b5'\n    // },\n    // ... 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [\n  {\n\t  id: 'node0',\n    type: 'donut', // 节点类型\n    donutAttrs: {  // 甜甜圈字段，每个字段必须为 [key: string]: number\n      prop1: 10,\n      prop2: 20,\n      prop3: 25,\n      prop5: 10,\n      prop6: 20,\n    },\n    // donutColorMap: { // 甜甜圈颜色映射，字段名与 donutAttrs 中的字段名对应\n    //   prop1: '#8eaade',\n    //   prop2: '#55a9f2',\n    //   prop3: '#0d47b5'\n    // },\n    ... // 其他配置\n  },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"donut 节点支持 ",paraId:10,tocIndex:3},{value:"节点通用配置",paraId:11,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"圆的直径",paraId:12,tocIndex:3},{value:"Number / Array",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:" 为数组时，取第一个值",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"背景圆的默认样式，与 circle 节点类似",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本内容",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"donutAttrs",paraId:12,tocIndex:3},{value:"甜甜圈统计字段",paraId:12,tocIndex:3},{value:"{ [key: string]: number }",paraId:12,tocIndex:3},{value:"donut 节点特有。必须含有两个及以上的合法字段，才能够显示出甜甜圈图",paraId:12,tocIndex:3},{value:"donutColorMap",paraId:12,tocIndex:3},{value:"甜甜圈色板",paraId:12,tocIndex:3},{value:"{ [key: string]: string }",paraId:12,tocIndex:3},{value:"donut 节点特有。不指定将使用默认色板。key 与 donutAttrs 中的字段名对应",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"linkPoints",paraId:12,tocIndex:3},{value:"视觉上的",paraId:12,tocIndex:3},{value:"四个锚点",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示，应与 ",paraId:12,tocIndex:3},{value:"anchorPoints",paraId:14,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:3},{value:"linkPoints",paraId:15,tocIndex:3},{value:"icon",paraId:12,tocIndex:3},{value:"圆上 icon 配置",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示 icon",paraId:12,tocIndex:3},{value:"Object 类型。支持 ",paraId:16,tocIndex:4},{value:"节点通用样式",paraId:17,tocIndex:4},{value:"。通过 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:"，使之达到如下图效果。",paraId:16,tocIndex:4},{value:" ",paraId:16,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'donut',\n      label: 'donut',\n      donutAttrs: {\n        prop1: 10,\n        prop2: 20,\n        prop3: 25,\n        prop5: 10,\n        prop6: 20,\n      },\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'donut',  // 在数据中已经指定 type，这里无需再次指定\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n    donutColorMap: { // 指定色板\n      prop1: '#8eaade',\n      prop2: '#55a9f2',\n      prop3: '#0d47b5',\n      prop5: '#7b8085',\n      prop6: '#003870'\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:4},{value:"Object 类型。通过 ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:19,tocIndex:5},{value:"节点通用标签配置",paraId:20,tocIndex:5},{value:"。基于上面 ",paraId:19,tocIndex:5},{value:"样式属性 style",paraId:21,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:19,tocIndex:5},{value:"defaultNode",paraId:19,tocIndex:5},{value:" 中增加了  ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:19,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      position: 'bottom',\n      offset: 10,\n      style: {\n        // ... 文本样式的配置\n      },\n    },\n  },\n});\n// ...\n",paraId:22,tocIndex:5},{value:"Object 类型。可以指定节点周围「上、下、左、右」四个方向上的四个小圆点。",paraId:23,tocIndex:6},{value:"⚠️ 注意:",paraId:24,tocIndex:6},{value:" 区分于 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:"： ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:24,tocIndex:6},{value:"数组",paraId:24,tocIndex:6},{value:"」，见 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:"；而 ",paraId:24,tocIndex:6},{value:"linkPoints",paraId:24,tocIndex:6},{value:" 仅是指定是否「",paraId:24,tocIndex:6},{value:"绘制",paraId:24,tocIndex:6},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:24,tocIndex:6},{value:"名称",paraId:26,tocIndex:6},{value:"含义",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"备注",paraId:26,tocIndex:6},{value:"top",paraId:26,tocIndex:6},{value:"是否显示上部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"bottom",paraId:26,tocIndex:6},{value:"是否显示底部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"left",paraId:26,tocIndex:6},{value:"是否显示左侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"right",paraId:26,tocIndex:6},{value:"是否显示右侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"size",paraId:26,tocIndex:6},{value:"圆点的大小",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"3",paraId:26,tocIndex:6},{value:"fill",paraId:26,tocIndex:6},{value:"圆点的填充色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"stroke",paraId:26,tocIndex:6},{value:"圆点的描边颜色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"lineWidth",paraId:26,tocIndex:6},{value:"圆点描边的宽度",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"1",paraId:26,tocIndex:6},{value:"基于上面 ",paraId:27,tocIndex:6},{value:"样式属性 style",paraId:28,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:27,tocIndex:6},{value:"defaultNode",paraId:27,tocIndex:6},{value:" 中增加了  ",paraId:27,tocIndex:6},{value:"linkPoints",paraId:27,tocIndex:6},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:27,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      fill: '#fff',\n      size: 5,\n    },\n  },\n});\n// ...\n",paraId:29,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:30,tocIndex:7},{value:"icon",paraId:30,tocIndex:7},{value:"，可以在节点上显示小图标。",paraId:30,tocIndex:7},{value:"名称",paraId:31,tocIndex:7},{value:"含义",paraId:31,tocIndex:7},{value:"类型",paraId:31,tocIndex:7},{value:"备注",paraId:31,tocIndex:7},{value:"show",paraId:31,tocIndex:7},{value:"是否显示 icon",paraId:31,tocIndex:7},{value:"Boolean",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"false",paraId:31,tocIndex:7},{value:"，不显示",paraId:31,tocIndex:7},{value:"width",paraId:31,tocIndex:7},{value:"icon 的宽度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"height",paraId:31,tocIndex:7},{value:"icon 的高度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"img",paraId:31,tocIndex:7},{value:"icon 的地址或 base64",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用图片作为 icon",paraId:31,tocIndex:7},{value:"text",paraId:31,tocIndex:7},{value:"icon 的 iconfont",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用 iconfont 作为 icon",paraId:31,tocIndex:7},{value:"基于上面 ",paraId:32,tocIndex:7},{value:"样式属性 style",paraId:33,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:32,tocIndex:7},{value:"defaultNode",paraId:32,tocIndex:7},{value:" 中增加了 ",paraId:32,tocIndex:7},{value:"icon",paraId:32,tocIndex:7},{value:"  配置项进行图标的配置，使之达到如下图效果。",paraId:32,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    icon: {\n      show: true,\n      //img: '...', 可更换为其他图片地址\n      width: 25,\n      height: 25,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n    },\n  },\n});\n// ...\n",paraId:34,tocIndex:7}]},20494:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了  ellipse 节点，其默认样式如下。标签文本位于椭圆中央。",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置节点",paraId:2,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.node(nodeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.node(nodeFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:0},{value:"节点的通用属性",paraId:5,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultNode",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'ellipse'",paraId:6,tocIndex:1},{value:"，即可使用 ",paraId:6,tocIndex:1},{value:"ellipse",paraId:6,tocIndex:1},{value:" 节点。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'ellipse',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'ellipse',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"ellipse  节点支持 ",paraId:10,tocIndex:3},{value:"节点通用配置",paraId:11,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"椭圆的大小",paraId:12,tocIndex:3},{value:"Number / Array",paraId:12,tocIndex:3},{value:"size 为 Number 时，效果为一个圆形。为 Array 时，size[0] 为椭圆长轴长度，size[1] 为椭圆短轴长度",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"椭圆的默认样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本内容",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"linkPoints",paraId:12,tocIndex:3},{value:"视觉上的",paraId:12,tocIndex:3},{value:"四个锚点",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示，应与 ",paraId:12,tocIndex:3},{value:"anchorPoints",paraId:14,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:3},{value:"linkPoints",paraId:15,tocIndex:3},{value:"icon",paraId:12,tocIndex:3},{value:"椭圆上 icon 配置",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示 icon",paraId:12,tocIndex:3},{value:"Object 类型。支持 ",paraId:16,tocIndex:4},{value:"节点通用样式",paraId:17,tocIndex:4},{value:"。通过 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:"，使之达到如下图效果。",paraId:16,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'ellipse',\n      label: 'ellipse',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'ellipse',  // 在数据中已经指定 type，这里可以不用再此指定\n    size: [130, 80],\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:4},{value:"Object 类型。通过 ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:19,tocIndex:5},{value:"节点通用标签配置",paraId:20,tocIndex:5},{value:"。基于上面 ",paraId:19,tocIndex:5},{value:"样式属性 style",paraId:21,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:19,tocIndex:5},{value:"defaultNode",paraId:19,tocIndex:5},{value:" 中增加了  ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:19,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      offset: 20,\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n    },\n  },\n});\n// ...\n",paraId:22,tocIndex:5},{value:"Object 类型。通过配置 ",paraId:23,tocIndex:6},{value:"linkPoints",paraId:23,tocIndex:6},{value:" ，可以指定节点上「上、下、左、右」四个小圆点。",paraId:23,tocIndex:6},{value:"⚠️ 注意:",paraId:24,tocIndex:6},{value:" 区分于 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:"： ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:24,tocIndex:6},{value:"数组",paraId:24,tocIndex:6},{value:"」，见 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:"；而 ",paraId:24,tocIndex:6},{value:"linkPoints",paraId:24,tocIndex:6},{value:" 仅是指定是否「",paraId:24,tocIndex:6},{value:"绘制",paraId:24,tocIndex:6},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:24,tocIndex:6},{value:"名称",paraId:26,tocIndex:6},{value:"含义",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"备注",paraId:26,tocIndex:6},{value:"top",paraId:26,tocIndex:6},{value:"是否显示上部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"bottom",paraId:26,tocIndex:6},{value:"是否显示底部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"left",paraId:26,tocIndex:6},{value:"是否显示左侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"right",paraId:26,tocIndex:6},{value:"是否显示右侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"size",paraId:26,tocIndex:6},{value:"圆点的大小",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"3",paraId:26,tocIndex:6},{value:"fill",paraId:26,tocIndex:6},{value:"圆点的填充色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"stroke",paraId:26,tocIndex:6},{value:"圆点的边框颜色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"lineWidth",paraId:26,tocIndex:6},{value:"圆点边框的宽度",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"1",paraId:26,tocIndex:6},{value:"基于上面 ",paraId:27,tocIndex:6},{value:"样式属性 style",paraId:28,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:27,tocIndex:6},{value:"defaultNode",paraId:27,tocIndex:6},{value:" 中增加了  ",paraId:27,tocIndex:6},{value:"linkPoints",paraId:27,tocIndex:6},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:27,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      size: 5,\n      fill: '#fff',\n    },\n  },\n});\n// ...\n",paraId:29,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:30,tocIndex:7},{value:"icon",paraId:30,tocIndex:7},{value:"，可以在圆上显示小图标。",paraId:30,tocIndex:7},{value:"名称",paraId:31,tocIndex:7},{value:"含义",paraId:31,tocIndex:7},{value:"类型",paraId:31,tocIndex:7},{value:"备注",paraId:31,tocIndex:7},{value:"show",paraId:31,tocIndex:7},{value:"是否显示 icon",paraId:31,tocIndex:7},{value:"Boolean",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"false",paraId:31,tocIndex:7},{value:"，不显示",paraId:31,tocIndex:7},{value:"width",paraId:31,tocIndex:7},{value:"icon 的宽度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"height",paraId:31,tocIndex:7},{value:"icon 的高度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 ",paraId:31,tocIndex:7},{value:"16",paraId:31,tocIndex:7},{value:"img",paraId:31,tocIndex:7},{value:"icon 的地址或 base64",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用图片作为 icon",paraId:31,tocIndex:7},{value:"text",paraId:31,tocIndex:7},{value:"icon 的 iconfont",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用 iconfont 作为 icon",paraId:31,tocIndex:7},{value:"基于上面 ",paraId:32,tocIndex:7},{value:"样式属性 style",paraId:33,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:32,tocIndex:7},{value:"defaultNode",paraId:32,tocIndex:7},{value:" 中增加了 ",paraId:32,tocIndex:7},{value:"icon",paraId:32,tocIndex:7},{value:"  配置项进行图标的配置，使之达到如下图效果。",paraId:32,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    icon: {\n      show: true,\n      width: 25,\n      height: 25,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n    },\n  },\n});\n// ...\n",paraId:34,tocIndex:7}]},13109:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了 image 节点，其默认样式如下。标签文本位于图片下方。",paraId:0,tocIndex:0},{value:"如 ",paraId:1,tocIndex:1},{value:"内置节点",paraId:2,tocIndex:1},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:1},{value:"graph.node(nodeFn)",paraId:1,tocIndex:1},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:1},{value:"使用 ",paraId:3,tocIndex:1},{value:"graph.node(nodeFn)",paraId:3,tocIndex:1},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:1},{value:"⚠️ 注意:",paraId:4,tocIndex:1},{value:" 除 ",paraId:4,tocIndex:1},{value:"id",paraId:4,tocIndex:1},{value:"、",paraId:4,tocIndex:1},{value:"label",paraId:4,tocIndex:1},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:1},{value:"节点的通用属性",paraId:5,tocIndex:1},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:1},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:2},{value:"defaultNode",paraId:6,tocIndex:2},{value:" 指定 ",paraId:6,tocIndex:2},{value:"type",paraId:6,tocIndex:2},{value:" 为 ",paraId:6,tocIndex:2},{value:"'image'",paraId:6,tocIndex:2},{value:"，即可使用 ",paraId:6,tocIndex:2},{value:"image",paraId:6,tocIndex:2},{value:" 节点。",paraId:6,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'image',\n    label: 'AntV Team',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:2},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:3},{value:"const data = {\n  nodes: [{\n    id: 'node0',\n  \timg: 'https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?max_age=31536000',\n    type: 'image',\n    size: 200,\n    label: 'AntV Team',\n    labelCfg: {\n      position: 'bottom'\n    },\n    // 裁剪图片配置\n    clipCfg: {\n      show: false,\n      type: 'circle',\n      r: 15\n    }\n  },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:3},{value:"image 节点支持 ",paraId:10,tocIndex:4},{value:"节点通用配置",paraId:11,tocIndex:4},{value:"，下表对部分属性进行解释：",paraId:10,tocIndex:4},{value:"img: 'https://yyb.gtimg.com/aiplat/page/product/visionimgidy/img/demo6-16a47e5d31.jpg?max_age=31536000',\nsize: 200,\n  labelCfg: {\n    position: 'bottom'\n  },\n  // 裁剪图片配置\n  clipCfg: {\n    show: false,\n    type: 'circle',\n    // circle\n    r: 15,\n    // ellipse\n    rx: 10,\n    ry: 15,\n    // rect\n    width: 15,\n    height: 15,\n    // 坐标\n    x: 0,\n    y: 0\n  }\n",paraId:12,tocIndex:4},{value:"名称",paraId:13,tocIndex:4},{value:"含义",paraId:13,tocIndex:4},{value:"类型",paraId:13,tocIndex:4},{value:"备注",paraId:13,tocIndex:4},{value:"img",paraId:13,tocIndex:4},{value:"图片 URL 地址",paraId:13,tocIndex:4},{value:"String",paraId:13,tocIndex:4},{value:"image 节点特有",paraId:13,tocIndex:4},{value:"size",paraId:13,tocIndex:4},{value:"图片大小",paraId:13,tocIndex:4},{value:"Number",paraId:13,tocIndex:4},{value:"Array",paraId:13,tocIndex:4},{value:"label",paraId:13,tocIndex:4},{value:"标签文本内容",paraId:13,tocIndex:4},{value:"String",paraId:13,tocIndex:4},{value:"labelCfg",paraId:13,tocIndex:4},{value:"标签文本配置项",paraId:13,tocIndex:4},{value:"Object",paraId:13,tocIndex:4},{value:"支持 ",paraId:13,tocIndex:4},{value:"节点通用标签配置",paraId:14,tocIndex:4},{value:"。",paraId:13,tocIndex:4},{value:"clipCfg",paraId:13,tocIndex:4},{value:"裁剪图片的配置项",paraId:13,tocIndex:4},{value:"Object",paraId:13,tocIndex:4},{value:"默认不裁剪，image 节点特有",paraId:13,tocIndex:4},{value:"clipCfg",paraId:15,tocIndex:5},{value:"名称",paraId:16,tocIndex:5},{value:"含义",paraId:16,tocIndex:5},{value:"类型",paraId:16,tocIndex:5},{value:"备注",paraId:16,tocIndex:5},{value:"type",paraId:16,tocIndex:5},{value:"裁剪的图片形状",paraId:16,tocIndex:5},{value:"String",paraId:16,tocIndex:5},{value:"支持 ",paraId:16,tocIndex:5},{value:"'circle'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'rect'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'ellipse'",paraId:16,tocIndex:5},{value:"x",paraId:16,tocIndex:5},{value:"裁剪图形的 x 坐标",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"默认为 0，类型为 ",paraId:16,tocIndex:5},{value:"'circle'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'rect'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'ellipse'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"y",paraId:16,tocIndex:5},{value:"裁剪图形的 y 坐标",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"默认为 0，类型为 ",paraId:16,tocIndex:5},{value:"'circle'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'rect'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'ellipse'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"show",paraId:16,tocIndex:5},{value:"是否启用裁剪功能",paraId:16,tocIndex:5},{value:"Boolean",paraId:16,tocIndex:5},{value:"默认不裁剪，值为 ",paraId:16,tocIndex:5},{value:"false",paraId:16,tocIndex:5},{value:"r",paraId:16,tocIndex:5},{value:"剪裁圆形的半径",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"剪裁 type 为  ",paraId:16,tocIndex:5},{value:"'circle'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"width",paraId:16,tocIndex:5},{value:"剪裁矩形的宽度",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"剪裁 type 为 ",paraId:16,tocIndex:5},{value:"'rect'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"height",paraId:16,tocIndex:5},{value:"剪裁矩形的长度",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"剪裁 type 为 ",paraId:16,tocIndex:5},{value:"'rect'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"rx",paraId:16,tocIndex:5},{value:"剪裁椭圆的长轴半径",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"剪裁 type 为 ",paraId:16,tocIndex:5},{value:"'ellipse'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"ry",paraId:16,tocIndex:5},{value:"剪裁椭圆的短轴半径",paraId:16,tocIndex:5},{value:"Number",paraId:16,tocIndex:5},{value:"剪裁 type 为 ",paraId:16,tocIndex:5},{value:"'ellipse'",paraId:16,tocIndex:5},{value:" 时生效",paraId:16,tocIndex:5},{value:"所有的裁剪类型都提供了默认值。下面代码演示在实例化图时全局配置 ",paraId:17,tocIndex:5},{value:"clipCfg",paraId:17,tocIndex:5},{value:" 的最简形式：",paraId:17,tocIndex:5},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'image',\n      label: 'image',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'image',  // 在数据中已经指定 type，这里无需再次指定\n    clipCfg: {\n      show: true,\n      type: 'circle',\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:5},{value:"circle",paraId:19,tocIndex:7},{value:" 当剪裁配置 ",paraId:19,tocIndex:7},{value:"clipCfg",paraId:19,tocIndex:7},{value:" 中的裁剪类型 ",paraId:19,tocIndex:7},{value:"type",paraId:19,tocIndex:7},{value:" 为 ",paraId:19,tocIndex:7},{value:"'circle'",paraId:19,tocIndex:7},{value:" 时，如下配置可以得到下图效果：",paraId:19,tocIndex:7},{value:"clipCfg: {\n  show: true,\n  type: 'circle',\n  r: 100\n}\n",paraId:20,tocIndex:7},{value:"rect",paraId:21,tocIndex:8},{value:"当剪裁配置 ",paraId:22,tocIndex:8},{value:"clipCfg",paraId:22,tocIndex:8},{value:" 中的裁剪类型 ",paraId:22,tocIndex:8},{value:"type",paraId:22,tocIndex:8},{value:" 为 ",paraId:22,tocIndex:8},{value:"'rect'",paraId:22,tocIndex:8},{value:" 时，如下配置可以得到下图效果：",paraId:22,tocIndex:8},{value:"clipCfg: {\n  show: true,\n  type: 'rect',\n  x: -50,\n  y: -50,\n  width: 100,\n  height: 100\n}\n",paraId:23,tocIndex:8},{value:"ellipse",paraId:24,tocIndex:9},{value:"当剪裁配置 ",paraId:25,tocIndex:9},{value:"clipCfg",paraId:25,tocIndex:9},{value:" 中的裁剪类型 ",paraId:25,tocIndex:9},{value:"type",paraId:25,tocIndex:9},{value:" 为 ",paraId:25,tocIndex:9},{value:"'ellipse'",paraId:25,tocIndex:9},{value:" 时，如下配置可以得到下图效果：",paraId:25,tocIndex:9},{value:"clipCfg: {\n  show: true,\n  type: 'ellipse',\n  rx: 100,\n  ry: 60\n}\n",paraId:26,tocIndex:9}]},69185:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了方形卡片 modelRect  节点，其默认样式如下。标签文本位于卡片下方。 ",paraId:0},{value:"**提示：**数据中无 ",paraId:1},{value:"description",paraId:1},{value:" 字段时，则不显示描述信息。",paraId:1},{value:"如 ",paraId:2,tocIndex:0},{value:"内置节点",paraId:3,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:2,tocIndex:0},{value:"graph.node(nodeFn)",paraId:2,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:2,tocIndex:0},{value:"使用 ",paraId:4,tocIndex:0},{value:"graph.node(nodeFn)",paraId:4,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:4,tocIndex:0},{value:"⚠️ 注意:",paraId:5,tocIndex:0},{value:" 除 ",paraId:5,tocIndex:0},{value:"id",paraId:5,tocIndex:0},{value:"、",paraId:5,tocIndex:0},{value:"label",paraId:5,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:5,tocIndex:0},{value:"节点的通用属性",paraId:6,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:5,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:7,tocIndex:1},{value:"defaultNode",paraId:7,tocIndex:1},{value:" 指定 ",paraId:7,tocIndex:1},{value:"type",paraId:7,tocIndex:1},{value:" 为 ",paraId:7,tocIndex:1},{value:"'modelRect'",paraId:7,tocIndex:1},{value:"，即可使用 ",paraId:7,tocIndex:1},{value:"modelRect",paraId:7,tocIndex:1},{value:" 节点。",paraId:7,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'modelRect',\n    // 其他配置\n  },\n});\n",paraId:8,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:9,tocIndex:2},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'modelRect',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:10,tocIndex:2},{value:"modelRect 节点支持 ",paraId:11,tocIndex:3},{value:"节点通用配置",paraId:12,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:11,tocIndex:3},{value:"名称",paraId:13,tocIndex:3},{value:"含义",paraId:13,tocIndex:3},{value:"类型",paraId:13,tocIndex:3},{value:"备注",paraId:13,tocIndex:3},{value:"size",paraId:13,tocIndex:3},{value:"卡片的大小",paraId:13,tocIndex:3},{value:"Number",paraId:13,tocIndex:3},{value:"Array",paraId:13,tocIndex:3},{value:"style",paraId:13,tocIndex:3},{value:"卡片的默认样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"Canvas 支持的属性",paraId:13,tocIndex:3},{value:"label",paraId:13,tocIndex:3},{value:"标签文本内容",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"labelCfg",paraId:13,tocIndex:3},{value:"文本配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"stateStyles",paraId:13,tocIndex:3},{value:"各状态下的样式",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"详见",paraId:13,tocIndex:3},{value:"配置状态样式",paraId:14,tocIndex:3},{value:"linkPoints",paraId:13,tocIndex:3},{value:"视觉上的",paraId:13,tocIndex:3},{value:"四个锚点",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"默认不显示，应与 ",paraId:13,tocIndex:3},{value:"anchorPoints",paraId:15,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:13,tocIndex:3},{value:"linkPoints",paraId:16,tocIndex:3},{value:"preRect",paraId:13,tocIndex:3},{value:"左侧的小矩形",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"modelRect 节点特有",paraId:13,tocIndex:3},{value:"logoIcon",paraId:13,tocIndex:3},{value:"左侧的 logo 图标",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"modelRect 节点特有",paraId:13,tocIndex:3},{value:"stateIcon",paraId:13,tocIndex:3},{value:"右侧的状态图标",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"modelRect 节点特有",paraId:13,tocIndex:3},{value:"description",paraId:13,tocIndex:3},{value:"节点主要文本下方的描述文本",paraId:13,tocIndex:3},{value:"String",paraId:13,tocIndex:3},{value:"modelRect 节点特有",paraId:13,tocIndex:3},{value:"descriptionCfg",paraId:13,tocIndex:3},{value:"在 V3.3 版本后支持",paraId:13,tocIndex:3},{value:"描述文本的配置项",paraId:13,tocIndex:3},{value:"Object",paraId:13,tocIndex:3},{value:"modelRect 节点特有",paraId:13,tocIndex:3},{value:"    // 节点中 icon 配置\n    logoIcon: {\n      // 是否显示 icon，值为 false 则不渲染 icon\n      show: true,\n      x: 0,\n      y: 0,\n      // icon 的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/basement_prod/4f81893c-1806-4de4-aff3-9a6b266bc8a2.svg',\n      width: 16,\n      height: 16,\n      // 用于调整图标的左右位置\n      offset: 0\n    },\n    // 节点中表示状态的 icon 配置\n    stateIcon: {\n      // 是否显示 icon，值为 false 则不渲染 icon\n      show: true,\n      x: 0,\n      y: 0,\n      // icon 的地址，字符串类型\n      img: 'https://gw.alipayobjects.com/zos/basement_prod/300a2523-67e0-4cbf-9d4a-67c077b40395.svg',\n      width: 16,\n      height: 16,\n      // 用于调整图标的左右位置\n      offset: -5\n    }\n",paraId:17,tocIndex:3},{value:"Object 类型。支持 ",paraId:18,tocIndex:4},{value:"节点通用样式",paraId:19,tocIndex:4},{value:"。通过 ",paraId:18,tocIndex:4},{value:"style",paraId:18,tocIndex:4},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:18,tocIndex:4},{value:"style",paraId:18,tocIndex:4},{value:"，使之达到如下图效果。",paraId:18,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'modelRect',\n      label: 'modelRect',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'modelRect',  // 在数据中已经指定 type，这里无需再次指定\n    size: [200, 80],\n    style: {\n      fill: '#f0f5ff',\n      stroke: '#adc6ff',\n      lineWidth: 2,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:20,tocIndex:4},{value:"Object 类型。通过 ",paraId:21,tocIndex:5},{value:"labelCfg",paraId:21,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:21,tocIndex:5},{value:"节点通用标签配置",paraId:22,tocIndex:5},{value:"。基于上面 ",paraId:21,tocIndex:5},{value:"样式属性 style",paraId:23,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:21,tocIndex:5},{value:"defaultNode",paraId:21,tocIndex:5},{value:" 中增加了  ",paraId:21,tocIndex:5},{value:"labelCfg",paraId:21,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:21,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n    },\n  },\n});\n// ...\n",paraId:24,tocIndex:5},{value:"⚠️ 注意:",paraId:25,tocIndex:6},{value:" 在 V3.3 版本后支持。",paraId:25,tocIndex:6},{value:"Object 类型。通过 ",paraId:26,tocIndex:6},{value:"descriptionCfg",paraId:26,tocIndex:6},{value:" 配置标签文本。支持 ",paraId:26,tocIndex:6},{value:"节点通用标签配置",paraId:27,tocIndex:6},{value:"。此外，还有一个特殊属性：",paraId:26,tocIndex:6},{value:"名称",paraId:28,tocIndex:6},{value:"含义",paraId:28,tocIndex:6},{value:"类型",paraId:28,tocIndex:6},{value:"备注",paraId:28,tocIndex:6},{value:"paddingTop",paraId:28,tocIndex:6},{value:"距离上方标签文本的垂直距离",paraId:28,tocIndex:6},{value:"Number",paraId:28,tocIndex:6},{value:"默认为 ",paraId:28,tocIndex:6},{value:"0",paraId:28,tocIndex:6},{value:"基于上面 ",paraId:29,tocIndex:6},{value:"样式属性 style",paraId:30,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:29,tocIndex:6},{value:"defaultNode",paraId:29,tocIndex:6},{value:" 中增加了  ",paraId:29,tocIndex:6},{value:"descriptionCfg",paraId:29,tocIndex:6},{value:"  配置项进行描述文本的配置。",paraId:29,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    descriptionCfg: {\n      style: {\n        fill: '#f00',\n      },\n    },\n  },\n});\n// ...\n",paraId:31,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:32,tocIndex:7},{value:"linkPoints",paraId:32,tocIndex:7},{value:" ，可以指定 modelRect 周围「上、下、左、右」四个小圆点。",paraId:32,tocIndex:7},{value:"⚠️ 注意:",paraId:33,tocIndex:7},{value:" 区分于 ",paraId:33,tocIndex:7},{value:"anchorPoints",paraId:33,tocIndex:7},{value:"： ",paraId:33,tocIndex:7},{value:"anchorPoints",paraId:33,tocIndex:7},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:33,tocIndex:7},{value:"数组",paraId:33,tocIndex:7},{value:"」，见 ",paraId:33,tocIndex:7},{value:"anchorPoints",paraId:34,tocIndex:7},{value:"；而 ",paraId:33,tocIndex:7},{value:"linkPoints",paraId:33,tocIndex:7},{value:" 仅是指定是否「",paraId:33,tocIndex:7},{value:"绘制",paraId:33,tocIndex:7},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:33,tocIndex:7},{value:"名称",paraId:35,tocIndex:7},{value:"含义",paraId:35,tocIndex:7},{value:"类型",paraId:35,tocIndex:7},{value:"备注",paraId:35,tocIndex:7},{value:"top",paraId:35,tocIndex:7},{value:"是否显示上部的圆点",paraId:35,tocIndex:7},{value:"Boolean",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"false",paraId:35,tocIndex:7},{value:"bottom",paraId:35,tocIndex:7},{value:"是否显示底部的圆点",paraId:35,tocIndex:7},{value:"Boolean",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"false",paraId:35,tocIndex:7},{value:"left",paraId:35,tocIndex:7},{value:"是否显示左侧的圆点",paraId:35,tocIndex:7},{value:"Boolean",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"false",paraId:35,tocIndex:7},{value:"right",paraId:35,tocIndex:7},{value:"是否显示右侧的圆点",paraId:35,tocIndex:7},{value:"Boolean",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"false",paraId:35,tocIndex:7},{value:"size",paraId:35,tocIndex:7},{value:"圆点的大小",paraId:35,tocIndex:7},{value:"Number",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"3",paraId:35,tocIndex:7},{value:"fill",paraId:35,tocIndex:7},{value:"圆点的填充色",paraId:35,tocIndex:7},{value:"String",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"'#72CC4A'",paraId:35,tocIndex:7},{value:"stroke",paraId:35,tocIndex:7},{value:"圆点的边框颜色",paraId:35,tocIndex:7},{value:"String",paraId:35,tocIndex:7},{value:"默认为 ",paraId:35,tocIndex:7},{value:"'#72CC4A'",paraId:35,tocIndex:7},{value:"lineWidth",paraId:35,tocIndex:7},{value:"圆点边框的宽度",paraId:35,tocIndex:7},{value:"Number",paraId:35,tocIndex:7},{value:"默认为 1",paraId:35,tocIndex:7},{value:"基于上面 ",paraId:36,tocIndex:7},{value:"样式属性 style",paraId:37,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:36,tocIndex:7},{value:"defaultNode",paraId:36,tocIndex:7},{value:" 中增加了  ",paraId:36,tocIndex:7},{value:"linkPoints",paraId:36,tocIndex:7},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:36,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      size: 5,\n      fill: '#fff',\n    },\n  },\n});\n// ...\n",paraId:38,tocIndex:7},{value:"通过 ",paraId:39,tocIndex:8},{value:"preRect",paraId:39,tocIndex:8},{value:" 可以配置左侧的小矩形形状。",paraId:39,tocIndex:8},{value:"名称",paraId:40,tocIndex:8},{value:"含义",paraId:40,tocIndex:8},{value:"类型",paraId:40,tocIndex:8},{value:"备注",paraId:40,tocIndex:8},{value:"show",paraId:40,tocIndex:8},{value:"是否显示左侧小矩形",paraId:40,tocIndex:8},{value:"Boolean",paraId:40,tocIndex:8},{value:"默认为 ",paraId:40,tocIndex:8},{value:"true",paraId:40,tocIndex:8},{value:"width",paraId:40,tocIndex:8},{value:"左侧小矩形的宽度",paraId:40,tocIndex:8},{value:"Number",paraId:40,tocIndex:8},{value:"默认为 4",paraId:40,tocIndex:8},{value:"fill",paraId:40,tocIndex:8},{value:"左侧小矩形的填充色",paraId:40,tocIndex:8},{value:"String",paraId:40,tocIndex:8},{value:"默认为  ",paraId:40,tocIndex:8},{value:"'#40a9ff'",paraId:40,tocIndex:8},{value:"radius",paraId:40,tocIndex:8},{value:"左侧小矩形的圆角弧度",paraId:40,tocIndex:8},{value:"Number",paraId:40,tocIndex:8},{value:"默认为 2",paraId:40,tocIndex:8},{value:"基于上面 ",paraId:41,tocIndex:8},{value:"样式属性 style",paraId:42,tocIndex:8},{value:" 中的代码，下面代码在 ",paraId:41,tocIndex:8},{value:"defaultNode",paraId:41,tocIndex:8},{value:" 中增加了  ",paraId:41,tocIndex:8},{value:"preRect",paraId:41,tocIndex:8},{value:"  配置项进行左侧小矩形的配置，使之达到如下图效果。",paraId:41,tocIndex:8},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    preRect: {\n      // 设置为 false，则不显示\n      show: true,\n      fill: '#f759ab',\n      width: 8,\n    },\n  },\n});\n// ...\n",paraId:43,tocIndex:8},{value:"通过 ",paraId:44,tocIndex:9},{value:"logoIcon",paraId:44,tocIndex:9},{value:" 和 ",paraId:44,tocIndex:9},{value:"stateIcon",paraId:44,tocIndex:9},{value:" 可以配置左侧的 logo 小图标和右边的状态小图标，这两个的配置项完全相同。",paraId:44,tocIndex:9},{value:"名称",paraId:45,tocIndex:9},{value:"含义",paraId:45,tocIndex:9},{value:"类型",paraId:45,tocIndex:9},{value:"备注",paraId:45,tocIndex:9},{value:"show",paraId:45,tocIndex:9},{value:"是否显示图标",paraId:45,tocIndex:9},{value:"Boolean",paraId:45,tocIndex:9},{value:"默认为 ",paraId:45,tocIndex:9},{value:"true",paraId:45,tocIndex:9},{value:"img",paraId:45,tocIndex:9},{value:"图标图片",paraId:45,tocIndex:9},{value:"String",paraId:45,tocIndex:9},{value:"- 左侧图标 ",paraId:45,tocIndex:9},{value:"logoIcon",paraId:45,tocIndex:9},{value:" 的图片默认为  ",paraId:45,tocIndex:9},{value:"- 右侧图标 ",paraId:45,tocIndex:9},{value:"stateIcon",paraId:45,tocIndex:9},{value:" 的图片默认为 ",paraId:45,tocIndex:9},{value:"width",paraId:45,tocIndex:9},{value:"图标的宽度",paraId:45,tocIndex:9},{value:"Number",paraId:45,tocIndex:9},{value:"默认为 16",paraId:45,tocIndex:9},{value:"height",paraId:45,tocIndex:9},{value:"图标的高度",paraId:45,tocIndex:9},{value:"Number",paraId:45,tocIndex:9},{value:"默认为 16",paraId:45,tocIndex:9},{value:"offset",paraId:45,tocIndex:9},{value:"图标的左右偏移量",paraId:45,tocIndex:9},{value:"Number",paraId:45,tocIndex:9},{value:"- 左侧图标 ",paraId:45,tocIndex:9},{value:"logoIcon",paraId:45,tocIndex:9},{value:" 的 ",paraId:45,tocIndex:9},{value:"offset",paraId:45,tocIndex:9},{value:" 默认为 0",paraId:45,tocIndex:9},{value:"- 右侧图标 ",paraId:45,tocIndex:9},{value:"stateIcon",paraId:45,tocIndex:9},{value:" 的 ",paraId:45,tocIndex:9},{value:"offset",paraId:45,tocIndex:9},{value:"  默认为 -5",paraId:45,tocIndex:9},{value:"基于上面 ",paraId:46,tocIndex:9},{value:"样式属性 style",paraId:47,tocIndex:9},{value:" 中的代码，下面代码在 ",paraId:46,tocIndex:9},{value:"defaultNode",paraId:46,tocIndex:9},{value:" 中增加了 ",paraId:46,tocIndex:9},{value:"logoIcon",paraId:46,tocIndex:9},{value:" 和 ",paraId:46,tocIndex:9},{value:"stateIcon",paraId:46,tocIndex:9},{value:" 配置项进行左右图标的配置，使之达到如下图效果，左侧图标不显示，右侧图标更换图片。",paraId:46,tocIndex:9},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    logoIcon: {\n      show: false,\n    },\n    stateIcon: {\n      show: true,\n      img:\n        'https://gw.alipayobjects.com/zos/basement_prod/c781088a-c635-452a-940c-0173663456d4.svg',\n    },\n  },\n});\n// ...\n",paraId:48,tocIndex:9}]},83289:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了 rect 节点，其默认样式如下。标签文本位于矩形中央。",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置节点",paraId:2,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.node(nodeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.node(nodeFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:0},{value:"节点的通用属性",paraId:5,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultNode",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'rect'",paraId:6,tocIndex:1},{value:"，即可使用 ",paraId:6,tocIndex:1},{value:"rect",paraId:6,tocIndex:1},{value:" 节点。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'rect',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'rect',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n};\n",paraId:9,tocIndex:2},{value:"rect 节点支持 ",paraId:10,tocIndex:3},{value:"节点通用配置",paraId:11,tocIndex:3},{value:"，下表对部分属性进行解释。对于 Object 类型的配置项将在后面有详细讲解：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"rect 的宽高",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"Array",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"rect 默认样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本内容",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"只对 ",paraId:12,tocIndex:3},{value:"keyShape",paraId:12,tocIndex:3},{value:" 起作用",paraId:12,tocIndex:3},{value:"linkPoints",paraId:12,tocIndex:3},{value:"视觉上的",paraId:12,tocIndex:3},{value:"四个锚点",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示，应与 ",paraId:12,tocIndex:3},{value:"anchorPoints",paraId:13,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:3},{value:"linkPoints",paraId:14,tocIndex:3},{value:"Object 类型。支持 ",paraId:15,tocIndex:4},{value:"节点通用样式",paraId:16,tocIndex:4},{value:"。通过 ",paraId:15,tocIndex:4},{value:"style",paraId:15,tocIndex:4},{value:" 配置来修改 ",paraId:15,tocIndex:4},{value:"rect",paraId:15,tocIndex:4},{value:" 的填充色、边框颜色、阴影等属性。",paraId:15,tocIndex:4},{value:"名称",paraId:17,tocIndex:4},{value:"含义",paraId:17,tocIndex:4},{value:"类型",paraId:17,tocIndex:4},{value:"备注",paraId:17,tocIndex:4},{value:"radius",paraId:17,tocIndex:4},{value:"圆角半径",paraId:17,tocIndex:4},{value:"Number",paraId:17,tocIndex:4},{value:"默认为直角矩形",paraId:17,tocIndex:4},{value:"stroke",paraId:17,tocIndex:4},{value:"描边颜色",paraId:17,tocIndex:4},{value:"String",paraId:17,tocIndex:4},{value:"lineWidth",paraId:17,tocIndex:4},{value:"描边粗细",paraId:17,tocIndex:4},{value:"Number",paraId:17,tocIndex:4},{value:"默认为 ",paraId:17,tocIndex:4},{value:"1",paraId:17,tocIndex:4},{value:"fill",paraId:17,tocIndex:4},{value:"填充色",paraId:17,tocIndex:4},{value:"String",paraId:17,tocIndex:4},{value:"fillOpacity",paraId:17,tocIndex:4},{value:"透明度",paraId:17,tocIndex:4},{value:"Number",paraId:17,tocIndex:4},{value:"默认为 ",paraId:17,tocIndex:4},{value:"1",paraId:17,tocIndex:4},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:18,tocIndex:4},{value:"style",paraId:18,tocIndex:4},{value:"，使之达到如下图效果。",paraId:18,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'rect',\n      label: 'rect',\n    },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 300,\n  defaultNode: {\n    // type: 'rect', // 在数据中已经指定了 type，这里无需再次指定\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n      radius: 10,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:19,tocIndex:4},{value:"Object 类型。通过 ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:20,tocIndex:5},{value:"节点通用标签配置",paraId:21,tocIndex:5},{value:"。基于上面 ",paraId:20,tocIndex:5},{value:"样式属性 style",paraId:22,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:20,tocIndex:5},{value:"defaultNode",paraId:20,tocIndex:5},{value:" 中增加了  ",paraId:20,tocIndex:5},{value:"labelCfg",paraId:20,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:20,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultNode: {\n    // ... 其他配置\n    labelCfg: {\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n      position: 'bottom',\n    },\n  },\n});\n// ...\n",paraId:23,tocIndex:5},{value:"Object 类型。通过配置 ",paraId:24,tocIndex:6},{value:"linkPoints",paraId:24,tocIndex:6},{value:" ，可以指定矩形周围「上、下、左、右」四个小圆点。",paraId:24,tocIndex:6},{value:"⚠️ 注意:",paraId:25,tocIndex:6},{value:" 区分于 ",paraId:25,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:"： ",paraId:25,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:25,tocIndex:6},{value:"数组",paraId:25,tocIndex:6},{value:"」，见 ",paraId:25,tocIndex:6},{value:"anchorPoints",paraId:26,tocIndex:6},{value:"；而 ",paraId:25,tocIndex:6},{value:"linkPoints",paraId:25,tocIndex:6},{value:" 仅是指定是否「",paraId:25,tocIndex:6},{value:"绘制",paraId:25,tocIndex:6},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:25,tocIndex:6},{value:"名称",paraId:27,tocIndex:6},{value:"含义",paraId:27,tocIndex:6},{value:"类型",paraId:27,tocIndex:6},{value:"备注",paraId:27,tocIndex:6},{value:"top",paraId:27,tocIndex:6},{value:"是否显示上部的圆点",paraId:27,tocIndex:6},{value:"Boolean",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"false",paraId:27,tocIndex:6},{value:"bottom",paraId:27,tocIndex:6},{value:"是否显示底部的圆点",paraId:27,tocIndex:6},{value:"Boolean",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"false",paraId:27,tocIndex:6},{value:"left",paraId:27,tocIndex:6},{value:"是否显示左侧的圆点",paraId:27,tocIndex:6},{value:"Boolean",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"false",paraId:27,tocIndex:6},{value:"right",paraId:27,tocIndex:6},{value:"是否显示右侧的圆点",paraId:27,tocIndex:6},{value:"Boolean",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"false",paraId:27,tocIndex:6},{value:"size",paraId:27,tocIndex:6},{value:"圆点的大小",paraId:27,tocIndex:6},{value:"Number",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"3",paraId:27,tocIndex:6},{value:"fill",paraId:27,tocIndex:6},{value:"圆点的填充色",paraId:27,tocIndex:6},{value:"String",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"'#72CC4A'",paraId:27,tocIndex:6},{value:"stroke",paraId:27,tocIndex:6},{value:"圆点的边框颜色",paraId:27,tocIndex:6},{value:"String",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"'#72CC4A'",paraId:27,tocIndex:6},{value:"lineWidth",paraId:27,tocIndex:6},{value:"圆点边框的宽度",paraId:27,tocIndex:6},{value:"Number",paraId:27,tocIndex:6},{value:"默认为 ",paraId:27,tocIndex:6},{value:"1",paraId:27,tocIndex:6},{value:"基于上面 ",paraId:28,tocIndex:6},{value:"样式属性 style",paraId:29,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:28,tocIndex:6},{value:"defaultNode",paraId:28,tocIndex:6},{value:" 中增加了  ",paraId:28,tocIndex:6},{value:"linkPoints",paraId:28,tocIndex:6},{value:"  配置项进行连入点的配置。",paraId:28,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他配置\n  defaultNode: {\n    // 其他配置\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      size: 5,\n      fill: '#fff',\n    },\n  },\n});\n// ...\n",paraId:30,tocIndex:6}]},35197:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了星形  star 节点，其默认样式如下。标签文本位于星形中央。",paraId:0},{value:"如 ",paraId:1,tocIndex:0},{value:"内置节点",paraId:2,tocIndex:0},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:0},{value:"graph.node(nodeFn)",paraId:1,tocIndex:0},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:0},{value:"使用 ",paraId:3,tocIndex:0},{value:"graph.node(nodeFn)",paraId:3,tocIndex:0},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:0},{value:"⚠️ 注意:",paraId:4,tocIndex:0},{value:" 除 ",paraId:4,tocIndex:0},{value:"id",paraId:4,tocIndex:0},{value:"、",paraId:4,tocIndex:0},{value:"label",paraId:4,tocIndex:0},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:0},{value:"节点的通用属性",paraId:5,tocIndex:0},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:0},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:1},{value:"defaultNode",paraId:6,tocIndex:1},{value:" 指定 ",paraId:6,tocIndex:1},{value:"type",paraId:6,tocIndex:1},{value:" 为 ",paraId:6,tocIndex:1},{value:"'star'",paraId:6,tocIndex:1},{value:"，即可使用 ",paraId:6,tocIndex:1},{value:"star",paraId:6,tocIndex:1},{value:" 节点。",paraId:6,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'star',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:1},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:2},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'star',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:2},{value:"star 节点支持 ",paraId:10,tocIndex:3},{value:"节点通用配置",paraId:11,tocIndex:3},{value:"，下表对部分属性进行解释：",paraId:10,tocIndex:3},{value:"名称",paraId:12,tocIndex:3},{value:"含义",paraId:12,tocIndex:3},{value:"类型",paraId:12,tocIndex:3},{value:"备注",paraId:12,tocIndex:3},{value:"size",paraId:12,tocIndex:3},{value:"五角星的大小",paraId:12,tocIndex:3},{value:"number",paraId:12,tocIndex:3},{value:"Array",paraId:12,tocIndex:3},{value:"innerR",paraId:12,tocIndex:3},{value:"五角星内环大小",paraId:12,tocIndex:3},{value:"Number",paraId:12,tocIndex:3},{value:"默认为 size * 3 / 8",paraId:12,tocIndex:3},{value:"style",paraId:12,tocIndex:3},{value:"五角星的默认样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"Canvas 支持的属性",paraId:12,tocIndex:3},{value:"label",paraId:12,tocIndex:3},{value:"标签文本内容",paraId:12,tocIndex:3},{value:"String",paraId:12,tocIndex:3},{value:"labelCfg",paraId:12,tocIndex:3},{value:"标签文本配置项",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"stateStyles",paraId:12,tocIndex:3},{value:"各状态下的样式",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"详见",paraId:12,tocIndex:3},{value:"配置状态样式",paraId:13,tocIndex:3},{value:"linkPoints",paraId:12,tocIndex:3},{value:"视觉上的",paraId:12,tocIndex:3},{value:"五个锚点",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示，应与 ",paraId:12,tocIndex:3},{value:"anchorPoints",paraId:14,tocIndex:3},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:3},{value:"linkPoints",paraId:15,tocIndex:3},{value:"icon",paraId:12,tocIndex:3},{value:"五角星上 icon 配置",paraId:12,tocIndex:3},{value:"Object",paraId:12,tocIndex:3},{value:"默认不显示 icon",paraId:12,tocIndex:3},{value:"Object 类型。支持 ",paraId:16,tocIndex:4},{value:"节点通用样式",paraId:17,tocIndex:4},{value:"。通过 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:4},{value:"style",paraId:16,tocIndex:4},{value:"，使之达到如下图效果。",paraId:16,tocIndex:4},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'star',\n      label: 'star',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'star',   // 在数据中已经指定 type，这里无需再次指定\n    size: 80,\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:18,tocIndex:4},{value:"Object 类型。通过 ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:" 配置标签文本。支持 ",paraId:19,tocIndex:5},{value:"节点通用标签配置",paraId:20,tocIndex:5},{value:"。基于上面 ",paraId:19,tocIndex:5},{value:"样式属性 style",paraId:21,tocIndex:5},{value:" 中的代码，下面代码在 ",paraId:19,tocIndex:5},{value:"defaultNode",paraId:19,tocIndex:5},{value:" 中增加了  ",paraId:19,tocIndex:5},{value:"labelCfg",paraId:19,tocIndex:5},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:19,tocIndex:5},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n    },\n  },\n});\n// ...\n",paraId:22,tocIndex:5},{value:"Object 类型。通过配置 ",paraId:23,tocIndex:6},{value:"linkPoints",paraId:23,tocIndex:6},{value:" ，可以指定圆周围「上、左下、➡ 右下、左、右」五个小圆点。",paraId:23,tocIndex:6},{value:"⚠️ 注意:",paraId:24,tocIndex:6},{value:" 区分于 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:"： ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:24,tocIndex:6},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:24,tocIndex:6},{value:"数组",paraId:24,tocIndex:6},{value:"」，见 ",paraId:24,tocIndex:6},{value:"anchorPoints",paraId:25,tocIndex:6},{value:"；而 ",paraId:24,tocIndex:6},{value:"linkPoints",paraId:24,tocIndex:6},{value:" 仅是指定是否「",paraId:24,tocIndex:6},{value:"绘制",paraId:24,tocIndex:6},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:24,tocIndex:6},{value:"名称",paraId:26,tocIndex:6},{value:"含义",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"备注",paraId:26,tocIndex:6},{value:"top",paraId:26,tocIndex:6},{value:"是否显示上部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"leftBottom",paraId:26,tocIndex:6},{value:"是否显示左底部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"，star 特有",paraId:26,tocIndex:6},{value:"rightBottom",paraId:26,tocIndex:6},{value:"是否显示右底部的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"，star 特有",paraId:26,tocIndex:6},{value:"left",paraId:26,tocIndex:6},{value:"是否显示左侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"right",paraId:26,tocIndex:6},{value:"是否显示右侧的圆点",paraId:26,tocIndex:6},{value:"Boolean",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"false",paraId:26,tocIndex:6},{value:"size",paraId:26,tocIndex:6},{value:"圆点的大小",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 3",paraId:26,tocIndex:6},{value:"fill",paraId:26,tocIndex:6},{value:"圆点的填充色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"stroke",paraId:26,tocIndex:6},{value:"圆点的边框颜色",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"'#72CC4A'",paraId:26,tocIndex:6},{value:"lineWidth",paraId:26,tocIndex:6},{value:"圆点边框的宽度",paraId:26,tocIndex:6},{value:"Number",paraId:26,tocIndex:6},{value:"默认为 ",paraId:26,tocIndex:6},{value:"1",paraId:26,tocIndex:6},{value:"基于上面 ",paraId:27,tocIndex:6},{value:"样式属性 style",paraId:28,tocIndex:6},{value:" 中的代码，下面代码在 ",paraId:27,tocIndex:6},{value:"defaultNode",paraId:27,tocIndex:6},{value:" 中增加了  ",paraId:27,tocIndex:6},{value:"linkPoints",paraId:27,tocIndex:6},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:27,tocIndex:6},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    linkPoints: {\n      top: true,\n      left: true,\n      right: true,\n      leftBottom: true,\n      rightBottom: true,\n      size: 5,\n      fill: '#fff',\n    },\n  },\n});\n// ...\n",paraId:29,tocIndex:6},{value:"Object 类型。通过配置 ",paraId:30,tocIndex:7},{value:"icon",paraId:30,tocIndex:7},{value:"，可以在圆上显示小图标。",paraId:30,tocIndex:7},{value:"名称",paraId:31,tocIndex:7},{value:"含义",paraId:31,tocIndex:7},{value:"类型",paraId:31,tocIndex:7},{value:"备注",paraId:31,tocIndex:7},{value:"show",paraId:31,tocIndex:7},{value:"是否显示 icon",paraId:31,tocIndex:7},{value:"Boolean",paraId:31,tocIndex:7},{value:"默认为 false，不显示",paraId:31,tocIndex:7},{value:"width",paraId:31,tocIndex:7},{value:"icon 的宽度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 16",paraId:31,tocIndex:7},{value:"height",paraId:31,tocIndex:7},{value:"icon 的高度",paraId:31,tocIndex:7},{value:"Number",paraId:31,tocIndex:7},{value:"默认为 16",paraId:31,tocIndex:7},{value:"img",paraId:31,tocIndex:7},{value:"icon 的地址或 base64",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用图片作为 icon",paraId:31,tocIndex:7},{value:"text",paraId:31,tocIndex:7},{value:"icon 的 iconfont",paraId:31,tocIndex:7},{value:"String",paraId:31,tocIndex:7},{value:"若配置则表示使用 iconfont 作为 icon",paraId:31,tocIndex:7},{value:"基于上面 ",paraId:32,tocIndex:7},{value:"样式属性 style",paraId:33,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:32,tocIndex:7},{value:"defaultNode",paraId:32,tocIndex:7},{value:" 中增加了 ",paraId:32,tocIndex:7},{value:"icon",paraId:32,tocIndex:7},{value:"  配置项进行图标的配置，使之达到如下图效果。",paraId:32,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    icon: {\n      show: true,\n      width: 25,\n      height: 25,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n    },\n  },\n});\n// ...\n",paraId:34,tocIndex:7}]},19649:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 内置了三角形  Triangle 节点，其默认样式如下。标签文本位于三角形下方。",paraId:0,tocIndex:0},{value:"如 ",paraId:1,tocIndex:1},{value:"内置节点",paraId:2,tocIndex:1},{value:" 一节所示，配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:1,tocIndex:1},{value:"graph.node(nodeFn)",paraId:1,tocIndex:1},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:1,tocIndex:1},{value:"使用 ",paraId:3,tocIndex:1},{value:"graph.node(nodeFn)",paraId:3,tocIndex:1},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:3,tocIndex:1},{value:"⚠️ 注意:",paraId:4,tocIndex:1},{value:" 除 ",paraId:4,tocIndex:1},{value:"id",paraId:4,tocIndex:1},{value:"、",paraId:4,tocIndex:1},{value:"label",paraId:4,tocIndex:1},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:4,tocIndex:1},{value:"节点的通用属性",paraId:5,tocIndex:1},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:4,tocIndex:1},{value:"用户在实例化 Graph 时候可以通过 ",paraId:6,tocIndex:2},{value:"defaultNode",paraId:6,tocIndex:2},{value:" 指定 ",paraId:6,tocIndex:2},{value:"type",paraId:6,tocIndex:2},{value:" 为 ",paraId:6,tocIndex:2},{value:"'triangle'",paraId:6,tocIndex:2},{value:"，即可使用 ",paraId:6,tocIndex:2},{value:"triangle",paraId:6,tocIndex:2},{value:" 节点。",paraId:6,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'triangle',\n    // 其他配置\n  },\n});\n",paraId:7,tocIndex:2},{value:"如果需要使不同节点有不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:8,tocIndex:3},{value:"const data = {\n  nodes: [{\n\t  id: 'node0',\n    type: 'triangle',\n    ... // 其他配置\n    },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:9,tocIndex:3},{value:"triangle 节点支持 ",paraId:10,tocIndex:4},{value:"节点通用配置",paraId:11,tocIndex:4},{value:"，下表对部分属性进行解释：",paraId:10,tocIndex:4},{value:"名称",paraId:12,tocIndex:4},{value:"含义",paraId:12,tocIndex:4},{value:"类型",paraId:12,tocIndex:4},{value:"备注",paraId:12,tocIndex:4},{value:"size",paraId:12,tocIndex:4},{value:"三角形的边长",paraId:12,tocIndex:4},{value:"Number",paraId:12,tocIndex:4},{value:"Array",paraId:12,tocIndex:4},{value:"direction",paraId:12,tocIndex:4},{value:"三角形的方向",paraId:12,tocIndex:4},{value:"String",paraId:12,tocIndex:4},{value:"可取值：",paraId:12,tocIndex:4},{value:"'up'",paraId:12,tocIndex:4},{value:"，",paraId:12,tocIndex:4},{value:"'down'",paraId:12,tocIndex:4},{value:"，",paraId:12,tocIndex:4},{value:"'left'",paraId:12,tocIndex:4},{value:"，",paraId:12,tocIndex:4},{value:"'right'",paraId:12,tocIndex:4},{value:"。默认为 ",paraId:12,tocIndex:4},{value:"'up'",paraId:12,tocIndex:4},{value:"style",paraId:12,tocIndex:4},{value:"三角形默认样式",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"Canvas 支持的属性",paraId:12,tocIndex:4},{value:"label",paraId:12,tocIndex:4},{value:"标签文本内容",paraId:12,tocIndex:4},{value:"String",paraId:12,tocIndex:4},{value:"labelCfg",paraId:12,tocIndex:4},{value:"标签文本配置项",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"stateStyles",paraId:12,tocIndex:4},{value:"各状态下的样式",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"详见",paraId:12,tocIndex:4},{value:"配置状态样式",paraId:13,tocIndex:4},{value:"linkPoints",paraId:12,tocIndex:4},{value:"视觉上的",paraId:12,tocIndex:4},{value:"三个锚点",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"默认不显示，应与 ",paraId:12,tocIndex:4},{value:"anchorPoints",paraId:14,tocIndex:4},{value:" 配合使用。二者区别请看 ",paraId:12,tocIndex:4},{value:"linkPoints",paraId:15,tocIndex:4},{value:"icon",paraId:12,tocIndex:4},{value:"三角形上 icon 配置",paraId:12,tocIndex:4},{value:"Object",paraId:12,tocIndex:4},{value:"默认不显示 icon",paraId:12,tocIndex:4},{value:"String 类型。可取值有：",paraId:16,tocIndex:5},{value:"'``up'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'down'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'left'",paraId:16,tocIndex:5},{value:"、",paraId:16,tocIndex:5},{value:"'right'",paraId:16,tocIndex:5},{value:"。默认为  ",paraId:16,tocIndex:5},{value:"'``up'",paraId:16,tocIndex:5},{value:"。通过设置 ",paraId:16,tocIndex:5},{value:"direction",paraId:16,tocIndex:5},{value:"，可以修改三角形的方向。下面代码演示在实例化图时全局配置方法中配置 ",paraId:16,tocIndex:5},{value:"direction",paraId:16,tocIndex:5},{value:"。",paraId:16,tocIndex:5},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'triangle',\n    direction: 'down',\n  },\n});\n",paraId:17,tocIndex:5},{value:"上图分别是将 ",paraId:18,tocIndex:5},{value:"direction",paraId:18,tocIndex:5},{value:" 配置为 ",paraId:18,tocIndex:5},{value:"'up'",paraId:18,tocIndex:5},{value:"，",paraId:18,tocIndex:5},{value:"'down'",paraId:18,tocIndex:5},{value:"，",paraId:18,tocIndex:5},{value:"'left'",paraId:18,tocIndex:5},{value:"，",paraId:18,tocIndex:5},{value:"'right'",paraId:18,tocIndex:5},{value:" 的结果",paraId:18,tocIndex:5},{value:"Object 类型。支持 ",paraId:19,tocIndex:6},{value:"节点通用样式",paraId:20,tocIndex:6},{value:"。通过 ",paraId:19,tocIndex:6},{value:"style",paraId:19,tocIndex:6},{value:" 配置来修改节点的填充色、描边等属性。下面代码演示在实例化图时全局配置方法中配置 ",paraId:19,tocIndex:6},{value:"style",paraId:19,tocIndex:6},{value:"，使之达到如下图效果。",paraId:19,tocIndex:6},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      type: 'triangle',\n      label: 'triangle',\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // type: 'triangle', // 在数据中已经指定 type，这里无需再次指定\n    direction: 'up',\n    size: 100,\n    style: {\n      fill: '#bae637',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:21,tocIndex:6},{value:"Object 类型。通过 ",paraId:22,tocIndex:7},{value:"labelCfg",paraId:22,tocIndex:7},{value:" 配置标签文本。支持 ",paraId:22,tocIndex:7},{value:"节点通用标签配置",paraId:23,tocIndex:7},{value:"。基于上面 ",paraId:22,tocIndex:7},{value:"样式属性 style",paraId:24,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:22,tocIndex:7},{value:"defaultNode",paraId:22,tocIndex:7},{value:" 中增加了  ",paraId:22,tocIndex:7},{value:"labelCfg",paraId:22,tocIndex:7},{value:"  配置项进行文本的配置，使之达到如下图效果。",paraId:22,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 节点其他属性\n    labelCfg: {\n      position: 'center',\n      style: {\n        fill: '#9254de',\n        fontSize: 18,\n      },\n    },\n  },\n});\n// ...\n",paraId:25,tocIndex:7},{value:"### linkPoints Object 类型。通过配置 ",paraId:26,tocIndex:7},{value:"linkPoints",paraId:26,tocIndex:7},{value:" ，可以指定节点上「上、左、右」三个小圆点。",paraId:26,tocIndex:7},{value:"⚠️ 注意:",paraId:27,tocIndex:7},{value:" 区分于 ",paraId:27,tocIndex:7},{value:"anchorPoints",paraId:27,tocIndex:7},{value:"： ",paraId:27,tocIndex:7},{value:"anchorPoints",paraId:27,tocIndex:7},{value:" 是真正用于指定该节点相关边的连入位置的「",paraId:27,tocIndex:7},{value:"数组",paraId:27,tocIndex:7},{value:"」，见 ",paraId:27,tocIndex:7},{value:"anchorPoints",paraId:28,tocIndex:7},{value:"；而 ",paraId:27,tocIndex:7},{value:"linkPoints",paraId:27,tocIndex:7},{value:" 仅是指定是否「",paraId:27,tocIndex:7},{value:"绘制",paraId:27,tocIndex:7},{value:"」出四个圆点，不起实际的连接相关边的作用。二者常常配合使用。",paraId:27,tocIndex:7},{value:"名称",paraId:29,tocIndex:7},{value:"含义",paraId:29,tocIndex:7},{value:"类型",paraId:29,tocIndex:7},{value:"备注",paraId:29,tocIndex:7},{value:"top",paraId:29,tocIndex:7},{value:"是否显示上部的圆点",paraId:29,tocIndex:7},{value:"Boolean",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"false",paraId:29,tocIndex:7},{value:"left",paraId:29,tocIndex:7},{value:"是否显示左侧的圆点",paraId:29,tocIndex:7},{value:"Boolean",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"false",paraId:29,tocIndex:7},{value:"right",paraId:29,tocIndex:7},{value:"是否显示右侧的圆点",paraId:29,tocIndex:7},{value:"Boolean",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"false",paraId:29,tocIndex:7},{value:"size",paraId:29,tocIndex:7},{value:"圆点的大小",paraId:29,tocIndex:7},{value:"Number",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"3",paraId:29,tocIndex:7},{value:"fill",paraId:29,tocIndex:7},{value:"圆点的填充色",paraId:29,tocIndex:7},{value:"String",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"'#72CC4A'",paraId:29,tocIndex:7},{value:"stroke",paraId:29,tocIndex:7},{value:"圆点的边框颜色",paraId:29,tocIndex:7},{value:"String",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"'#72CC4A'",paraId:29,tocIndex:7},{value:"lineWidth",paraId:29,tocIndex:7},{value:"圆点边框的宽度",paraId:29,tocIndex:7},{value:"Number",paraId:29,tocIndex:7},{value:"默认为 ",paraId:29,tocIndex:7},{value:"1",paraId:29,tocIndex:7},{value:"基于上面 ",paraId:30,tocIndex:7},{value:"样式属性 style",paraId:31,tocIndex:7},{value:" 中的代码，下面代码在 ",paraId:30,tocIndex:7},{value:"defaultNode",paraId:30,tocIndex:7},{value:" 中增加了  ",paraId:30,tocIndex:7},{value:"linkPoints",paraId:30,tocIndex:7},{value:"  配置项进行连入点的配置，使之达到如下图效果。",paraId:30,tocIndex:7},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    linkPoints: {\n      top: true,\n      bottom: true,\n      left: true,\n      right: true,\n      fill: '#fff',\n      size: 5,\n    },\n  },\n});\n// ...\n",paraId:32,tocIndex:7},{value:"Object 类型。通过配置 ",paraId:33,tocIndex:8},{value:"icon",paraId:33,tocIndex:8},{value:"，可以在圆上显示小图标。",paraId:33,tocIndex:8},{value:"名称",paraId:34,tocIndex:8},{value:"含义",paraId:34,tocIndex:8},{value:"类型",paraId:34,tocIndex:8},{value:"备注",paraId:34,tocIndex:8},{value:"show",paraId:34,tocIndex:8},{value:"是否显示 icon",paraId:34,tocIndex:8},{value:"Boolean",paraId:34,tocIndex:8},{value:"默认为 false，不显示",paraId:34,tocIndex:8},{value:"width",paraId:34,tocIndex:8},{value:"icon 的宽度",paraId:34,tocIndex:8},{value:"Number",paraId:34,tocIndex:8},{value:"默认为 16",paraId:34,tocIndex:8},{value:"height",paraId:34,tocIndex:8},{value:"icon 的高度",paraId:34,tocIndex:8},{value:"Number",paraId:34,tocIndex:8},{value:"默认为 16",paraId:34,tocIndex:8},{value:"img",paraId:34,tocIndex:8},{value:"icon 的地址或 base64",paraId:34,tocIndex:8},{value:"String",paraId:34,tocIndex:8},{value:"若配置则表示使用 iconfont 作为 icon",paraId:34,tocIndex:8},{value:"text",paraId:34,tocIndex:8},{value:"icon 的 iconfont",paraId:34,tocIndex:8},{value:"String",paraId:34,tocIndex:8},{value:"若配置则表示使用 iconfont 作为 icon",paraId:34,tocIndex:8},{value:"offset",paraId:34,tocIndex:8},{value:"icon 的偏移量",paraId:34,tocIndex:8},{value:"Number",paraId:34,tocIndex:8},{value:"默认为 0，triangle 节点的 icon 特有的配置",paraId:34,tocIndex:8},{value:"基于上面 ",paraId:35,tocIndex:8},{value:"样式属性 style",paraId:36,tocIndex:8},{value:" 中的代码，下面代码在 ",paraId:35,tocIndex:8},{value:"defaultNode",paraId:35,tocIndex:8},{value:" 中增加了 ",paraId:35,tocIndex:8},{value:"icon",paraId:35,tocIndex:8},{value:"  配置项进行图标的配置，使之达到如下图效果。",paraId:35,tocIndex:8},{value:"const data = {\n  // ... data 内容\n};\nconst graph = new G6.Graph({\n  // ... 图的其他属性\n  defaultNode: {\n    // ... 其他属性\n    icon: {\n      show: true,\n      width: 30,\n      height: 30,\n      offset: 20,\n      // img: '...', 可更换为其他图片地址\n      // text: '...', 使用 iconfont\n    },\n  },\n});\n// ...\n",paraId:37,tocIndex:8}]},96369:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了一系列",paraId:0},{value:"内置节点",paraId:1},{value:"，包括 ",paraId:0},{value:"circle",paraId:2},{value:"、",paraId:0},{value:"rect",paraId:3},{value:"、",paraId:0},{value:"diamond",paraId:4},{value:"、",paraId:0},{value:"triangle",paraId:5},{value:"、",paraId:0},{value:"star",paraId:6},{value:"、",paraId:0},{value:"image",paraId:7},{value:"、",paraId:0},{value:"modelRect",paraId:8},{value:"。若内置节点无法满足需求，用户还可以通过 ",paraId:0},{value:"G6.registerNode(typeName: string, nodeDefinition: object, extendedNodeType?: string)",paraId:0},{value:" 进行自定义节点，方便用户开发更加定制化的节点，包括含有复杂图形的节点、复杂交互的节点、带有动画的节点等。其参数：",paraId:0},{value:"typeName",paraId:9},{value:"：该新节点类型名称；",paraId:9},{value:"extendedNodeType",paraId:9},{value:"：被继承的节点类型，可以是内置节点类型名，也可以是其他自定义节点的类型名。",paraId:9},{value:"extendedNodeType",paraId:9},{value:" 未指定时代表不继承其他类型的节点；",paraId:9},{value:"nodeDefinition",paraId:9},{value:"：该新节点类型的定义，其中必要函数详见 ",paraId:9},{value:"自定义机制 API",paraId:10},{value:"。当有 ",paraId:9},{value:"extendedNodeType",paraId:9},{value:" 时，没被复写的函数将会继承 ",paraId:9},{value:"extendedNodeType",paraId:9},{value:" 的定义。",paraId:9},{value:"需要注意的是",paraId:11},{value:"，自定义节点/边时，若给定了 ",paraId:11},{value:"extendedNodeType",paraId:11},{value:"，如 ",paraId:11},{value:"draw",paraId:11},{value:"，",paraId:11},{value:"update",paraId:11},{value:"，",paraId:11},{value:"setState",paraId:11},{value:" 等必要的函数若不在 ",paraId:11},{value:"nodeDefinition",paraId:11},{value:" 中进行复写，将会继承 ",paraId:11},{value:"extendedNodeType",paraId:11},{value:" 中的相关定义。常见问题：",paraId:11},{value:"Q：节点/边更新时，没有按照在 ",paraId:12},{value:"nodeDefinition",paraId:12},{value:" 中自定义实现的 ",paraId:12},{value:"draw",paraId:12},{value:" 或 ",paraId:12},{value:"drawShape",paraId:12},{value:" 逻辑更新。例如，有些图形没有被更新，增加了没有在 ",paraId:12},{value:"draw",paraId:12},{value:" 或 ",paraId:12},{value:"drawShape",paraId:12},{value:" 方法中定义的图形等。",paraId:12},{value:"A：由于继承了 ",paraId:12},{value:"extendedNodeType",paraId:12},{value:"，且在 ",paraId:12},{value:"nodeDefinition",paraId:12},{value:" 中没有复写 ",paraId:12},{value:"update",paraId:12},{value:" 方法，导致节点/边更新时执行了 ",paraId:12},{value:"extendedNodeType",paraId:12},{value:" 中的 ",paraId:12},{value:"update",paraId:12},{value:" 方法，从而与自定义的 ",paraId:12},{value:"draw",paraId:12},{value:" 或 ",paraId:12},{value:"drawShape",paraId:12},{value:" 有出入。可以通过复写 ",paraId:12},{value:"update",paraId:12},{value:" 方法为 ",paraId:12},{value:"undefined",paraId:12},{value:" 解决。当 ",paraId:12},{value:"update",paraId:12},{value:" 方法为 ",paraId:12},{value:"undefined",paraId:12},{value:" 时，节点/边的更新将会执行 ",paraId:12},{value:"draw",paraId:12},{value:" 或 ",paraId:12},{value:"drawShape",paraId:12},{value:" 进行重绘。",paraId:12},{value:"在本章中我们会通过五个案例，从简单到复杂讲解节点的自定义。这五个案例是： ",paraId:13},{value:" ",paraId:13},{value:"1. 从无到有的定义节点：",paraId:13},{value:"绘制图形；优化性能。 ",paraId:13},{value:" ",paraId:13},{value:"2. 扩展现有的节点：",paraId:13},{value:"附加图形；增加动画。 ",paraId:13},{value:" ",paraId:13},{value:"3. 调整节点的锚点；",paraId:13},{value:" ",paraId:13},{value:" ",paraId:13},{value:"4. 调整节点的鼠标选中/悬浮样式：",paraId:13},{value:"样式变化响应；动画响应； ",paraId:13},{value:" ",paraId:13},{value:"5. 使用 DOM 自定义节点。",paraId:13},{value:"通过 ",paraId:14},{value:"图形 Shape",paraId:15},{value:" 章节的学习，我们应该已经知道了自定义节点时需要满足以下两点：",paraId:14},{value:"控制节点的生命周期；",paraId:16},{value:"解析用户输入的数据，在图形上展示。",paraId:16},{value:"G6 中自定义节点的 API 如下：",paraId:17},{value:"G6.registerNode(\n  'nodeName',\n  {\n    options: {\n      style: {},\n      stateStyles: {\n        hover: {},\n        selected: {},\n      },\n    },\n    /**\n     * 绘制节点，包含文本\n     * @param  {Object} cfg 节点的配置项\n     * @param  {G.Group} group 图形分组，节点中图形对象的容器\n     * @return {G.Shape} 返回一个绘制的图形作为 keyShape，通过 node.get('keyShape') 可以获取。\n     * 关于 keyShape 可参考文档 核心概念-节点/边/Combo-图形 Shape 与 keyShape\n     */\n    draw(cfg, group) {},\n    /**\n     * 绘制后的附加操作，默认没有任何操作\n     * @param  {Object} cfg 节点的配置项\n     * @param  {G.Group} group 图形分组，节点中图形对象的容器\n     */\n    afterDraw(cfg, group) {},\n    /**\n     * 更新节点，包含文本\n     * @override\n     * @param  {Object} cfg 节点的配置项\n     * @param  {Node} node 节点\n     */\n    update(cfg, node) {},\n    /**\n     * 更新节点后的操作，一般同 afterDraw 配合使用\n     * @override\n     * @param  {Object} cfg 节点的配置项\n     * @param  {Node} node 节点\n     */\n    afterUpdate(cfg, node) {},\n    /**\n     * 响应节点的状态变化。\n     * 在需要使用动画来响应状态变化时需要被复写，其他样式的响应参见下文提及的 [配置状态样式] 文档\n     * @param  {String} name 状态名称\n     * @param  {Object} value 状态值\n     * @param  {Node} node 节点\n     */\n    setState(name, value, node) {},\n    /**\n     * 获取锚点（相关边的连入点）\n     * @param  {Object} cfg 节点的配置项\n     * @return {Array|null} 锚点（相关边的连入点）的数组,如果为 null，则没有控制点\n     */\n    getAnchorPoints(cfg) {},\n  },\n  // 继承内置节点类型的名字，例如基类 'single-node'，或 'circle', 'rect' 等\n  // 当不指定该参数则代表不继承任何内置节点类型\n  extendedNodeType,\n);\n",paraId:18},{value:"   ",paraId:19},{value:"⚠️ 注意:",paraId:19},{value:"如果不从任何现有的节点或从 ",paraId:20},{value:"'single-node'",paraId:20},{value:" 扩展新节点时，",paraId:20},{value:"draw",paraId:20},{value:" 方法是必须的；",paraId:20},{value:"节点内部所有图形",paraId:20},{value:"使用相对于节点自身的坐标系",paraId:20},{value:"，即 ",paraId:20},{value:"(0, 0)",paraId:20},{value:" 是该节点的中心。而节点的坐标是相对于画布的，由该节点 group 上的矩阵控制，自定义节点中不需要用户感知。若在自定义节点内增加 ",paraId:20},{value:"rect",paraId:20},{value:" 图形，要注意让它的 x 与 y 各减去其长与宽的一半。详见例子 ",paraId:20},{value:"从无到有定义节点",paraId:21},{value:"；",paraId:20},{value:"update",paraId:20},{value:" 方法可以不定义：\n",paraId:20},{value:"当 ",paraId:22},{value:"update",paraId:22},{value:" 未定义：若指定了 ",paraId:22},{value:"registerNode",paraId:22},{value:" 的第三个参数 ",paraId:22},{value:"extendedNodeType",paraId:22},{value:"（即代表继承指定的内置节点类型），则节点更新时将执行被继承的内置节点类型的 ",paraId:22},{value:"update",paraId:22},{value:" 逻辑；若未指定 ",paraId:22},{value:"registerNode",paraId:22},{value:" 的第三个参数，则节点更新时会执行 ",paraId:22},{value:"draw",paraId:22},{value:" 方法，所有图形清除重绘；",paraId:22},{value:"当定义了 ",paraId:22},{value:"update",paraId:22},{value:" 方法，则不论是否指定 ",paraId:22},{value:"registerNode",paraId:22},{value:" 的第三个参数，在节点更新时都会执行复写的 ",paraId:22},{value:"update",paraId:22},{value:" 函数逻辑。",paraId:22},{value:"afterDraw",paraId:20},{value:"，",paraId:20},{value:"afterUpdate",paraId:20},{value:" 方法一般用于扩展已有的节点，例如：在矩形节点上附加图片，圆节点增加动画等；",paraId:20},{value:"setState",paraId:20},{value:" 只有在需要使用动画的方式来响应状态变化时需要复写，一般的样式响应状态变化可以通过 ",paraId:20},{value:"配置状态样式",paraId:23},{value:" 实现；",paraId:20},{value:"getAnchorPoints",paraId:20},{value:" 方法仅在需要限制与边的连接点时才需要复写，也可以在数据中直接指定。",paraId:20},{value:"我们自己来实现一个菱形的节点，如下图所示。",paraId:24,tocIndex:1},{value:"G6 有内置的菱形节点 diamond。为了演示，这里实现了一个自定义的菱形，相当于复写了内置的 diamond。",paraId:25,tocIndex:1},{value:"   ",paraId:26,tocIndex:1},{value:"⚠️ 注意:",paraId:26,tocIndex:1},{value:" 从下面代码可以看出，自定义节点中所有通过 ",paraId:26,tocIndex:1},{value:"addShape",paraId:26,tocIndex:1},{value:" 增加的图形的坐标都是",paraId:26,tocIndex:1},{value:"相对于节点自身的子坐标系",paraId:26,tocIndex:1},{value:"，即 ",paraId:26,tocIndex:1},{value:"(0, 0)",paraId:26,tocIndex:1},{value:" 是该节点的中心。如 ",paraId:26,tocIndex:1},{value:"'text'",paraId:26,tocIndex:1},{value:" 图形的 ",paraId:26,tocIndex:1},{value:"x",paraId:26,tocIndex:1},{value:" 和 ",paraId:26,tocIndex:1},{value:"y",paraId:26,tocIndex:1},{value:" 均为 0，代表该图形相对于该节点居中；",paraId:26,tocIndex:1},{value:"'path'",paraId:26,tocIndex:1},{value:" 图形 ",paraId:26,tocIndex:1},{value:"path",paraId:26,tocIndex:1},{value:" 属性中的坐标也是以 ",paraId:26,tocIndex:1},{value:"(0, 0)",paraId:26,tocIndex:1},{value:" 为原点计算的。换句话说，在",paraId:26,tocIndex:1},{value:"自定义节点时不需要感知相对于画布的节点坐标",paraId:26,tocIndex:1},{value:"，节点坐标由该节点所在 group 的矩阵控制。",paraId:26,tocIndex:1},{value:"G6.registerNode('diamond', {\n  draw(cfg, group) {\n    // 如果 cfg 中定义了 style 需要同这里的属性进行融合\n    const keyShape = group.addShape('path', {\n      attrs: {\n        path: this.getPath(cfg), // 根据配置获取路径\n        stroke: cfg.color, // 颜色应用到描边上，如果应用到填充，则使用 fill: cfg.color\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'path-shape',\n      // 设置 draggable 以允许响应鼠标的图拽事件\n      draggable: true,\n    });\n    if (cfg.label) {\n      // 如果有文本\n      // 如果需要复杂的文本配置项，可以通过 labeCfg 传入\n      // const style = (cfg.labelCfg && cfg.labelCfg.style) || {};\n      // style.text = cfg.label;\n      const label = group.addShape('text', {\n        // attrs: style\n        attrs: {\n          x: 0, // 居中\n          y: 0,\n          textAlign: 'center',\n          textBaseline: 'middle',\n          text: cfg.label,\n          fill: '#666',\n        },\n        // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        name: 'text-shape',\n        // 设置 draggable 以允许响应鼠标的图拽事件\n        draggable: true,\n      });\n    }\n    return keyShape;\n  },\n  // 返回菱形的路径\n  getPath(cfg) {\n    const size = cfg.size || [40, 40]; // 如果没有 size 时的默认大小\n    const width = size[0];\n    const height = size[1];\n    //  / 1 \\\n    // 4     2\n    //  \\ 3 /\n    const path = [\n      ['M', 0, 0 - height / 2], // 上部顶点\n      ['L', width / 2, 0], // 右侧顶点\n      ['L', 0, height / 2], // 下部顶点\n      ['L', -width / 2, 0], // 左侧顶点\n      ['Z'], // 封闭\n    ];\n    return path;\n  },\n});\n",paraId:27,tocIndex:1},{value:"上面的代码自定义了一个菱形节点。值得注意的是，G6 3.3 需要用户为自定义节点中的图形设置 ",paraId:28,tocIndex:1},{value:"name",paraId:28,tocIndex:1},{value:" 和 ",paraId:28,tocIndex:1},{value:"draggable",paraId:28,tocIndex:1},{value:"。",paraId:28,tocIndex:1},{value:"其中，",paraId:28,tocIndex:1},{value:"name",paraId:28,tocIndex:1},{value:" 值必须在同元素类型内唯一",paraId:28,tocIndex:1},{value:"。",paraId:28,tocIndex:1},{value:"draggable",paraId:28,tocIndex:1},{value:" 为 ",paraId:28,tocIndex:1},{value:"true",paraId:28,tocIndex:1},{value:" 是表示允许该图形响应鼠标的拖拽事件，只有 ",paraId:28,tocIndex:1},{value:"draggable: true",paraId:28,tocIndex:1},{value:" 时，图上的交互行为 ",paraId:28,tocIndex:1},{value:"'drag-node'",paraId:28,tocIndex:1},{value:" 才能在该图形上生效。若上面代码仅在 keyShape 上设置了 ",paraId:28,tocIndex:1},{value:"draggable: true",paraId:28,tocIndex:1},{value:"，而 label 图形上没有设置，则鼠标拖拽只能在 keyShape 上响应。",paraId:28,tocIndex:1},{value:"现在，我们使用下面的数据输入就会绘制出 diamond 这个节点。",paraId:29,tocIndex:1},{value:"const data = {\n  nodes: [\n    { id: 'node1', x: 50, y: 100, type: 'diamond' }, // 最简单的\n    { id: 'node2', x: 150, y: 100, type: 'diamond', size: [50, 100] }, // 添加宽高\n    { id: 'node3', x: 250, y: 100, color: 'red', type: 'diamond' }, // 添加颜色\n    { id: 'node4', x: 350, y: 100, label: '菱形', type: 'diamond' }, // 附加文本\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n});\ngraph.data(data);\ngraph.render();\n",paraId:30,tocIndex:1},{value:"当图中节点或边通过  ",paraId:31,tocIndex:2},{value:"graph.update(item, cfg)",paraId:31,tocIndex:2},{value:" 重绘时，默认情况下会调用节点的 ",paraId:31,tocIndex:2},{value:"draw",paraId:31,tocIndex:2},{value:" 方法进行重新绘制。在数据量大或节点上图形数量非常多（特别是文本多）的情况下，",paraId:31,tocIndex:2},{value:"draw",paraId:31,tocIndex:2},{value:" 方法中对所有图形、赋予样式将会非常消耗性能。",paraId:31,tocIndex:2},{value:"在自定义节点时，重写  ",paraId:32,tocIndex:2},{value:"update",paraId:32,tocIndex:2},{value:" 方法，在更新时将会调用该方法替代 ",paraId:32,tocIndex:2},{value:"draw",paraId:32,tocIndex:2},{value:"。我们可以在该方法中指定需要更新的图形，从而避免频繁调用  ",paraId:32,tocIndex:2},{value:"draw",paraId:32,tocIndex:2},{value:" 、全量更新节点上的所有图形。当然，",paraId:32,tocIndex:2},{value:"update",paraId:32,tocIndex:2},{value:" 方法是可选的，如果没有性能优化的需求可以不重写该方法。",paraId:32,tocIndex:2},{value:"在实现 diamond 的过程中，重写  ",paraId:33,tocIndex:2},{value:"update",paraId:33,tocIndex:2},{value:" 方法，找到需要更新的 shape 进行更新，从而优化性能。寻找需要更新的图形可以通过：",paraId:33,tocIndex:2},{value:"group.get('children')[0]",paraId:34,tocIndex:2},{value:" 找到 ",paraId:34,tocIndex:2},{value:"关键图形  keyShape",paraId:35,tocIndex:2},{value:"，也就是 ",paraId:34,tocIndex:2},{value:"draw",paraId:34,tocIndex:2},{value:" 方法返回的 shape；",paraId:34,tocIndex:2},{value:"group.get('children')[1]",paraId:34,tocIndex:2},{value:" 找到 label 图形。",paraId:34,tocIndex:2},{value:"下面代码仅更新了 diamond 的关键图形的路径和颜色。",paraId:36,tocIndex:2},{value:"G6.registerNode('diamond', {\n  draw(cfg, group) {\n    // ... // 见前面代码\n  },\n  getPath(cfg) {\n    // ... // 见前面代码\n  },\n  update(cfg, node) {\n    const group = node.getContainer(); // 获取容器\n    const shape = group.get('children')[0]; // 按照添加的顺序\n    const style = {\n      path: this.getPath(cfg),\n      stroke: cfg.color,\n    };\n    shape.attr(style); // 更新属性\n    // 更新文本的逻辑类似，但是需要考虑 cfg.label 是否存在的问题\n    // 通过 label.attr() 更新文本属性即可\n  },\n});\n",paraId:37,tocIndex:2},{value:"G6 中已经",paraId:38,tocIndex:4},{value:"内置了一些节点",paraId:39,tocIndex:4},{value:"，如果用户仅仅想对现有节点进行调整，复用原有的代码，则可以基于现有的节点进行扩展。同样实现 diamond ，可以基于  circle、ellipse、rect 等内置节点的进行扩展。single-node 是这些内置节点类型的基类，也可以基于它进行扩展。（single-edge 是所有内置边类型的基类。）",paraId:38,tocIndex:4},{value:"下面以基于 single-node 为例进行扩展。",paraId:40,tocIndex:4},{value:"update",paraId:40,tocIndex:4},{value:"，",paraId:40,tocIndex:4},{value:"setState",paraId:40,tocIndex:4},{value:" 方法在  single-node 中都有实现，这里仅需要复写 ",paraId:40,tocIndex:4},{value:"draw",paraId:40,tocIndex:4},{value:" 方法即可。返回的对象中包含自定义图形的路径和其他样式。",paraId:40,tocIndex:4},{value:"G6.registerNode(\n  'diamond',\n  {\n    draw(cfg, group) {\n      const size = this.getSize(cfg); // 转换成 [width, height] 的模式\n      const color = cfg.color;\n      const width = size[0];\n      const height = size[1];\n      //  / 1 \\\n      // 4     2\n      //  \\ 3 /\n      const path = [\n        ['M', 0, 0 - height / 2], // 上部顶点\n        ['L', width / 2, 0], // 右侧顶点\n        ['L', 0, height / 2], // 下部顶点\n        ['L', -width / 2, 0], // 左侧顶点\n        ['Z'], // 封闭\n      ];\n      const style = G6.Util.mix(\n        {},\n        {\n          path: path,\n          stroke: color,\n        },\n        cfg.style,\n      );\n      // 增加一个 path 图形作为 keyShape\n      const keyShape = group.addShape('path', {\n        attrs: {\n          ...style,\n        },\n        draggable: true,\n        name: 'diamond-keyShape', // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      });\n      // 返回 keyShape\n      return keyShape;\n    },\n  },\n  // 注意这里继承了 'single-node'\n  'single-node',\n);\n",paraId:41,tocIndex:4},{value:"通过 ",paraId:42,tocIndex:5},{value:"afterDraw",paraId:42,tocIndex:5},{value:" 同样可以实现扩展，下面我们来看一个节点的动画场景，如下图所示。",paraId:42,tocIndex:5},{value:" ",paraId:42,tocIndex:5},{value:"上面的动画效果，可以通过以下方式实现：",paraId:43,tocIndex:5},{value:"扩展内置的 rect，在 rect 中添加一个图形；",paraId:44,tocIndex:5},{value:"反复执行新添加图形的旋转动画。",paraId:44,tocIndex:5},{value:"// 自定义一个名为 inner-animate 的节点\nG6.registerNode('inner-animate', {\n  afterDraw(cfg, group) {\n    const size = cfg.size;\n    const width = size[0] - 14;\n    const height = size[1] - 14;\n    // 添加图片\n    const image = group.addShape('image', {\n      attrs: {\n        x: - width / 2,\n        y: - height / 2,\n        width: width,\n        height: height,\n        img: cfg.img\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'image-shape'\n    });\n    // 执行旋转动画\n    image.animate((ratio) => {\n      const matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      const toMatrix = Util.transform(matrix, [\n        ['r', ratio * Math.PI * 2]\n      ]) ;\n      return {\n        matrix: toMatrix\n      };\n    }, {\n      repeat: true\n      duration: 3000,\n      easing: 'easeCubic'\n    });\n  }\n},\n// 继承了 rect 节点\n'rect');\n",paraId:45,tocIndex:5},{value:"更多关于动画的实现，请参考",paraId:46,tocIndex:5},{value:"基础动画",paraId:47,tocIndex:5},{value:"章节。",paraId:46,tocIndex:5},{value:"节点上的",paraId:48,tocIndex:6},{value:"锚点 anchorPoint",paraId:49,tocIndex:6},{value:" 作用是",paraId:48,tocIndex:6},{value:"确定节点与边的相交的位置",paraId:48,tocIndex:6},{value:"，看下面的场景：",paraId:48,tocIndex:6},{value:"（左）没有设置锚点时。（右）diamond 设置了锚点后。",paraId:50,tocIndex:6},{value:"有两种方式来调整节点上的锚点：",paraId:51,tocIndex:6},{value:"在数据里面指定 ",paraId:52,tocIndex:6},{value:"anchorPoints",paraId:52,tocIndex:6},{value:"。",paraId:52,tocIndex:6},{value:"**适用场景：**可以为不同节点配置不同的锚点，更定制化。",paraId:53,tocIndex:6},{value:"自定义节点中通过 ",paraId:54,tocIndex:6},{value:"getAnchorPoints",paraId:54,tocIndex:6},{value:" 方法指定锚点。",paraId:54,tocIndex:6},{value:"**适用场景：**全局配置锚点，所有该自定义节点类型的节点都相同。",paraId:55,tocIndex:6},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      x: 100,\n      y: 100,\n      anchorPoints: [\n        [0, 0.5], // 左侧中间\n        [1, 0.5], // 右侧中间\n      ],\n    },\n    //...       // 其他节点\n  ],\n  edges: [\n    //... // 边\n  ],\n};\n",paraId:56,tocIndex:7},{value:"G6.registerNode(\n  'diamond',\n  {\n    //... // 其他方法\n    getAnchorPoints() {\n      return [\n        [0, 0.5], // 左侧中间\n        [1, 0.5], // 右侧中间\n      ];\n    },\n  },\n  'rect',\n);\n",paraId:57,tocIndex:8},{value:"常见的交互都需要节点和边通过样式变化做出反馈，例如鼠标移动到节点上、点击选中节点/边、通过交互激活边上的交互等，都需要改变节点和边的样式，有两种方式来实现这种效果：",paraId:58,tocIndex:9},{value:"在数据上添加标志字段，在自定义 shape 过程中根据约定进行渲染；",paraId:59,tocIndex:9},{value:"将交互状态同原始数据和绘制节点的逻辑分开，仅更新节点。",paraId:59,tocIndex:9},{value:"我们推荐用户使用第二种方式来实现节点的状态调整，可以通过以下方式来实现：",paraId:60,tocIndex:9},{value:"在 G6 中自定义节点/边时在 ",paraId:61,tocIndex:9},{value:"setState",paraId:61,tocIndex:9},{value:" 方法中进行节点状态变化的响应；",paraId:61,tocIndex:9},{value:"通过 ",paraId:61,tocIndex:9},{value:"graph.setItemState()",paraId:61,tocIndex:9},{value:" 方法来设置状态。",paraId:61,tocIndex:9},{value:"基于 rect 扩展出一个 custom 图形，默认填充色为白色，当鼠标点击时变成红色，实现这一效果的示例代码如下：",paraId:62,tocIndex:9},{value:"// 基于 rect 扩展出新的图形\nG6.registerNode(\n  'custom',\n  {\n    // 响应状态变化\n    setState(name, value, item) {\n      const group = item.getContainer();\n      const shape = group.get('children')[0]; // 顺序根据 draw 时确定\n      if (name === 'selected') {\n        if (value) {\n          shape.attr('fill', 'red');\n        } else {\n          shape.attr('fill', 'white');\n        }\n      }\n    },\n  },\n  'rect',\n);\n\n// 点击时选中，再点击时取消\ngraph.on('node:click', (ev) => {\n  const node = ev.item;\n  graph.setItemState(node, 'selected', !node.hasState('selected')); // 切换选中\n});\n",paraId:63,tocIndex:9},{value:"G6 并未限定节点的状态，只要你在 ",paraId:64,tocIndex:9},{value:"setState",paraId:64,tocIndex:9},{value:" 方法中进行处理你可以实现任何交互，如实现鼠标放到节点上后节点逐渐变大的效果。",paraId:64,tocIndex:9},{value:" ",paraId:64,tocIndex:9},{value:"G6.registerNode(\n  'custom',\n  {\n    // 响应状态变化\n    setState(name, value, item) {\n      const group = item.getContainer();\n      const shape = group.get('children')[0]; // 顺序根据 draw 时确定\n      if (name === 'running') {\n        if (value) {\n          shape.animate(\n            {\n              r: 20,\n            },\n            {\n              repeat: true,\n              duration: 1000,\n            },\n          );\n        } else {\n          shape.stopAnimate();\n          shape.attr('r', 10);\n        }\n      }\n    },\n  },\n  'circle',\n);\n\n// 鼠标移动到上面 running，移出结束\ngraph.on('node:mouseenter', (ev) => {\n  const node = ev.item;\n  graph.setItemState(node, 'running', true);\n});\n\ngraph.on('node:mouseleave', (ev) => {\n  const node = ev.item;\n  graph.setItemState(node, 'running', false);\n});\n",paraId:65,tocIndex:9},{value:"SVG 与 DOM 图形在 V3.3.x 中不支持。\n仅在 Graph 的 ",paraId:66,tocIndex:10},{value:"renderer",paraId:66,tocIndex:10},{value:" 为 ",paraId:66,tocIndex:10},{value:"'svg'",paraId:66,tocIndex:10},{value:" 时可以使用 DOM 自定义节点。",paraId:66,tocIndex:10},{value:"⚠️ 注意:",paraId:67,tocIndex:10},{value:"只支持原生 HTML DOM，不支持各类 react、vue 组件；",paraId:68,tocIndex:10},{value:"使用 ",paraId:68,tocIndex:10},{value:"'dom'",paraId:68,tocIndex:10},{value:" 进行自定义的节点或边，不支持 G6 的交互事件，请使用原生 DOM 的交互事件；",paraId:68,tocIndex:10},{value:"在 Safari 中，若 dom 节点被设置了 ",paraId:68,tocIndex:10},{value:"position:relative",paraId:68,tocIndex:10},{value:"，将会导致渲染异常。该问题与 ",paraId:68,tocIndex:10},{value:"Safari 的 foreignObject bug",paraId:68,tocIndex:10},{value:" 有关。",paraId:68,tocIndex:10},{value:"Issus",paraId:68,tocIndex:10},{value:"。",paraId:68,tocIndex:10},{value:"这里，我们演示使用 DOM 自定义一个名为 ",paraId:69,tocIndex:10},{value:"'dom-node'",paraId:69,tocIndex:10},{value:" 的节点。在 ",paraId:69,tocIndex:10},{value:"draw",paraId:69,tocIndex:10},{value:" 方法中使用 ",paraId:69,tocIndex:10},{value:"group.addShape",paraId:69,tocIndex:10},{value:" 增加一个 ",paraId:69,tocIndex:10},{value:"'dom'",paraId:69,tocIndex:10},{value:" 类型的图形，并设置其 ",paraId:69,tocIndex:10},{value:"html",paraId:69,tocIndex:10},{value:" 为 DOM 的 ",paraId:69,tocIndex:10},{value:"html",paraId:69,tocIndex:10},{value:" 值。",paraId:69,tocIndex:10},{value:'G6.registerNode(\n  \'dom-node\',\n  {\n    draw: (cfg: ModelConfig, group: Group) => {\n      return group.addShape(\'dom\', {\n        attrs: {\n          width: cfg.size[0],\n          height: cfg.size[1],\n          // 传入 DOM 的 html\n          html: `\n        <div style="background-color: #fff; border: 2px solid #5B8FF9; border-radius: 5px; width: ${\n          cfg.size[0] - 5\n        }px; height: ${cfg.size[1] - 5}px; display: flex;">\n          <div style="height: 100%; width: 33%; background-color: #CDDDFD">\n            <img alt="img" style="line-height: 100%; padding-top: 6px; padding-left: 8px;" src="https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*Q_FQT6nwEC8AAAAAAAAAAABkARQnAQ" width="20" height="20" />  \n          </div>\n          <span style="margin:auto; padding:auto; color: #5B8FF9">${cfg.label}</span>\n        </div>\n          `,\n        },\n        name: \'dom-node-keyShape\',  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        draggable: true,\n      });\n    },\n  },\n  \'single-node\',\n);\n',paraId:70,tocIndex:10},{value:"上面的代码自定义了一个名为 ",paraId:71,tocIndex:10},{value:"'dom-node'",paraId:71,tocIndex:10},{value:" 的带有 DOM 的节点。值得注意的是，G6 3.3 需要用户为自定义节点中的图形设置 ",paraId:71,tocIndex:10},{value:"name",paraId:71,tocIndex:10},{value:" 和 ",paraId:71,tocIndex:10},{value:"draggable",paraId:71,tocIndex:10},{value:"。",paraId:71,tocIndex:10},{value:"其中，",paraId:71,tocIndex:10},{value:"name",paraId:71,tocIndex:10},{value:" 值必须在同元素类型内唯一",paraId:71,tocIndex:10},{value:"。",paraId:71,tocIndex:10},{value:"draggable",paraId:71,tocIndex:10},{value:" 为 ",paraId:71,tocIndex:10},{value:"true",paraId:71,tocIndex:10},{value:" 是表示允许该图形响应鼠标的拖拽事件，只有 ",paraId:71,tocIndex:10},{value:"draggable: true",paraId:71,tocIndex:10},{value:" 时，图上的交互行为 ",paraId:71,tocIndex:10},{value:"'drag-node'",paraId:71,tocIndex:10},{value:" 才能在该图形上生效。",paraId:71,tocIndex:10},{value:"现在，我们使用下面的数据输入就会绘制出带有 ",paraId:72,tocIndex:10},{value:"'dom-node'",paraId:72,tocIndex:10},{value:" 节点的图。",paraId:72,tocIndex:10},{value:"const data = {\n  nodes: [\n    { id: 'node1', x: 50, y: 100 },\n    { id: 'node2', x: 150, y: 100 },\n  ],\n  edges: [{source: 'node1'}, {target: 'node2'}],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  defaultNode: {\n    type: 'dom-node',\n    size: [120, 40],\n  },\n});\ngraph.data(data);\ngraph.render();\n",paraId:73,tocIndex:10},{value:"⚠️ 注意:",paraId:74,tocIndex:10},{value:" G6 的节点/边事件不支持 DOM 类型的图形。如果需要为 DOM 节点绑定事件，请使用原生 DOM 事件。例如：",paraId:74,tocIndex:10},{value:'G6.registerNode(\n  \'dom-node\',\n  {\n    draw: (cfg: ModelConfig, group: Group) => {\n      return group.addShape(\'dom\', {\n        attrs: {\n          width: cfg.size[0],\n          height: cfg.size[1],\n          // 传入 DOM 的 html，带有原生 onclick 事件\n          html: `\n        <div onclick="alert(\'Hi\')" style="background-color: #fff; border: 2px solid #5B8FF9; border-radius: 5px; width: ${\n          cfg.size[0] - 5\n        }px; height: ${cfg.size[1] - 5}px; display: flex;">\n          <div style="height: 100%; width: 33%; background-color: #CDDDFD">\n            <img alt="img" style="line-height: 100%; padding-top: 6px; padding-left: 8px;" src="https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*Q_FQT6nwEC8AAAAAAAAAAABkARQnAQ" width="20" height="20" />  \n          </div>\n          <span style="margin:auto; padding:auto; color: #5B8FF9">${cfg.label}</span>\n        </div>\n          `,\n        },\n        name: \'dom-node-keyShape\',  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n        draggable: true,\n      });\n    },\n  },\n  \'single-node\',\n);\n',paraId:75,tocIndex:10}]},26931:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 的内置节点包括 circle，rect，ellipse，diamond，triangle，star，image，modelRect，donut（v4.2.5 起支持）。这些内置节点的默认样式分别如下图所示。",paraId:0},{value:" ",paraId:0},{value:"本文将概述 G6 中的各个内置节点类型、内置节点的通用属性、配置方法。各类型节点详细配置项及配置方法见本目录下相应文档。",paraId:1},{value:"下面表格中显示了内置的各类节点，同时对一些特殊的字段进行了说明：",paraId:2,tocIndex:0},{value:"名称",paraId:3,tocIndex:0},{value:"描述",paraId:3,tocIndex:0},{value:"默认示例",paraId:3,tocIndex:0},{value:"circle",paraId:3,tocIndex:0},{value:"圆形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是单个数字，表示直径",paraId:3,tocIndex:0},{value:"- 圆心位置对应节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Circle",paraId:4,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"rect",paraId:3,tocIndex:0},{value:"矩形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，例如：[100, 50]",paraId:3,tocIndex:0},{value:"- 矩形的中心位置是节点的位置，而不是左上角",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Rect",paraId:5,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"ellipse",paraId:3,tocIndex:0},{value:"椭圆：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，表示椭圆的长轴直径和短轴直径",paraId:3,tocIndex:0},{value:"- 椭圆的圆心是节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Ellipse",paraId:6,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"diamond",paraId:3,tocIndex:0},{value:"菱形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，表示菱形的宽和高",paraId:3,tocIndex:0},{value:"- 菱形的中心位置是节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Diamond",paraId:7,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"triangle",paraId:3,tocIndex:0},{value:"三角形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，表示三角形的底和高",paraId:3,tocIndex:0},{value:"- 三角形的中心位置是节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点下方",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Triangle",paraId:8,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"star",paraId:3,tocIndex:0},{value:"星形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是单个数字，表示星形的大小",paraId:3,tocIndex:0},{value:"- 星星的中心位置是节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Star",paraId:9,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"image",paraId:3,tocIndex:0},{value:"图片：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，表示图片的宽和高",paraId:3,tocIndex:0},{value:"- 图片的中心位置是节点位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"img",paraId:3,tocIndex:0},{value:" 图片的路径，也可以在 ",paraId:3,tocIndex:0},{value:"style",paraId:3,tocIndex:0},{value:" 里面设置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段不生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点下方",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Image",paraId:10,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"modelRect",paraId:3,tocIndex:0},{value:"卡片：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是数组，表示卡片的宽和高",paraId:3,tocIndex:0},{value:"- 卡片的中心位置是节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 若有  ",paraId:3,tocIndex:0},{value:"description",paraId:3,tocIndex:0},{value:" 字段则显示在标签文本下方显示  ",paraId:3,tocIndex:0},{value:"description",paraId:3,tocIndex:0},{value:" 内容",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"ModelRect",paraId:11,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:" ",paraId:3,tocIndex:0},{value:"donut",paraId:3,tocIndex:0},{value:"圆形：",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"size",paraId:3,tocIndex:0},{value:" 是单个数字，表示直径",paraId:3,tocIndex:0},{value:"- 圆心位置对应节点的位置",paraId:3,tocIndex:0},{value:"- ",paraId:3,tocIndex:0},{value:"color",paraId:3,tocIndex:0},{value:" 字段默认在描边上生效",paraId:3,tocIndex:0},{value:"- 标签文本默认在节点中央",paraId:3,tocIndex:0},{value:"- 必须指定合法的 ",paraId:3,tocIndex:0},{value:"donutAttrs",paraId:3,tocIndex:0},{value:" 字段",paraId:3,tocIndex:0},{value:"- 更多字段见 ",paraId:3,tocIndex:0},{value:"Donut",paraId:12,tocIndex:0},{value:" 节点教程",paraId:3,tocIndex:0},{value:"所有内置的节点支持的通用属性：",paraId:13,tocIndex:1},{value:"名称",paraId:14,tocIndex:1},{value:"是否必须",paraId:14,tocIndex:1},{value:"类型",paraId:14,tocIndex:1},{value:"备注",paraId:14,tocIndex:1},{value:"id",paraId:14,tocIndex:1},{value:"true",paraId:14,tocIndex:1},{value:"String",paraId:14,tocIndex:1},{value:"节点唯一 ID，",paraId:14,tocIndex:1},{value:"必须",paraId:14,tocIndex:1},{value:"是唯一的 string",paraId:14,tocIndex:1},{value:"x",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Number",paraId:14,tocIndex:1},{value:"x 坐标",paraId:14,tocIndex:1},{value:"y",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Number",paraId:14,tocIndex:1},{value:"y 坐标",paraId:14,tocIndex:1},{value:"type",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"String",paraId:14,tocIndex:1},{value:"指定节点类型，内置节点类型名称或自定义节点的名称。默认为 ",paraId:14,tocIndex:1},{value:"'circle'",paraId:14,tocIndex:1},{value:"size",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Number / Array",paraId:14,tocIndex:1},{value:"节点的大小",paraId:14,tocIndex:1},{value:"anchorPoints",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Array",paraId:14,tocIndex:1},{value:"指定边连入节点的连接点的位置（相对于该节点而言），可以为空。例如: ",paraId:14,tocIndex:1},{value:"[0, 0]",paraId:14,tocIndex:1},{value:"，代表节点左上角的锚点，",paraId:14,tocIndex:1},{value:"[1, 1]",paraId:14,tocIndex:1},{value:",代表节点右下角的锚点",paraId:14,tocIndex:1},{value:"style",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Object",paraId:14,tocIndex:1},{value:"节点的样式属性。",paraId:14,tocIndex:1},{value:"label",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"String",paraId:14,tocIndex:1},{value:"文本文字",paraId:14,tocIndex:1},{value:"labelCfg",paraId:14,tocIndex:1},{value:"false",paraId:14,tocIndex:1},{value:"Object",paraId:14,tocIndex:1},{value:"文本配置项",paraId:14,tocIndex:1},{value:"Object 类型。通过 ",paraId:15,tocIndex:2},{value:"style",paraId:15,tocIndex:2},{value:" 配置来修改节点的填充色、边框颜色、阴影等属性。下表是 ",paraId:15,tocIndex:2},{value:"style",paraId:15,tocIndex:2},{value:" 对象中常用的配置项：",paraId:15,tocIndex:2},{value:"名称",paraId:16,tocIndex:2},{value:"是否必须",paraId:16,tocIndex:2},{value:"类型",paraId:16,tocIndex:2},{value:"备注",paraId:16,tocIndex:2},{value:"fill",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:"节点填充色",paraId:16,tocIndex:2},{value:"stroke",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:"节点的描边颜色",paraId:16,tocIndex:2},{value:"lineWidth",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"描边宽度",paraId:16,tocIndex:2},{value:"lineDash",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number[]",paraId:16,tocIndex:2},{value:"描边虚线，数组代表实、虚长度",paraId:16,tocIndex:2},{value:"shadowColor",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:"阴影颜色",paraId:16,tocIndex:2},{value:"shadowBlur",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"阴影范围",paraId:16,tocIndex:2},{value:"shadowOffsetX",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"阴影 x 方向偏移量",paraId:16,tocIndex:2},{value:"shadowOffsetY",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"阴影 y 方向偏移量",paraId:16,tocIndex:2},{value:"opacity",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"设置绘图的当前 alpha 或透明值",paraId:16,tocIndex:2},{value:"fillOpacity",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"Number",paraId:16,tocIndex:2},{value:"设置填充的 alpha 或透明值",paraId:16,tocIndex:2},{value:"cursor",paraId:16,tocIndex:2},{value:"false",paraId:16,tocIndex:2},{value:"String",paraId:16,tocIndex:2},{value:"鼠标在该节点上时的鼠标样式，",paraId:16,tocIndex:2},{value:"CSS 的 cursor",paraId:16,tocIndex:2},{value:" 选项都支持",paraId:16,tocIndex:2},{value:"下面代码演示在实例化图时全局配置方法中配置 ",paraId:17,tocIndex:2},{value:"style",paraId:17,tocIndex:2},{value:"：",paraId:17,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // ... 其他属性\n    style: {\n      fill: '#steelblue',\n      stroke: '#eaff8f',\n      lineWidth: 5,\n      // ... 其他属性\n    },\n  },\n});\n",paraId:18,tocIndex:2},{value:"label",paraId:19,tocIndex:3},{value:" String 类型。标签文本的文字内容。",paraId:19,tocIndex:3},{value:"labelCfg",paraId:19,tocIndex:3},{value:" Object 类型。配置标签文本。下面是 ",paraId:19,tocIndex:3},{value:"labelCfg",paraId:19,tocIndex:3},{value:" 对象中的常用配置项：",paraId:19,tocIndex:3},{value:"名称",paraId:20,tocIndex:3},{value:"是否必须",paraId:20,tocIndex:3},{value:"类型",paraId:20,tocIndex:3},{value:"备注",paraId:20,tocIndex:3},{value:"position",paraId:20,tocIndex:3},{value:"false",paraId:20,tocIndex:3},{value:"String",paraId:20,tocIndex:3},{value:"文本相对于节点的位置，目前支持的位置有：",paraId:20,tocIndex:3},{value:"'center'",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"'top'",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"'left'",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"'right'",paraId:20,tocIndex:3},{value:"，",paraId:20,tocIndex:3},{value:"'bottom'",paraId:20,tocIndex:3},{value:"。默认为 ",paraId:20,tocIndex:3},{value:"'center'",paraId:20,tocIndex:3},{value:"。modelRect 节点不支持该属性",paraId:20,tocIndex:3},{value:"offset",paraId:20,tocIndex:3},{value:"false",paraId:20,tocIndex:3},{value:"Number",paraId:20,tocIndex:3},{value:"文本的偏移，",paraId:20,tocIndex:3},{value:"position",paraId:20,tocIndex:3},{value:" 为 ",paraId:20,tocIndex:3},{value:"'bottom'",paraId:20,tocIndex:3},{value:" 时，文本的上方偏移量；",paraId:20,tocIndex:3},{value:"position",paraId:20,tocIndex:3},{value:" 为 ",paraId:20,tocIndex:3},{value:"'left'",paraId:20,tocIndex:3},{value:" 时，文本的右方偏移量；以此类推在其他 ",paraId:20,tocIndex:3},{value:"position",paraId:20,tocIndex:3},{value:" 时的情况。modelRect 节点的 ",paraId:20,tocIndex:3},{value:"offset",paraId:20,tocIndex:3},{value:" 为左边距",paraId:20,tocIndex:3},{value:"style",paraId:20,tocIndex:3},{value:"false",paraId:20,tocIndex:3},{value:"Object",paraId:20,tocIndex:3},{value:"标签的样式属性。",paraId:20,tocIndex:3},{value:"上表中的标签的样式属性 ",paraId:21,tocIndex:3},{value:"style",paraId:21,tocIndex:3},{value:" 的常用配置项如下：",paraId:21,tocIndex:3},{value:"名称",paraId:22,tocIndex:3},{value:"是否必须",paraId:22,tocIndex:3},{value:"类型",paraId:22,tocIndex:3},{value:"备注",paraId:22,tocIndex:3},{value:"fill",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"文本颜色",paraId:22,tocIndex:3},{value:"stroke",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"文本描边颜色",paraId:22,tocIndex:3},{value:"lineWidth",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"文本描边粗细",paraId:22,tocIndex:3},{value:"opacity",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"文本透明度",paraId:22,tocIndex:3},{value:"fontFamily",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"String",paraId:22,tocIndex:3},{value:"文本字体",paraId:22,tocIndex:3},{value:"fontSize",paraId:22,tocIndex:3},{value:"false",paraId:22,tocIndex:3},{value:"Number",paraId:22,tocIndex:3},{value:"文本字体大小",paraId:22,tocIndex:3},{value:"... 节点标签与边标签样式属性相同，统一整理在 ",paraId:22,tocIndex:3},{value:"Text 图形 API",paraId:23,tocIndex:3},{value:"下面代码演示在实例化图时全局配置方法中配置  ",paraId:24,tocIndex:3},{value:"label",paraId:24,tocIndex:3},{value:" 和  ",paraId:24,tocIndex:3},{value:"labelCfg",paraId:24,tocIndex:3},{value:"。",paraId:24,tocIndex:3},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    // ... 其他属性\n    label: 'node-label',\n    labelCfg: {\n      position: 'bottom',\n      offset: 10,\n      style: {\n        fill: '#666',\n      },\n    },\n  },\n});\n",paraId:25,tocIndex:3},{value:"配置节点的方式有三种：实例化图时全局配置，在数据中动态配置，使用 ",paraId:26,tocIndex:4},{value:"graph.node(nodeFn)",paraId:26,tocIndex:4},{value:" 函数配置。这几种配置方法可以同时使用，优先级：",paraId:26,tocIndex:4},{value:"使用 ",paraId:27,tocIndex:4},{value:"graph.node(nodeFn)",paraId:27,tocIndex:4},{value:" 配置 > 数据中动态配置 > 实例化图时全局配置",paraId:27,tocIndex:4},{value:"即有相同的配置项时，优先级高的方式将会覆盖优先级低的。",paraId:28,tocIndex:4},{value:"⚠️ 注意:",paraId:29,tocIndex:4},{value:" 除 ",paraId:29,tocIndex:4},{value:"id",paraId:29,tocIndex:4},{value:"、",paraId:29,tocIndex:4},{value:"label",paraId:29,tocIndex:4},{value:" 应当配置到每个节点数据中外，其余的 ",paraId:29,tocIndex:4},{value:"节点的通用属性",paraId:30,tocIndex:4},{value:" 以及各个节点类型的特有属性（见内置节点类型）均支持这三种配置方式。",paraId:29,tocIndex:4},{value:"用户在实例化 Graph 时候可以通过 ",paraId:31,tocIndex:5},{value:"defaultNode",paraId:31,tocIndex:5},{value:" 配置节点，这里的配置是全局的配置，将会在所有节点上生效。",paraId:31,tocIndex:5},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'circle',\n    // 其他配置\n  },\n});\n",paraId:32,tocIndex:5},{value:"如果需要为不同节点进行不同的配置，可以将配置写入到节点数据中。这种配置方式可以通过下面代码的形式直接写入数据，也可以通过遍历数据的方式写入。",paraId:33,tocIndex:6},{value:"const data = {\n  nodes: [{\n    id: 'node0',\n    size: 100,\n    type: 'rect',\n    ...    // 其他属性\n    style: {\n      ...  // 样式属性，每种节点的详细样式属性参见各节点文档\n    }\n  },{\n    id: 'node1',\n    size: [50, 100],\n    type: 'ellipse',\n    ...    // 其他属性\n    style: {\n      ...  // 样式属性，每种节点的详细样式属性参见各节点文档\n    }\n  },\n    ... // 其他节点\n  ],\n  edges: [\n    ... // 边\n  ]\n}\n",paraId:34,tocIndex:6},{value:"该方法可以为不同节点进行不同的配置。",paraId:35,tocIndex:7},{value:"提示:",paraId:36,tocIndex:7},{value:"该方法必须",paraId:37,tocIndex:7},{value:"在 render 之前调用",paraId:37,tocIndex:7},{value:"，否则不起作用；",paraId:37,tocIndex:7},{value:"由于该方法优先级最高，将覆盖其他地方对节点的配置，这可能将造成一些其他配置不生效的疑惑；",paraId:37,tocIndex:7},{value:"该方法在增加元素、更新元素时会被调用，如果数据量大、每个节点上需要更新的内容多时，可能会有性能问题。",paraId:37,tocIndex:7},{value:"// const data = ...\n// const graph = ...\ngraph.node((node) => {\n  return {\n    id: node.id,\n    type: 'rect',\n    style: {\n      fill: 'blue',\n    },\n  };\n});\n\ngraph.data(data);\ngraph.render();\n",paraId:38,tocIndex:7},{value:"const data = {\n  nodes: [\n    {\n      id: 'node_circle',\n      x: 100,\n      y: 100,\n      type: 'circle',\n      label: 'circle',\n    },\n    {\n      id: 'node_rect',\n      x: 200,\n      y: 100,\n      type: 'rect',\n      label: 'rect',\n    },\n    {\n      id: 'node-ellipse',\n      x: 330,\n      y: 100,\n      type: 'ellipse',\n      label: 'ellipse',\n    },\n    {\n      id: 'node-diamond',\n      x: 460,\n      y: 100,\n      type: 'diamond',\n      label: 'diamond',\n    },\n    {\n      id: 'node-triangle',\n      x: 560,\n      y: 100,\n      //size: 80,\n      type: 'triangle',\n      label: 'triangle',\n    },\n    {\n      id: 'node-star',\n      x: 660,\n      y: 100,\n      //size: [60, 30],\n      type: 'star',\n      label: 'star',\n    },\n    {\n      id: 'node-image',\n      x: 760,\n      y: 100,\n      size: 50,\n      type: 'image',\n      img: 'https://gw.alipayobjects.com/zos/rmsportal/XuVpGqBFxXplzvLjJBZB.svg',\n      label: 'image',\n    },\n    {\n      id: 'node-modelRect',\n      x: 900,\n      y: 100,\n      type: 'modelRect',\n      label: 'modelRect',\n    },\n  ],\n};\n\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 1500,\n  height: 300,\n});\ngraph.data(data);\ngraph.render();\n",paraId:39,tocIndex:8},{value:"显示结果： ",paraId:40,tocIndex:8},{value:" ",paraId:40,tocIndex:8},{value:"triangle 节点和 image 节点的标签文本默认位置为：",paraId:41,tocIndex:8},{value:"position:'bottom'",paraId:41,tocIndex:8},{value:" ，其他节点文本的默认位置都为：",paraId:41,tocIndex:8},{value:"position: 'center'",paraId:41,tocIndex:8},{value:"；",paraId:41,tocIndex:8},{value:"下面演示通过将配置写入数据的方式，调整 ",paraId:42,tocIndex:9},{value:"id",paraId:42,tocIndex:9},{value:" 为 ",paraId:42,tocIndex:9},{value:"'node-ellipse'",paraId:42,tocIndex:9},{value:" 的椭圆节点的文本位置，颜色和样式。将下面代码替换上面代码中 ",paraId:42,tocIndex:9},{value:"id",paraId:42,tocIndex:9},{value:" 为  ",paraId:42,tocIndex:9},{value:"'node-ellipse'",paraId:42,tocIndex:9},{value:" 的节点数据即可生效。",paraId:42,tocIndex:9},{value:"{\n  id: 'node-ellipse',\n  x: 330,\n  y: 100,\n  type: 'ellipse',\n  size: [60, 30],\n  label: 'ellipse',\n  labelCfg: {\n    position: 'bottom',\n    offset: 5\n  },\n  style: {\n    fill: '#fa8c16',\n    stroke: '#000',\n    lineWidth: 2\n  }\n}\n",paraId:43,tocIndex:9},{value:"再为  ",paraId:44,tocIndex:9},{value:"id",paraId:44,tocIndex:9},{value:" 为 ",paraId:44,tocIndex:9},{value:"'node-modelRect'",paraId:44,tocIndex:9},{value:" 的 modelRect 节点添加描述文字，使用下面代码替换  ",paraId:44,tocIndex:9},{value:"id",paraId:44,tocIndex:9},{value:" 为  ",paraId:44,tocIndex:9},{value:"'node-modelRect'",paraId:44,tocIndex:9},{value:" 的节点数据即可得到带有内容为 '描述文本 xxxxxxxxxxx' 的 modelRect 节点。",paraId:44,tocIndex:9},{value:"{\n  id: 'node-modelRect',\n  x: 900,\n  y: 100,\n  description: '描述文本xxxxxxxxxxx',\n  type: 'modelRect',\n  label: 'modelRect'\n}\n",paraId:45,tocIndex:9},{value:"状态 State",paraId:46,tocIndex:10},{value:" —— 交互过程中的样式变化。",paraId:47,tocIndex:10}]},7416:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在 G6 3.7.0 及以后的版本中，用户以使用类似 JSX 的语法来定义节点。只需要在使用 G6.registerNode 自定义节点时，将第二个参数设置为字符串或一个返回值为 ",paraId:0},{value:"string",paraId:0},{value:" 的 ",paraId:0},{value:"function",paraId:0},{value:"。",paraId:0},{value:'<[group|shape] [key]="value" style={{ [key]: value }}>\n  <[more tag] /> ...\n  <text>value</text>\n</[group|shape]>\n',paraId:1,tocIndex:0},{value:"基础语法和大家熟悉的 HTML 标记语言基本相同，通过标签名来使用 shape 或者 group，同时定义 shape 需要填写 shape 的各个 attributes，而定义形状样式的 attrs 则由 style 属性来进行表达。style 里面的结构是一个 Object，对象的值可以是字符串，数字等 JSON 支持的数据类型（注意，这里不能够是函数，函数只会导致解析错误）。",paraId:2,tocIndex:0},{value:"自定义节点的类型和 style 参考：",paraId:3,tocIndex:0},{value:"https://g6.antv.antgroup.com/api/shape-properties",paraId:3,tocIndex:0},{value:" 其中，为了相对定位，我们新加入了 marginTop 和 marginLeft 来定义左边和上面的间隔。",paraId:3,tocIndex:0},{value:"在最外层包裹 ",paraId:4,tocIndex:1},{value:"group",paraId:4,tocIndex:1},{value:" 标签，保证节点里面图形树结构完整",paraId:4,tocIndex:1},{value:"字符串最好使用单引号包裹，以免遇到解析错误",paraId:4,tocIndex:1},{value:"style",paraId:4,tocIndex:1},{value:" 中随 node 变化的变量推荐使用 ${} 的模板语法加入",paraId:4,tocIndex:1},{value:"图形内的相对定位推荐使用 ",paraId:4,tocIndex:1},{value:"marginTop",paraId:4,tocIndex:1},{value:" 和 ",paraId:4,tocIndex:1},{value:"marginLeft",paraId:4,tocIndex:1},{value:" 进行设置，",paraId:4,tocIndex:1},{value:"x",paraId:4,tocIndex:1},{value:" 与 ",paraId:4,tocIndex:1},{value:"y",paraId:4,tocIndex:1},{value:" 会破坏层级关系定位",paraId:4,tocIndex:1},{value:"如果涉及到需要横向排列的元素，在上一个元素使用",paraId:4,tocIndex:1},{value:"next: inline",paraId:4,tocIndex:1},{value:"来实现下一个元素跟随在上个元素后方",paraId:4,tocIndex:1},{value:"使用类 JSX 语法来定义 G6 节点时，支持使用以下的标签：",paraId:5,tocIndex:2},{value:"<group />",paraId:6,tocIndex:2},{value:"<rect />",paraId:6,tocIndex:2},{value:"<circle />",paraId:6,tocIndex:2},{value:"<text />",paraId:6,tocIndex:2},{value:"<path />",paraId:6,tocIndex:2},{value:"<line />",paraId:6,tocIndex:2},{value:"<points />",paraId:6,tocIndex:2},{value:"<polygon />",paraId:6,tocIndex:2},{value:"<polyline />",paraId:6,tocIndex:2},{value:"<image />",paraId:6,tocIndex:2},{value:"使用标签的形式来定义节点，所有的样式属性都写到 style 里面，name、keyShape 等和 style 同级，所支持的属性和 addShape 中完全一致。",paraId:7,tocIndex:2},{value:"特别说明",paraId:8,tocIndex:2},{value:"：使用类 HTML 语法定义节点时，style 里面属性不支持 function，因此使用类 HTML 语法定义节点时，目前不支持 marker 标签。",paraId:8,tocIndex:2},{value:"我们先来看一下，使用类 JSX 语法来定义一个简单的矩形。",paraId:9,tocIndex:3},{value:"G6.registerNode(\n  'rect-xml',\n  (cfg) => `\n  <rect style={{\n    width: 100, height: 20, fill: '#1890ff', stroke: '#1890ff', radius: [6, 6, 0, 0]\n  }} keyshape=\"true\" name=\"test\">\n    <text style={{ \n\t\t\tmarginTop: 2, \n\t\t\tmarginLeft: 50, \n      textAlign: 'center', \n      fontWeight: 'bold', \n      fill: '#fff' }} \n\t\t\tname=\"title\">${cfg.label || cfg.id}</text>\n    <polygon style={{\n      points:[[ 30, 30 ], [ 40, 20 ], [ 30, 50 ], [ 60, 100 ]],\n          fill: 'red'\n    }} />\n        <polyline style={{ points: [[ 30, 30 ], [ 40, 20 ], [ 60, 100 ]] }} />\n        <image style={{ img: 'https://gw.alipayobjects.com/zos/antfincdn/FLrTNDvlna/antv.png', width: 48, height: 48, marginTop: 100 }} />\n  </rect>\n`,\n);\n",paraId:10,tocIndex:3},{value:"我们再来看一个稍微复杂的案例。",paraId:11,tocIndex:3},{value:"// 假设一个节点数据如下：\nconst data = {\n  nodes: [\n    {\n      id: 'node1',\n      type: 'xml-card', // 使用自定义的节点名称\n      metric: 'CPU usage',\n      cpuUsage: 80\n    },\n  ]\n}\n\n// 定义进度条的绘制方式\nconst percentageBar = ({ width, used, height = 12 }) => `\n  <rect style={{\n    marginLeft: 10,\n    marginTop: 3,\n    width: ${width},\n    height: ${height},\n    fill: '#fff',\n    stroke: '#1890ff'\n  }} name=\"body\" >\n    <rect style={{\n      marginLeft: 10,\n      width: ${(width / 100) * used},\n      height: ${height},\n      fill: '#1890ff',\n      stroke: '#1890ff'\n    }}/>\n  </rect>\n`;\n\n// 定义节点的 jsx 绘制方式\nconst textXML = (cfg) => `\n<group>\n  <rect style={{\n    width: 100, height: 20, fill: '#1890ff', stroke: '#1890ff', radius: [6, 6, 0, 0]\n  }}>\n    <text style={{ marginTop: 2, marginLeft: 50, \n\t\t\ttextAlign: 'center',\n\t\t\tfontWeight: 'bold', \n\t\t\tfill: '#fff' }}>${cfg.id}</text>\n  </rect>\n  <rect style={{ width: 100, height: 80, fill: 'rgba(24,144,255,0.15)', \n\t\tradius: [0, 0, 6, 6] }} \n\t\tkeyshape=\"true\" \n\t\tcursor=\"move\">\n    <text style={{marginLeft: 10 ,fill: 'red'}}>FULL</text>\n    <text style={{ marginTop: 5, marginLeft: 10, fill: '#333'}}>${cfg.metric}: </text>\n    <text style={{\n      marginTop: 1,\n      marginLeft: ${cfg.cpuUsage * 0.8},\n      fontSize: 10,\n      fill: '#1890ff',\n    }}>${cfg.cpuUsage}%</text>\n    ${percentageBar({ width: 80, used: cfg.cpuUsage })}\n  </rect>\n</group>\n`;\n\n// 注册节点\nG6.registerNode('xml-card', {\n  jsx: textXML,\n});\n",paraId:12,tocIndex:3},{value:"效果如下图所示：",paraId:13,tocIndex:3}]},10439:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"长期以来，定义节点一直是一个比较让大家烦恼的问题，即使推出了 jsx 方案来简化，也依然有一定难度，于是我们推出了 ",paraId:0},{value:"@antv/g6-react-node",paraId:0},{value:" 这一个包，让大家可以更简单的定义节点，这个包支持 ts 提示，并且包含了高阶的基于 shape 的事件动画等，让大家可以更方便的使用 G6。",paraId:0},{value:"首先在安装完 G6 后，你需要额外安装 ",paraId:1,tocIndex:0},{value:"@antv/g6-react-node",paraId:1,tocIndex:0},{value:"npm install @antv/g6-react-node\n// yarn add @antv/g6-react-node\n",paraId:2,tocIndex:0},{value:"以一个简单的卡片为例子，它包含了定义，自定义事件，节点数据管理等的示例：",paraId:3,tocIndex:0},{value:"import React from 'react';\nimport G6 from '@antv/g6';\nimport { Rect, Text, Circle, Image, Group, createNodeFromReact } from '@antv/g6-react-node';\n\nconst Tag = ({ text, color }) => (\n  <Rect\n    style={{\n      fill: color,\n      padding: [5, 10],\n      width: 'auto',\n      radius: [4],\n      margin: [0, 8],\n    }}\n  >\n    <Text style={{ fill: '#fff', fontSize: 10 }}>{text}</Text>\n  </Rect>\n);\n\nconst Card = ({ cfg }) => {\n  const { collapsed = false } = cfg;\n\n  return (\n    <Group draggable>\n      <Rect\n        style={{\n          width: 400,\n          height: 'auto',\n          fill: '#fff',\n          stroke: '#ddd',\n          shadowColor: '#eee',\n          shadowBlur: 30,\n          radius: [8],\n          justifyContent: 'center',\n          padding: [18, 0],\n        }}\n        draggable\n      >\n        <Text\n          style={{\n            fill: '#000',\n            margin: [0, 24],\n            fontSize: 16,\n            fontWeight: 'bold',\n          }}\n        >\n          这是一个卡片\n        </Text>\n        <Text style={{ fill: '#ccc', fontSize: 12, margin: [12, 24] }}>\n          我是一段特别特别特别特别特别特别特别长的描述\n        </Text>\n        {collapsed && (\n          <Group>\n            <Image\n              style={{\n                img: 'https://gw.alipayobjects.com/zos/antfincdn/aPkFc8Sj7n/method-draw-image.svg',\n                width: 200,\n                height: 200,\n                margin: [24, 'auto'],\n              }}\n            />\n            <Rect style={{ width: 'auto', flexDirection: 'row', padding: [4, 12] }}>\n              <Tag color=\"#66ccff\" text=\"我是\" />\n              <Tag color=\"#66ccff\" text=\"很多个\" />\n              <Tag color=\"#66ccff\" text=\"很多个的\" />\n              <Tag color=\"#66ccff\" text=\"标签\" />\n            </Rect>\n          </Group>\n        )}\n        <Circle\n          style={{\n            position: 'absolute',\n            x: 380,\n            y: 20,\n            r: 5,\n            fill: collapsed ? 'blue' : 'green',\n          }}\n        >\n          <Text\n            style={{\n              fill: '#fff',\n              fontSize: 10,\n              margin: [-6, -3, 0],\n              cursor: 'pointer',\n            }}\n            onClick={(evt, node, shape, graph) => {\n              graph.updateItem(node, {\n                collapsed: !collapsed,\n              });\n            }}\n          >\n            {collapsed ? '-' : '+'}\n          </Text>\n        </Circle>\n      </Rect>\n    </Group>\n  );\n};\n\nG6.registerNode('test', createNodeFromReact(Card));\n",paraId:4,tocIndex:0},{value:"展示了这样一个卡片的节点：",paraId:5,tocIndex:0},{value:"定义 React 组件节点的时候，你不能使用任何的 hook 或者异步获取的逻辑，因为目前节点绘制需要是一个同步的过程，并且，我们推荐把所有状态以及数据信息放在节点本身 data 中，这样可以更方便的进行管理。在React组件节点中，所有的数据流动都应该是：节点数据 -> react 组件 props(cfg) -> 节点内容变化。组件本身需要是没有任何副作用的，所有对于节点数据的改变，都是基于 updateItem 的。",paraId:6,tocIndex:2},{value:"如果你没有做任何定位或者布局，所有布局都会按照正常的文档流，自上而下排布。为了让大家有更自由的布局方式， React 内部还支持了 flex 布局，你可以通过操作：",paraId:7,tocIndex:3},{value:"alignContent",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"alignItems",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"alignSelf",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"display",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flex",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flexBasis",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flexGrow",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flexShrink",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flexDirection",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"flexWrap",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"height",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"width",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"justifyContent",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"margin",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"padding",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"maxHeight",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"maxWidth",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"minHeight",paraId:7,tocIndex:3},{value:",",paraId:7,tocIndex:3},{value:"minWidth",paraId:7,tocIndex:3},{value:" 这几个属性来控制节点内部的布局。",paraId:7,tocIndex:3},{value:"为了更加方便的控制节点，我们支持了在节点内部的某一个图形进行事件绑定(事件冒泡会在后续版本支持)，这些事件绑定函数都有统一的参数： ",paraId:8,tocIndex:4},{value:"(evt: G6本身的事件, node: 事件发生的节点, shape: 事件发生的Shape, graph: 发出事件的graph)",paraId:8,tocIndex:4},{value:"，目前我们支持了大部分的 G6 事件：",paraId:8,tocIndex:4},{value:"onClick",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDBClick ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseEnter",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseMove ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseOut",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseOver ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseLeave",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseDown ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onMouseUp ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDragStart ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDrag",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDragEnd ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDragEnter ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDragLeave ",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDragOver",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onDrop",paraId:8,tocIndex:4},{value:",",paraId:8,tocIndex:4},{value:"onContextMenu",paraId:8,tocIndex:4},{value:"⚠️ 注意： 使用了事件后，需要使用函数 ",paraId:9,tocIndex:4},{value:"appenAutoShapeListener(graph)",paraId:9,tocIndex:4},{value:" 对所进行对图进行事件挂载才可以生效，该方法可以直接从 ",paraId:9,tocIndex:4},{value:"@antv/g6-react-node",paraId:9,tocIndex:4},{value:" 包引出。",paraId:9,tocIndex:4},{value:"为了更加方便给节点添加动画，所以我们内置了一些简单的动画来使用，希望能满足基本交互的效果，第一期我们暂时只推出了六种动画， ",paraId:10,tocIndex:5},{value:"animation",paraId:10,tocIndex:5},{value:" 属性设置后就有动画，属性为空则停止动画。",paraId:10,tocIndex:5},{value:"示例：",paraId:11,tocIndex:5},{value:"<Rect\n        style={{\n          width: 400,\n          // ...\n        }}\n        draggable\n        animation={\n          animated && {\n            animate: 'rubber', // 同时支持 'spin','flash','pulse','tada','bounce'\n            repeat: true,\n            duration: 2000,\n          }\n        }\n      >\n",paraId:12,tocIndex:5},{value:"「如何用React在G6里面优雅的定制节点」",paraId:13,tocIndex:6},{value:"G6 React Node Docs",paraId:14,tocIndex:6}]},60714:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图的元素（Item）包含图上的节点 Node 、边 Edge 和 Combo 三大类。每个图元素由一个或多个 ",paraId:0},{value:"图形（Shape）",paraId:1},{value:" 组成，且都会有自己的唯一关键图形（keyShape）。G6 内置了一系列具有不同基本图形样式的节点/边/ Combo，例如，节点可以是圆形、矩形、图片等。G6 中所有内置的元素样式详见 ",paraId:0},{value:"内置节点",paraId:2},{value:"，",paraId:0},{value:"内置边",paraId:3},{value:"，",paraId:0},{value:"内置 Combo",paraId:4},{value:"。除了使用内置的节点/边/ Combo 外，G6 还允许用户通过自己搭配和组合 shape 进行节点/边/ Combo 的自定义，详见 ",paraId:0},{value:"自定义节点",paraId:5},{value:"，",paraId:0},{value:"自定义边",paraId:6},{value:"，",paraId:0},{value:"自定义 Combo",paraId:7},{value:"。",paraId:0},{value:"图元素具有公共的通用属性和通用方法。图元素的属性包括：",paraId:8},{value:"样式属性，通过 ",paraId:9},{value:"style",paraId:9},{value:" 字段对象进行配置，和元素的关键图形相关，例如 ",paraId:9},{value:"fill",paraId:9},{value:"，",paraId:9},{value:"stroke",paraId:9},{value:"。可在",paraId:9},{value:"元素状态",paraId:10},{value:"改变时被改变。",paraId:9},{value:"其他属性，例如 ",paraId:9},{value:"id",paraId:9},{value:"、",paraId:9},{value:"type",paraId:9},{value:"，不能在元素状态改变是进行改变，可通过 ",paraId:9},{value:"graph.updateItem",paraId:11},{value:" 进行手动更新。完整的元素属性列表参考：",paraId:9},{value:"元素配置项",paraId:12},{value:"。除了各类元素共有的通用属性外，每种节点/边/ Combo 都有各自的特有属性。",paraId:9},{value:"图元素实例上具有对元素进行更新、销毁、获取属性、修改状态等",paraId:13},{value:"通用方法",paraId:14},{value:"，同时，对于实例的变更也可以通过调用 ",paraId:13},{value:"graph",paraId:15},{value:" 上的方法进行。",paraId:13},{value:"本章对三大类图元素的通用属性和方法进行了概览性介绍，每种图元素（节点/边/ Combo）各自的属性和使用方法将在后面章节中详述。",paraId:16}]},32963:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"   ",paraId:0},{value:"⚠️ 注意:",paraId:0},{value:" ",paraId:0},{value:" 图形分组 Group 与 ",paraId:0},{value:"节点分组 Combo",paraId:1},{value:" 属于不同层次的概念。",paraId:0},{value:"图形分组针对 ",paraId:2},{value:"图形 Shape",paraId:3},{value:" 层次的分组；",paraId:2},{value:"节点分组 Combo",paraId:4},{value:"  是针对 ",paraId:2},{value:"节点",paraId:5},{value:" 的分组，与数据结构中的层次、分组对应。",paraId:2},{value:"图形分组 group 类似于 ",paraId:6,tocIndex:0},{value:"SVG 中的 ",paraId:6,tocIndex:0},{value:"<g>",paraId:6,tocIndex:0},{value:" 标签",paraId:6,tocIndex:0},{value:"：元素  ",paraId:6,tocIndex:0},{value:"g",paraId:6,tocIndex:0},{value:"  是用来组合图形对象的容器。在 group  上添加变换（例如剪裁、旋转、放缩、平移等）会应用到其所有的子元素上。在 group  上添加属性（例如颜色、位置等）会被其所有的子元素继承。此外， group 可以多层嵌套使用，因此可以用来定义复杂的对象。",paraId:6,tocIndex:0},{value:"在 G6 中，Graph 的一个实例中的所有节点属于同一个变量名为 ",paraId:7,tocIndex:0},{value:"nodeGroup",paraId:7,tocIndex:0},{value:" 的 group，所有的边属于同一个变量名为 ",paraId:7,tocIndex:0},{value:"edgeGroup",paraId:7,tocIndex:0},{value:" 的 group。节点 group 在视觉上的层级（zIndex）高于边 group，即所有节点会绘制在所有边的上层。",paraId:7,tocIndex:0},{value:"如下图（左）三个节点属于  ",paraId:7,tocIndex:0},{value:"nodeGroup",paraId:7,tocIndex:0},{value:" ，两条边属于 ",paraId:7,tocIndex:0},{value:"edgeGroup",paraId:7,tocIndex:0},{value:" ， ",paraId:7,tocIndex:0},{value:"nodeGroup",paraId:7,tocIndex:0},{value:"  层级高于 ",paraId:7,tocIndex:0},{value:"edgeGroup",paraId:7,tocIndex:0},{value:" ，三个节点绘制在两条边的上层。下图（右）是（左）图的节点降低透明度后的效果，可以更清晰看到边绘制在节点下方。",paraId:7,tocIndex:0},{value:"（左）节点和边的图形分组 Group 演示。（右）给左图的节点降低了透明度。",paraId:8,tocIndex:0},{value:"自定义节点",paraId:9,tocIndex:1},{value:"、",paraId:10,tocIndex:1},{value:"自定义边",paraId:11,tocIndex:1},{value:"时将会涉及到图形分组 Group 的概念。图形分组 Group 方便了用户对节点或边上元素的组合和管理。",paraId:10,tocIndex:1},{value:"例如，如下图中的节点 A 有一个包含节点 A 中所有图形的 group，该 group 中包含了一个 circle 图形和一个文本图形。节点 B 是一个自定义节点，有一个包含节点 B 中所有图形的 group，该 group 包含了 circle 图形、rect 图形、文本图形。",paraId:10,tocIndex:1},{value:"图形分组一般会在",paraId:12,tocIndex:2},{value:"自定义节点",paraId:13,tocIndex:2},{value:"、",paraId:12,tocIndex:2},{value:"自定义边",paraId:14,tocIndex:2},{value:"时用到。Group 的完整实例方法请参考 ",paraId:12,tocIndex:2},{value:"Graphics Group API",paraId:15,tocIndex:2},{value:"。",paraId:12,tocIndex:2},{value:"// 获取元素(节点/边/Combo)的图形对象的容器\nconst group = item.getContainer();\n\n// 等价于\nconst group = item.get('group');\n",paraId:16,tocIndex:3},{value:"addGroup(cfgs)",paraId:17,tocIndex:4},{value:"向分组中添加新的分组。",paraId:18,tocIndex:4},{value:"const subGroup = group.addGroup({\n  id: 'rect',\n});\n",paraId:19,tocIndex:4},{value:"addShape(type, cfgs)",paraId:20,tocIndex:4},{value:"向分组中添加新的图形。",paraId:21,tocIndex:4},{value:"const keyShape = group.addShape('rect', {\n  attrs: {\n    stroke: 'red',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:22,tocIndex:4},{value:"提示：在分组上添加的 ",paraId:23,tocIndex:4},{value:"clip",paraId:23,tocIndex:4},{value:"， ",paraId:23,tocIndex:4},{value:"transform",paraId:23,tocIndex:4},{value:" 等会影响到该分组中的所有元素（子分组或图形）。",paraId:23,tocIndex:4}]},5682:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 中的元素（节点/边）是",paraId:0},{value:"由一个或多个",paraId:0},{value:"图形 Shape",paraId:1},{value:" ",paraId:0},{value:"组成",paraId:0},{value:"，主要通过自定义节点或自定义边时在 ",paraId:0},{value:"draw",paraId:0},{value:" 方法中使用 ",paraId:0},{value:"group.addShape",paraId:0},{value:" 添加，G6 中支持以下的图形 Shape：",paraId:0},{value:"circle",paraId:2},{value:"：圆；",paraId:3},{value:"rect",paraId:4},{value:"：矩形；",paraId:3},{value:"ellipse",paraId:5},{value:"：椭圆；",paraId:3},{value:"polygon",paraId:6},{value:"：多边形；",paraId:3},{value:"fan",paraId:7},{value:"：扇形；",paraId:3},{value:"image",paraId:8},{value:"：图片；",paraId:3},{value:"marker",paraId:9},{value:"：标记；",paraId:3},{value:"path",paraId:10},{value:"：路径；",paraId:3},{value:"text",paraId:11},{value:"：文本；",paraId:3},{value:"dom(svg)",paraId:12},{value:"：DOM（图渲染方式 ",paraId:3},{value:"renderer",paraId:3},{value:" 为 ",paraId:3},{value:"'svg'",paraId:3},{value:" 时可用）。",paraId:3},{value:"属性名",paraId:13,tocIndex:0},{value:"含义",paraId:13,tocIndex:0},{value:"备注",paraId:13,tocIndex:0},{value:"fill",paraId:13,tocIndex:0},{value:"设置用于填充绘画的颜色、渐变或模式",paraId:13,tocIndex:0},{value:"对应 Canvas 属性 ",paraId:13,tocIndex:0},{value:"fillStyle",paraId:13,tocIndex:0},{value:"stroke",paraId:13,tocIndex:0},{value:"设置用于笔触的颜色、渐变或模式",paraId:13,tocIndex:0},{value:"对应 Canvas 属性 ",paraId:13,tocIndex:0},{value:"strokeStyle",paraId:13,tocIndex:0},{value:"lineWidth",paraId:13,tocIndex:0},{value:"描边宽度",paraId:13,tocIndex:0},{value:"lineDash",paraId:13,tocIndex:0},{value:"描边虚线",paraId:13,tocIndex:0},{value:"Number[] 类型代表实、虚长度",paraId:13,tocIndex:0},{value:"shadowColor",paraId:13,tocIndex:0},{value:"设置用于阴影的颜色",paraId:13,tocIndex:0},{value:"shadowBlur",paraId:13,tocIndex:0},{value:"设置用于阴影的模糊级别",paraId:13,tocIndex:0},{value:"数值越大，越模糊",paraId:13,tocIndex:0},{value:"shadowOffsetX",paraId:13,tocIndex:0},{value:"设置阴影距形状的水平距离",paraId:13,tocIndex:0},{value:"shadowOffsetY",paraId:13,tocIndex:0},{value:"设置阴影距形状的垂直距离",paraId:13,tocIndex:0},{value:"opacity",paraId:13,tocIndex:0},{value:"设置绘图的当前 alpha 或透明值",paraId:13,tocIndex:0},{value:"对应 Canvas 属性 ",paraId:13,tocIndex:0},{value:"globalAlpha",paraId:13,tocIndex:0},{value:"fillOpacity",paraId:13,tocIndex:0},{value:"设置填充的 alpha 或透明值",paraId:13,tocIndex:0},{value:"cursor",paraId:13,tocIndex:0},{value:"鼠标在该节点上时的鼠标样式，",paraId:13,tocIndex:0},{value:"CSS 的 cursor",paraId:13,tocIndex:0},{value:" 选项都支持",paraId:13,tocIndex:0},{value:"group.addShape('rect', {\n  attrs: {\n    fill: 'red',\n    shadowOffsetX: 10,\n    shadowOffsetY: 10,\n    shadowColor: 'blue',\n    shadowBlur: 10,\n    opacity: 0.8,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:14,tocIndex:1},{value:"设置或获取实例的绘图属性。",paraId:15,tocIndex:3},{value:"获取实例的属性值。",paraId:16,tocIndex:4},{value:"const width = shape.attr('width');\n",paraId:17,tocIndex:4},{value:"更新实例的单个绘图属性。",paraId:18,tocIndex:5},{value:"批量更新实例绘图属性。",paraId:19,tocIndex:6},{value:"rect.attr({\n    fill: '#999',\n    stroke: '#666'\n});\n",paraId:20,tocIndex:6},{value:"属性名",paraId:21,tocIndex:8},{value:"含义",paraId:21,tocIndex:8},{value:"x",paraId:21,tocIndex:8},{value:"圆心的 x 坐标",paraId:21,tocIndex:8},{value:"y",paraId:21,tocIndex:8},{value:"圆心的 y 坐标",paraId:21,tocIndex:8},{value:"r",paraId:21,tocIndex:8},{value:"圆的半径",paraId:21,tocIndex:8},{value:"group.addShape('circle', {\n  attrs: {\n    x: 100,\n    y: 100,\n    r: 50,\n    fill: 'blue',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'circle-shape',\n});\n",paraId:22,tocIndex:9},{value:"属性名",paraId:23,tocIndex:11},{value:"含义",paraId:23,tocIndex:11},{value:"备注",paraId:23,tocIndex:11},{value:"x",paraId:23,tocIndex:11},{value:"矩形左上角的 x 坐标",paraId:23,tocIndex:11},{value:"y",paraId:23,tocIndex:11},{value:"矩形左上角的 y 坐标",paraId:23,tocIndex:11},{value:"width",paraId:23,tocIndex:11},{value:"矩形的宽度",paraId:23,tocIndex:11},{value:"height",paraId:23,tocIndex:11},{value:"矩形的高度",paraId:23,tocIndex:11},{value:"radius",paraId:23,tocIndex:11},{value:"定义圆角",paraId:23,tocIndex:11},{value:"支持整数或数组形式， 分别对应左上、右上、右下、左下角的半径：",paraId:23,tocIndex:11},{value:"- radius 缩写为 1 或 [ 1 ] 相当于 [ 1, 1, 1, 1 ]",paraId:23,tocIndex:11},{value:"- radius 缩写为 [ 1, 2 ] 相当于 [ 1, 2, 1, 2 ]",paraId:23,tocIndex:11},{value:"- radius 缩写为 [ 1, 2, 3 ] 相当于 [ 1, 2, 3, 2 ]",paraId:23,tocIndex:11},{value:"group.addShape('rect', {\n  attrs: {\n    x: 150,\n    y: 150,\n    width: 150,\n    height: 150,\n    stroke: 'black',\n    radius: [2, 4],\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:24,tocIndex:12},{value:"属性名",paraId:25,tocIndex:14},{value:"含义",paraId:25,tocIndex:14},{value:"x",paraId:25,tocIndex:14},{value:"圆心的 x 坐标",paraId:25,tocIndex:14},{value:"y",paraId:25,tocIndex:14},{value:"圆心的 y 坐标",paraId:25,tocIndex:14},{value:"rx",paraId:25,tocIndex:14},{value:"水平半径",paraId:25,tocIndex:14},{value:"ry",paraId:25,tocIndex:14},{value:"垂直半径",paraId:25,tocIndex:14},{value:"group.addShape('ellipse', {\n  attrs: {\n    x: 100,\n    y: 100,\n    rx: 50,\n    ry: 50,\n    fill: 'blue',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'ellipse-shape',\n});\n",paraId:26,tocIndex:15},{value:"属性名",paraId:27,tocIndex:17},{value:"含义",paraId:27,tocIndex:17},{value:"备注",paraId:27,tocIndex:17},{value:"points",paraId:27,tocIndex:17},{value:"多边形的所有端点坐标",paraId:27,tocIndex:17},{value:"数组形式",paraId:27,tocIndex:17},{value:"group.addShape('polygon', {\n  attrs: {\n    points: [\n      [30, 30],\n      [40, 20],\n      [30, 50],\n      [60, 100],\n    ],\n    fill: 'red',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'polygon-shape',\n});\n",paraId:28,tocIndex:18},{value:"属性名",paraId:29,tocIndex:20},{value:"含义",paraId:29,tocIndex:20},{value:"备注",paraId:29,tocIndex:20},{value:"x",paraId:29,tocIndex:20},{value:"图片左上角的 x 坐标",paraId:29,tocIndex:20},{value:"y",paraId:29,tocIndex:20},{value:"图片左上角的 y 坐标",paraId:29,tocIndex:20},{value:"width",paraId:29,tocIndex:20},{value:"图片宽度",paraId:29,tocIndex:20},{value:"height",paraId:29,tocIndex:20},{value:"图片高度",paraId:29,tocIndex:20},{value:"img",paraId:29,tocIndex:20},{value:"图片源",paraId:29,tocIndex:20},{value:"G6 支持多种格式的图片：url、ImageData、Image、canvas",paraId:29,tocIndex:20},{value:"group.addShape('image', {\n  attrs: {\n    x: 0,\n    y: 0,\n    img: 'https://g.alicdn.com/cm-design/arms-trace/1.0.155/styles/armsTrace/images/TAIR.png',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'image-shape',\n});\n",paraId:30,tocIndex:21},{value:"属性名",paraId:31,tocIndex:23},{value:"含义",paraId:31,tocIndex:23},{value:"备注",paraId:31,tocIndex:23},{value:"x",paraId:31,tocIndex:23},{value:"中心的 x 坐标",paraId:31,tocIndex:23},{value:"y",paraId:31,tocIndex:23},{value:"中心的 y 坐标",paraId:31,tocIndex:23},{value:"r",paraId:31,tocIndex:23},{value:"形状半径",paraId:31,tocIndex:23},{value:"symbol",paraId:31,tocIndex:23},{value:"指定形状",paraId:31,tocIndex:23},{value:"内置了一些常用形状，如圆形 ",paraId:31,tocIndex:23},{value:"circle",paraId:31,tocIndex:23},{value:" ， 矩形  ",paraId:31,tocIndex:23},{value:"square",paraId:31,tocIndex:23},{value:" ， 菱形  ",paraId:31,tocIndex:23},{value:"diamond",paraId:31,tocIndex:23},{value:" ，三角形  ",paraId:31,tocIndex:23},{value:"triangle",paraId:31,tocIndex:23},{value:" ， 倒三角形 ",paraId:31,tocIndex:23},{value:"triangle-down",paraId:31,tocIndex:23},{value:" ，也可以是自定义的 path 路径。",paraId:31,tocIndex:23},{value:"group.addShape('marker', {\n  attrs: {\n    x: 10,\n    y: 10,\n    r: 10,\n    symbol: function (x, y, r) {\n      return [['M', x, y], ['L', x + r, y + r], ['L', x + r * 2, y], ['Z']];\n    },\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'marker-shape',\n});\n",paraId:32,tocIndex:24},{value:"   ",paraId:33,tocIndex:25},{value:"⚠️ 注意:",paraId:33,tocIndex:25},{value:" 当边太细交互不易命中时，请设置 ",paraId:33,tocIndex:25},{value:"lineAppendWidth",paraId:33,tocIndex:25},{value:" 属性值。",paraId:33,tocIndex:25},{value:"属性名",paraId:34,tocIndex:26},{value:"含义",paraId:34,tocIndex:26},{value:"备注",paraId:34,tocIndex:26},{value:"path",paraId:34,tocIndex:26},{value:"线条路径",paraId:34,tocIndex:26},{value:"可以是 String 形式，也可以是线段的数组。",paraId:34,tocIndex:26},{value:"startArrow",paraId:34,tocIndex:26},{value:"起始端的箭头",paraId:34,tocIndex:26},{value:"为 ",paraId:34,tocIndex:26},{value:"true",paraId:34,tocIndex:26},{value:" 时在边的结束端绘制默认箭头，为 ",paraId:34,tocIndex:26},{value:"false",paraId:34,tocIndex:26},{value:" 时不绘制结束端箭头。也可以是一个通过 path 自定义的箭头",paraId:34,tocIndex:26},{value:"endArrow",paraId:34,tocIndex:26},{value:"末尾端的箭头",paraId:34,tocIndex:26},{value:"为 ",paraId:34,tocIndex:26},{value:"true",paraId:34,tocIndex:26},{value:" 时在边的开始端绘制默认箭头，为 ",paraId:34,tocIndex:26},{value:"false",paraId:34,tocIndex:26},{value:" 时不绘制开始端箭头。也可以是一个通过 path 自定义的箭头",paraId:34,tocIndex:26},{value:"lineAppendWidth",paraId:34,tocIndex:26},{value:"边的击中范围",paraId:34,tocIndex:26},{value:"提升边的击中范围，扩展响应范围，数值越大，响应范围越广",paraId:34,tocIndex:26},{value:"lineCap",paraId:34,tocIndex:26},{value:"设置线条的结束端点样式",paraId:34,tocIndex:26},{value:"lineJoin",paraId:34,tocIndex:26},{value:"设置两条线相交时，所创建的拐角形状",paraId:34,tocIndex:26},{value:"lineWidth",paraId:34,tocIndex:26},{value:"设置当前的线条宽度",paraId:34,tocIndex:26},{value:"miterLimit",paraId:34,tocIndex:26},{value:"设置最大斜接长度",paraId:34,tocIndex:26},{value:"lineDash",paraId:34,tocIndex:26},{value:"设置线的虚线样式，可以指定一个数组",paraId:34,tocIndex:26},{value:"一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。",paraId:34,tocIndex:26},{value:"group.addShape('path', {\n  attrs: {\n    startArrow: {\n      // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n      path: 'M 0,0 L 20,10 L 20,-10 Z',\n      // 箭头的偏移量，负值代表向 x 轴正方向移动\n      // d: -10,\n    },\n    endArrow: {\n      // 自定义箭头指向(0, 0)，尾部朝向 x 轴正方向的 path\n      path: 'M 0,0 L 20,10 L 20,-10 Z',\n      // 箭头的偏移量，负值代表向 x 轴正方向移动\n      // d: -10,\n    },\n    path: [\n      ['M', 100, 100],\n      ['L', 200, 200],\n    ],\n    stroke: '#000',\n    lineWidth: 8,\n    lineAppendWidth: 5,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'path-shape',\n});\n",paraId:35,tocIndex:27},{value:"属性名",paraId:36,tocIndex:29},{value:"含义",paraId:36,tocIndex:29},{value:"备注",paraId:36,tocIndex:29},{value:"fill",paraId:36,tocIndex:29},{value:"设置用于填充绘画的颜色、渐变或模式",paraId:36,tocIndex:29},{value:"对应 Canvas 属性 ",paraId:36,tocIndex:29},{value:"fillStyle",paraId:36,tocIndex:29},{value:"stroke",paraId:36,tocIndex:29},{value:"设置用于笔触的颜色、渐变或模式",paraId:36,tocIndex:29},{value:"对应 Canvas 属性 ",paraId:36,tocIndex:29},{value:"strokeStyle",paraId:36,tocIndex:29},{value:"shadowColor",paraId:36,tocIndex:29},{value:"设置用于阴影的颜色",paraId:36,tocIndex:29},{value:"shadowBlur",paraId:36,tocIndex:29},{value:"设置用于阴影的模糊级别",paraId:36,tocIndex:29},{value:"数值越大，越模糊",paraId:36,tocIndex:29},{value:"shadowOffsetX",paraId:36,tocIndex:29},{value:"设置阴影距形状的水平距离",paraId:36,tocIndex:29},{value:"shadowOffsetY",paraId:36,tocIndex:29},{value:"设置阴影距形状的垂直距离",paraId:36,tocIndex:29},{value:"opacity",paraId:36,tocIndex:29},{value:"设置绘图的当前 alpha 或透明值",paraId:36,tocIndex:29},{value:"对应 Canvas 属性 ",paraId:36,tocIndex:29},{value:"globalAlpha",paraId:36,tocIndex:29},{value:"textAlign",paraId:36,tocIndex:29},{value:"设置文本内容的当前对齐方式",paraId:36,tocIndex:29},{value:"支持的属性：",paraId:36,tocIndex:29},{value:"center",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"end",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"left",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"right",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"start",paraId:36,tocIndex:29},{value:"，默认值为 ",paraId:36,tocIndex:29},{value:"start",paraId:36,tocIndex:29},{value:"textBaseline",paraId:36,tocIndex:29},{value:"设置在绘制文本时使用的当前文本基线",paraId:36,tocIndex:29},{value:"支持的属性:",paraId:36,tocIndex:29},{value:"top",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"middle",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"bottom",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"alphabetic",paraId:36,tocIndex:29},{value:" / ",paraId:36,tocIndex:29},{value:"hanging",paraId:36,tocIndex:29},{value:"。默认值为 ",paraId:36,tocIndex:29},{value:"bottom",paraId:36,tocIndex:29},{value:"fontStyle",paraId:36,tocIndex:29},{value:"字体样式",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"font-style",paraId:36,tocIndex:29},{value:"fontVariant",paraId:36,tocIndex:29},{value:"设置为小型大写字母字体",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"font-variant",paraId:36,tocIndex:29},{value:"fontWeight",paraId:36,tocIndex:29},{value:"字体粗细",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"font-weight",paraId:36,tocIndex:29},{value:"fontSize",paraId:36,tocIndex:29},{value:"字体大小",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"font-size",paraId:36,tocIndex:29},{value:"fontFamily",paraId:36,tocIndex:29},{value:"字体系列",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"font-family",paraId:36,tocIndex:29},{value:"lineHeight",paraId:36,tocIndex:29},{value:"行高",paraId:36,tocIndex:29},{value:"对应 ",paraId:36,tocIndex:29},{value:"line-height",paraId:36,tocIndex:29},{value:"group.addShape('text', {\n  attrs: {\n    text: 'test text',\n    x: 0,\n    y: 10,\n    fontSize: 14,\n    textAlign: 'left',\n    textBaseline: 'middle',\n    fill: '#0000D9',\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'text-shape',\n});\n",paraId:37,tocIndex:30},{value:"仅在 Graph 的 ",paraId:38,tocIndex:31},{value:"renderer",paraId:38,tocIndex:31},{value:" 为 ",paraId:38,tocIndex:31},{value:"'svg'",paraId:38,tocIndex:31},{value:" 时可以使用。",paraId:38,tocIndex:31},{value:"⚠️ 注意:",paraId:39,tocIndex:31},{value:"只支持原生 HTML DOM，不支持各类 react、vue 组件；",paraId:40,tocIndex:31},{value:"使用 ",paraId:40,tocIndex:31},{value:"'dom'",paraId:40,tocIndex:31},{value:" 进行自定义的节点或边，不支持 G6 的交互事件，请使用原生 DOM 的交互事件；",paraId:40,tocIndex:31},{value:"在 Safari 中，若 dom 节点被设置了 ",paraId:40,tocIndex:31},{value:"position:relative",paraId:40,tocIndex:31},{value:"，将会导致渲染异常。该问题与 ",paraId:40,tocIndex:31},{value:"Safari 的 foreignObject bug",paraId:40,tocIndex:31},{value:" 有关。",paraId:40,tocIndex:31},{value:"Issus",paraId:40,tocIndex:31},{value:"。",paraId:40,tocIndex:31},{value:"属性名",paraId:41,tocIndex:32},{value:"含义",paraId:41,tocIndex:32},{value:"备注",paraId:41,tocIndex:32},{value:"html",paraId:41,tocIndex:32},{value:"DOM 的 html 值",paraId:41,tocIndex:32},{value:'group.addShape(\'dom\', {\n  attrs: {\n    width: cfg.size[0],\n    height: cfg.size[1],\n    // DOM\'s html\n    html: `\n    <div style="background-color: #fff; border: 2px solid #5B8FF9; border-radius: 5px; width: ${\n      cfg.size[0] - 5\n    }px; height: ${cfg.size[1] - 5}px; display: flex;">\n      <div style="height: 100%; width: 33%; background-color: #CDDDFD">\n        <img alt="img" style="line-height: 100%; padding-top: 6px; padding-left: 8px;" src="https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*Q_FQT6nwEC8AAAAAAAAAAABkARQnAQ" width="20" height="20" />  \n      </div>\n      <span style="margin:auto; padding:auto; color: #5B8FF9">${cfg.label}</span>\n    </div>\n      `,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: \'dom-shape\',\n  draggable: true,\n});\n',paraId:42,tocIndex:33}]},16724:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Shape 指 G6 中的图形、形状，它可以是圆形、矩形、路径等。它一般与 G6 中的节点、边、Combo 相关。",paraId:0,tocIndex:0},{value:"G6 中的每一种节点/边/ Combo 由一个或多个 Shape 组成。节点、边、Combo、标签文本的配置都会被体现到对应的图形上。",paraId:0,tocIndex:0},{value:"例如下图（左）的节点包含了一个圆形图形；下图（中）的节点含有有一个圆形和一个文本图形；下图（右）的节点中含有 5 个圆形（蓝绿色的圆和上下左右四个锚点）、一个文本图形。但每种节点/边/ Combo 都会有自己的唯一关键图形 keyShape，下图中三个节点的 keyShape 都是蓝绿色的圆，keyShape 主要用于交互检测、样式随",paraId:1,tocIndex:0},{value:"状态",paraId:2,tocIndex:0},{value:"自动更新等，见  ",paraId:1,tocIndex:0},{value:"keyShape",paraId:3,tocIndex:0},{value:"。",paraId:1,tocIndex:0},{value:"     ",paraId:1,tocIndex:0},{value:"      ",paraId:1,tocIndex:0},{value:"（左）只含有一个圆形图形的节点，keyShape 是该圆形。（中）含有圆形和文本图形的节点，keyShape 是圆形。（右）含有主要圆形、文本、上下左右四个小圆形的节点，keyShape 是圆形。",paraId:4,tocIndex:0},{value:"G6 使用不同的 shape 组合，设计了多种内置的节点/边/ Combo 。G6 内置节点的有 'circle'， 'rect'，'ellipse'，...（详见 ",paraId:5,tocIndex:0},{value:"内置节点",paraId:6,tocIndex:0},{value:"）；内置边的有 'line'，'polyline'，'cubic'，...（详见 ",paraId:5,tocIndex:0},{value:"内置边",paraId:7,tocIndex:0},{value:"）；内置 Combo 有 'circle'，'rect'，()详见 ",paraId:5,tocIndex:0},{value:"内置 Combo",paraId:8,tocIndex:0},{value:"）。",paraId:5,tocIndex:0},{value:"除了使用内置的节点/边/ Combo 外，G6 还允许用户通过自己搭配和组合 shape 进行节点/边/ Combo 的自定义，详见 ",paraId:9,tocIndex:0},{value:"自定义节点",paraId:10,tocIndex:0},{value:"，",paraId:9,tocIndex:0},{value:"自定义边",paraId:11,tocIndex:0},{value:"，",paraId:9,tocIndex:0},{value:"自定义 Combo",paraId:12,tocIndex:0},{value:"。",paraId:9,tocIndex:0},{value:"如上所述，每一种节点/边/ Combo 都有一个唯一的关键图形 keyShape。keyShape 是在节点/边/ Combo 的 ",paraId:13,tocIndex:1},{value:"draw()",paraId:13,tocIndex:1},{value:" 方法或 ",paraId:13,tocIndex:1},{value:"drawShape()",paraId:13,tocIndex:1},{value:" 方法中返回的图形对象。它有两个主要特点：",paraId:13,tocIndex:1},{value:"内置节点/边/ Combo 配置项中的 ",paraId:14,tocIndex:2},{value:"style",paraId:14,tocIndex:2},{value:" 只体现在它的 keyShape 上。而内置节点/边/ Combo 的状态样式 （图实例的 ",paraId:14,tocIndex:2},{value:"nodeStateStyles",paraId:14,tocIndex:2},{value:" / ",paraId:14,tocIndex:2},{value:"edgeStateStyles",paraId:14,tocIndex:2},{value:" / ",paraId:14,tocIndex:2},{value:"comboStateStyles",paraId:14,tocIndex:2},{value:" 或元素自身的 ",paraId:14,tocIndex:2},{value:"stateStyles",paraId:14,tocIndex:2},{value:") 中需要体现在 keyShape 或其他图形上的写法有所不同，详见 ",paraId:14,tocIndex:2},{value:"配置状态样式",paraId:15,tocIndex:2},{value:"。",paraId:14,tocIndex:2},{value:"想要更自由地响应样式（绘制或状态变化时），可以 ",paraId:16,tocIndex:2},{value:"自定义节点",paraId:17,tocIndex:2},{value:" / ",paraId:16,tocIndex:2},{value:"自定义边",paraId:18,tocIndex:2},{value:" / ",paraId:16,tocIndex:2},{value:"自定义 Combo",paraId:19,tocIndex:2},{value:"。",paraId:16,tocIndex:2},{value:"该示例使用了内置 rect 节点，节点的 keyShape 是中间的 rect，其他 Shape 包括上下左右四个 circle 以及一个 text。代码设置了节点的样式 ",paraId:20,tocIndex:3},{value:"style",paraId:20,tocIndex:3},{value:"，仅在 rect 上生效，其他 Shape 都以默认样式渲染。该节点上的其他图形需要使用其他配置项进行配置。例如，上下左右四个 circle 的样式需要在 ",paraId:20,tocIndex:3},{value:"linkPoints",paraId:20,tocIndex:3},{value:" 中配置，文本样式需要在 ",paraId:20,tocIndex:3},{value:"labelCfg",paraId:20,tocIndex:3},{value:" 中配置。",paraId:20,tocIndex:3},{value:"代码中还监听了鼠标的进入节点和离开节点事件，触发了 hover 状态后 ",paraId:21,tocIndex:3},{value:"nodeStateStyles",paraId:21,tocIndex:3},{value:" 里 hover 的样式仅在 keyShape 上生效。若需要节点中其他图形响应状态发生样式变化，参考 ",paraId:21,tocIndex:3},{value:"配置状态样式",paraId:22,tocIndex:3},{value:"。",paraId:21,tocIndex:3},{value:"const data = {\n  nodes: [\n    {\n      x: 100,\n      y: 100,\n      label: 'rect',\n      type: 'rect',\n      style: {\n        // 仅在 keyShape 上生效\n        fill: 'lightblue',\n        stroke: '#888',\n        lineWidth: 1,\n        radius: 7,\n      },\n      linkPoints: {\n        top: true,\n        bottom: true,\n        left: true,\n        right: true,\n        // ... 四个圆的样式可以在这里指定\n      },\n      // labelCfg: {...} // 标签的样式可以在这里指定\n    },\n  ],\n};\nconst graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 300,\n  nodeStateStyles: {\n    // 各状态下的样式，平铺的配置项仅在 keyShape 上生效。需要在其他 shape 样式上响应状态变化则写法不同，参见上文提到的 配置状态样式 链接\n    hover: {\n      fillOpacity: 0.1,\n      lineWidth: 10,\n    },\n  },\n});\ngraph.data(data);\ngraph.render();\n// 监听鼠标进入节点事件\ngraph.on('node:mouseenter', (evt) => {\n  const node = evt.item;\n  // 激活该节点的 hover 状态\n  graph.setItemState(node, 'hover', true);\n});\n// 监听鼠标离开节点事件\ngraph.on('node:mouseleave', (evt) => {\n  const node = evt.item;\n  // 关闭该节点的 hover 状态\n  graph.setItemState(node, 'hover', false);\n});\n",paraId:23,tocIndex:3},{value:"确定节点 / Combo 的包围盒（Bounding Box） —— bbox（x, y, width, height)",paraId:24,tocIndex:4},{value:" ，从而计算相关边的连入点（与相关边的交点）。若 keyShape 不同，节点与边的交点计算结果不同。",paraId:24,tocIndex:4},{value:"本例中的一个节点由一个 rect 图形和一个带灰色描边、填充透明的 circle 图形构成。",paraId:25,tocIndex:5},{value:"当节点的 keyShape 为 circle 时：",paraId:26,tocIndex:5},{value:"当节点的 keyShape 为 rect 时：",paraId:27,tocIndex:5},{value:"当用户需要",paraId:28,tocIndex:6},{value:"自定义节点",paraId:29,tocIndex:6},{value:"、",paraId:28,tocIndex:6},{value:"自定义边",paraId:30,tocIndex:6},{value:"、",paraId:28,tocIndex:6},{value:"自定义 Combo",paraId:31,tocIndex:6},{value:" 时，需要了解 Shape 的生命周期。使用内置节点/边/ Combo 则可以跳过这一部分内容。",paraId:28,tocIndex:6},{value:"从整体来看，Shape 的生命周期分为：",paraId:32,tocIndex:6},{value:"初始化渲染；",paraId:33,tocIndex:6},{value:"更新；",paraId:33,tocIndex:6},{value:"操作；",paraId:33,tocIndex:6},{value:"销毁。",paraId:33,tocIndex:6},{value:"Shape 作为 Graph 上的核心元素，这几个阶段都需要考虑，但是销毁可以交给 Graph 来处理，所以在定义 Shape 时不需要考虑，仅需要考虑三个阶段即可：",paraId:34,tocIndex:6},{value:"绘制：从无到有的绘制 Shape 及文本；",paraId:35,tocIndex:6},{value:"更新：数据发生改变导致 Shape 及文本发生变化；",paraId:35,tocIndex:6},{value:"操作：给 Shape 添加状态，如：selected，active 等。",paraId:35,tocIndex:6},{value:"所以我们在设计自定义节点/边/ Combo 时，定义了三个方法，若需要自定义节点/边/ Combo ，需要有选择性地复写它们：",paraId:36,tocIndex:6},{value:"draw(cfg, group)",paraId:37,tocIndex:6},{value:": 绘制，提供了绘制的配置项（数据定义时透传过来）和图形容器，",paraId:37,tocIndex:6},{value:"必须",paraId:37,tocIndex:6},{value:"返回合理的图形作为 keyShape；",paraId:37,tocIndex:6},{value:"update(cfg, n)",paraId:37,tocIndex:6},{value:": 更新，更新时的配置项（更新的字段和原始字段的合并）和元素对象；",paraId:37,tocIndex:6},{value:"setState(name, value, item)",paraId:37,tocIndex:6},{value:": 响应节点/边/ Combo 状态的变化。",paraId:37,tocIndex:6},{value:"关于自定义节点和边的更多方法请参考 ",paraId:38,tocIndex:6},{value:"自定义节点与边 API",paraId:39,tocIndex:6},{value:"。",paraId:38,tocIndex:6}]},11789:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 3.2 及以下版本中，实现变换可通过以下方式。",paraId:0,tocIndex:0},{value:"实例变换方法。参数以数组形式提供，按顺序执行。",paraId:1,tocIndex:1},{value:"例如画布上有以下的一个矩形实例。",paraId:2,tocIndex:1},{value:"const rect = group.addShape('rect', {\n  attrs: {\n    width: 100,\n    height: 100,\n    x: 100,\n    y: 100,\n    fill: '#9EC9FF',\n    stroke: '#5B8FF9',\n    lineWidth: 3,\n  },\n  // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n  name: 'rect-shape',\n});\n",paraId:3,tocIndex:1},{value:"得到的结果如下图所示： ",paraId:4,tocIndex:1},{value:"对其进行如下操作：",paraId:5,tocIndex:1},{value:"rect.transform([\n  ['t', 10, 10], // x 方向平移 10, y 方向平移 10\n  ['s', 1.2], // 缩放 1.2 倍\n  ['r', Math.PI / 4], // 旋转 45 度\n]);\n",paraId:6,tocIndex:1},{value:"实例的相对位移方法。",paraId:7,tocIndex:2},{value:"实例的相对位移方法。",paraId:8,tocIndex:3},{value:"根据旋转弧度值对图形进行旋转。",paraId:9,tocIndex:4},{value:"对图形进行缩放。",paraId:10,tocIndex:5},{value:"清除图形实例的所有变换效果。",paraId:11,tocIndex:6},{value:"获取应用到实例上的所有变换的矩阵。",paraId:12,tocIndex:7},{value:"在 G6 3.3 及以上版本中，废弃了 Group / Canvas 上只适用于三阶矩阵的变换函数：",paraId:13,tocIndex:8},{value:"🗑 平移函数 translate；",paraId:14,tocIndex:8},{value:"🗑 移动函数 move；",paraId:14,tocIndex:8},{value:"🗑 缩放函数 scale；",paraId:14,tocIndex:8},{value:"🗑 旋转函数 rotate；",paraId:14,tocIndex:8},{value:"🗑 以 (0, 0) 点为中心的旋转函数 rotateAtStart。",paraId:14,tocIndex:8},{value:"在 G6 3.3 版本中要应用矩阵变换的效果，需要手动设置矩阵的值：",paraId:15,tocIndex:8},{value:"获取当前矩阵：getMatrix()；",paraId:16,tocIndex:8},{value:"设置矩阵：setMatrix(matrix) 或 attr('matrix', matrix)；",paraId:16,tocIndex:8},{value:"重置矩阵：resetMatrix()。",paraId:16,tocIndex:8},{value:"为了方面使用，我们提供了矩阵变换的工具方法：",paraId:17,tocIndex:8},{value:"import { ext } from '@antv/matrix-util';\n\nconst transform = ext.transform;\n\n// 3*3 矩阵变换，用于二维渲染\ntransform(m, [\n  ['t', 100, 50], // translate (100, 50)\n  ['r', Math.PI], // rotate Math.PI\n  ['s', 2, 2], // scale 2 times at x-axis and y-axis\n]);\n",paraId:18,tocIndex:8},{value:"以下方法实现了在自定义节点 example 中增加一个矩形，并将该矩形位移 ",paraId:19,tocIndex:9},{value:"(100, 50)",paraId:19,tocIndex:9},{value:" 后，旋转 ",paraId:19,tocIndex:9},{value:"Math.PI / 4",paraId:19,tocIndex:9},{value:"，最后在 x 方向放大 2 倍，并在 y 方向缩小 2 倍：",paraId:19,tocIndex:9},{value:"import { ext } from '@antv/matrix-util';\n\nconst transform = ext.transform;\n\nG6.registerNode('example', {\n  drawShape: (cfg, group) => {\n    const rect = group.addShape('rect', {\n      attrs: {\n        width: 100,\n        height: 100,\n        x: 100,\n        y: 100,\n        fill: '#9EC9FF',\n        stroke: '#5B8FF9',\n        lineWidth: 3,\n      },\n      // 在 G6 3.3 及之后的版本中，必须指定 name，可以是任意字符串，但需要在同一个自定义元素类型中保持唯一性\n      name: 'rect-shape',\n      draggable: true,\n    });\n    let matrix = rect.getMatrix();\n\n    // 图形或分组的初始矩阵时 null，为了避免变换一个 null 矩阵，需要将其初始化为单位矩阵\n    if (!matrix) matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n    // 3*3 矩阵变换，用于二维渲染\n    const newMatrix = transform(matrix, [\n      ['t', 100, 50], // translate\n      ['r', Math.PI / 4], // rotate\n      ['s', 2, 0.5], // scale\n    ]);\n\n    rect.setMatrix(newMatrix);\n  },\n});\n",paraId:20,tocIndex:9}]},34663:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"中文字“图”在大家的传统认知里指的是图画、图像，而图论与可视化中的“图”—— Graph 则有着更精确的定位：主体（objects）与关系（relationships）的组成。它甚至不局限于视觉，主体与关系的数据也可以称为图。",paraId:0,tocIndex:0},{value:"—— 摘自 ",paraId:1,tocIndex:0},{value:"AntV 专栏",paraId:1,tocIndex:0},{value:"文章：",paraId:1,tocIndex:0},{value:"Graph Visualization · 知多少 之 《HelloWorld 图可视化》",paraId:1,tocIndex:0},{value:"。",paraId:1,tocIndex:0},{value:"在 G6 中，Graph 对象是图的载体，它包含了图上的所有元素（节点、边等），同时挂载了图的相关操作（如交互监听、元素操作、渲染等）。",paraId:2,tocIndex:0},{value:"Graph 对象的生命周期为：初始化 —> 加载数据 —> 渲染 —> 更新 —> 销毁。",paraId:2,tocIndex:0},{value:"在 ",paraId:3,tocIndex:0},{value:"快速上手",paraId:4,tocIndex:0},{value:" 中，我们简单介绍了 初始化、加载数据、渲染图 的使用方法。本文将主要介绍初始化/实例化图。",paraId:3,tocIndex:0},{value:"本文的讲解将会基于下面这份内嵌 JavaScript 的 HTML 代码。该代码通过定义数据、实例化图、读取数据、渲染图等操作中完成了下图中简单的图：",paraId:5,tocIndex:1},{value:" ",paraId:5,tocIndex:1},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    /* 图的画布容器 */\n    <div id=\"mountNode\"></div>\n    /* 引入 G6 */\n    <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script>\n    <script>\n      // 定义数据源\n      const data = {\n        // 点集\n        nodes: [\n          {\n            id: 'node1',\n            x: 100,\n            y: 200,\n          },\n          {\n            id: 'node2',\n            x: 300,\n            y: 200,\n          },\n        ],\n        // 边集\n        edges: [\n          // 表示一条从 node1 节点连接到 node2 节点的边\n          {\n            source: 'node1',\n            target: 'node2',\n          },\n        ],\n      };\n\n      // 创建 G6 图实例\n      const graph = new G6.Graph({\n        container: 'mountNode', // 指定图画布的容器 id，与第 9 行的容器对应\n        // 画布宽高\n        width: 800,\n        height: 500,\n      });\n      // 读取数据\n      graph.data(data);\n      // 渲染图\n      graph.render();\n    <\/script>\n  </body>\n</html>\n",paraId:6,tocIndex:1},{value:"通过  ",paraId:7,tocIndex:2},{value:"new G6.Graph(config)",paraId:7,tocIndex:2},{value:" 进行图的实例化。其中参数  ",paraId:7,tocIndex:2},{value:"config",paraId:7,tocIndex:2},{value:" 是 Object 类型的图的配置项，图的大部分功能可以通过该配置项进行全局配置。如 ",paraId:7,tocIndex:2},{value:"前提代码",paraId:8,tocIndex:2},{value:" 这样实例化图：",paraId:7,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode', // 指定图画布的容器 id，与第 9 行的容器对应\n  // 画布宽高\n  width: 800,\n  height: 500,\n});\n",paraId:9,tocIndex:2},{value:"上面代码中实例化 Graph 的部分使用了三个必要的配置项：",paraId:10,tocIndex:3},{value:"container",paraId:11,tocIndex:3},{value:"类型：String | Object。图的 DOM 容器。可以是 String，为 DOM 容器的 ",paraId:12,tocIndex:3},{value:"id",paraId:12,tocIndex:3},{value:"。也可以是 Object ，为 DOM 对象。",paraId:12,tocIndex:3},{value:"width",paraId:13,tocIndex:3},{value:"、",paraId:13,tocIndex:3},{value:"height",paraId:13,tocIndex:3},{value:"类型：Number。图的画布的宽度和高度。",paraId:14,tocIndex:3},{value:"下面列举实例化图时常见的配置项，完整的配置项参见 ",paraId:15,tocIndex:4},{value:"Graph API",paraId:16,tocIndex:4},{value:"。",paraId:15,tocIndex:4},{value:"renderer",paraId:17,tocIndex:5},{value:"类型：String；默认：'canvas'，可选项：'canvas' / 'svg' 。配置使用 canvas 或 svg 渲染，",paraId:18,tocIndex:5},{value:"除 V3.3.x 外其他版本均支持。",paraId:18,tocIndex:5},{value:" G6 默认使用 Canvas 渲染图， SVG 渲染也支持 Canvas 的所有功能。需要注意的是，我们都知道 SVG 的性能较差，在大规模数据或图元的情况下请谨慎选择。SVG 除支持内置的所有节点/边类型以及自定义节点/边时使用与 Canvas 相同的图形外，还支持在自定义节点/边时使用 ",paraId:18,tocIndex:5},{value:"'dom'",paraId:18,tocIndex:5},{value:" 图形，详见 ",paraId:18,tocIndex:5},{value:"使用 DOM 自定义节点",paraId:19,tocIndex:5},{value:"。",paraId:18,tocIndex:5},{value:"fitView",paraId:20,tocIndex:6},{value:"类型：Boolean；默认：'false'。图是否自适应画布。",paraId:21,tocIndex:6},{value:"fitViewPadding",paraId:22,tocIndex:6},{value:"类型：Number | Array；默认：0。图自适应画布时的四周留白像素值。",paraId:23,tocIndex:6},{value:"fitView",paraId:23,tocIndex:6},{value:" 为 ",paraId:23,tocIndex:6},{value:"true",paraId:23,tocIndex:6},{value:" 时生效。",paraId:23,tocIndex:6},{value:"fitCenter",paraId:24,tocIndex:6},{value:"类型：Boolean；默认：'false'。是否平移图使其中心对齐到画布中心。",paraId:25,tocIndex:6},{value:"v3.5.1 后支持。",paraId:25,tocIndex:6},{value:"defaultNode",paraId:26,tocIndex:7},{value:"类型：Object。默认情况下全局节点的配置项，包括样式属性和其他属性。详见 ",paraId:27,tocIndex:7},{value:"内置节点",paraId:28,tocIndex:7},{value:" 教程。",paraId:27,tocIndex:7},{value:"defaultEdge",paraId:29,tocIndex:7},{value:"类型：Object。默认情况下全局边的配置项，包括样式属性和其他属性。详见 ",paraId:30,tocIndex:7},{value:"内置边",paraId:31,tocIndex:7},{value:" 教程。",paraId:30,tocIndex:7},{value:"nodeStateStyles",paraId:32,tocIndex:7},{value:"类型：Object。除默认状态外的其他状态下节点的样式配置。详见 ",paraId:33,tocIndex:7},{value:"状态 State",paraId:34,tocIndex:7},{value:" 教程。",paraId:33,tocIndex:7},{value:"edgeStateStyles",paraId:35,tocIndex:7},{value:"类型：Object。除默认状态外的其他状态下边的样式配置。详见  ",paraId:36,tocIndex:7},{value:"状态 State",paraId:37,tocIndex:7},{value:" 教程。",paraId:36,tocIndex:7},{value:"layout",paraId:38,tocIndex:8},{value:"类型：Object。若数据中不存在节点位置，则默认为随机布局。配置布局类型及其参数。详见 ",paraId:39,tocIndex:8},{value:"使用布局 Layout",paraId:40,tocIndex:8},{value:" 教程，",paraId:39,tocIndex:8},{value:"图布局 API",paraId:41,tocIndex:8},{value:" 或 ",paraId:39,tocIndex:8},{value:"树图布局 API",paraId:42,tocIndex:8},{value:"。",paraId:39,tocIndex:8},{value:"modes",paraId:43,tocIndex:9},{value:"类型：Array。配置多种交互模式及其包含的交互事件的。详见 ",paraId:44,tocIndex:9},{value:"交互模式 Mode",paraId:45,tocIndex:9},{value:"。",paraId:44,tocIndex:9},{value:"animate",paraId:46,tocIndex:10},{value:"类型：Boolean；默认：'false'。是否启用全局动画。启用后，布局变化时将会以动画形式变换节点位置。",paraId:47,tocIndex:10},{value:"animateCfg",paraId:48,tocIndex:10},{value:"类型：Object。全局动画的配置项，包括动画效果、动画时长等。详见 ",paraId:49,tocIndex:10},{value:"动画 Animation",paraId:50,tocIndex:10},{value:"。",paraId:49,tocIndex:10},{value:"plugins",paraId:51,tocIndex:11},{value:"类型：Array。配置辅助插件。详见 ",paraId:52,tocIndex:11},{value:"插件与工具",paraId:53,tocIndex:11},{value:"。",paraId:52,tocIndex:11},{value:"在前面的代码中使用了两个必要的函数：",paraId:54,tocIndex:12},{value:"// 读取数据\ngraph.data(data);\n// 渲染图\ngraph.render();\n",paraId:55,tocIndex:12},{value:"data(data)",paraId:56,tocIndex:12},{value:"：读取数据源 ",paraId:56,tocIndex:12},{value:"data",paraId:56,tocIndex:12},{value:" 到图实例 ",paraId:56,tocIndex:12},{value:"graph",paraId:56,tocIndex:12},{value:" 中。",paraId:56,tocIndex:12},{value:"render()：渲染图。",paraId:56,tocIndex:12},{value:"Graph 的完整函数参见 ",paraId:57,tocIndex:12},{value:"Graph API",paraId:58,tocIndex:12},{value:"。",paraId:57,tocIndex:12}]},32590:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图可视分析应用中，如何选择合适的布局让每次查询的数据都能够很清晰地展示是一个不小的挑战，虽然我们可以像 Gephi 一样，把布局的配置切换交给用户来做，让用户自己切换布局、调整参数来选择合适的布局，但这样的效率显然太低。为了彻底解决布局选择的问题，G6 提供了智能布局预测的能力，预测引擎会根据查询到的数据，推荐最适合的布局，用户直接使用推荐的布局即可。",paraId:0,tocIndex:0},{value:"智能布局是指在结合神经网络进行建模，通过大量的标注数据（标记布局分类）进行训练输出预测模型，业务场景中针对通过模型对真实的图数据进行预测，从而推荐出该数据最适合的布局分类的方法。",paraId:1,tocIndex:1},{value:"@antv/vis-predict-engine 定位为可视化预测引擎，短期内主要用于图布局的分类预测。常久来看，可视化预测引擎会支持布局配置参数预测、节点类别预测、chart 类别预测等。",paraId:2,tocIndex:2},{value:"G6 中图布局预测的整体流程如下图所示。",paraId:3,tocIndex:2},{value:"AntV 团队将图布局预测的能力封装成 NPM 包 @antv/vis-predict-engine，通过 predict 方法来预测提供的数据应该使用什么布局，基本用法如下。",paraId:4,tocIndex:3},{value:"import G6 from '@antv/g6'\nimport { GraphLayoutPredict } from '@antv/vis-predict-engine'\nconst data = {\n    nodes: [],\n  edges: []\n}\n// predictLayout 表示预测的布局，如 force 或 radial\n// confidence 表示预测的可信度\nconst { predictLayout, confidence } = await GraphLayoutPredict.predict(data);\nconst graph = new G6.Graph({\n  // 省略其他配置\n    layout: {\n    type: predictLayout\n  }\n})\n",paraId:5,tocIndex:3},{value:'如下图所示，在一份医疗健康图谱中，通过智能布局预测引擎得出 "Force" 的布局效果最佳，通过对比实验，也符合预期。',paraId:6,tocIndex:4},{value:"具体 Demo 参考这里：",paraId:7,tocIndex:5},{value:"AI 智能布局推荐 DEMO",paraId:8,tocIndex:5}]},93766:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了一般图和树图的一些常用布局，使用方式参见：中级教程  ",paraId:0},{value:"一般图布局 Layout",paraId:1},{value:"，",paraId:0},{value:"树图布局 Layout",paraId:2},{value:"，",paraId:0},{value:"图布局 API",paraId:3},{value:" 或 ",paraId:0},{value:"树图布局 API",paraId:4},{value:"。当这些内置布局无法满足需求时，G6 还提供了一般图的自定义布局的机制，方便用户进行更定制化的扩展。",paraId:0},{value:"   ",paraId:5},{value:"⚠️ 注意:",paraId:5},{value:" 树图暂时不支持自定义布局。",paraId:5},{value:"本文将会通过自定义 Bigraph 布局的例子讲解自定义布局。",paraId:6},{value:"G6 中自定义布局的 API 如下：",paraId:7,tocIndex:0},{value:"/**\n * 注册布局的方法\n * @param {string} type 布局类型，外部引用指定必须，不要与已有布局类型重名\n * @param {object} layout 布局方法\n */\nLayout.registerLayout = function(type, {\n  /**\n   * 定义自定义行为的默认参数，会与用户传入的参数进行合并\n   */\n  getDefaultCfg() {\n    return {};\n  },\n  /**\n   * 初始化\n   * @param {object} data 数据\n   */\n  init(data) {},\n  /**\n   * 执行布局\n   */\n  execute() {},\n  /**\n   * 根据传入的数据进行布局\n   * @param {object} data 数据\n   */\n  layout(data) {},\n  /**\n   * 更新布局配置，但不执行布局\n   * @param {object} cfg 需要更新的配置项\n   */\n  updateCfg(cfg) {},\n  /**\n   * 销毁\n   */\n  destroy() {},\n});\n",paraId:8,tocIndex:0},{value:"下面，我们将讲解如何自定义布局如下图的二分图 Bigraph。二分图只存在两部分节点之间的边，同属于一个部分的节点之间没有边。我们希望布局能够对两部分节点分别进行排序，减少边的交叉。",paraId:9,tocIndex:1},{value:"该二分图数据如下，节点根据 ",paraId:10,tocIndex:1},{value:"cluster",paraId:10,tocIndex:1},{value:" 字段分为 了 ",paraId:10,tocIndex:1},{value:"'part1'",paraId:10,tocIndex:1},{value:" 和 ",paraId:10,tocIndex:1},{value:"'part2'",paraId:10,tocIndex:1},{value:"，代表二分图的两部分。",paraId:10,tocIndex:1},{value:"const data = {\n  nodes: [\n    { id: '0', label: 'A', cluster: 'part1' },\n    { id: '1', label: 'B', cluster: 'part1' },\n    { id: '2', label: 'C', cluster: 'part1' },\n    { id: '3', label: 'D', cluster: 'part1' },\n    { id: '4', label: 'E', cluster: 'part1' },\n    { id: '5', label: 'F', cluster: 'part1' },\n    { id: '6', label: 'a', cluster: 'part2' },\n    { id: '7', label: 'b', cluster: 'part2' },\n    { id: '8', label: 'c', cluster: 'part2' },\n    { id: '9', label: 'd', cluster: 'part2' },\n  ],\n  edges: [\n    { source: '0', target: '6' },\n    { source: '0', target: '7' },\n    { source: '0', target: '9' },\n    { source: '1', target: '6' },\n    { source: '1', target: '9' },\n    { source: '1', target: '7' },\n    { source: '2', target: '8' },\n    { source: '2', target: '9' },\n    { source: '2', target: '6' },\n    { source: '3', target: '8' },\n    { source: '4', target: '6' },\n    { source: '4', target: '7' },\n    { source: '5', target: '9' },\n  ],\n};\n",paraId:11,tocIndex:1},{value:"为了减少边的交叉，可以通过排序，将 ",paraId:12,tocIndex:2},{value:"'part1'",paraId:12,tocIndex:2},{value:"  的节点 A 对齐到所有与 A 相连的 ",paraId:12,tocIndex:2},{value:"'part2'",paraId:12,tocIndex:2},{value:" 中的节点的平均中心；同样将 ",paraId:12,tocIndex:2},{value:"'part2'",paraId:12,tocIndex:2},{value:" 中的节点 a 对齐到所有与 a 相连的 ",paraId:12,tocIndex:2},{value:"'part1'",paraId:12,tocIndex:2},{value:" 中的节点的平均中心。可以描述成如下过程：",paraId:12,tocIndex:2},{value:"Step 1：为  ",paraId:13,tocIndex:2},{value:"'part1'",paraId:13,tocIndex:2},{value:"  和  ",paraId:13,tocIndex:2},{value:"'part2'",paraId:13,tocIndex:2},{value:"  的节点初始化随机序号 index，都分别从 0 开始；",paraId:13,tocIndex:2},{value:"Step 2：遍历  ",paraId:13,tocIndex:2},{value:"'part1'",paraId:13,tocIndex:2},{value:" 的节点，对每一个节点 A：\n",paraId:13,tocIndex:2},{value:"找到与 A 相连的属于  ",paraId:14,tocIndex:2},{value:"'part2'",paraId:14,tocIndex:2},{value:"  的节点的集合 ",paraId:14,tocIndex:2},{value:"，加和  ",paraId:14,tocIndex:2},{value:" 中所有节点的 index，并除以 ",paraId:14,tocIndex:2},{value:" 的元素个数，得数覆盖 A 的 index 值：",paraId:14,tocIndex:2},{value:"Step 3：遍历  ",paraId:13,tocIndex:2},{value:"'part2'",paraId:13,tocIndex:2},{value:" 的节点，对每一个节点 B（与  Step 2 相似）：\n",paraId:13,tocIndex:2},{value:"找到与 B 相连的属于  ",paraId:15,tocIndex:2},{value:"'part1'",paraId:15,tocIndex:2},{value:"  的节点的集合 ",paraId:15,tocIndex:2},{value:"，加和  ",paraId:15,tocIndex:2},{value:"  中所有节点的 index，并除以 ",paraId:15,tocIndex:2},{value:"  的元素个数，得数覆盖 B 的 index 值：",paraId:15,tocIndex:2},{value:"Step 4：两部分节点分别按照节点的序号 index 进行排序，最终按照节点顺序安排节点位置。",paraId:13,tocIndex:2},{value:"下面代码展示了自定义名为  ",paraId:16,tocIndex:3},{value:"'bigraph-layout'",paraId:16,tocIndex:3},{value:" 的二分图布局，完整代码参见：",paraId:16,tocIndex:3},{value:"自定义布局-二分图",paraId:16,tocIndex:3},{value:"。使用该布局的方式与使用内置布局方式相同，都是在实例化图时将其配置到 ",paraId:16,tocIndex:3},{value:"layout",paraId:16,tocIndex:3},{value:" 配置项中，详见：",paraId:16,tocIndex:3},{value:"一般图布局",paraId:17,tocIndex:3},{value:"。",paraId:16,tocIndex:3},{value:"G6.registerLayout('bigraph-layout', {\n  // 默认参数\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      center: [0, 0], // 布局的中心\n      biSep: 100, // 两部分的间距\n      nodeSep: 20, // 同一部分的节点间距\n      direction: 'horizontal', // 两部分的分布方向\n      nodeSize: 20, // 节点大小\n    };\n  },\n  // 执行布局\n  execute: function execute() {\n    var self = this;\n    var center = self.center;\n    var biSep = self.biSep;\n    var nodeSep = self.nodeSep;\n    var nodeSize = self.nodeSize;\n    var part1Pos = 0,\n      part2Pos = 0;\n    // 若指定为横向分布\n    if (self.direction === 'horizontal') {\n      part1Pos = center[0] - biSep / 2;\n      part2Pos = center[0] + biSep / 2;\n    }\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var part1Nodes = [];\n    var part2Nodes = [];\n    var part1NodeMap = new Map();\n    var part2NodeMap = new Map();\n    // separate the nodes and init the positions\n    nodes.forEach(function (node, i) {\n      if (node.cluster === 'part1') {\n        part1Nodes.push(node);\n        part1NodeMap.set(node.id, i);\n      } else {\n        part2Nodes.push(node);\n        part2NodeMap.set(node.id, i);\n      }\n    });\n\n    // 对 part1 的节点进行排序\n    part1Nodes.forEach(function (p1n) {\n      var index = 0;\n      var adjCount = 0;\n      edges.forEach(function (edge) {\n        var sourceId = edge.source;\n        var targetId = edge.target;\n        if (sourceId === p1n.id) {\n          index += part2NodeMap.get(targetId);\n          adjCount++;\n        } else if (targetId === p1n.id) {\n          index += part2NodeMap.get(sourceId);\n          adjCount++;\n        }\n      });\n      index /= adjCount;\n      p1n.index = index;\n    });\n    part1Nodes.sort(function (a, b) {\n      return a.index - b.index;\n    });\n\n    // 对 part2 的节点进行排序\n    part2Nodes.forEach(function (p2n) {\n      var index = 0;\n      var adjCount = 0;\n      edges.forEach(function (edge) {\n        var sourceId = edge.source;\n        var targetId = edge.target;\n        if (sourceId === p2n.id) {\n          index += part1NodeMap.get(targetId);\n          adjCount++;\n        } else if (targetId === p2n.id) {\n          index += part1NodeMap.get(sourceId);\n          adjCount++;\n        }\n      });\n      index /= adjCount;\n      p2n.index = index;\n    });\n    part2Nodes.sort(function (a, b) {\n      return a.index - b.index;\n    });\n\n    // 放置节点\n    var hLength = part1Nodes.length > part2Nodes.length ? part1Nodes.length : part2Nodes.length;\n    var height = hLength * (nodeSep + nodeSize);\n    var begin = center[1] - height / 2;\n    if (self.direction === 'vertical') {\n      begin = center[0] - height / 2;\n    }\n    part1Nodes.forEach(function (p1n, i) {\n      if (self.direction === 'horizontal') {\n        p1n.x = part1Pos;\n        p1n.y = begin + i * (nodeSep + nodeSize);\n      } else {\n        p1n.x = begin + i * (nodeSep + nodeSize);\n        p1n.y = part1Pos;\n      }\n    });\n    part2Nodes.forEach(function (p2n, i) {\n      if (self.direction === 'horizontal') {\n        p2n.x = part2Pos;\n        p2n.y = begin + i * (nodeSep + nodeSize);\n      } else {\n        p2n.x = begin + i * (nodeSep + nodeSize);\n        p2n.y = part2Pos;\n      }\n    });\n  },\n});\n",paraId:18,tocIndex:3}]},53178:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图布局是指图中节点的排布方式，根据图的数据结构不同，布局可以分为两类：一般图布局、树图布局。G6 为这两类图都内置了一些常用的图布局算法。使用内置的图布局可以完成",paraId:0,tocIndex:0},{value:"布局的参数、方法、数据的切换",paraId:1,tocIndex:0},{value:"等。G6 还提供了一般图布局的 ",paraId:0,tocIndex:0},{value:"Web-Worker 机制",paraId:2,tocIndex:0},{value:"，在大规模图布局中使用该机制可以使布局计算不阻塞页面。",paraId:0,tocIndex:0},{value:"除了内置布局方法外，一般图布局还支持 ",paraId:3,tocIndex:0},{value:"自定义布局",paraId:4,tocIndex:0},{value:" 机制。",paraId:3,tocIndex:0},{value:"事实上，G6 的布局是自由的，内置布局算法仅仅是操作了数据中节点的 ",paraId:5,tocIndex:0},{value:"x",paraId:5,tocIndex:0},{value:" 和 ",paraId:5,tocIndex:0},{value:"y",paraId:5,tocIndex:0},{value:" 值。因此，除了使用内置布局以及自定义的一般图布局外，用户还可以使用外部图布局算法，计算节点位置后赋值到数据中节点的 ",paraId:5,tocIndex:0},{value:"x",paraId:5,tocIndex:0},{value:" 和 ",paraId:5,tocIndex:0},{value:"y",paraId:5,tocIndex:0},{value:" 字段上，G6 便可以根据该位置信息进行绘制。",paraId:5,tocIndex:0},{value:"本文将逐一介绍内置的布局算法，及其使用方式。",paraId:6,tocIndex:0},{value:"Random Layout",paraId:7,tocIndex:1},{value:"：随机布局；",paraId:8,tocIndex:1},{value:"Force2 Layout",paraId:9,tocIndex:1},{value:"：G6 4.7.0 后支持力导向布局，与 gForce 相比性能更强；",paraId:8,tocIndex:1},{value:"GForce Layout",paraId:10,tocIndex:1},{value:"：G6 4.0 支持的经典力导向布局，支持 GPU 并行计算；",paraId:8,tocIndex:1},{value:"Force Layout",paraId:11,tocIndex:1},{value:"：引用 d3 的经典力导向布局；",paraId:8,tocIndex:1},{value:"Fruchterman Layout",paraId:12,tocIndex:1},{value:"：Fruchterman 布局，一种力导布局；",paraId:8,tocIndex:1},{value:"Circular Layout",paraId:13,tocIndex:1},{value:"：环形布局；",paraId:8,tocIndex:1},{value:"Radial Layout",paraId:14,tocIndex:1},{value:"：辐射状布局；",paraId:8,tocIndex:1},{value:"MDS Layout",paraId:15,tocIndex:1},{value:"：高维数据降维算法布局；",paraId:8,tocIndex:1},{value:"Dagre Layout",paraId:16,tocIndex:1},{value:"：层次布局；",paraId:8,tocIndex:1},{value:"Concentric Layout",paraId:17,tocIndex:1},{value:"：同心圆布局；",paraId:8,tocIndex:1},{value:"Grid Layout",paraId:18,tocIndex:1},{value:"：网格布局；",paraId:8,tocIndex:1},{value:"Combo Force Layout",paraId:19,tocIndex:1},{value:"：*V3.5 新增。*适用于带有 combo 图的力导向布局，推荐有 combo 的图使用该布局。",paraId:8,tocIndex:1},{value:"Combo Combined Layout",paraId:20,tocIndex:1},{value:"：*V4.6 新增。*适用于带有 combo 的图，可自由组合内外布局，默认情况下可以有较好的效果，推荐有 combo 的图使用该布局。",paraId:8,tocIndex:1},{value:"用户可以通过在实例化图时使用图的配置项 ",paraId:21,tocIndex:2},{value:"layout",paraId:21,tocIndex:2},{value:" 指定布局方法。下面代码在实例化图时设置了布局方法为 ",paraId:21,tocIndex:2},{value:"type: 'force'",paraId:21,tocIndex:2},{value:"，即经典力导向图布局。并设置了参数 ",paraId:21,tocIndex:2},{value:"preventOverlap: true",paraId:21,tocIndex:2},{value:"  和 ",paraId:21,tocIndex:2},{value:"nodeSize: 30",paraId:21,tocIndex:2},{value:"，表示希望节点不重叠。节点大小 ",paraId:21,tocIndex:2},{value:"nodeSize",paraId:21,tocIndex:2},{value:" 用于算法中判断节点是否重叠，更多配置项见各布局的配置项。",paraId:21,tocIndex:2},{value:"const graph = new G6.Graph({\n  // ...                      // 其他配置项\n  layout: {\n    // Object，可选，布局的方法及其配置项，默认为 random 布局。\n    type: 'force',\n    preventOverlap: true,\n    nodeSize: 30,\n    // workerEnabled: true, // 是否启用 webworker\n    // gpuEnabled: true // 是否使用 gpu 版本的布局算法，G6 4.0 支持，目前仅支持 gForce 及 fruchterman\n    // ...                    // 其他配置\n  },\n});\n",paraId:22,tocIndex:2},{value:"除了每种布局方法各自的配置项外，所有布局方法都可以在上面代码的 ",paraId:23,tocIndex:2},{value:"layout",paraId:23,tocIndex:2},{value:" 中配置 ",paraId:23,tocIndex:2},{value:"workerEnabled: true",paraId:23,tocIndex:2},{value:" 以开启布局的 web-worker 机制。开启后图的布局计算过程将不会阻塞页面。",paraId:23,tocIndex:2},{value:"当实例化图时没有配置布局时：",paraId:24,tocIndex:2},{value:"若数据中节点有位置信息（",paraId:25,tocIndex:2},{value:"x",paraId:25,tocIndex:2},{value:" 和 ",paraId:25,tocIndex:2},{value:"y",paraId:25,tocIndex:2},{value:"），则按照数据的位置信息进行绘制；",paraId:25,tocIndex:2},{value:"若数据中节点没有位置信息，则默认使用 Random Layout 进行布局。",paraId:25,tocIndex:2},{value:"图布局通用 API：",paraId:26,tocIndex:3},{value:"Layout API",paraId:27,tocIndex:3},{value:"。",paraId:26,tocIndex:3},{value:"描述",paraId:28,tocIndex:4},{value:"：随机布局。 ",paraId:28,tocIndex:4},{value:"API",paraId:28,tocIndex:4},{value:"：",paraId:28,tocIndex:4},{value:"Random API",paraId:29,tocIndex:4},{value:" ",paraId:28,tocIndex:4},{value:"参数",paraId:28,tocIndex:4},{value:"：",paraId:28,tocIndex:4},{value:"参数名",paraId:30,tocIndex:4},{value:"类型",paraId:30,tocIndex:4},{value:"示例",paraId:30,tocIndex:4},{value:"默认值",paraId:30,tocIndex:4},{value:"说明",paraId:30,tocIndex:4},{value:"center",paraId:30,tocIndex:4},{value:"Array",paraId:30,tocIndex:4},{value:"[ 0, 0 ]",paraId:30,tocIndex:4},{value:"图的中心",paraId:30,tocIndex:4},{value:"布局的中心",paraId:30,tocIndex:4},{value:"width",paraId:30,tocIndex:4},{value:"Number",paraId:30,tocIndex:4},{value:"300",paraId:30,tocIndex:4},{value:"图的宽",paraId:30,tocIndex:4},{value:"height",paraId:30,tocIndex:4},{value:"Number",paraId:30,tocIndex:4},{value:"300",paraId:30,tocIndex:4},{value:"图的高",paraId:30,tocIndex:4},{value:"workerEnabled",paraId:30,tocIndex:4},{value:"Boolean",paraId:30,tocIndex:4},{value:"true / false",paraId:30,tocIndex:4},{value:"false",paraId:30,tocIndex:4},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:30,tocIndex:4},{value:" ",paraId:31,tocIndex:5},{value:"描述",paraId:31,tocIndex:5},{value:"：G6 4.0 支持力导向布局（由 graphin-force 沉淀，性能更强）。能够更加自由地支持设置节点质量、群组中心力等。当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:31,tocIndex:5},{value:"fx",paraId:31,tocIndex:5},{value:" 与 ",paraId:31,tocIndex:5},{value:"fy",paraId:31,tocIndex:5},{value:" 作为固定的坐标。",paraId:31,tocIndex:5},{value:"Force2 布局固定被拖拽节点位置的 Demo",paraId:32,tocIndex:5},{value:"。\n",paraId:31,tocIndex:5},{value:" ",paraId:31,tocIndex:5},{value:"API",paraId:31,tocIndex:5},{value:"：",paraId:31,tocIndex:5},{value:"Force API",paraId:33,tocIndex:5},{value:" ",paraId:31,tocIndex:5},{value:"参数",paraId:31,tocIndex:5},{value:"：",paraId:31,tocIndex:5},{value:"参数名",paraId:34,tocIndex:5},{value:"类型",paraId:34,tocIndex:5},{value:"示例",paraId:34,tocIndex:5},{value:"默认值",paraId:34,tocIndex:5},{value:"说明",paraId:34,tocIndex:5},{value:"center",paraId:34,tocIndex:5},{value:"Array",paraId:34,tocIndex:5},{value:"[ 0, 0 ]",paraId:34,tocIndex:5},{value:"图的中心",paraId:34,tocIndex:5},{value:"布局的中心",paraId:34,tocIndex:5},{value:"animate",paraId:34,tocIndex:5},{value:"boolean",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"是否每次迭代都刷新画布，若为 ",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:" 则将表现出带有动画逐步布局的效果",paraId:34,tocIndex:5},{value:"linkDistance",paraId:34,tocIndex:5},{value:"number / Function",paraId:34,tocIndex:5},{value:"示例 1: 50 ",paraId:34,tocIndex:5},{value:"示例 2:",paraId:34,tocIndex:5},{value:"d => {",paraId:34,tocIndex:5},{value:"  // d 是一条边",paraId:34,tocIndex:5},{value:"  if (d.id === 'edge1') {",paraId:34,tocIndex:5},{value:"    return 100;",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return 50;",paraId:34,tocIndex:5},{value:"}",paraId:34,tocIndex:5},{value:"1",paraId:34,tocIndex:5},{value:"边长。可以使用回调函数的形式对不同对边定义不同边长（如示例 2）",paraId:34,tocIndex:5},{value:"nodeStrength",paraId:34,tocIndex:5},{value:"number / Function",paraId:34,tocIndex:5},{value:"示例 1: -30 ",paraId:34,tocIndex:5},{value:"示例 2:",paraId:34,tocIndex:5},{value:"d => {",paraId:34,tocIndex:5},{value:"  // d 是一个节点",paraId:34,tocIndex:5},{value:"  if (d.id === 'node1') {",paraId:34,tocIndex:5},{value:"    return -100;",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return -30;",paraId:34,tocIndex:5},{value:"} / 1000",paraId:34,tocIndex:5},{value:"1000",paraId:34,tocIndex:5},{value:"节点作用力，正数代表节点之间的斥力作用，负数代表节点之间的引力作用（注意与 'force' 相反）（如示例 2）",paraId:34,tocIndex:5},{value:"edgeStrength",paraId:34,tocIndex:5},{value:"number / Function",paraId:34,tocIndex:5},{value:"示例 1: 1 ",paraId:34,tocIndex:5},{value:"示例 2:",paraId:34,tocIndex:5},{value:"d => {",paraId:34,tocIndex:5},{value:"  // d 是一个节点",paraId:34,tocIndex:5},{value:"  if (d.id === 'node1') {",paraId:34,tocIndex:5},{value:"    return 10;",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return 1;",paraId:34,tocIndex:5},{value:"}",paraId:34,tocIndex:5},{value:"200",paraId:34,tocIndex:5},{value:"边的作用力，默认根据节点的出入度自适应。可以使用回调函数的形式对不同对节点定义不同边作用力（如示例 2）",paraId:34,tocIndex:5},{value:"preventOverlap",paraId:34,tocIndex:5},{value:"Boolean",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"是否防止重叠，必须配合属性 ",paraId:34,tocIndex:5},{value:"nodeSize",paraId:34,tocIndex:5},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:34,tocIndex:5},{value:"nodeSize",paraId:34,tocIndex:5},{value:" 值，才能够进行节点重叠的碰撞检测。若未设置 ",paraId:34,tocIndex:5},{value:"nodeSize",paraId:34,tocIndex:5},{value:" ，则根据节点数据中的 ",paraId:34,tocIndex:5},{value:"size",paraId:34,tocIndex:5},{value:" 进行碰撞检测。若二者都未设置，则默认以 10 为节点大小进行碰撞检测",paraId:34,tocIndex:5},{value:"nodeSize",paraId:34,tocIndex:5},{value:"Array / Number",paraId:34,tocIndex:5},{value:"20",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"节点大小（直径）。用于碰撞检测。",paraId:34,tocIndex:5},{value:"若不指定，则根据传入的数据节点中的 ",paraId:34,tocIndex:5},{value:"size",paraId:34,tocIndex:5},{value:"  字段计算。若即不指定，节点中也没有 ",paraId:34,tocIndex:5},{value:"size",paraId:34,tocIndex:5},{value:"，则默认大小为 10",paraId:34,tocIndex:5},{value:"nodeSpacing",paraId:34,tocIndex:5},{value:"number / Function",paraId:34,tocIndex:5},{value:"示例 1 : 10",paraId:34,tocIndex:5},{value:"示例 2 : ",paraId:34,tocIndex:5},{value:"d => {",paraId:34,tocIndex:5},{value:"  // d 是一个节点",paraId:34,tocIndex:5},{value:"  if (d.id === 'node1') {",paraId:34,tocIndex:5},{value:"    return 100;",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return 10;",paraId:34,tocIndex:5},{value:"}",paraId:34,tocIndex:5},{value:"0",paraId:34,tocIndex:5},{value:"preventOverlap",paraId:34,tocIndex:5},{value:" 为 ",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:" 时生效，防止重叠时节点边缘间距的最小值。可以是回调函数，为不同节点设置不同的最小间距，如示例 2 所示",paraId:34,tocIndex:5},{value:"minMovement",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"0.1",paraId:34,tocIndex:5},{value:"0.5",paraId:34,tocIndex:5},{value:"当一次迭代的平均/最大/最小（根据",paraId:34,tocIndex:5},{value:"distanceThresholdMode",paraId:34,tocIndex:5},{value:"决定）移动长度小于该值时停止迭代。数字越小，布局越收敛，所用时间将越长",paraId:34,tocIndex:5},{value:"distanceThresholdMode",paraId:34,tocIndex:5},{value:"'mean' / 'max' / 'min'",paraId:34,tocIndex:5},{value:"'mean'",paraId:34,tocIndex:5},{value:"'mean'",paraId:34,tocIndex:5},{value:"minMovement",paraId:34,tocIndex:5},{value:" 的使用条件，",paraId:34,tocIndex:5},{value:"'mean'",paraId:34,tocIndex:5},{value:" 代表平均移动距离小于 ",paraId:34,tocIndex:5},{value:"minMovement",paraId:34,tocIndex:5},{value:" 时停止迭代，",paraId:34,tocIndex:5},{value:"'max'",paraId:34,tocIndex:5},{value:" / ",paraId:34,tocIndex:5},{value:"'min'",paraId:34,tocIndex:5},{value:" 代表最大/最小移动距离小于时 ",paraId:34,tocIndex:5},{value:"minMovement",paraId:34,tocIndex:5},{value:" 时停时迭代。默认为 ",paraId:34,tocIndex:5},{value:"'mean'",paraId:34,tocIndex:5},{value:"maxIteration",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"500",paraId:34,tocIndex:5},{value:"1000",paraId:34,tocIndex:5},{value:"最大迭代次数。当迭代次数超过该值，但平均移动长度仍然没有达到 minMovement，也将强制停止迭代",paraId:34,tocIndex:5},{value:"damping",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"0.99",paraId:34,tocIndex:5},{value:"0.9",paraId:34,tocIndex:5},{value:"阻尼系数，取值范围 [0, 1]。数字越大，速度降低得越慢",paraId:34,tocIndex:5},{value:"interval",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"0.05",paraId:34,tocIndex:5},{value:"0.02",paraId:34,tocIndex:5},{value:"控制每个迭代节点的移动速度",paraId:34,tocIndex:5},{value:"factor",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"1",paraId:34,tocIndex:5},{value:"1",paraId:34,tocIndex:5},{value:"斥力系数，数值越大，斥力越大",paraId:34,tocIndex:5},{value:"maxSpeed",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"10",paraId:34,tocIndex:5},{value:"1000",paraId:34,tocIndex:5},{value:"一次迭代的最大移动长度",paraId:34,tocIndex:5},{value:"coulombDisScale",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"0.003",paraId:34,tocIndex:5},{value:"0.005",paraId:34,tocIndex:5},{value:"库伦系数，斥力的一个系数，数字越大，节点之间的斥力越大",paraId:34,tocIndex:5},{value:"getMass",paraId:34,tocIndex:5},{value:"Function",paraId:34,tocIndex:5},{value:"d => {",paraId:34,tocIndex:5},{value:"  // d 是一个节点",paraId:34,tocIndex:5},{value:"  if (d.id === 'node1') {",paraId:34,tocIndex:5},{value:"    return 100;",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return 10;",paraId:34,tocIndex:5},{value:"}",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量。使用方法与 ",paraId:34,tocIndex:5},{value:"nodeSpacing",paraId:34,tocIndex:5},{value:" 类似，每个回调函数返回一个数值作为该节点的质量",paraId:34,tocIndex:5},{value:"getCenter",paraId:34,tocIndex:5},{value:"Function",paraId:34,tocIndex:5},{value:"(d, degree) => {",paraId:34,tocIndex:5},{value:"  // d 是一个节点, degree 为该节点度数",paraId:34,tocIndex:5},{value:"  if (d.degree === 0') {",paraId:34,tocIndex:5},{value:"    return [100, 100, 10]; // x, y, 强度",paraId:34,tocIndex:5},{value:"  }",paraId:34,tocIndex:5},{value:"  return [210, 150, 5]; // x, y, 强度",paraId:34,tocIndex:5},{value:"}",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力",paraId:34,tocIndex:5},{value:"gravity",paraId:34,tocIndex:5},{value:"number",paraId:34,tocIndex:5},{value:"20",paraId:34,tocIndex:5},{value:"10",paraId:34,tocIndex:5},{value:"中心力大小，指所有节点被吸引到 ",paraId:34,tocIndex:5},{value:"center",paraId:34,tocIndex:5},{value:" 的力。数字越大，布局越紧凑",paraId:34,tocIndex:5},{value:"centripetalOptions",paraId:34,tocIndex:5},{value:"CentripetalOptions",paraId:34,tocIndex:5},{value:"见下文",paraId:34,tocIndex:5},{value:"见下文",paraId:34,tocIndex:5},{value:"详细配置见下文。向心力配置，包括叶子节点、离散点、其他节点的向心中心及向心力大小",paraId:34,tocIndex:5},{value:"leafCluster",paraId:34,tocIndex:5},{value:"boolean",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"是否需要叶子结点聚类，若为 ",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:"，则 centripetalOptions.single 将为 100；centripetalOptions.leaf 将使用 ",paraId:34,tocIndex:5},{value:"getClusterNodeStrength",paraId:34,tocIndex:5},{value:" 返回值；getClusterNodeStrength.center 将为叶子节点返回当前所有叶子节点的平均中心",paraId:34,tocIndex:5},{value:"clustering",paraId:34,tocIndex:5},{value:"boolean",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"是否需要全部节点聚类，若为 ",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:"，将使用 ",paraId:34,tocIndex:5},{value:"nodeClusterBy",paraId:34,tocIndex:5},{value:" 配置的节点数据中的字段作为聚类依据。 centripetalOptions.single、centripetalOptions.leaf、centripetalOptions.others 将使用 ",paraId:34,tocIndex:5},{value:"getClusterNodeStrength",paraId:34,tocIndex:5},{value:" 返回值；leaf、centripetalOptions.center 将使用当前节点所属聚类中所有节点的平均中心",paraId:34,tocIndex:5},{value:"nodeClusterBy",paraId:34,tocIndex:5},{value:"string",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"指定节点数据中的字段名称作为节点聚类的依据，",paraId:34,tocIndex:5},{value:"clustering",paraId:34,tocIndex:5},{value:" 为 ",paraId:34,tocIndex:5},{value:"true",paraId:34,tocIndex:5},{value:" 时生效，自动生成 ",paraId:34,tocIndex:5},{value:"centripetalOptions",paraId:34,tocIndex:5},{value:"，可配合 ",paraId:34,tocIndex:5},{value:"clusterNodeStrength",paraId:34,tocIndex:5},{value:" 使用",paraId:34,tocIndex:5},{value:"clusterNodeStrength",paraId:34,tocIndex:5},{value:"number / Function",paraId:34,tocIndex:5},{value:"node => node.weight",paraId:34,tocIndex:5},{value:"20",paraId:34,tocIndex:5},{value:"配合 ",paraId:34,tocIndex:5},{value:"clustering",paraId:34,tocIndex:5},{value:" 和 ",paraId:34,tocIndex:5},{value:"nodeClusterBy",paraId:34,tocIndex:5},{value:" 使用，指定聚类向心力的大小",paraId:34,tocIndex:5},{value:"monitor",paraId:34,tocIndex:5},{value:"(params:{ energy: number, nodes: NodeData[], edges: EdgeData[], iterations: number }) => void",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"每个迭代的监控信息回调，",paraId:34,tocIndex:5},{value:"energy",paraId:34,tocIndex:5},{value:" 表示布局的收敛能量。若配置可能带来额外的计算能量性能消耗，不配置则不计算",paraId:34,tocIndex:5},{value:"onTick",paraId:34,tocIndex:5},{value:"Function",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"每一次迭代的回调函数",paraId:34,tocIndex:5},{value:"onLayoutEnd",paraId:34,tocIndex:5},{value:"Function",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"undefined",paraId:34,tocIndex:5},{value:"布局完成后的回调函数",paraId:34,tocIndex:5},{value:"workerEnabled",paraId:34,tocIndex:5},{value:"Boolean",paraId:34,tocIndex:5},{value:"true / false",paraId:34,tocIndex:5},{value:"false",paraId:34,tocIndex:5},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:34,tocIndex:5},{value:"CentripetalOptions",paraId:35,tocIndex:5},{value:" 类型说明：",paraId:35,tocIndex:5},{value:"参数名",paraId:36,tocIndex:5},{value:"类型",paraId:36,tocIndex:5},{value:"示例",paraId:36,tocIndex:5},{value:"默认值",paraId:36,tocIndex:5},{value:"说明",paraId:36,tocIndex:5},{value:"single",paraId:36,tocIndex:5},{value:"number / Function",paraId:36,tocIndex:5},{value:"2",paraId:36,tocIndex:5},{value:"2,",paraId:36,tocIndex:5},{value:"离散节点（即度数为 0 的节点）受到的向心力大小",paraId:36,tocIndex:5},{value:"leaf",paraId:36,tocIndex:5},{value:"number / Function",paraId:36,tocIndex:5},{value:"2",paraId:36,tocIndex:5},{value:"2",paraId:36,tocIndex:5},{value:"叶子节点（即度数为 1 的节点）受到的向心力大小",paraId:36,tocIndex:5},{value:"others",paraId:36,tocIndex:5},{value:"number / Function",paraId:36,tocIndex:5},{value:"1",paraId:36,tocIndex:5},{value:"1",paraId:36,tocIndex:5},{value:"除离散节点、叶子节点以外的其他节点（即度数 > 1 的节点）受到的向心力大小",paraId:36,tocIndex:5},{value:"center",paraId:36,tocIndex:5},{value:"Function",paraId:36,tocIndex:5},{value:"(node, nodes, edges) => ({ x: 10, y: 10 })",paraId:36,tocIndex:5},{value:"图的中心",paraId:36,tocIndex:5},{value:"向心力发出的位置，可根据节点、边的情况返回不同的值",paraId:36,tocIndex:5},{value:"centripetalOptions",paraId:37,tocIndex:5},{value:" 示例：",paraId:37,tocIndex:5},{value:"centripetalOptions: {\n  // single、leaf、others 的函数形式的参数为当前节点数据、所有节点数据、所有边数据\n  single: (node, nodes, edges) => node.field1 || 1,\n  leaf: (node, nodes, edges) => node.field2 || 1,\n  others: (node, nodes, edges) => node.field3|| 1,\n  // 参数为当前节点数据、所有节点数据、所有边数据、画布宽度、画布高度\n  center: (node, nodes, edges, width, height) => {\n    if (node.field4) return { x: width / 2, y: height / 2 };\n    if (node.field5) return { x: node.field6, y: node.field7 };\n    // ...\n  }\n}\n",paraId:38,tocIndex:5},{value:" ",paraId:39,tocIndex:6},{value:"描述",paraId:39,tocIndex:6},{value:"：G6 4.0 支持的经典力导向布局。能够更加自由地支持设置节点质量、群组中心力等。更重要的是，它支持 GPU 并行计算。当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:39,tocIndex:6},{value:"fx",paraId:39,tocIndex:6},{value:" 与 ",paraId:39,tocIndex:6},{value:"fy",paraId:39,tocIndex:6},{value:" 作为固定的坐标。",paraId:39,tocIndex:6},{value:"GForce 布局固定被拖拽节点位置的 Demo",paraId:40,tocIndex:6},{value:"。\n",paraId:39,tocIndex:6},{value:" ",paraId:39,tocIndex:6},{value:"API",paraId:39,tocIndex:6},{value:"：",paraId:39,tocIndex:6},{value:"Force API",paraId:41,tocIndex:6},{value:" ",paraId:39,tocIndex:6},{value:"参数",paraId:39,tocIndex:6},{value:"：",paraId:39,tocIndex:6},{value:"参数名",paraId:42,tocIndex:6},{value:"类型",paraId:42,tocIndex:6},{value:"示例",paraId:42,tocIndex:6},{value:"默认值",paraId:42,tocIndex:6},{value:"说明",paraId:42,tocIndex:6},{value:"center",paraId:42,tocIndex:6},{value:"Array",paraId:42,tocIndex:6},{value:"[ 0, 0 ]",paraId:42,tocIndex:6},{value:"图的中心",paraId:42,tocIndex:6},{value:"布局的中心",paraId:42,tocIndex:6},{value:"linkDistance",paraId:42,tocIndex:6},{value:"Number / Function",paraId:42,tocIndex:6},{value:"示例 1: 50 ",paraId:42,tocIndex:6},{value:"示例 2:",paraId:42,tocIndex:6},{value:"d => {",paraId:42,tocIndex:6},{value:"  // d 是一条边",paraId:42,tocIndex:6},{value:"  if (d.id === 'edge1') {",paraId:42,tocIndex:6},{value:"    return 100;",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return 50;",paraId:42,tocIndex:6},{value:"}",paraId:42,tocIndex:6},{value:"1",paraId:42,tocIndex:6},{value:"边长。可以使用回调函数的形式对不同对边定义不同边长（如示例 2）",paraId:42,tocIndex:6},{value:"nodeStrength",paraId:42,tocIndex:6},{value:"Number / Function",paraId:42,tocIndex:6},{value:"示例 1: -30 ",paraId:42,tocIndex:6},{value:"示例 2:",paraId:42,tocIndex:6},{value:"d => {",paraId:42,tocIndex:6},{value:"  // d 是一个节点",paraId:42,tocIndex:6},{value:"  if (d.id === 'node1') {",paraId:42,tocIndex:6},{value:"    return -100;",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return -30;",paraId:42,tocIndex:6},{value:"} / 1000",paraId:42,tocIndex:6},{value:"1000",paraId:42,tocIndex:6},{value:"节点作用力，正数代表节点之间的斥力作用，负数代表节点之间的引力作用（注意与 'force' 相反）（如示例 2）",paraId:42,tocIndex:6},{value:"edgeStrength",paraId:42,tocIndex:6},{value:"Number / Function",paraId:42,tocIndex:6},{value:"示例 1: 1 ",paraId:42,tocIndex:6},{value:"示例 2:",paraId:42,tocIndex:6},{value:"d => {",paraId:42,tocIndex:6},{value:"  // d 是一个节点",paraId:42,tocIndex:6},{value:"  if (d.id === 'node1') {",paraId:42,tocIndex:6},{value:"    return 10;",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return 1;",paraId:42,tocIndex:6},{value:"}",paraId:42,tocIndex:6},{value:"200",paraId:42,tocIndex:6},{value:"边的作用力，默认根据节点的出入度自适应。可以使用回调函数的形式对不同对节点定义不同边作用力（如示例 2）",paraId:42,tocIndex:6},{value:"preventOverlap",paraId:42,tocIndex:6},{value:"Boolean",paraId:42,tocIndex:6},{value:"false",paraId:42,tocIndex:6},{value:"false",paraId:42,tocIndex:6},{value:"是否防止重叠，必须配合属性 ",paraId:42,tocIndex:6},{value:"nodeSize",paraId:42,tocIndex:6},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:42,tocIndex:6},{value:"nodeSize",paraId:42,tocIndex:6},{value:" 值，才能够进行节点重叠的碰撞检测。若未设置 ",paraId:42,tocIndex:6},{value:"nodeSize",paraId:42,tocIndex:6},{value:" ，则根据节点数据中的 ",paraId:42,tocIndex:6},{value:"size",paraId:42,tocIndex:6},{value:" 进行碰撞检测。若二者都未设置，则默认以 10 为节点大小进行碰撞检测",paraId:42,tocIndex:6},{value:"nodeSize",paraId:42,tocIndex:6},{value:"Array / Number",paraId:42,tocIndex:6},{value:"20",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"节点大小（直径）。用于碰撞检测。",paraId:42,tocIndex:6},{value:"若不指定，则根据传入的数据节点中的 ",paraId:42,tocIndex:6},{value:"size",paraId:42,tocIndex:6},{value:"  字段计算。若即不指定，节点中也没有 ",paraId:42,tocIndex:6},{value:"size",paraId:42,tocIndex:6},{value:"，则默认大小为 10",paraId:42,tocIndex:6},{value:"nodeSpacing",paraId:42,tocIndex:6},{value:"Number / Function",paraId:42,tocIndex:6},{value:"示例 1 : 10",paraId:42,tocIndex:6},{value:"示例 2 : ",paraId:42,tocIndex:6},{value:"d => {",paraId:42,tocIndex:6},{value:"  // d 是一个节点",paraId:42,tocIndex:6},{value:"  if (d.id === 'node1') {",paraId:42,tocIndex:6},{value:"    return 100;",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return 10;",paraId:42,tocIndex:6},{value:"}",paraId:42,tocIndex:6},{value:"0",paraId:42,tocIndex:6},{value:"preventOverlap",paraId:42,tocIndex:6},{value:" 为 ",paraId:42,tocIndex:6},{value:"true",paraId:42,tocIndex:6},{value:" 时生效，防止重叠时节点边缘间距的最小值。可以是回调函数，为不同节点设置不同的最小间距，如示例 2 所示",paraId:42,tocIndex:6},{value:"minMovement",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"0.1",paraId:42,tocIndex:6},{value:"0.5",paraId:42,tocIndex:6},{value:"当一次迭代的平均移动长度小于该值时停止迭代。数字越小，布局越收敛，所用时间将越长",paraId:42,tocIndex:6},{value:"maxIteration",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"500",paraId:42,tocIndex:6},{value:"1000",paraId:42,tocIndex:6},{value:"最大迭代次数。当迭代次数超过该值，但平均移动长度仍然没有达到 minMovement，也将强制停止迭代",paraId:42,tocIndex:6},{value:"damping",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"0.99",paraId:42,tocIndex:6},{value:"0.9",paraId:42,tocIndex:6},{value:"阻尼系数，取值范围 [0, 1]。数字越大，速度降低得越慢",paraId:42,tocIndex:6},{value:"maxSpeed",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"10",paraId:42,tocIndex:6},{value:"1000",paraId:42,tocIndex:6},{value:"一次迭代的最大移动长度",paraId:42,tocIndex:6},{value:"coulombDisScale",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"0.003",paraId:42,tocIndex:6},{value:"0.005",paraId:42,tocIndex:6},{value:"库伦系数，斥力的一个系数，数字越大，节点之间的斥力越大",paraId:42,tocIndex:6},{value:"getMass",paraId:42,tocIndex:6},{value:"Function",paraId:42,tocIndex:6},{value:"d => {",paraId:42,tocIndex:6},{value:"  // d 是一个节点",paraId:42,tocIndex:6},{value:"  if (d.id === 'node1') {",paraId:42,tocIndex:6},{value:"    return 100;",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return 10;",paraId:42,tocIndex:6},{value:"}",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"每个节点质量的回调函数，若不指定，则默认使用度数作为节点质量。使用方法与 ",paraId:42,tocIndex:6},{value:"nodeSpacing",paraId:42,tocIndex:6},{value:" 类似，每个回调函数返回一个数值作为该节点的质量",paraId:42,tocIndex:6},{value:"getCenter",paraId:42,tocIndex:6},{value:"Function",paraId:42,tocIndex:6},{value:"(d, degree) => {",paraId:42,tocIndex:6},{value:"  // d 是一个节点, degree 为该节点度数",paraId:42,tocIndex:6},{value:"  if (d.degree === 0') {",paraId:42,tocIndex:6},{value:"    return [100, 100, 10]; // x, y, 强度",paraId:42,tocIndex:6},{value:"  }",paraId:42,tocIndex:6},{value:"  return [210, 150, 5]; // x, y, 强度",paraId:42,tocIndex:6},{value:"}",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"每个节点中心力的 x、y、强度的回调函数，若不指定，则没有额外中心力",paraId:42,tocIndex:6},{value:"gravity",paraId:42,tocIndex:6},{value:"Number",paraId:42,tocIndex:6},{value:"20",paraId:42,tocIndex:6},{value:"10",paraId:42,tocIndex:6},{value:"中心力大小，指所有节点被吸引到 ",paraId:42,tocIndex:6},{value:"center",paraId:42,tocIndex:6},{value:" 的力。数字越大，布局越紧凑",paraId:42,tocIndex:6},{value:"onTick",paraId:42,tocIndex:6},{value:"Function",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"每一次迭代的回调函数",paraId:42,tocIndex:6},{value:"onLayoutEnd",paraId:42,tocIndex:6},{value:"Function",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"undefined",paraId:42,tocIndex:6},{value:"布局完成后的回调函数",paraId:42,tocIndex:6},{value:"workerEnabled",paraId:42,tocIndex:6},{value:"Boolean",paraId:42,tocIndex:6},{value:"true / false",paraId:42,tocIndex:6},{value:"false",paraId:42,tocIndex:6},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:42,tocIndex:6},{value:"gpuEnabled",paraId:42,tocIndex:6},{value:"Boolean",paraId:42,tocIndex:6},{value:"true / false",paraId:42,tocIndex:6},{value:"false",paraId:42,tocIndex:6},{value:"是否启用 GPU 并行计算，G6 4.0 支持。若用户的机器或浏览器不支持 GPU 计算，将会自动降级为 CPU 计算",paraId:42,tocIndex:6},{value:" ",paraId:43,tocIndex:7},{value:"描述",paraId:43,tocIndex:7},{value:"：经典力导向布局。当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:43,tocIndex:7},{value:"fx",paraId:43,tocIndex:7},{value:" 与 ",paraId:43,tocIndex:7},{value:"fy",paraId:43,tocIndex:7},{value:" 作为固定的坐标。",paraId:43,tocIndex:7},{value:"Force 布局固定被拖拽节点位置的 Demo",paraId:44,tocIndex:7},{value:"。\n",paraId:43,tocIndex:7},{value:" ",paraId:43,tocIndex:7},{value:"API",paraId:43,tocIndex:7},{value:"：",paraId:43,tocIndex:7},{value:"Force API",paraId:45,tocIndex:7},{value:" ",paraId:43,tocIndex:7},{value:"参数",paraId:43,tocIndex:7},{value:"：与 d3.js 的力导布局参数相对应。",paraId:43,tocIndex:7},{value:"参数名",paraId:46,tocIndex:7},{value:"类型",paraId:46,tocIndex:7},{value:"示例",paraId:46,tocIndex:7},{value:"默认值",paraId:46,tocIndex:7},{value:"说明",paraId:46,tocIndex:7},{value:"center",paraId:46,tocIndex:7},{value:"Array",paraId:46,tocIndex:7},{value:"[ 0, 0 ]",paraId:46,tocIndex:7},{value:"图的中心",paraId:46,tocIndex:7},{value:"布局的中心",paraId:46,tocIndex:7},{value:"linkDistance",paraId:46,tocIndex:7},{value:"Number / Function",paraId:46,tocIndex:7},{value:"示例 1: 50 ",paraId:46,tocIndex:7},{value:"示例 2:",paraId:46,tocIndex:7},{value:"d => {",paraId:46,tocIndex:7},{value:"  // d 是一条边",paraId:46,tocIndex:7},{value:"  if (d.id === 'edge1') {",paraId:46,tocIndex:7},{value:"    return 100;",paraId:46,tocIndex:7},{value:"  }",paraId:46,tocIndex:7},{value:"  return 50;",paraId:46,tocIndex:7},{value:"}",paraId:46,tocIndex:7},{value:"50",paraId:46,tocIndex:7},{value:"边长。可以使用回调函数的形式对不同对边定义不同边长（如示例 2）",paraId:46,tocIndex:7},{value:"nodeStrength",paraId:46,tocIndex:7},{value:"Number / Function",paraId:46,tocIndex:7},{value:"示例 1: -30 ",paraId:46,tocIndex:7},{value:"示例 2:",paraId:46,tocIndex:7},{value:"d => {",paraId:46,tocIndex:7},{value:"  // d 是一个节点",paraId:46,tocIndex:7},{value:"  if (d.id === 'node1') {",paraId:46,tocIndex:7},{value:"    return -100;",paraId:46,tocIndex:7},{value:"  }",paraId:46,tocIndex:7},{value:"  return -30;",paraId:46,tocIndex:7},{value:"} / null",paraId:46,tocIndex:7},{value:"-30",paraId:46,tocIndex:7},{value:"节点作用力，正数代表节点之间的引力作用，负数代表节点之间的斥力作用。可以使用回调函数的形式对不同对节点定义不同节点作用力（如示例 2）",paraId:46,tocIndex:7},{value:"edgeStrength",paraId:46,tocIndex:7},{value:"Number / Function",paraId:46,tocIndex:7},{value:"示例 1: 1 ",paraId:46,tocIndex:7},{value:"示例 2:",paraId:46,tocIndex:7},{value:"d => {",paraId:46,tocIndex:7},{value:"  // d 是一个节点",paraId:46,tocIndex:7},{value:"  if (d.id === 'node1') {",paraId:46,tocIndex:7},{value:"    return 10;",paraId:46,tocIndex:7},{value:"  }",paraId:46,tocIndex:7},{value:"  return 1;",paraId:46,tocIndex:7},{value:"}",paraId:46,tocIndex:7},{value:"null",paraId:46,tocIndex:7},{value:"边的作用力，范围是 0 到 1，默认根据节点的出入度自适应。可以使用回调函数的形式对不同对节点定义不同边作用力（如示例 2）",paraId:46,tocIndex:7},{value:"preventOverlap",paraId:46,tocIndex:7},{value:"Boolean",paraId:46,tocIndex:7},{value:"false",paraId:46,tocIndex:7},{value:"false",paraId:46,tocIndex:7},{value:"是否防止重叠，必须配合属性 ",paraId:46,tocIndex:7},{value:"nodeSize",paraId:46,tocIndex:7},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:46,tocIndex:7},{value:"nodeSize",paraId:46,tocIndex:7},{value:" 值，才能够进行节点重叠的碰撞检测。若未设置 ",paraId:46,tocIndex:7},{value:"nodeSize",paraId:46,tocIndex:7},{value:" ，则根据节点数据中的 ",paraId:46,tocIndex:7},{value:"size",paraId:46,tocIndex:7},{value:" 进行碰撞检测。若二者都未设置，则默认以 10 为节点大小进行碰撞检测",paraId:46,tocIndex:7},{value:"nodeSize",paraId:46,tocIndex:7},{value:"Array / Number",paraId:46,tocIndex:7},{value:"20",paraId:46,tocIndex:7},{value:"undefined",paraId:46,tocIndex:7},{value:"节点大小（直径）。用于碰撞检测。",paraId:46,tocIndex:7},{value:"若不指定，则根据传入的数据节点中的 ",paraId:46,tocIndex:7},{value:"size",paraId:46,tocIndex:7},{value:"  字段计算。若即不指定，节点中也没有 ",paraId:46,tocIndex:7},{value:"size",paraId:46,tocIndex:7},{value:"，则默认大小为 10",paraId:46,tocIndex:7},{value:"nodeSpacing",paraId:46,tocIndex:7},{value:"Number / Function",paraId:46,tocIndex:7},{value:"示例 1 : 10",paraId:46,tocIndex:7},{value:"示例 2 : ",paraId:46,tocIndex:7},{value:"d => {",paraId:46,tocIndex:7},{value:"  // d 是一个节点",paraId:46,tocIndex:7},{value:"  if (d.id === 'node1') {",paraId:46,tocIndex:7},{value:"    return 100;",paraId:46,tocIndex:7},{value:"  }",paraId:46,tocIndex:7},{value:"  return 10;",paraId:46,tocIndex:7},{value:"}",paraId:46,tocIndex:7},{value:"0",paraId:46,tocIndex:7},{value:"preventOverlap",paraId:46,tocIndex:7},{value:" 为 ",paraId:46,tocIndex:7},{value:"true",paraId:46,tocIndex:7},{value:" 时生效，防止重叠时节点边缘间距的最小值。可以是回调函数，为不同节点设置不同的最小间距，如示例 2 所示",paraId:46,tocIndex:7},{value:"alphaDecay",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.03",paraId:46,tocIndex:7},{value:"0.028",paraId:46,tocIndex:7},{value:"迭代阈值的衰减率。范围 [0, 1]，0.028 对应迭代数为 300",paraId:46,tocIndex:7},{value:"alphaMin",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.03",paraId:46,tocIndex:7},{value:"0.001",paraId:46,tocIndex:7},{value:"停止迭代的阈值",paraId:46,tocIndex:7},{value:"alpha",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.1",paraId:46,tocIndex:7},{value:"0.3",paraId:46,tocIndex:7},{value:"当前阈值",paraId:46,tocIndex:7},{value:"collideStrength",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.8",paraId:46,tocIndex:7},{value:"1",paraId:46,tocIndex:7},{value:"防止重叠的力强度，范围 [0, 1]",paraId:46,tocIndex:7},{value:"clustering",paraId:46,tocIndex:7},{value:"Boolean",paraId:46,tocIndex:7},{value:"false",paraId:46,tocIndex:7},{value:"false",paraId:46,tocIndex:7},{value:"是否按照聚类信息布局",paraId:46,tocIndex:7},{value:"clusterNodeStrength",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"-1",paraId:46,tocIndex:7},{value:"-0.8",paraId:46,tocIndex:7},{value:"聚类节点作用力。负数代表斥力",paraId:46,tocIndex:7},{value:"clusterEdgeStrength",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.1",paraId:46,tocIndex:7},{value:"0.2",paraId:46,tocIndex:7},{value:"聚类边作用力",paraId:46,tocIndex:7},{value:"clusterEdgeDistance",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"100",paraId:46,tocIndex:7},{value:"50",paraId:46,tocIndex:7},{value:"聚类边长度",paraId:46,tocIndex:7},{value:"clusterNodeSize",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"10",paraId:46,tocIndex:7},{value:"15",paraId:46,tocIndex:7},{value:"聚类节点大小 / 直径，直径越大，越分散",paraId:46,tocIndex:7},{value:"clusterFociStrength",paraId:46,tocIndex:7},{value:"Number",paraId:46,tocIndex:7},{value:"0.8",paraId:46,tocIndex:7},{value:"0.5",paraId:46,tocIndex:7},{value:"用于 foci 的力",paraId:46,tocIndex:7},{value:"forceSimulation",paraId:46,tocIndex:7},{value:"Object",paraId:46,tocIndex:7},{value:"null",paraId:46,tocIndex:7},{value:"自定义 force 方法，若不指定，则使用 d3 的方法。",paraId:46,tocIndex:7},{value:"onTick",paraId:46,tocIndex:7},{value:"Function",paraId:46,tocIndex:7},{value:"{}",paraId:46,tocIndex:7},{value:"每一次迭代的回调函数",paraId:46,tocIndex:7},{value:"onLayoutEnd",paraId:46,tocIndex:7},{value:"Function",paraId:46,tocIndex:7},{value:"{}",paraId:46,tocIndex:7},{value:"布局完成后的回调函数",paraId:46,tocIndex:7},{value:"workerEnabled",paraId:46,tocIndex:7},{value:"Boolean",paraId:46,tocIndex:7},{value:"true / false",paraId:46,tocIndex:7},{value:"false",paraId:46,tocIndex:7},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:46,tocIndex:7},{value:"描述",paraId:47,tocIndex:8},{value:"：Fruchterman 布局，一种力导布局。当你希望固定某个节点的位置，不受力的影响时，可以在该节点数据中配置 ",paraId:47,tocIndex:8},{value:"fx",paraId:47,tocIndex:8},{value:" 与 ",paraId:47,tocIndex:8},{value:"fy",paraId:47,tocIndex:8},{value:" 作为固定的坐标。",paraId:47,tocIndex:8},{value:"Fruchterman 布局固定被拖拽节点位置的 Demo",paraId:48,tocIndex:8},{value:"。\n",paraId:47,tocIndex:8},{value:"API",paraId:47,tocIndex:8},{value:"：",paraId:47,tocIndex:8},{value:"Fruchterman API",paraId:49,tocIndex:8},{value:"参数",paraId:47,tocIndex:8},{value:"：",paraId:47,tocIndex:8},{value:"参数名",paraId:50,tocIndex:8},{value:"类型",paraId:50,tocIndex:8},{value:"示例",paraId:50,tocIndex:8},{value:"默认值",paraId:50,tocIndex:8},{value:"说明",paraId:50,tocIndex:8},{value:"center",paraId:50,tocIndex:8},{value:"Array",paraId:50,tocIndex:8},{value:"[ 0, 0 ]",paraId:50,tocIndex:8},{value:"图的中心",paraId:50,tocIndex:8},{value:"布局的中心",paraId:50,tocIndex:8},{value:"maxIteration",paraId:50,tocIndex:8},{value:"Number",paraId:50,tocIndex:8},{value:"1000",paraId:50,tocIndex:8},{value:"1000",paraId:50,tocIndex:8},{value:"最大迭代次数",paraId:50,tocIndex:8},{value:"gravity",paraId:50,tocIndex:8},{value:"Number",paraId:50,tocIndex:8},{value:"10",paraId:50,tocIndex:8},{value:"10",paraId:50,tocIndex:8},{value:"重力大小，影响布局的紧凑程度",paraId:50,tocIndex:8},{value:"speed",paraId:50,tocIndex:8},{value:"Number",paraId:50,tocIndex:8},{value:"1",paraId:50,tocIndex:8},{value:"1",paraId:50,tocIndex:8},{value:"每次迭代节点移动的速度。速度太快可能会导致强烈震荡",paraId:50,tocIndex:8},{value:"clustering",paraId:50,tocIndex:8},{value:"Boolean",paraId:50,tocIndex:8},{value:"false",paraId:50,tocIndex:8},{value:"false",paraId:50,tocIndex:8},{value:"是否按照聚类布局",paraId:50,tocIndex:8},{value:"clusterGravity",paraId:50,tocIndex:8},{value:"Number",paraId:50,tocIndex:8},{value:"30",paraId:50,tocIndex:8},{value:"10",paraId:50,tocIndex:8},{value:"聚类内部的重力大小，影响聚类的紧凑程度",paraId:50,tocIndex:8},{value:"workerEnabled",paraId:50,tocIndex:8},{value:"Boolean",paraId:50,tocIndex:8},{value:"true / false",paraId:50,tocIndex:8},{value:"false",paraId:50,tocIndex:8},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:50,tocIndex:8},{value:"gpuEnabled",paraId:50,tocIndex:8},{value:"Boolean",paraId:50,tocIndex:8},{value:"true / false",paraId:50,tocIndex:8},{value:"false",paraId:50,tocIndex:8},{value:"是否启用 GPU 并行计算，G6 4.0 支持",paraId:50,tocIndex:8},{value:"描述",paraId:51,tocIndex:9},{value:"：环形布局。 ",paraId:51,tocIndex:9},{value:"API",paraId:51,tocIndex:9},{value:"：",paraId:51,tocIndex:9},{value:"Circular API",paraId:52,tocIndex:9},{value:" ",paraId:51,tocIndex:9},{value:"参数",paraId:51,tocIndex:9},{value:"：",paraId:51,tocIndex:9},{value:"参数名",paraId:53,tocIndex:9},{value:"类型",paraId:53,tocIndex:9},{value:"示例/可选值",paraId:53,tocIndex:9},{value:"默认值",paraId:53,tocIndex:9},{value:"说明",paraId:53,tocIndex:9},{value:"center",paraId:53,tocIndex:9},{value:"Array",paraId:53,tocIndex:9},{value:"[ 0, 0 ]",paraId:53,tocIndex:9},{value:"图的中心",paraId:53,tocIndex:9},{value:"布局的中心",paraId:53,tocIndex:9},{value:"radius",paraId:53,tocIndex:9},{value:"Number",paraId:53,tocIndex:9},{value:"50",paraId:53,tocIndex:9},{value:"null",paraId:53,tocIndex:9},{value:"圆的半径。若设置了 ",paraId:53,tocIndex:9},{value:"radius",paraId:53,tocIndex:9},{value:"，则 ",paraId:53,tocIndex:9},{value:"startRadius",paraId:53,tocIndex:9},{value:" 与 ",paraId:53,tocIndex:9},{value:"endRadius",paraId:53,tocIndex:9},{value:" 不生效",paraId:53,tocIndex:9},{value:"startRadius",paraId:53,tocIndex:9},{value:"Number",paraId:53,tocIndex:9},{value:"10",paraId:53,tocIndex:9},{value:"null",paraId:53,tocIndex:9},{value:"螺旋状布局的起始半径",paraId:53,tocIndex:9},{value:"endRadius",paraId:53,tocIndex:9},{value:"Number",paraId:53,tocIndex:9},{value:"100",paraId:53,tocIndex:9},{value:"null",paraId:53,tocIndex:9},{value:"螺旋状布局的结束半径",paraId:53,tocIndex:9},{value:"clockwise",paraId:53,tocIndex:9},{value:"Boolean",paraId:53,tocIndex:9},{value:"true",paraId:53,tocIndex:9},{value:"true",paraId:53,tocIndex:9},{value:"是否顺时针排列",paraId:53,tocIndex:9},{value:"divisions",paraId:53,tocIndex:9},{value:"Number",paraId:53,tocIndex:9},{value:"3",paraId:53,tocIndex:9},{value:"1",paraId:53,tocIndex:9},{value:"节点在环上的分段数（几个段将均匀分布），在 ",paraId:53,tocIndex:9},{value:"endRadius - startRadius != 0",paraId:53,tocIndex:9},{value:" 时生效",paraId:53,tocIndex:9},{value:"ordering",paraId:53,tocIndex:9},{value:"String",paraId:53,tocIndex:9},{value:"null",paraId:53,tocIndex:9},{value:"'topology'",paraId:53,tocIndex:9},{value:"'degree'",paraId:53,tocIndex:9},{value:"angleRatio",paraId:53,tocIndex:9},{value:"Number",paraId:53,tocIndex:9},{value:"1",paraId:53,tocIndex:9},{value:"1",paraId:53,tocIndex:9},{value:"从第一个节点到最后节点之间相隔多少个 2*PI",paraId:53,tocIndex:9},{value:"workerEnabled",paraId:53,tocIndex:9},{value:"Boolean",paraId:53,tocIndex:9},{value:"true / false",paraId:53,tocIndex:9},{value:"false",paraId:53,tocIndex:9},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:53,tocIndex:9},{value:"描述",paraId:54,tocIndex:10},{value:"：辐射状布局。 ",paraId:54,tocIndex:10},{value:"API",paraId:54,tocIndex:10},{value:"：",paraId:54,tocIndex:10},{value:"Radial API",paraId:55,tocIndex:10},{value:" ",paraId:54,tocIndex:10},{value:"参数",paraId:54,tocIndex:10},{value:"：",paraId:54,tocIndex:10},{value:"参数名",paraId:56,tocIndex:10},{value:"类型",paraId:56,tocIndex:10},{value:"示例",paraId:56,tocIndex:10},{value:"默认值",paraId:56,tocIndex:10},{value:"说明",paraId:56,tocIndex:10},{value:"center",paraId:56,tocIndex:10},{value:"Array",paraId:56,tocIndex:10},{value:"[ 0, 0 ]",paraId:56,tocIndex:10},{value:"图的中心",paraId:56,tocIndex:10},{value:"布局的中心",paraId:56,tocIndex:10},{value:"linkDistance",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"50",paraId:56,tocIndex:10},{value:"50",paraId:56,tocIndex:10},{value:"边长",paraId:56,tocIndex:10},{value:"maxIteration",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"1000",paraId:56,tocIndex:10},{value:"1000",paraId:56,tocIndex:10},{value:"停止迭代到最大迭代数",paraId:56,tocIndex:10},{value:"focusNode",paraId:56,tocIndex:10},{value:"String / Object",paraId:56,tocIndex:10},{value:"'node1'",paraId:56,tocIndex:10},{value:"null",paraId:56,tocIndex:10},{value:"中心点，默认为数据中第一个节点。可以传入节点 id 或节点本身。",paraId:56,tocIndex:10},{value:"unitRadius",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:"100",paraId:56,tocIndex:10},{value:"每一圈距离上一圈的距离。默认填充整个画布，即根据图的大小决定",paraId:56,tocIndex:10},{value:"preventOverlap",paraId:56,tocIndex:10},{value:"Boolean",paraId:56,tocIndex:10},{value:"false",paraId:56,tocIndex:10},{value:"false",paraId:56,tocIndex:10},{value:"是否防止重叠，必须配合属性 ",paraId:56,tocIndex:10},{value:"nodeSize",paraId:56,tocIndex:10},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:56,tocIndex:10},{value:"nodeSize",paraId:56,tocIndex:10},{value:" 值，才能够进行节点重叠的碰撞检测。",paraId:56,tocIndex:10},{value:"：",paraId:56,tocIndex:10},{value:"若未设置 ",paraId:56,tocIndex:10},{value:"nodeSize",paraId:56,tocIndex:10},{value:"，则将会根据数据中节点的 ",paraId:56,tocIndex:10},{value:"size",paraId:56,tocIndex:10},{value:" 字段数值进行碰撞检测计算。若二者皆未设置，则以节点大小为 ",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:" 进行计算。",paraId:56,tocIndex:10},{value:"maxPreventOverlapIteration",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"500",paraId:56,tocIndex:10},{value:"200",paraId:56,tocIndex:10},{value:"防止重叠步骤的最大迭代次数",paraId:56,tocIndex:10},{value:"nodeSize",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:"节点大小（直径）。用于防止节点重叠时的碰撞检测。",paraId:56,tocIndex:10},{value:"：",paraId:56,tocIndex:10},{value:"若未设置则使用数据中节点的 ",paraId:56,tocIndex:10},{value:"size",paraId:56,tocIndex:10},{value:" 字段数值进行碰撞检测计算。若二者皆未设置，则以节点大小为 ",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:" 进行计算。",paraId:56,tocIndex:10},{value:"nodeSpacing",paraId:56,tocIndex:10},{value:"Number / Function",paraId:56,tocIndex:10},{value:"示例 1 : 10",paraId:56,tocIndex:10},{value:"示例 2 : ",paraId:56,tocIndex:10},{value:"d => {",paraId:56,tocIndex:10},{value:"  // d 是一个节点",paraId:56,tocIndex:10},{value:"  if (d.id === 'node1') {",paraId:56,tocIndex:10},{value:"    return 100;",paraId:56,tocIndex:10},{value:"  }",paraId:56,tocIndex:10},{value:"  return 10;",paraId:56,tocIndex:10},{value:"}",paraId:56,tocIndex:10},{value:"0",paraId:56,tocIndex:10},{value:"preventOverlap",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:" 时生效，防止重叠时节点边缘间距的最小值。可以是回调函数，为不同节点设置不同的最小间距，如示例 2 所示",paraId:56,tocIndex:10},{value:"strictRadial",paraId:56,tocIndex:10},{value:"Boolean",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:"false",paraId:56,tocIndex:10},{value:"是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。",paraId:56,tocIndex:10},{value:"preventOverlap",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:" 时生效。详见 ",paraId:56,tocIndex:10},{value:"Radial-strictRadial API",paraId:57,tocIndex:10},{value:"- 当 ",paraId:56,tocIndex:10},{value:"preventOverlap",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:"，且 ",paraId:56,tocIndex:10},{value:"strictRadial",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"false",paraId:56,tocIndex:10},{value:" 时，有重叠的节点严格沿着所在的环展开，但在一个环上若节点过多，可能无法完全避免节点重叠。",paraId:56,tocIndex:10},{value:"- 当 ",paraId:56,tocIndex:10},{value:"preventOverlap",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:"，且 ",paraId:56,tocIndex:10},{value:"strictRadial",paraId:56,tocIndex:10},{value:" 为 ",paraId:56,tocIndex:10},{value:"true",paraId:56,tocIndex:10},{value:"  时，允许同环上重叠的节点不严格沿着该环布局，可以在该环的前后偏移以避免重叠。",paraId:56,tocIndex:10},{value:"sortBy",paraId:56,tocIndex:10},{value:"String",paraId:56,tocIndex:10},{value:"'data' / 'cluster'",paraId:56,tocIndex:10},{value:"undefined",paraId:56,tocIndex:10},{value:"同层节点布局后相距远近的依据。默认 ",paraId:56,tocIndex:10},{value:"undefined",paraId:56,tocIndex:10},{value:" ，表示根据数据的拓扑结构（节点间最短路径）排布，即关系越近/点对间最短路径越小的节点将会被尽可能排列在一起；",paraId:56,tocIndex:10},{value:"'data'",paraId:56,tocIndex:10},{value:" 表示按照节点在数据中的顺序排列，即在数据顺序上靠近的节点将会尽可能排列在一起；也可以指定为节点数据中的某个字段名，例如 ",paraId:56,tocIndex:10},{value:"'cluster'",paraId:56,tocIndex:10},{value:"、",paraId:56,tocIndex:10},{value:"'name'",paraId:56,tocIndex:10},{value:" 等（必须在数据中存在）",paraId:56,tocIndex:10},{value:"sortStrength",paraId:56,tocIndex:10},{value:"Number",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:"10",paraId:56,tocIndex:10},{value:"同层节点根据 ",paraId:56,tocIndex:10},{value:"sortBy",paraId:56,tocIndex:10},{value:" 排列的强度，数值越大，",paraId:56,tocIndex:10},{value:"sortBy",paraId:56,tocIndex:10},{value:" 指定的方式计算出距离越小的越靠近。",paraId:56,tocIndex:10},{value:"sortBy",paraId:56,tocIndex:10},{value:" 不为 ",paraId:56,tocIndex:10},{value:"undefined",paraId:56,tocIndex:10},{value:" 时生效",paraId:56,tocIndex:10},{value:"workerEnabled",paraId:56,tocIndex:10},{value:"Boolean",paraId:56,tocIndex:10},{value:"true / false",paraId:56,tocIndex:10},{value:"false",paraId:56,tocIndex:10},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:56,tocIndex:10},{value:"描述",paraId:58,tocIndex:11},{value:"：高维数据降维算法布局。",paraId:58,tocIndex:11},{value:"API",paraId:58,tocIndex:11},{value:"：",paraId:58,tocIndex:11},{value:"MDS API",paraId:59,tocIndex:11},{value:"参数",paraId:58,tocIndex:11},{value:"：",paraId:58,tocIndex:11},{value:"参数名",paraId:60,tocIndex:11},{value:"类型",paraId:60,tocIndex:11},{value:"示例",paraId:60,tocIndex:11},{value:"默认值",paraId:60,tocIndex:11},{value:"说明",paraId:60,tocIndex:11},{value:"center",paraId:60,tocIndex:11},{value:"Array",paraId:60,tocIndex:11},{value:"[ 0, 0 ]",paraId:60,tocIndex:11},{value:"图的中心",paraId:60,tocIndex:11},{value:"布局的中心",paraId:60,tocIndex:11},{value:"linkDistance",paraId:60,tocIndex:11},{value:"Number",paraId:60,tocIndex:11},{value:"50",paraId:60,tocIndex:11},{value:"50",paraId:60,tocIndex:11},{value:"边长",paraId:60,tocIndex:11},{value:"workerEnabled",paraId:60,tocIndex:11},{value:"Boolean",paraId:60,tocIndex:11},{value:"true / false",paraId:60,tocIndex:11},{value:"false",paraId:60,tocIndex:11},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:60,tocIndex:11},{value:"描述",paraId:61,tocIndex:12},{value:"：层次布局。",paraId:61,tocIndex:12},{value:"API",paraId:61,tocIndex:12},{value:"：",paraId:61,tocIndex:12},{value:"Dagre API",paraId:62,tocIndex:12},{value:"参数",paraId:61,tocIndex:12},{value:"：",paraId:61,tocIndex:12},{value:"参数名",paraId:63,tocIndex:12},{value:"类型",paraId:63,tocIndex:12},{value:"示例/可选值",paraId:63,tocIndex:12},{value:"默认值",paraId:63,tocIndex:12},{value:"说明",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:"String",paraId:63,tocIndex:12},{value:"'TB' / 'BT' / 'LR' / 'RL'",paraId:63,tocIndex:12},{value:"'TB'",paraId:63,tocIndex:12},{value:"layout 的方向。T：top；B：bottom；L：left；R：right",paraId:63,tocIndex:12},{value:"align",paraId:63,tocIndex:12},{value:"String",paraId:63,tocIndex:12},{value:"'UL' / 'UR' / 'DL' / 'DR' / undefined",paraId:63,tocIndex:12},{value:"undefined",paraId:63,tocIndex:12},{value:"节点对齐方式。默认值是 ",paraId:63,tocIndex:12},{value:"undefined",paraId:63,tocIndex:12},{value:"，代表对齐到中心。U：upper；D：down；L：left；R：right",paraId:63,tocIndex:12},{value:"nodesep",paraId:63,tocIndex:12},{value:"Number",paraId:63,tocIndex:12},{value:"40",paraId:63,tocIndex:12},{value:"50",paraId:63,tocIndex:12},{value:"在 ",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 ",paraId:63,tocIndex:12},{value:"'TB'",paraId:63,tocIndex:12},{value:" 或 ",paraId:63,tocIndex:12},{value:"'BT'",paraId:63,tocIndex:12},{value:" 时代表节点水平间距(px)；在 ",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 ",paraId:63,tocIndex:12},{value:"'LR'",paraId:63,tocIndex:12},{value:" 或 ",paraId:63,tocIndex:12},{value:"'RL'",paraId:63,tocIndex:12},{value:" 时代表节点的竖直间距。优先级低于 ",paraId:63,tocIndex:12},{value:"nodesepFunc",paraId:63,tocIndex:12},{value:"ranksep",paraId:63,tocIndex:12},{value:"Number",paraId:63,tocIndex:12},{value:"40",paraId:63,tocIndex:12},{value:"50",paraId:63,tocIndex:12},{value:"层间距（px）。在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 ",paraId:63,tocIndex:12},{value:"'TB'",paraId:63,tocIndex:12},{value:" 或 ",paraId:63,tocIndex:12},{value:"'BT'",paraId:63,tocIndex:12},{value:" 时是竖直方向相邻层间距；在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 ",paraId:63,tocIndex:12},{value:"'LR'",paraId:63,tocIndex:12},{value:" 或 ",paraId:63,tocIndex:12},{value:"'RL'",paraId:63,tocIndex:12},{value:" 时代表水平方向相邻层间距。优先级低于 ",paraId:63,tocIndex:12},{value:"ranksepFunc",paraId:63,tocIndex:12},{value:"nodesepFunc",paraId:63,tocIndex:12},{value:"Function",paraId:63,tocIndex:12},{value:"d => {",paraId:63,tocIndex:12},{value:"  // d 是一个节点",paraId:63,tocIndex:12},{value:"  if (d.id === 'node1') {",paraId:63,tocIndex:12},{value:"    return 100;",paraId:63,tocIndex:12},{value:"  }",paraId:63,tocIndex:12},{value:"  return 10;",paraId:63,tocIndex:12},{value:"}",paraId:63,tocIndex:12},{value:"undefined",paraId:63,tocIndex:12},{value:"节点水平间距（px）的回调函数，通过该参数可以对不同节点设置不同的节点间距。在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 'TB' 或 'BT' 时是节点的水平间距；在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 'LR' 或 'RL' 时是节点的竖直间距。优先级高于 ",paraId:63,tocIndex:12},{value:"nodesep",paraId:63,tocIndex:12},{value:"，即若设置了 ",paraId:63,tocIndex:12},{value:"nodesepFunc",paraId:63,tocIndex:12},{value:"，则 ",paraId:63,tocIndex:12},{value:"nodesep",paraId:63,tocIndex:12},{value:" 不生效",paraId:63,tocIndex:12},{value:"ranksepFunc",paraId:63,tocIndex:12},{value:"Function",paraId:63,tocIndex:12},{value:"d => {",paraId:63,tocIndex:12},{value:"  // d 是一个节点",paraId:63,tocIndex:12},{value:"  if (d.id === 'node1') {",paraId:63,tocIndex:12},{value:"    return 100;",paraId:63,tocIndex:12},{value:"  }",paraId:63,tocIndex:12},{value:"  return 10;",paraId:63,tocIndex:12},{value:"}",paraId:63,tocIndex:12},{value:"undefined",paraId:63,tocIndex:12},{value:"层间距（px）的回调函数，通过该参数可以对不同节点设置不同的层间距。在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 'TB' 或 'BT' 时是竖直方向相邻层间距；在",paraId:63,tocIndex:12},{value:"rankdir",paraId:63,tocIndex:12},{value:" 为 'LR' 或 'RL' 时代表水平方向相邻层间距。优先级高于 ",paraId:63,tocIndex:12},{value:"ranksep",paraId:63,tocIndex:12},{value:"，即若设置了 ",paraId:63,tocIndex:12},{value:"ranksepFunc",paraId:63,tocIndex:12},{value:"，则 ",paraId:63,tocIndex:12},{value:"ranksep",paraId:63,tocIndex:12},{value:" 不生效",paraId:63,tocIndex:12},{value:"controlPoints",paraId:63,tocIndex:12},{value:"Boolean",paraId:63,tocIndex:12},{value:"true",paraId:63,tocIndex:12},{value:"true",paraId:63,tocIndex:12},{value:"是否保留布局连线的控制点",paraId:63,tocIndex:12},{value:"workerEnabled",paraId:63,tocIndex:12},{value:"Boolean",paraId:63,tocIndex:12},{value:"true / false",paraId:63,tocIndex:12},{value:"false",paraId:63,tocIndex:12},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:63,tocIndex:12},{value:"sortByCombo",paraId:63,tocIndex:12},{value:"Boolean",paraId:63,tocIndex:12},{value:"true / false",paraId:63,tocIndex:12},{value:"false",paraId:63,tocIndex:12},{value:"同一层节点是否根据每个节点数据中的 ",paraId:63,tocIndex:12},{value:"comboId",paraId:63,tocIndex:12},{value:" 进行排序，以防止 combo 重叠",paraId:63,tocIndex:12},{value:"注：该算法参考 ",paraId:64,tocIndex:13},{value:"cytoscape.js",paraId:64,tocIndex:13},{value:"，遵守 MIT 开源协议。",paraId:64,tocIndex:13},{value:"描述",paraId:64,tocIndex:13},{value:"：同心圆布局。",paraId:64,tocIndex:13},{value:"API",paraId:64,tocIndex:13},{value:"：",paraId:64,tocIndex:13},{value:"Concentric API",paraId:65,tocIndex:13},{value:"参数",paraId:64,tocIndex:13},{value:"：",paraId:64,tocIndex:13},{value:"参数名",paraId:66,tocIndex:13},{value:"类型",paraId:66,tocIndex:13},{value:"示例/可选值",paraId:66,tocIndex:13},{value:"默认值",paraId:66,tocIndex:13},{value:"说明",paraId:66,tocIndex:13},{value:"center",paraId:66,tocIndex:13},{value:"Array",paraId:66,tocIndex:13},{value:"[ 0, 0 ]",paraId:66,tocIndex:13},{value:"图的中心",paraId:66,tocIndex:13},{value:"布局的中心",paraId:66,tocIndex:13},{value:"nodeSize",paraId:66,tocIndex:13},{value:"Number",paraId:66,tocIndex:13},{value:"30",paraId:66,tocIndex:13},{value:"30",paraId:66,tocIndex:13},{value:"节点大小（直径）。用于防止节点重叠时的碰撞检测",paraId:66,tocIndex:13},{value:"nodeSpacing",paraId:66,tocIndex:13},{value:"Number",paraId:66,tocIndex:13},{value:"10",paraId:66,tocIndex:13},{value:"10",paraId:66,tocIndex:13},{value:"环与环之间最小间距，用于调整半径",paraId:66,tocIndex:13},{value:"preventOverlap",paraId:66,tocIndex:13},{value:"Boolean",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"是否防止重叠，必须配合属性 ",paraId:66,tocIndex:13},{value:"nodeSize",paraId:66,tocIndex:13},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:66,tocIndex:13},{value:"nodeSize",paraId:66,tocIndex:13},{value:" 值，才能够进行节点重叠的碰撞检测。若未设置 ",paraId:66,tocIndex:13},{value:"nodeSize",paraId:66,tocIndex:13},{value:" ，则将根据节点数据中的 ",paraId:66,tocIndex:13},{value:"size",paraId:66,tocIndex:13},{value:" 进行碰撞检测。若二者都未设置，则默认以 30 为节点大小进行碰撞检测",paraId:66,tocIndex:13},{value:"sweep",paraId:66,tocIndex:13},{value:"Number",paraId:66,tocIndex:13},{value:"Math.PI",paraId:66,tocIndex:13},{value:"undefined",paraId:66,tocIndex:13},{value:"第一个节点与最后一个节点之间的弧度差",paraId:66,tocIndex:13},{value:"equidistant",paraId:66,tocIndex:13},{value:"Boolean",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"环与环之间的距离是否相等",paraId:66,tocIndex:13},{value:"startAngle",paraId:66,tocIndex:13},{value:"Number",paraId:66,tocIndex:13},{value:"3.14",paraId:66,tocIndex:13},{value:"3 / 2 * Math.PI",paraId:66,tocIndex:13},{value:"开始放置节点的弧度",paraId:66,tocIndex:13},{value:"clockwise",paraId:66,tocIndex:13},{value:"Boolean",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"是否按照顺时针顺序",paraId:66,tocIndex:13},{value:"maxLevelDiff",paraId:66,tocIndex:13},{value:"Number",paraId:66,tocIndex:13},{value:"0.5",paraId:66,tocIndex:13},{value:"undefined",paraId:66,tocIndex:13},{value:"每一层同心值的求和。若为 undefined，则将会被设置为 maxValue / 4 ，其中 maxValue 为最大的排序依据的属性值。例如，若 sortBy='degree'，则 maxValue 为所有节点中度数最大的节点的度数",paraId:66,tocIndex:13},{value:"sortBy",paraId:66,tocIndex:13},{value:"String",paraId:66,tocIndex:13},{value:"'degree' / 'property1' / 'weight' / ...",paraId:66,tocIndex:13},{value:"undefined",paraId:66,tocIndex:13},{value:"指定的节点排序的依据（节点属性名）。该属性值高的放在中心。如果是 ",paraId:66,tocIndex:13},{value:"sortBy",paraId:66,tocIndex:13},{value:" 为 ",paraId:66,tocIndex:13},{value:"undefined",paraId:66,tocIndex:13},{value:" 则会计算节点度数，度数最高的放在中心。",paraId:66,tocIndex:13},{value:"workerEnabled",paraId:66,tocIndex:13},{value:"Boolean",paraId:66,tocIndex:13},{value:"true / false",paraId:66,tocIndex:13},{value:"false",paraId:66,tocIndex:13},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:66,tocIndex:13},{value:"注：该算法参考 ",paraId:67,tocIndex:14},{value:"cytoscape.js",paraId:67,tocIndex:14},{value:"，遵守 MIT 开源协议。",paraId:67,tocIndex:14},{value:"描述",paraId:67,tocIndex:14},{value:"：网格布局。",paraId:67,tocIndex:14},{value:"API",paraId:67,tocIndex:14},{value:"：",paraId:67,tocIndex:14},{value:"Grid API",paraId:68,tocIndex:14},{value:"参数",paraId:67,tocIndex:14},{value:"：",paraId:67,tocIndex:14},{value:"参数名",paraId:69,tocIndex:14},{value:"类型",paraId:69,tocIndex:14},{value:"示例/可选值",paraId:69,tocIndex:14},{value:"默认值",paraId:69,tocIndex:14},{value:"说明",paraId:69,tocIndex:14},{value:"begin",paraId:69,tocIndex:14},{value:"Array",paraId:69,tocIndex:14},{value:"[ 0, 0 ]",paraId:69,tocIndex:14},{value:"[ 0, 0 ]",paraId:69,tocIndex:14},{value:"网格开始位置（左上角）",paraId:69,tocIndex:14},{value:"preventOverlap",paraId:69,tocIndex:14},{value:"Boolean",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:"是否防止重叠，必须配合属性 ",paraId:69,tocIndex:14},{value:"nodeSize",paraId:69,tocIndex:14},{value:" ，只有设置了与当前图节点大小相同的 ",paraId:69,tocIndex:14},{value:"nodeSize",paraId:69,tocIndex:14},{value:" 值，才能够进行节点重叠的碰撞检测。若未设置 ",paraId:69,tocIndex:14},{value:"nodeSize",paraId:69,tocIndex:14},{value:" ，则将根据节点数据中的 ",paraId:69,tocIndex:14},{value:"size",paraId:69,tocIndex:14},{value:" 进行碰撞检测。若二者都未设置，则默认以 30 为节点大小进行碰撞检测",paraId:69,tocIndex:14},{value:"preventOverlapPadding",paraId:69,tocIndex:14},{value:"Number",paraId:69,tocIndex:14},{value:"10",paraId:69,tocIndex:14},{value:"10",paraId:69,tocIndex:14},{value:"避免重叠时节点的间距 padding。",paraId:69,tocIndex:14},{value:"preventOverlap",paraId:69,tocIndex:14},{value:" 为 ",paraId:69,tocIndex:14},{value:"true",paraId:69,tocIndex:14},{value:" 时生效",paraId:69,tocIndex:14},{value:"nodeSize",paraId:69,tocIndex:14},{value:"Number",paraId:69,tocIndex:14},{value:"30",paraId:69,tocIndex:14},{value:"30",paraId:69,tocIndex:14},{value:"节点大小（直径）。用于防止节点重叠时的碰撞检测",paraId:69,tocIndex:14},{value:"condense",paraId:69,tocIndex:14},{value:"Boolean",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:"为 ",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:" 时表示利用所有可用画布空间，为 ",paraId:69,tocIndex:14},{value:"true",paraId:69,tocIndex:14},{value:" 时表示利用最小的画布空间",paraId:69,tocIndex:14},{value:"rows",paraId:69,tocIndex:14},{value:"Number",paraId:69,tocIndex:14},{value:"5",paraId:69,tocIndex:14},{value:"undefined",paraId:69,tocIndex:14},{value:"网格的行数，为 undefined 时算法根据节点数量、布局空间、",paraId:69,tocIndex:14},{value:"cols",paraId:69,tocIndex:14},{value:"（若指定）自动计算",paraId:69,tocIndex:14},{value:"cols",paraId:69,tocIndex:14},{value:"Number",paraId:69,tocIndex:14},{value:"5",paraId:69,tocIndex:14},{value:"undefined",paraId:69,tocIndex:14},{value:"网格的列数，为 undefined 时算法根据节点数量、布局空间、",paraId:69,tocIndex:14},{value:"rows",paraId:69,tocIndex:14},{value:"（若指定）自动计算",paraId:69,tocIndex:14},{value:"sortBy",paraId:69,tocIndex:14},{value:"String",paraId:69,tocIndex:14},{value:"'degree' / 'property1' / 'weight' / ...",paraId:69,tocIndex:14},{value:"'degree'",paraId:69,tocIndex:14},{value:"指定排序的依据（节点属性名），数值越高则该节点被放置得越中心。若为 undefined，则会计算节点的度数，度数越高，节点将被放置得越中心",paraId:69,tocIndex:14},{value:"workerEnabled",paraId:69,tocIndex:14},{value:"Boolean",paraId:69,tocIndex:14},{value:"true / false",paraId:69,tocIndex:14},{value:"false",paraId:69,tocIndex:14},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:69,tocIndex:14},{value:"API",paraId:70,tocIndex:15},{value:"：",paraId:70,tocIndex:15},{value:"Combo Force API",paraId:71,tocIndex:15},{value:"参数",paraId:70,tocIndex:15},{value:"：",paraId:70,tocIndex:15},{value:"参数名",paraId:72,tocIndex:15},{value:"类型",paraId:72,tocIndex:15},{value:"示例",paraId:72,tocIndex:15},{value:"默认值",paraId:72,tocIndex:15},{value:"说明",paraId:72,tocIndex:15},{value:"center",paraId:72,tocIndex:15},{value:"Array",paraId:72,tocIndex:15},{value:"[ 0, 0 ]",paraId:72,tocIndex:15},{value:"图的中心",paraId:72,tocIndex:15},{value:"布局的中心",paraId:72,tocIndex:15},{value:"maxIteration",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"100",paraId:72,tocIndex:15},{value:"100",paraId:72,tocIndex:15},{value:"最大迭代次数",paraId:72,tocIndex:15},{value:"linkDistance",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1: 50 ",paraId:72,tocIndex:15},{value:"示例 2:",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一条边",paraId:72,tocIndex:15},{value:"  if (d.id === 'edge1') {",paraId:72,tocIndex:15},{value:"    return 100;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 50;",paraId:72,tocIndex:15},{value:"}",paraId:72,tocIndex:15},{value:"10",paraId:72,tocIndex:15},{value:"边长。可以使用回调函数的形式对不同对边定义不同边长（如示例 2）",paraId:72,tocIndex:15},{value:"nodeStrength",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1: 10 ",paraId:72,tocIndex:15},{value:"示例 2:",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一个节点",paraId:72,tocIndex:15},{value:"  if (d.id === 'node1') {",paraId:72,tocIndex:15},{value:"    return 10;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 30;",paraId:72,tocIndex:15},{value:"} / null",paraId:72,tocIndex:15},{value:"30",paraId:72,tocIndex:15},{value:"节点作用力",paraId:72,tocIndex:15},{value:"edgeStrength",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1: 1 ",paraId:72,tocIndex:15},{value:"示例 2:",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一个节点",paraId:72,tocIndex:15},{value:"  if (d.id === 'node1') {",paraId:72,tocIndex:15},{value:"    return 10;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 1;",paraId:72,tocIndex:15},{value:"}",paraId:72,tocIndex:15},{value:"0.2",paraId:72,tocIndex:15},{value:"边的作用力",paraId:72,tocIndex:15},{value:"preventOverlap",paraId:72,tocIndex:15},{value:"Boolean",paraId:72,tocIndex:15},{value:"false",paraId:72,tocIndex:15},{value:"false",paraId:72,tocIndex:15},{value:"是否防止节点之间以及 combo 之间的重叠，若开启，则 ",paraId:72,tocIndex:15},{value:"preventNodeOverlap",paraId:72,tocIndex:15},{value:" 与 ",paraId:72,tocIndex:15},{value:"preventComboOverlap",paraId:72,tocIndex:15},{value:" 将均被开启。详见 ",paraId:72,tocIndex:15},{value:"preventNodeOverlap",paraId:72,tocIndex:15},{value:" 与 ",paraId:72,tocIndex:15},{value:"preventComboOverlap",paraId:72,tocIndex:15},{value:" 介绍",paraId:72,tocIndex:15},{value:"preventNodeOverlap",paraId:72,tocIndex:15},{value:"Boolean",paraId:72,tocIndex:15},{value:"false",paraId:72,tocIndex:15},{value:"true",paraId:72,tocIndex:15},{value:"是否防止节点之间的重叠。必须配合下面属性 ",paraId:72,tocIndex:15},{value:"nodeSize",paraId:72,tocIndex:15},{value:" 或节点数据中的 ",paraId:72,tocIndex:15},{value:"size",paraId:72,tocIndex:15},{value:" 属性，只有在数据中设置了 ",paraId:72,tocIndex:15},{value:"size",paraId:72,tocIndex:15},{value:" 或在该布局中配置了与当前图节点大小相同的 ",paraId:72,tocIndex:15},{value:"nodeSize",paraId:72,tocIndex:15},{value:" 值，才能够进行节点重叠的碰撞检测",paraId:72,tocIndex:15},{value:"preventComboOverlap",paraId:72,tocIndex:15},{value:"Boolean",paraId:72,tocIndex:15},{value:"false",paraId:72,tocIndex:15},{value:"true",paraId:72,tocIndex:15},{value:"是否防止 combo 之间的重叠",paraId:72,tocIndex:15},{value:"collideStrength",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.1",paraId:72,tocIndex:15},{value:"undefined",paraId:72,tocIndex:15},{value:"统一设置防止节点之间以及 combo 之间重叠的力强度，范围 [0, 1]。若 ",paraId:72,tocIndex:15},{value:"collideStrength",paraId:72,tocIndex:15},{value:" 不为 ",paraId:72,tocIndex:15},{value:"undefined",paraId:72,tocIndex:15},{value:"，则 ",paraId:72,tocIndex:15},{value:"nodeCollideStrength",paraId:72,tocIndex:15},{value:" 与 ",paraId:72,tocIndex:15},{value:"comboCollideStrength",paraId:72,tocIndex:15},{value:" 将均被设置为统一的值",paraId:72,tocIndex:15},{value:"nodeCollideStrength",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.4",paraId:72,tocIndex:15},{value:"0.5",paraId:72,tocIndex:15},{value:"设置防止节点之间重叠的力强度，范围 [0, 1]",paraId:72,tocIndex:15},{value:"comboCollideStrength",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.4",paraId:72,tocIndex:15},{value:"0.5",paraId:72,tocIndex:15},{value:"防止 combo 之间重叠的力强度，范围 [0, 1]",paraId:72,tocIndex:15},{value:"nodeSize",paraId:72,tocIndex:15},{value:"Array / Number",paraId:72,tocIndex:15},{value:"10",paraId:72,tocIndex:15},{value:"10",paraId:72,tocIndex:15},{value:"节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:72,tocIndex:15},{value:"size",paraId:72,tocIndex:15},{value:"，则默认大小为 ",paraId:72,tocIndex:15},{value:"10",paraId:72,tocIndex:15},{value:"nodeSpacing",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1 : 10",paraId:72,tocIndex:15},{value:"示例 2 : ",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一个节点",paraId:72,tocIndex:15},{value:"  if (d.id === 'node1') {",paraId:72,tocIndex:15},{value:"    return 100;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 10;",paraId:72,tocIndex:15},{value:"}",paraId:72,tocIndex:15},{value:"0",paraId:72,tocIndex:15},{value:"preventNodeOverlap",paraId:72,tocIndex:15},{value:" 或 ",paraId:72,tocIndex:15},{value:"preventOverlap",paraId:72,tocIndex:15},{value:" 为 ",paraId:72,tocIndex:15},{value:"true",paraId:72,tocIndex:15},{value:" 时生效, 防止重叠时节点边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:72,tocIndex:15},{value:"comboSpacing",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1 : 10",paraId:72,tocIndex:15},{value:"示例 2 : ",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一个节点",paraId:72,tocIndex:15},{value:"  if (d.id === 'node1') {",paraId:72,tocIndex:15},{value:"    return 100;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 10;",paraId:72,tocIndex:15},{value:"}",paraId:72,tocIndex:15},{value:"0",paraId:72,tocIndex:15},{value:"preventComboOverlap",paraId:72,tocIndex:15},{value:" 或 ",paraId:72,tocIndex:15},{value:"preventOverlap",paraId:72,tocIndex:15},{value:" 为 ",paraId:72,tocIndex:15},{value:"true",paraId:72,tocIndex:15},{value:" 时生效, 防止重叠时 combo 边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距, 如示例 2 所示",paraId:72,tocIndex:15},{value:"comboPadding",paraId:72,tocIndex:15},{value:"Number / Function",paraId:72,tocIndex:15},{value:"示例 1 : 10",paraId:72,tocIndex:15},{value:"示例 2 : ",paraId:72,tocIndex:15},{value:"d => {",paraId:72,tocIndex:15},{value:"  // d 是一个节点",paraId:72,tocIndex:15},{value:"  if (d.id === 'node1') {",paraId:72,tocIndex:15},{value:"    return 100;",paraId:72,tocIndex:15},{value:"  }",paraId:72,tocIndex:15},{value:"  return 10;",paraId:72,tocIndex:15},{value:"}",paraId:72,tocIndex:15},{value:"0",paraId:72,tocIndex:15},{value:"Combo 内部的 padding 值，不用于渲染，仅用于计算力。推荐设置为与视图上 combo 内部 padding 值相同的值",paraId:72,tocIndex:15},{value:"alphaDecay",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.03",paraId:72,tocIndex:15},{value:"0.028",paraId:72,tocIndex:15},{value:"迭代阈值的衰减率。范围 [0, 1]，0.028 对应迭代数为 300",paraId:72,tocIndex:15},{value:"alphaMin",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.03",paraId:72,tocIndex:15},{value:"0.001",paraId:72,tocIndex:15},{value:"停止迭代的阈值",paraId:72,tocIndex:15},{value:"alpha",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.1",paraId:72,tocIndex:15},{value:"1",paraId:72,tocIndex:15},{value:"当前阈值",paraId:72,tocIndex:15},{value:"onTick",paraId:72,tocIndex:15},{value:"Function",paraId:72,tocIndex:15},{value:"{}",paraId:72,tocIndex:15},{value:"每一次迭代的回调函数",paraId:72,tocIndex:15},{value:"onLayoutEnd",paraId:72,tocIndex:15},{value:"Function",paraId:72,tocIndex:15},{value:"{}",paraId:72,tocIndex:15},{value:"布局完成后的回调函数",paraId:72,tocIndex:15},{value:"gravity",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"10",paraId:72,tocIndex:15},{value:"重力的大小，影响布局的紧凑程度",paraId:72,tocIndex:15},{value:"comboGravity",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"30",paraId:72,tocIndex:15},{value:"每个 combo 内部的重力大小，影响聚类的紧凑程度",paraId:72,tocIndex:15},{value:"optimizeRangeFactor",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"1",paraId:72,tocIndex:15},{value:"优化计算性能，两节点间距超过 ",paraId:72,tocIndex:15},{value:"optimizeRangeFactor * width",paraId:72,tocIndex:15},{value:" 则不再计算斥力和重叠斥力。通过合理设置该参数可以较少计算量",paraId:72,tocIndex:15},{value:"depthAttractiveForceScale",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.5",paraId:72,tocIndex:15},{value:"根据边两端节点层级差距的调整引力的系数的因子，取值范围 [0, 1]。层级差距越大，引力越小",paraId:72,tocIndex:15},{value:"depthRepulsiveForceScale",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"2",paraId:72,tocIndex:15},{value:"根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大",paraId:72,tocIndex:15},{value:"velocityDecay",paraId:72,tocIndex:15},{value:"Number",paraId:72,tocIndex:15},{value:"0.4",paraId:72,tocIndex:15},{value:"0.6",paraId:72,tocIndex:15},{value:"每个迭代节点运动速度衰减参数",paraId:72,tocIndex:15},{value:"workerEnabled",paraId:72,tocIndex:15},{value:"Boolean",paraId:72,tocIndex:15},{value:"true / false",paraId:72,tocIndex:15},{value:"false",paraId:72,tocIndex:15},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:72,tocIndex:15},{value:"API",paraId:73,tocIndex:16},{value:"：",paraId:73,tocIndex:16},{value:"Combo Combined API",paraId:74,tocIndex:16},{value:"参数",paraId:73,tocIndex:16},{value:"：",paraId:73,tocIndex:16},{value:"参数名",paraId:75,tocIndex:16},{value:"类型",paraId:75,tocIndex:16},{value:"示例",paraId:75,tocIndex:16},{value:"默认值",paraId:75,tocIndex:16},{value:"说明",paraId:75,tocIndex:16},{value:"center",paraId:75,tocIndex:16},{value:"Array",paraId:75,tocIndex:16},{value:"[ 0, 0 ]",paraId:75,tocIndex:16},{value:"图的中心",paraId:75,tocIndex:16},{value:"布局的中心",paraId:75,tocIndex:16},{value:"nodeSize",paraId:75,tocIndex:16},{value:"Array / Number",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"节点大小（直径）。用于碰撞检测。若不指定，则根据传入的节点的 size 属性计算。若即不指定，节点中也没有 ",paraId:75,tocIndex:16},{value:"size",paraId:75,tocIndex:16},{value:"，则默认大小为 ",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"spacing",paraId:75,tocIndex:16},{value:"Number / Function",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"0",paraId:75,tocIndex:16},{value:"preventNodeOverlap",paraId:75,tocIndex:16},{value:" 或 ",paraId:75,tocIndex:16},{value:"preventOverlap",paraId:75,tocIndex:16},{value:" 为 ",paraId:75,tocIndex:16},{value:"true",paraId:75,tocIndex:16},{value:" 时生效, 防止重叠时节点/ combo 边缘间距的最小值。可以是回调函数, 为不同节点设置不同的最小间距",paraId:75,tocIndex:16},{value:"comboPadding",paraId:75,tocIndex:16},{value:"Number / Function",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"10",paraId:75,tocIndex:16},{value:"Combo 内部的 padding 值，不用于渲染，仅用于计算力。推荐设置为与视图上 combo 内部 padding 值相同的值",paraId:75,tocIndex:16},{value:"outerLayout",paraId:75,tocIndex:16},{value:"Object",paraId:75,tocIndex:16},{value:"GForce 实例",paraId:75,tocIndex:16},{value:"ForceAtlas2 实例",paraId:75,tocIndex:16},{value:"最外层的布局算法，需要使用同步的布局算法，默认为 gForce。具体参数详见被使用布局的文档",paraId:75,tocIndex:16},{value:"innerLayout",paraId:75,tocIndex:16},{value:"Object",paraId:75,tocIndex:16},{value:"Concentric 实例",paraId:75,tocIndex:16},{value:"Grid 实例",paraId:75,tocIndex:16},{value:"combo 内部的布局算法，默认为 concentric。具体参数详见被使用布局的文档",paraId:75,tocIndex:16},{value:"workerEnabled",paraId:75,tocIndex:16},{value:"Boolean",paraId:75,tocIndex:16},{value:"true / false",paraId:75,tocIndex:16},{value:"false",paraId:75,tocIndex:16},{value:"是否启用 web-worker 以防布局计算时间过长阻塞页面交互",paraId:75,tocIndex:16}]},44266:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 提供了两种关于布局的切换机制：",paraId:0},{value:"updateLayout(params)",paraId:1},{value:"：布局方法或参数的切换；",paraId:1},{value:"changeData()",paraId:1},{value:"：数据的切换。",paraId:1},{value:"接口定义：",paraId:2,tocIndex:0},{value:"/**\n * 更换布局或布局参数\n * @param {String | object} cfg 新布局配置项\n * 若 cfg 为 String 或含有 type 字段，且与之前的布局方法不同时将会更换布局\n * 否则只是更新原有布局的参数\n */\nupdateLayout(cfg);\n",paraId:3,tocIndex:0},{value:"布局方法切换：",paraId:4,tocIndex:0},{value:"若参数  ",paraId:4,tocIndex:0},{value:"cfg",paraId:4,tocIndex:0},{value:" 为 ",paraId:4,tocIndex:0},{value:"String",paraId:4,tocIndex:0},{value:" 或是含有 ",paraId:4,tocIndex:0},{value:"type",paraId:4,tocIndex:0},{value:" 字段的对象，且与之前的布局方法名不同时将会更换布局。",paraId:4,tocIndex:0},{value:"布局参数切换：",paraId:5,tocIndex:0},{value:"若参数  ",paraId:5,tocIndex:0},{value:"cfg",paraId:5,tocIndex:0},{value:"  是对象且其中不含有 ",paraId:5,tocIndex:0},{value:"type",paraId:5,tocIndex:0},{value:" 字段，或指定的布局方法名称与之前的布局方法相同，则保持原有布局方法，仅更新该布局的参数。",paraId:5,tocIndex:0},{value:"接口定义：",paraId:6,tocIndex:1},{value:"/**\n * 更改源数据，根据新数据重新渲染视图\n * @param {object} data 源数据\n * @return {object} this\n */\nchangeData(data);\n",paraId:7,tocIndex:1},{value:"初始化时使用默认 random 布局，2000 ms 后更换为允许节点重叠的 force 布局，4000 ms 后更换为不允许节点重叠的 force 布局，6000 ms 后更换数据为 ",paraId:8,tocIndex:3},{value:"data2",paraId:8,tocIndex:3},{value:"。",paraId:8,tocIndex:3},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Layout Demo</title>\n  </head>\n  <body>\n    <div id=\"mountNode\"></div>\n    <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script>\n    <script src=\"https://gw.alipayobjects.com/os/antv/assets/lib/jquery-3.2.1.min.js\"><\/script>\n    <script>\n      const data = {\n        nodes: [\n          { id: '0', label: '0' },\n          { id: '1', label: '1' },\n          { id: '2', label: '2' },\n          { id: '3', label: '3' },\n          { id: '4', label: '4' },\n        ],\n        edges: [\n          { source: '0', target: '1' },\n          { source: '0', target: '2' },\n          { source: '0', target: '3' },\n          { source: '0', target: '4' },\n          { source: '1', target: '2' },\n          { source: '1', target: '3' },\n        ],\n      };\n\n      const data2 = {\n        nodes: [\n          { id: '0', label: '0' },\n          { id: '1', label: '1' },\n          { id: '2', label: '2' },\n        ],\n        edges: [\n          { source: '0', target: '1' },\n          { source: '0', target: '2' },\n        ],\n      };\n\n      const graph = new G6.Graph({\n        container: 'mountNode', // String | HTMLElement，必须，容器 id 或容器本身\n        width: 300, // Number，必须，图的宽度\n        height: 300, // Number，必须，图的高度\n        animate: true, // Boolean，可选，切换布局时是否使用动画过度\n      });\n\n      // 读取数据和渲染\n      graph.data(data);\n      graph.render();\n\n      // 2000 ms 后切换为允许节点重叠的 force 布局\n      setTimeout(() => {\n        graph.updateLayout('force'); // 参数为 String 代表布局名称\n      }, 8000);\n\n      // 4000 ms 后切换为不允许节点重叠且边长为 100 的 force 布局。\n      setTimeout(() => {\n        graph.updateLayout({\n          type: 'force', // 布局名称\n          preventOverlap: true, // 布局参数，是否允许重叠\n          nodeSize: 40, // 布局参数，节点大小，用于判断节点是否重叠\n          linkDistance: 100, // 布局参数，边长\n        });\n      }, 10000);\n\n      // 6000 ms 后切换数据为 data2\n      setTimeout(() => {\n        graph.changeData(data2);\n      }, 12000);\n    <\/script>\n  </body>\n</html>\n",paraId:9,tocIndex:4}]},16044:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"v4.3.0 新增",paraId:0,tocIndex:0},{value:"，支持在 Graph.layout 中同时配置多个子图布局。",paraId:0,tocIndex:0},{value:"在实例化图时配置 layout.pipes 数组，指定多个子图布局的布局类型（",paraId:1,tocIndex:1},{value:"type",paraId:1,tocIndex:1},{value:"）、布局参数、节点过滤函数（",paraId:1,tocIndex:1},{value:"nodesFilter",paraId:1,tocIndex:1},{value:"）。值得注意的是，若某些节点同时属于不同的子图（即这些节点在不同的子图的 ",paraId:1,tocIndex:1},{value:"nodesFilter",paraId:1,tocIndex:1},{value:" 配置都返回为 true），则这些节点位置的计算将按照 pipes 数组顺序后者覆盖前者。",paraId:1,tocIndex:1},{value:"layout.pipes",paraId:2,tocIndex:1},{value:" 的数据类型如下：",paraId:2,tocIndex:1},{value:"type Pipes =\n  {\n    // 该子图所使用的布局类型\n    type: 'random' | 'radial' | 'mds' | 'circular' | 'fruchterman' | 'force' | 'gForce' | 'dagre' | 'concentric' | 'grid' | 'forceAtlas2',\n    // 节点的筛选器，参数为节点数据，返回布尔值代表该节点是否在该子图中\n    nodesFilter: (node: NodeData) => boolean;\n    ... // 布局对应的参数，详见各个布局的参数\n  }[];\n",paraId:3,tocIndex:1},{value:"使用示例：",paraId:4,tocIndex:1},{value:"// 在实例化图时配置 layout.pipes\nconst graph = new G6.Graph({\n  // ...                      // 其他配置项\n  layout: {\n    pipes: [\n      {\n        // 该子图所使用的布局类型\n        type: 'circular',\n        // 根据节点的某个字段判断是否属于该子图\n        nodesFilter: (node) => node.subGraphId === '1',\n        // ... 可配置该 circular 布局的参数，详见各布局文档\n      },\n      {\n        type: 'grid',\n        nodesFilter: (node) => node.subGraphId === '2',\n        // 该 grid 布局的其他参数\n        begin: [100, 0],\n      }\n    ]\n  },\n});\n",paraId:5,tocIndex:1}]},75565:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"目前，子图布局独立与全局布局的思路，与 graph 不挂钩，直接使用实例化布局方法的方式，灌入子图数据，通过布局将位置写到相应数据中。这种机制还可供外部的全局布局使用，即使不用 G6 渲染，也可以计算节点布局后的位置。",paraId:0,tocIndex:0},{value:"v4.3.0 新增流水线子图布局",paraId:1,tocIndex:0},{value:"，支持在 Graph.layout 中同时配置多个子图布局。详见",paraId:1,tocIndex:0},{value:"流水线子图布局教程",paraId:2,tocIndex:0},{value:"。",paraId:1,tocIndex:0},{value:"// 实例化布局\nconst subgraphLayout = new G6.Layout['force']({\n  center: [500, 450],\n});\n\n// 初始化布局，灌入子图数据\nsubgraphLayout.init({\n  nodes: subGraphNodes,\n  edges: subGraphEdges,\n});\n\n// 执行布局\nsubgraphLayout.execute();\n\n// 图实例根据数据更新节点位置\ngraph.positionsAnimate();\n",paraId:3,tocIndex:1}]},58340:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图布局是指图中节点的排布方式，根据图的数据结构不同，布局可以分为两类：一般图布局、树图布局。G6 为这两类图都内置了一些常用的图布局算法。使用内置的图布局可以完成",paraId:0,tocIndex:0},{value:"布局的参数、方法、数据的切换",paraId:1,tocIndex:0},{value:"等。G6 还提供了一般图布局的 ",paraId:0,tocIndex:0},{value:"Web-Worker 机制",paraId:2,tocIndex:0},{value:"，在大规模图布局中使用该机制可以使布局计算不阻塞页面。",paraId:0,tocIndex:0},{value:"除了内置布局方法外，一般图布局还支持 ",paraId:3,tocIndex:0},{value:"自定义布局",paraId:4,tocIndex:0},{value:" 机制。",paraId:3,tocIndex:0},{value:"事实上，G6 的布局是自由的，内置布局算法仅仅是操作了数据中节点的 ",paraId:5,tocIndex:0},{value:"x",paraId:5,tocIndex:0},{value:" 和 ",paraId:5,tocIndex:0},{value:"y",paraId:5,tocIndex:0},{value:" 值。因此，除了使用内置布局以及自定义的一般图布局外，用户还可以使用外部图布局算法，计算节点位置后赋值到数据中节点的 ",paraId:5,tocIndex:0},{value:"x",paraId:5,tocIndex:0},{value:" 和 ",paraId:5,tocIndex:0},{value:"y",paraId:5,tocIndex:0},{value:" 字段上，G6 便可以根据该位置信息进行绘制。",paraId:5,tocIndex:0},{value:"由于树图特殊性，G6 扩展出了  TreeGraph ，详细文档请见：",paraId:6,tocIndex:0},{value:"TreeGraph",paraId:7,tocIndex:0},{value:" API。树布局是一种能很好展示有一定层次结构数据的布局方式。推荐使用 G6.TreeGraph 实现。本文将逐一介绍内置的树图布局算法，及其使用方式。",paraId:6,tocIndex:0},{value:"CompactBox Layout",paraId:8,tocIndex:1},{value:"：紧凑树布局；",paraId:9,tocIndex:1},{value:"Dendrogram Layout",paraId:10,tocIndex:1},{value:"：树状布局（叶子节点布局对齐到同一层）；",paraId:9,tocIndex:1},{value:"Indented Layout",paraId:11,tocIndex:1},{value:"：缩进布局；",paraId:9,tocIndex:1},{value:"Mindmap Layout",paraId:12,tocIndex:1},{value:"：脑图布局。",paraId:9,tocIndex:1},{value:"与一般图 Graph 配置方法相似，通过实例化图时配置 ",paraId:13,tocIndex:2},{value:"layout",paraId:13,tocIndex:2},{value:" 属性设置树的布局，还可以通过 ",paraId:13,tocIndex:2},{value:"modes",paraId:13,tocIndex:2},{value:" 属性为树配置 ",paraId:13,tocIndex:2},{value:"展开/收缩行为",paraId:14,tocIndex:2},{value:"。以下代码声明了一个实例，定义了布局为从左到右结构的基础树图，并且定义了展开收缩行为。",paraId:13,tocIndex:2},{value:"const graph = new G6.TreeGraph({\n  container: 'mountNode',\n  modes: {\n    default: [\n      {\n        // 定义展开/收缩行为\n        type: 'collapse-expand',\n      },\n      'drag-canvas',\n    ],\n  },\n  // 定义布局\n  layout: {\n    type: 'dendrogram', // 布局类型\n    direction: 'LR', // 自左至右布局，可选的有 H / V / LR / RL / TB / BT\n    nodeSep: 50, // 节点之间间距\n    rankSep: 100, // 每个层级之间的间距\n    excludeInvisibles: true, // 布局计算是否排除掉隐藏的节点，v4.8.8 起支持\n  },\n});\n",paraId:15,tocIndex:2},{value:"描述",paraId:16,tocIndex:4},{value:"：紧凑树布局。从根节点开始，同一深度的节点在同一层，并且布局时会将节点大小考虑进去。",paraId:16,tocIndex:4},{value:"API",paraId:16,tocIndex:4},{value:"：",paraId:16,tocIndex:4},{value:"CompactBox API",paraId:17,tocIndex:4},{value:"参数",paraId:16,tocIndex:4},{value:"：",paraId:16,tocIndex:4},{value:"参数名",paraId:18,tocIndex:4},{value:"类型",paraId:18,tocIndex:4},{value:"示例/可选值",paraId:18,tocIndex:4},{value:"默认值",paraId:18,tocIndex:4},{value:"说明",paraId:18,tocIndex:4},{value:"direction",paraId:18,tocIndex:4},{value:"String",paraId:18,tocIndex:4},{value:"'TB' / 'BT' / 'LR' / 'RL' / 'H' / 'V'",paraId:18,tocIndex:4},{value:"'LR'",paraId:18,tocIndex:4},{value:"layout 的方向。",paraId:18,tocIndex:4},{value:"- TB —— 根节点在上，往下布局",paraId:18,tocIndex:4},{value:"- BT —— 根节点在下，往上布局",paraId:18,tocIndex:4},{value:"     ",paraId:18,tocIndex:4},{value:"（左）TB。（右）BT。",paraId:18,tocIndex:4},{value:"- LR —— 根节点在左，往右布局",paraId:18,tocIndex:4},{value:"- RL —— 根节点在右，往左布局",paraId:18,tocIndex:4},{value:"             ",paraId:18,tocIndex:4},{value:" ",paraId:18,tocIndex:4},{value:"（左）LR。（右）RL。",paraId:18,tocIndex:4},{value:"- H —— 根节点在中间，水平对称布局",paraId:18,tocIndex:4},{value:"- V —— 根节点在中间，垂直对称布局",paraId:18,tocIndex:4},{value:"          ",paraId:18,tocIndex:4},{value:"> （左）H。（右）V。",paraId:18,tocIndex:4},{value:"getId",paraId:18,tocIndex:4},{value:"Function",paraId:18,tocIndex:4},{value:"(d) => {",paraId:18,tocIndex:4},{value:"  // d 是一个节点",paraId:18,tocIndex:4},{value:"  return d.id + 'node';",paraId:18,tocIndex:4},{value:"}",paraId:18,tocIndex:4},{value:"undefined",paraId:18,tocIndex:4},{value:"节点 id 的回调函数",paraId:18,tocIndex:4},{value:"getHeight",paraId:18,tocIndex:4},{value:"Function",paraId:18,tocIndex:4},{value:"(d) => {",paraId:18,tocIndex:4},{value:"  // d 是一个节点",paraId:18,tocIndex:4},{value:"  return 10;",paraId:18,tocIndex:4},{value:"}",paraId:18,tocIndex:4},{value:"undefined",paraId:18,tocIndex:4},{value:"节点高度的回调函数",paraId:18,tocIndex:4},{value:"getWidth",paraId:18,tocIndex:4},{value:"Function",paraId:18,tocIndex:4},{value:"(d) => {",paraId:18,tocIndex:4},{value:"  // d 是一个节点",paraId:18,tocIndex:4},{value:"  return 20;",paraId:18,tocIndex:4},{value:"}",paraId:18,tocIndex:4},{value:"undefined",paraId:18,tocIndex:4},{value:"节点宽度的回调函数",paraId:18,tocIndex:4},{value:"getVGap",paraId:18,tocIndex:4},{value:"Function",paraId:18,tocIndex:4},{value:"(d) => {",paraId:18,tocIndex:4},{value:"  // d 是一个节点",paraId:18,tocIndex:4},{value:"  return 100;",paraId:18,tocIndex:4},{value:"}",paraId:18,tocIndex:4},{value:"undefined",paraId:18,tocIndex:4},{value:"节点纵向间距的回调函数",paraId:18,tocIndex:4},{value:"getHGap",paraId:18,tocIndex:4},{value:"Function",paraId:18,tocIndex:4},{value:"(d) => {",paraId:18,tocIndex:4},{value:"// d 是一个节点",paraId:18,tocIndex:4},{value:"  return 50;",paraId:18,tocIndex:4},{value:"}",paraId:18,tocIndex:4},{value:"undefined",paraId:18,tocIndex:4},{value:"节点横向间距的回调函数",paraId:18,tocIndex:4},{value:"radial",paraId:18,tocIndex:4},{value:"Boolean",paraId:18,tocIndex:4},{value:"true",paraId:18,tocIndex:4},{value:"false",paraId:18,tocIndex:4},{value:"是否按照辐射状布局。若 ",paraId:18,tocIndex:4},{value:"radial",paraId:18,tocIndex:4},{value:" 为 ",paraId:18,tocIndex:4},{value:"true",paraId:18,tocIndex:4},{value:"，建议 ",paraId:18,tocIndex:4},{value:"direction",paraId:18,tocIndex:4},{value:" 设置为 ",paraId:18,tocIndex:4},{value:"'LR'",paraId:18,tocIndex:4},{value:" 或 ",paraId:18,tocIndex:4},{value:"'RL'",paraId:18,tocIndex:4},{value:"：",paraId:18,tocIndex:4},{value:"描述",paraId:19,tocIndex:5},{value:"：生态树布局。不管数据的深度多少，总是叶节点对齐。不考虑节点大小，布局时将节点视为 1 个像素点。",paraId:19,tocIndex:5},{value:"API",paraId:19,tocIndex:5},{value:"：",paraId:19,tocIndex:5},{value:"Dendrogram API",paraId:20,tocIndex:5},{value:"参数",paraId:19,tocIndex:5},{value:"：",paraId:19,tocIndex:5},{value:"参数名",paraId:21,tocIndex:5},{value:"类型",paraId:21,tocIndex:5},{value:"示例/可选值",paraId:21,tocIndex:5},{value:"默认值",paraId:21,tocIndex:5},{value:"说明",paraId:21,tocIndex:5},{value:"direction",paraId:21,tocIndex:5},{value:"String",paraId:21,tocIndex:5},{value:"'TB' / 'BT' / 'LR' / 'RL' / 'H' / 'V'",paraId:21,tocIndex:5},{value:"'LR'",paraId:21,tocIndex:5},{value:"layout 的方向。",paraId:21,tocIndex:5},{value:"- TB —— 根节点在上，往下布局",paraId:21,tocIndex:5},{value:"- BT —— 根节点在下，往上布局",paraId:21,tocIndex:5},{value:"> （左）TB。（右）BT。",paraId:21,tocIndex:5},{value:"- LR —— 根节点在左，往右布局",paraId:21,tocIndex:5},{value:"- RL —— 根节点在右，往左布局",paraId:21,tocIndex:5},{value:"> （左）LR。（右）RL。",paraId:21,tocIndex:5},{value:"- H —— 根节点在中间，水平对称布局",paraId:21,tocIndex:5},{value:"- V —— 根节点在中间，垂直对称布局",paraId:21,tocIndex:5},{value:"> （左）H。（右）V。",paraId:21,tocIndex:5},{value:"nodeSep",paraId:21,tocIndex:5},{value:"Number",paraId:21,tocIndex:5},{value:"50",paraId:21,tocIndex:5},{value:"0",paraId:21,tocIndex:5},{value:"节点间距",paraId:21,tocIndex:5},{value:"rankSep",paraId:21,tocIndex:5},{value:"Number",paraId:21,tocIndex:5},{value:"100",paraId:21,tocIndex:5},{value:"0",paraId:21,tocIndex:5},{value:"层与层之间的间距",paraId:21,tocIndex:5},{value:"radial",paraId:21,tocIndex:5},{value:"Boolean",paraId:21,tocIndex:5},{value:"true",paraId:21,tocIndex:5},{value:"false",paraId:21,tocIndex:5},{value:"是否按照辐射状布局。若 ",paraId:21,tocIndex:5},{value:"radial",paraId:21,tocIndex:5},{value:" 为 ",paraId:21,tocIndex:5},{value:"true",paraId:21,tocIndex:5},{value:"，建议 ",paraId:21,tocIndex:5},{value:"direction",paraId:21,tocIndex:5},{value:" 设置为 ",paraId:21,tocIndex:5},{value:"'LR'",paraId:21,tocIndex:5},{value:" 或 ",paraId:21,tocIndex:5},{value:"'RL'",paraId:21,tocIndex:5},{value:"：",paraId:21,tocIndex:5},{value:"描述",paraId:22,tocIndex:6},{value:"：缩进树布局。每个元素会占一行/一列。",paraId:22,tocIndex:6},{value:"API",paraId:23,tocIndex:6},{value:"：",paraId:23,tocIndex:6},{value:"Indented API",paraId:24,tocIndex:6},{value:"参数",paraId:23,tocIndex:6},{value:"：",paraId:23,tocIndex:6},{value:"参数名",paraId:25,tocIndex:6},{value:"类型",paraId:25,tocIndex:6},{value:"示例/可选值",paraId:25,tocIndex:6},{value:"默认值",paraId:25,tocIndex:6},{value:"说明",paraId:25,tocIndex:6},{value:"direction",paraId:25,tocIndex:6},{value:"String",paraId:25,tocIndex:6},{value:"'LR' / 'RL' / 'H'",paraId:25,tocIndex:6},{value:"'LR'",paraId:25,tocIndex:6},{value:"layout 的方向。",paraId:25,tocIndex:6},{value:"'LR' —— 根节点在左，往右布局（下图左）",paraId:25,tocIndex:6},{value:"'RL' —— 根节点在右，往左布局（下图中）",paraId:25,tocIndex:6},{value:"'H' —— 根节点在中间，水平对称布局（下图右）",paraId:25,tocIndex:6},{value:"indent",paraId:25,tocIndex:6},{value:"Number",paraId:25,tocIndex:6},{value:"80",paraId:25,tocIndex:6},{value:"20",paraId:25,tocIndex:6},{value:"列间间距",paraId:25,tocIndex:6},{value:"getHeight",paraId:25,tocIndex:6},{value:"Function",paraId:25,tocIndex:6},{value:"(d) => {",paraId:25,tocIndex:6},{value:"  // d 是一个节点",paraId:25,tocIndex:6},{value:"  return 10;",paraId:25,tocIndex:6},{value:"}",paraId:25,tocIndex:6},{value:"undefined",paraId:25,tocIndex:6},{value:"节点高度的回调函数",paraId:25,tocIndex:6},{value:"getWidth",paraId:25,tocIndex:6},{value:"Function",paraId:25,tocIndex:6},{value:"(d) => {",paraId:25,tocIndex:6},{value:"  // d 是一个节点",paraId:25,tocIndex:6},{value:"  return 20;",paraId:25,tocIndex:6},{value:"}",paraId:25,tocIndex:6},{value:"undefined",paraId:25,tocIndex:6},{value:"节点宽度的回调函数",paraId:25,tocIndex:6},{value:"getSide",paraId:25,tocIndex:6},{value:"Function",paraId:25,tocIndex:6},{value:"(d) => {",paraId:25,tocIndex:6},{value:"  // d 是一个节点",paraId:25,tocIndex:6},{value:"  return 'left';",paraId:25,tocIndex:6},{value:"}",paraId:25,tocIndex:6},{value:"undefined",paraId:25,tocIndex:6},{value:"节点放置在根节点左侧或右侧的回调函数，仅对与根节点直接相连的节点有效，设置后将会影响被设置节点的所有子孙节点",paraId:25,tocIndex:6},{value:"align",paraId:25,tocIndex:6},{value:"'center' / undefined",paraId:25,tocIndex:6},{value:"'center'",paraId:25,tocIndex:6},{value:"undefined",paraId:25,tocIndex:6},{value:"告知 indented 布局，节点在绘制时自身坐标系的原点在其中心还是左上角。所有的内置节点的自身坐标系原点均在中心，例如 'circle' 类型节点的 keyShape 是圆形图形，它的圆心 x、y 被设置为 0，代表原点对齐在该 keyShape 的圆心（即中心）；而 'rect' 类型的内置节点 keyShape 是矩形图形，内置定义中它的 x、y 分别被设置为 ",paraId:25,tocIndex:6},{value:"width / 2",paraId:25,tocIndex:6},{value:" 和 ",paraId:25,tocIndex:6},{value:"height / 2",paraId:25,tocIndex:6},{value:"，意味着矩形的左上角在 [width / 2, height / 2] 坐标上，那么坐标系原点就在矩形的中心。但自定义的 keyShape 为矩形的节点中，矩形的 x、y 可能被设置为 0，那么这一节点类型的自身坐标系原点就在其左上角。从整个图来看，每个节点的自身坐标系原点，将对齐到布局计算的节点位置上（画布绘制坐标系）。根据你使用的节点类型，告知 indented 布局是如何对齐的，可以更准确地计算节点位置，当然，这同时需要配合准确的 ",paraId:25,tocIndex:6},{value:"getWidth",paraId:25,tocIndex:6},{value:" 和 ",paraId:25,tocIndex:6},{value:"getHeight",paraId:25,tocIndex:6},{value:" 的返回值",paraId:25,tocIndex:6},{value:"描述",paraId:26,tocIndex:7},{value:"：脑图布局。深度相同的节点将会被放置在同一层，与 compactBox 不同的是，布局不会考虑节点的大小。",paraId:26,tocIndex:7},{value:"API",paraId:26,tocIndex:7},{value:"：",paraId:26,tocIndex:7},{value:"Mindmap API",paraId:27,tocIndex:7},{value:"参数",paraId:26,tocIndex:7},{value:"：",paraId:26,tocIndex:7},{value:"参数名",paraId:28,tocIndex:7},{value:"类型",paraId:28,tocIndex:7},{value:"示例/可选值",paraId:28,tocIndex:7},{value:"默认值",paraId:28,tocIndex:7},{value:"说明",paraId:28,tocIndex:7},{value:"direction",paraId:28,tocIndex:7},{value:"String",paraId:28,tocIndex:7},{value:"'H' / 'V'",paraId:28,tocIndex:7},{value:"'H'",paraId:28,tocIndex:7},{value:"layout 的方向。",paraId:28,tocIndex:7},{value:"- H：horizontal（水平）—— 根节点的子节点分成两部分横向放置在根节点左右两侧",paraId:28,tocIndex:7},{value:"- V：vertical （竖直）—— 将根节点的所有孩子纵向排列",paraId:28,tocIndex:7},{value:"getHeight",paraId:28,tocIndex:7},{value:"Function",paraId:28,tocIndex:7},{value:"(d) => {",paraId:28,tocIndex:7},{value:"  // d 是一个节点",paraId:28,tocIndex:7},{value:"  return 10;",paraId:28,tocIndex:7},{value:"}",paraId:28,tocIndex:7},{value:"undefined",paraId:28,tocIndex:7},{value:"节点高度的回调函数",paraId:28,tocIndex:7},{value:"getWidth",paraId:28,tocIndex:7},{value:"Function",paraId:28,tocIndex:7},{value:"(d) => {",paraId:28,tocIndex:7},{value:"  // d 是一个节点",paraId:28,tocIndex:7},{value:"  return 20;",paraId:28,tocIndex:7},{value:"}",paraId:28,tocIndex:7},{value:"undefined",paraId:28,tocIndex:7},{value:"节点宽度的回调函数",paraId:28,tocIndex:7},{value:"getVGap",paraId:28,tocIndex:7},{value:"Function",paraId:28,tocIndex:7},{value:"(d) => {",paraId:28,tocIndex:7},{value:"  // d 是一个节点",paraId:28,tocIndex:7},{value:"  return 100;",paraId:28,tocIndex:7},{value:"}",paraId:28,tocIndex:7},{value:"18",paraId:28,tocIndex:7},{value:"节点纵向间距的回调函数",paraId:28,tocIndex:7},{value:"getHGap",paraId:28,tocIndex:7},{value:"Function",paraId:28,tocIndex:7},{value:"(d) => {",paraId:28,tocIndex:7},{value:"  // d 是一个节点",paraId:28,tocIndex:7},{value:"  return 50;",paraId:28,tocIndex:7},{value:"}",paraId:28,tocIndex:7},{value:"18",paraId:28,tocIndex:7},{value:"节点横向间距的回调函数",paraId:28,tocIndex:7},{value:"getSide",paraId:28,tocIndex:7},{value:"String",paraId:28,tocIndex:7},{value:"Function",paraId:28,tocIndex:7},{value:"(d) => {",paraId:28,tocIndex:7},{value:"  // d 是一个节点",paraId:28,tocIndex:7},{value:"  return 'left';",paraId:28,tocIndex:7},{value:"} / 'right'",paraId:28,tocIndex:7},{value:"节点排布在根节点的左侧/右侧。若设置了该值，则所有节点会在根节点同一侧，即 direction = 'H' 不再起效。若该参数为回调函数，则可以指定每一个节点在根节点的左/右侧",paraId:28,tocIndex:7}]},98550:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"在大规模图可视化中，布局算法往往需要较大的计算量。若配置了布局，G6 需要首先完成布局才可以将图渲染出来。然而，在一些应用页面中，这一过程可能会阻塞页面的其他部分用户交互。为了让大规模图布局不阻塞页面，G6 为",paraId:0},{value:"一般图",paraId:0},{value:"布局提供了 Web-Worker 机制。只需要在配置布局时，将 ",paraId:0},{value:"workerEnabled",paraId:0},{value:" 设置为 ",paraId:0},{value:"true",paraId:0},{value:" 即可。如下：",paraId:0},{value:"const graph = new G6.Graph({\n  // ...                      // 其他配置项\n  layout: {\n    // Object，可选，布局的方法及其配置项，默认为 random 布局。\n    type: 'fruchterman',\n    workerEnabled: true, // 开启 Web-Worker\n    // ...                 // 其他配置\n  },\n});\n",paraId:1},{value:"注意：",paraId:2},{value:"树图不支持 Web-Worker 机制；",paraId:3},{value:"子图布局机制暂不支持 Web-Worker 机制；",paraId:3},{value:"worker 使用的是 @antv/layout 线上的脚本，如果你的项目无法访问到线上资源，请保存 ",paraId:3},{value:"layout 脚本",paraId:3},{value:"，并放在可以访问到的地址上，将 layout 的 ",paraId:3},{value:"workerScriptURL",paraId:3},{value:" 配置为该地址即可",paraId:3}]},44046:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"初始化和渲染",paraId:0,tocIndex:0},{value:"图形和属性",paraId:1,tocIndex:1},{value:"关键图形（Key Shape）",paraId:1,tocIndex:1},{value:"图形分组（Shape group)",paraId:1,tocIndex:1},{value:"图形变换 （Transform）",paraId:1,tocIndex:1},{value:"节点\n",paraId:2,tocIndex:2},{value:"内置节点",paraId:3,tocIndex:2},{value:"自定义节点",paraId:3,tocIndex:2},{value:"节点的连接点 anchorPoints",paraId:3,tocIndex:2},{value:"边\n",paraId:2,tocIndex:2},{value:"内置边",paraId:4,tocIndex:2},{value:"自定义边",paraId:4,tocIndex:2},{value:"Combo\n",paraId:2,tocIndex:2},{value:"内置 Combo",paraId:5,tocIndex:2},{value:"自定义 Combo",paraId:5,tocIndex:2},{value:"Combo 机制",paraId:5,tocIndex:2},{value:"创建与拆分 Combo",paraId:5,tocIndex:2},{value:"高级样式\n",paraId:2,tocIndex:2},{value:"设置元素背景",paraId:6,tocIndex:2},{value:"设置元素渐变色",paraId:6,tocIndex:2},{value:"设置纹理",paraId:6,tocIndex:2},{value:"更新文本样式",paraId:6,tocIndex:2},{value:"高级操作\n",paraId:2,tocIndex:2},{value:"更新节点或边的样式",paraId:7,tocIndex:2},{value:"层级调整",paraId:7,tocIndex:2},{value:"显示隐藏",paraId:7,tocIndex:2},{value:"锁定/解锁",paraId:7,tocIndex:2},{value:"内置布局",paraId:8,tocIndex:3},{value:"自定义布局",paraId:8,tocIndex:3},{value:"监听与绑定事件",paraId:9,tocIndex:4},{value:"内置交互行为",paraId:9,tocIndex:4},{value:"自定义交互行为（选读）",paraId:9,tocIndex:4},{value:"交互模式 Mode",paraId:9,tocIndex:4},{value:"全局动画",paraId:10,tocIndex:5},{value:"元素动画",paraId:10,tocIndex:5}]},52422:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 中支持插件提供了一些可插拔的组件，包括：",paraId:0},{value:"Legend",paraId:1},{value:" ",paraId:2},{value:"v4.3.0 起支持",paraId:2},{value:"SnapLine",paraId:3},{value:" ",paraId:2},{value:"v4.3.0 起支持",paraId:2},{value:"Grid",paraId:4},{value:"Minimap",paraId:5},{value:"ImageMinimap",paraId:6},{value:"Edge Bundling",paraId:7},{value:"Menu",paraId:8},{value:"ToolBar",paraId:9},{value:"TimeBar",paraId:10},{value:"Tooltip",paraId:11},{value:"Fisheye",paraId:12},{value:"EdgeFilterLens",paraId:13},{value:"引入 G6 后，首先实例化需要使用的某插件对象。然后，在实例化图时将其配置到 ",paraId:14,tocIndex:0},{value:"plugins",paraId:14,tocIndex:0},{value:" 中：",paraId:14,tocIndex:0},{value:"// 实例化 Grid 插件\nconst grid = new G6.Grid();\nconst minimap = new G6.Minimap();\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [grid, minimap], // 配置 Grid 插件和 Minimap 插件\n});\n",paraId:15,tocIndex:0},{value:"Legend 是 G6 内置的图例插件。用于说明图中不同类型的节点和边所代表的含义，并可以通过与图例的交互做简单的高亮和过滤。 ",paraId:16,tocIndex:1},{value:"v4.3.0 起支持",paraId:16,tocIndex:1},{value:"。",paraId:16,tocIndex:1},{value:"名称",paraId:17,tocIndex:2},{value:"类型",paraId:17,tocIndex:2},{value:"描述",paraId:17,tocIndex:2},{value:"data",paraId:17,tocIndex:2},{value:"GraphData",paraId:17,tocIndex:2},{value:"图例的数据，与图数据格式相同。节点图例目前支持 ",paraId:17,tocIndex:2},{value:"'circle'",paraId:17,tocIndex:2},{value:"，",paraId:17,tocIndex:2},{value:"'rect'",paraId:17,tocIndex:2},{value:"，和 ",paraId:17,tocIndex:2},{value:"'ellipse'",paraId:17,tocIndex:2},{value:"，边图例目前支持 ",paraId:17,tocIndex:2},{value:"'line'",paraId:17,tocIndex:2},{value:"、",paraId:17,tocIndex:2},{value:"'cubic'",paraId:17,tocIndex:2},{value:"、",paraId:17,tocIndex:2},{value:"'quadratic'",paraId:17,tocIndex:2},{value:"。通过指定每个数据项中的 ",paraId:17,tocIndex:2},{value:"type",paraId:17,tocIndex:2},{value:" 字段以确定图例元素的类型，每个数据项中的 ",paraId:17,tocIndex:2},{value:"order",paraId:17,tocIndex:2},{value:" 字段可用于同组图例的排序",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:"'top' / 'top-left' / 'top-right' / 'right' / 'right-top' / 'right-bottom' / 'left' / 'left-top' / 'left-bottom' / 'bottom' / 'bottom-left' / 'bottom-right'",paraId:17,tocIndex:2},{value:"图例在画布中的相对位置，默认为 ",paraId:17,tocIndex:2},{value:"'top'",paraId:17,tocIndex:2},{value:"，代表在画布正上方",paraId:17,tocIndex:2},{value:"padding",paraId:17,tocIndex:2},{value:"number / number[]",paraId:17,tocIndex:2},{value:"图例区域内部内容到边框的距离，四位数组分别代表上、右、下、左边距",paraId:17,tocIndex:2},{value:"margin",paraId:17,tocIndex:2},{value:"number / number[]",paraId:17,tocIndex:2},{value:"图例区域与画布边界的距离，四位数组分别代表上、右、下、左边距。在 ",paraId:17,tocIndex:2},{value:"position:'top'",paraId:17,tocIndex:2},{value:" 时只有上边距生效，其他情况类似",paraId:17,tocIndex:2},{value:"offsetX",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例区域离 ",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:" 对应的默认位置的 x 方向的偏移量，可被用于图例位置的微调",paraId:17,tocIndex:2},{value:"offsetY",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例区域离 ",paraId:17,tocIndex:2},{value:"position",paraId:17,tocIndex:2},{value:" 对应的默认位置的 y 方向的偏移量，可被用于图例位置的微调",paraId:17,tocIndex:2},{value:"containerStyle",paraId:17,tocIndex:2},{value:"ShapeStyle",paraId:17,tocIndex:2},{value:"图例背景框的样式，格式与 ",paraId:17,tocIndex:2},{value:"rect 图形的样式",paraId:18,tocIndex:2},{value:"相同",paraId:17,tocIndex:2},{value:"horiSep",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例之间的水平间距",paraId:17,tocIndex:2},{value:"vertiSep",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例之间的竖直间距",paraId:17,tocIndex:2},{value:"layout",paraId:17,tocIndex:2},{value:"'vertical' / 'horizontal'",paraId:17,tocIndex:2},{value:"图例的布局方式。默认为 ",paraId:17,tocIndex:2},{value:"'horizontal'",paraId:17,tocIndex:2},{value:" 横向布局",paraId:17,tocIndex:2},{value:"align",paraId:17,tocIndex:2},{value:"'center' / 'right' / 'left'",paraId:17,tocIndex:2},{value:"图例的对齐方式，可以是居中、右对齐、左对齐。默认为 ",paraId:17,tocIndex:2},{value:"'center'",paraId:17,tocIndex:2},{value:" 居中",paraId:17,tocIndex:2},{value:"title",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"图例的标题文本内容，样式通过 ",paraId:17,tocIndex:2},{value:"titleConfig",paraId:17,tocIndex:2},{value:" 设置",paraId:17,tocIndex:2},{value:"titleConfig",paraId:17,tocIndex:2},{value:"object",paraId:17,tocIndex:2},{value:"图例标题的样式，具体配置项如下",paraId:17,tocIndex:2},{value:"titleConfig.position",paraId:17,tocIndex:2},{value:"'center' / 'right' / 'left'",paraId:17,tocIndex:2},{value:"图例标题的对齐方式，可以是居中、右对齐、左对齐。默认为 ",paraId:17,tocIndex:2},{value:"'center'",paraId:17,tocIndex:2},{value:" 居中",paraId:17,tocIndex:2},{value:"titleConfig.offsetX",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例标题的 x 方向偏移，用于微调标题位置",paraId:17,tocIndex:2},{value:"titleConfig.offsetY",paraId:17,tocIndex:2},{value:"number",paraId:17,tocIndex:2},{value:"图例标题的 y 方向偏移，用于微调标题位置",paraId:17,tocIndex:2},{value:"titleConfig[key]",paraId:17,tocIndex:2},{value:"ShapeStyle",paraId:17,tocIndex:2},{value:"其他对于文本本身的样式，支持的内容与 ",paraId:17,tocIndex:2},{value:"text 图形的样式",paraId:19,tocIndex:2},{value:"相同",paraId:17,tocIndex:2},{value:"filter",paraId:17,tocIndex:2},{value:"object",paraId:17,tocIndex:2},{value:"通过图例的交互对主图元素进行过滤的配置项，具体配置如下",paraId:17,tocIndex:2},{value:"filter.enable",paraId:17,tocIndex:2},{value:"boolean",paraId:17,tocIndex:2},{value:"是否允许通过图例的交互对主图元素过滤，默认为 ",paraId:17,tocIndex:2},{value:"false",paraId:17,tocIndex:2},{value:"filter.multiple",paraId:17,tocIndex:2},{value:"boolean",paraId:17,tocIndex:2},{value:"是否支持多种元素过滤，默认为 ",paraId:17,tocIndex:2},{value:"false",paraId:17,tocIndex:2},{value:"，只有 ",paraId:17,tocIndex:2},{value:"filter.trigger",paraId:17,tocIndex:2},{value:" 为 ",paraId:17,tocIndex:2},{value:"'click'",paraId:17,tocIndex:2},{value:" 时方可多选图例",paraId:17,tocIndex:2},{value:"filter.trigger",paraId:17,tocIndex:2},{value:"'click' / 'mouseenter'",paraId:17,tocIndex:2},{value:"触发主图元素过滤的图例交互方式，默认为 ",paraId:17,tocIndex:2},{value:"click",paraId:17,tocIndex:2},{value:"filter.legendStateStyles",paraId:17,tocIndex:2},{value:"{ active?: ShapeStyle, inactive?: ShapeStyle",paraId:17,tocIndex:2},{value:"在过滤时，图例本身的状态样式，包括 ",paraId:17,tocIndex:2},{value:"filter.legendStateStyles.active",paraId:17,tocIndex:2},{value:" 和 ",paraId:17,tocIndex:2},{value:"filter.legendStateStyles.inactive",paraId:17,tocIndex:2},{value:" 两种，每种的类型均为 ShapeStyle。类似图的 ",paraId:17,tocIndex:2},{value:"nodeStateStyles",paraId:17,tocIndex:2},{value:" 配置",paraId:17,tocIndex:2},{value:"filter.graphActiveState",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"主图元素过滤时，被选中的主图元素的状态名，将寻找主图元素的对应的状态样式进行主图元素的更新。默认值为 ",paraId:17,tocIndex:2},{value:"'active'",paraId:17,tocIndex:2},{value:"filter.graphInactiveState",paraId:17,tocIndex:2},{value:"string",paraId:17,tocIndex:2},{value:"主图元素过滤时，未被选中的主图元素的状态名，将寻找主图元素的对应的状态样式进行主图元素的更新。默认值为 ",paraId:17,tocIndex:2},{value:"'inactive'",paraId:17,tocIndex:2},{value:"filter.filterFunctions",paraId:17,tocIndex:2},{value:"{ [key: string]: (d) => boolean; }",paraId:17,tocIndex:2},{value:"由于图例的数据与主图解耦，因此需要配置每种图例对应的主图过滤函数，",paraId:17,tocIndex:2},{value:"key",paraId:17,tocIndex:2},{value:" 为图例数据的 ",paraId:17,tocIndex:2},{value:"type",paraId:17,tocIndex:2},{value:"，值为函数，函数的参数为主图元素的数据，返回值为布尔型，代表是否被选中",paraId:17,tocIndex:2},{value:"SnapLine 是 G6 内置的对齐线插件。 ",paraId:20,tocIndex:3},{value:"v4.3.0 起支持",paraId:20,tocIndex:3},{value:"。",paraId:20,tocIndex:3},{value:"实例化时可以通过配置项调整 SnapLine 的样式和功能。",paraId:21,tocIndex:3},{value:"名称",paraId:22,tocIndex:4},{value:"类型",paraId:22,tocIndex:4},{value:"描述",paraId:22,tocIndex:4},{value:"line",paraId:22,tocIndex:4},{value:"ShapeStyle",paraId:22,tocIndex:4},{value:"辅助线的样式",paraId:22,tocIndex:4},{value:"itemAlignType",paraId:22,tocIndex:4},{value:"boolean、'horizontal' 、'vertical'、'center';",paraId:22,tocIndex:4},{value:"辅助线类型，true 表示全部",paraId:22,tocIndex:4},{value:"Grid 插件在画布上绘制了网格。",paraId:23,tocIndex:5},{value:"使用 ",paraId:24,tocIndex:5},{value:"配置方法",paraId:25,tocIndex:5},{value:" 中代码实例化时可以通过配置项调整 Grid 的图片。",paraId:24,tocIndex:5},{value:"名称",paraId:26,tocIndex:6},{value:"类型",paraId:26,tocIndex:6},{value:"描述",paraId:26,tocIndex:6},{value:"img",paraId:26,tocIndex:6},{value:"String",paraId:26,tocIndex:6},{value:"grid 图片，base64 格式字符串",paraId:26,tocIndex:6},{value:"Minimap 是用于快速预览和探索图的工具。",paraId:27,tocIndex:7},{value:"实例化时可以通过配置项调整 Minimap 的样式和功能。",paraId:28,tocIndex:7},{value:"名称",paraId:29,tocIndex:8},{value:"类型",paraId:29,tocIndex:8},{value:"描述",paraId:29,tocIndex:8},{value:"container",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"放置 Minimap 的 DOM 容器。若不指定则自动生成",paraId:29,tocIndex:8},{value:"className",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"生成的 DOM 元素的 className",paraId:29,tocIndex:8},{value:"viewportClassName",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"Minimap 上视窗 DOM 元素的 className",paraId:29,tocIndex:8},{value:"type",paraId:29,tocIndex:8},{value:"String",paraId:29,tocIndex:8},{value:"选项：",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:"：渲染图上所有图形；",paraId:29,tocIndex:8},{value:"'keyShape'",paraId:29,tocIndex:8},{value:"：只渲染图上元素的 keyShape，以减少渲染成本；",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:"：只渲染图上元素的大致图形，以降低渲染成本。渲染成本 ",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:" > ",paraId:29,tocIndex:8},{value:"'keyShape'",paraId:29,tocIndex:8},{value:" > ",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:"。默认为 ",paraId:29,tocIndex:8},{value:"'default'",paraId:29,tocIndex:8},{value:"size",paraId:29,tocIndex:8},{value:"Array",paraId:29,tocIndex:8},{value:"Minimap 的大小",paraId:29,tocIndex:8},{value:"delegateStyle",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"在 ",paraId:29,tocIndex:8},{value:"type",paraId:29,tocIndex:8},{value:" 为 ",paraId:29,tocIndex:8},{value:"'delegate'",paraId:29,tocIndex:8},{value:" 时生效，代表元素大致图形的样式",paraId:29,tocIndex:8},{value:"hideEdge",paraId:29,tocIndex:8},{value:"Boolean",paraId:29,tocIndex:8},{value:"false",paraId:29,tocIndex:8},{value:"其中，delegateStyle 可以设置如下属性：",paraId:30,tocIndex:8},{value:"名称",paraId:31,tocIndex:8},{value:"类型",paraId:31,tocIndex:8},{value:"描述",paraId:31,tocIndex:8},{value:"fill",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"填充颜色",paraId:31,tocIndex:8},{value:"stroke",paraId:31,tocIndex:8},{value:"String",paraId:31,tocIndex:8},{value:"描边颜色",paraId:31,tocIndex:8},{value:"lineWidth",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"描边宽度",paraId:31,tocIndex:8},{value:"opacity",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"透明度",paraId:31,tocIndex:8},{value:"fillOpacity",paraId:31,tocIndex:8},{value:"Number",paraId:31,tocIndex:8},{value:"填充透明度",paraId:31,tocIndex:8},{value:"由于 ",paraId:32,tocIndex:9},{value:"Minimap",paraId:33,tocIndex:9},{value:" 的原理是将主画布内容复制到 minimap 的画布上，在大数据量下可能会造成双倍的绘制效率成本。为缓解该问题，Image Minimap 采用另一种机制，根据提供的图片地址或 base64 字符串 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:" 绘制 ",paraId:32,tocIndex:9},{value:"<img />",paraId:32,tocIndex:9},{value:" 代替 minimap 上的 canvas。该方法可以大大减轻两倍 canvas 绘制的压力。但 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:" 完全交由 G6 的用户控制，需要注意主画布更新时需要使用 ",paraId:32,tocIndex:9},{value:"updateGraphImg",paraId:32,tocIndex:9},{value:" 方法替换 ",paraId:32,tocIndex:9},{value:"graphImg",paraId:32,tocIndex:9},{value:"。",paraId:32,tocIndex:9},{value:"实例化时可以通过配置项调整 Image inimap 的样式和功能。",paraId:34,tocIndex:9},{value:"名称",paraId:35,tocIndex:10},{value:"类型",paraId:35,tocIndex:10},{value:"是否必须",paraId:35,tocIndex:10},{value:"描述",paraId:35,tocIndex:10},{value:"graphImg",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"true",paraId:35,tocIndex:10},{value:"minimap 的图片地址或 base64 文本",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"Number",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"minimap 的宽度。Image Minimap 的长宽比一定等于主图长宽比。因此，若设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"，则按照主画布容器长宽比确定 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"，也就是说，",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 的优先级高于 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"。",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"Number",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"minimap 的高度。Image Minimap 的长宽比一定等于主图长宽比。若未设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"，但设置了 ",paraId:35,tocIndex:10},{value:"height",paraId:35,tocIndex:10},{value:"，则按照主画布容器长宽比确定 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:"；若设置了 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 则以 ",paraId:35,tocIndex:10},{value:"width",paraId:35,tocIndex:10},{value:" 为准",paraId:35,tocIndex:10},{value:"container",paraId:35,tocIndex:10},{value:"Object",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"放置 Minimap 的 DOM 容器。若不指定则自动生成",paraId:35,tocIndex:10},{value:"className",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"生成的 DOM 元素的 className",paraId:35,tocIndex:10},{value:"viewportClassName",paraId:35,tocIndex:10},{value:"String",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"Minimap 上视窗 DOM 元素的 className",paraId:35,tocIndex:10},{value:"delegateStyle",paraId:35,tocIndex:10},{value:"Object",paraId:35,tocIndex:10},{value:"false",paraId:35,tocIndex:10},{value:"在 ",paraId:35,tocIndex:10},{value:"type",paraId:35,tocIndex:10},{value:" 为 ",paraId:35,tocIndex:10},{value:"'delegate'",paraId:35,tocIndex:10},{value:" 时生效，代表元素大致图形的样式",paraId:35,tocIndex:10},{value:"其中，",paraId:36,tocIndex:10},{value:"delegateStyle",paraId:36,tocIndex:10},{value:" 可以设置如下属性：",paraId:36,tocIndex:10},{value:"名称",paraId:37,tocIndex:10},{value:"类型",paraId:37,tocIndex:10},{value:"描述",paraId:37,tocIndex:10},{value:"fill",paraId:37,tocIndex:10},{value:"String",paraId:37,tocIndex:10},{value:"填充颜色",paraId:37,tocIndex:10},{value:"stroke",paraId:37,tocIndex:10},{value:"String",paraId:37,tocIndex:10},{value:"描边颜色",paraId:37,tocIndex:10},{value:"lineWidth",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"描边宽度",paraId:37,tocIndex:10},{value:"opacity",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"透明度",paraId:37,tocIndex:10},{value:"fillOpacity",paraId:37,tocIndex:10},{value:"Number",paraId:37,tocIndex:10},{value:"填充透明度",paraId:37,tocIndex:10},{value:"更新 minimap 图片。建议在主画布更新时使用该方法同步更新 minimap 图片。",paraId:38,tocIndex:12},{value:"参数：",paraId:39,tocIndex:12},{value:"名称",paraId:40,tocIndex:12},{value:"类型",paraId:40,tocIndex:12},{value:"是否必须",paraId:40,tocIndex:12},{value:"描述",paraId:40,tocIndex:12},{value:"img",paraId:40,tocIndex:12},{value:"String",paraId:40,tocIndex:12},{value:"true",paraId:40,tocIndex:12},{value:"minimap 的图片地址或 base64 文本",paraId:40,tocIndex:12},{value:"实例化 Image Minimap 插件时，",paraId:41,tocIndex:13},{value:"graphImg",paraId:41,tocIndex:13},{value:" 是必要参数。",paraId:41,tocIndex:13},{value:"// 实例化 Image Minimap 插件\nconst imageMinimap = new G6.ImageMinimap({\n  width: 200,\n  graphImg: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ'\n});\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [imageMinimap], // 配置 imageMinimap 插件\n});\n\ngraph.data(data);\ngraph.render()\n\n... // 一些主画布更新操作\nimageMinimap.updateGraphImg(img); // 使用新的图片（用户自己生成）替换 minimap 图片\n\n",paraId:42,tocIndex:13},{value:"在关系复杂、繁多的大规模图上，通过边绑定可以降低视觉复杂度。",paraId:43,tocIndex:14},{value:"美国航线图边绑定。",paraId:44,tocIndex:14},{value:"Demo 链接",paraId:44,tocIndex:14},{value:"。该 ",paraId:44,tocIndex:14},{value:"Demo 教程",paraId:44,tocIndex:14},{value:"。",paraId:44,tocIndex:14},{value:"实例化时可以通过配置项调整边绑定的功能。",paraId:45,tocIndex:14},{value:"名称",paraId:46,tocIndex:15},{value:"类型",paraId:46,tocIndex:15},{value:"默认值",paraId:46,tocIndex:15},{value:"描述",paraId:46,tocIndex:15},{value:"K",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.1",paraId:46,tocIndex:15},{value:"边绑定的强度",paraId:46,tocIndex:15},{value:"lambda",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.1",paraId:46,tocIndex:15},{value:"算法的初始步长",paraId:46,tocIndex:15},{value:"divisions",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"1",paraId:46,tocIndex:15},{value:"初始的切割点数，即每条边将会被切割成的份数。每次迭代将会被乘以 ",paraId:46,tocIndex:15},{value:"divRate",paraId:46,tocIndex:15},{value:"divRate",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"2",paraId:46,tocIndex:15},{value:"切割增长率，每次迭代都会乘以该数字。数字越大，绑定越平滑，但计算量将增大",paraId:46,tocIndex:15},{value:"cycles",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"6",paraId:46,tocIndex:15},{value:"迭代次数",paraId:46,tocIndex:15},{value:"iterations",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"90",paraId:46,tocIndex:15},{value:"初始的内迭代次数，每次外迭代中将会被乘以 ",paraId:46,tocIndex:15},{value:"iterRate",paraId:46,tocIndex:15},{value:"iterRate",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.6666667",paraId:46,tocIndex:15},{value:"迭代下降率",paraId:46,tocIndex:15},{value:"bundleThreshold",paraId:46,tocIndex:15},{value:"Number",paraId:46,tocIndex:15},{value:"0.6",paraId:46,tocIndex:15},{value:"判定边是否应该绑定在一起的相似容忍度，数值越大，被绑在一起的边相似度越低，数量越多",paraId:46,tocIndex:15},{value:"Menu 用于配置节点上的右键菜单。",paraId:47,tocIndex:16},{value:"名称",paraId:48,tocIndex:17},{value:"类型",paraId:48,tocIndex:17},{value:"默认值",paraId:48,tocIndex:17},{value:"描述",paraId:48,tocIndex:17},{value:"className",paraId:48,tocIndex:17},{value:"string",paraId:48,tocIndex:17},{value:"null",paraId:48,tocIndex:17},{value:"menu 容器的 class 类名",paraId:48,tocIndex:17},{value:"getContent",paraId:48,tocIndex:17},{value:"(evt?: IG6GraphEvent, graph?: IGraph) => HTMLDivElement / string",paraId:48,tocIndex:17},{value:"菜单项内容，支持 DOM 元素或字符串",paraId:48,tocIndex:17},{value:"handleMenuClick",paraId:48,tocIndex:17},{value:"(target: HTMLElement, item: Item, graph?: IGraph) => void",paraId:48,tocIndex:17},{value:"undefined",paraId:48,tocIndex:17},{value:"点击菜单项的回调函数",paraId:48,tocIndex:17},{value:"shouldBegin",paraId:48,tocIndex:17},{value:"(evt: G6Event) => boolean",paraId:48,tocIndex:17},{value:"undefined",paraId:48,tocIndex:17},{value:"是否允许 menu 出现，可以根据 ",paraId:48,tocIndex:17},{value:"evt.item",paraId:48,tocIndex:17},{value:"（当前鼠标事件中的元素） 或 ",paraId:48,tocIndex:17},{value:"evt.target",paraId:48,tocIndex:17},{value:"（当前鼠标事件中的图形）的内容判断此时是否允许 menu 出现",paraId:48,tocIndex:17},{value:"offsetX",paraId:48,tocIndex:17},{value:"number",paraId:48,tocIndex:17},{value:"6",paraId:48,tocIndex:17},{value:"menu 的 x 方向偏移值，需要考虑父级容器的 padding",paraId:48,tocIndex:17},{value:"offsetY",paraId:48,tocIndex:17},{value:"number",paraId:48,tocIndex:17},{value:"6",paraId:48,tocIndex:17},{value:"menu 的 y 方向偏移值，需要考虑父级容器的 padding",paraId:48,tocIndex:17},{value:"itemTypes",paraId:48,tocIndex:17},{value:"string[]",paraId:48,tocIndex:17},{value:"['node', 'edge', 'combo']",paraId:48,tocIndex:17},{value:"menu 作用在哪些类型的元素上，若只想在节点上显示，可将其设置为 ['node']",paraId:48,tocIndex:17},{value:"trigger",paraId:48,tocIndex:17},{value:"'click' / 'contextmenu'",paraId:48,tocIndex:17},{value:"'contextmenu'",paraId:48,tocIndex:17},{value:"menu 出现的触发方式，默认为 ",paraId:48,tocIndex:17},{value:"'contextmenu'",paraId:48,tocIndex:17},{value:"，即右击。",paraId:48,tocIndex:17},{value:"'click'",paraId:48,tocIndex:17},{value:" 代表左击。",paraId:48,tocIndex:17},{value:"v4.3.2 起支持 'click'",paraId:48,tocIndex:17},{value:"实例化 Menu 插件时，如果不传参数，则使用 G6 默认提供的值，只能展示默认的菜单项，不能进行任何操作。",paraId:49,tocIndex:18},{value:"// 实例化 Menu 插件\nconst menu = new G6.Menu();\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:50,tocIndex:18},{value:"const menu = new G6.Menu({\n  offsetX: 6,\n  offsetX: 10,\n  itemTypes: ['node'],\n  getContent(e, graph) {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `<ul>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n        <li>测试01</li>\n      </ul>`\n    return outDiv\n  },\n  handleMenuClick(target, item, graph) {\n    console.log(target, item, graph)\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:51,tocIndex:19},{value:"const menu = new G6.Menu({\n  getContent(evt) {\n    return `<ul>\n      <li title='1'>测试02</li>\n      <li title='2'>测试02</li>\n      <li>测试02</li>\n      <li>测试02</li>\n      <li>测试02</li>\n    </ul>`;\n  },\n  handleMenuClick(target, item) {\n    console.log(target, item)\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [menu], // 配置 Menu 插件\n});\n",paraId:52,tocIndex:20},{value:"ToolBar 集成了以下常见的操作：",paraId:53,tocIndex:21},{value:"重做；",paraId:54,tocIndex:21},{value:"撤销；",paraId:54,tocIndex:21},{value:"放大；",paraId:54,tocIndex:21},{value:"缩小；",paraId:54,tocIndex:21},{value:"适应屏幕；",paraId:54,tocIndex:21},{value:"实际大小。",paraId:54,tocIndex:21},{value:"| 名称 | 类型 | 默认值 | 描述 |\n| --- | --- | --- | --- | --- |\n| container | HTMLDivElement | null | ToolBar 容器，如果不设置，则默认使用 canvas 的 DOM 容器 |\n| className | string | null | ToolBar 内容元素的 class 类名 |\n| getContent | (graph?: IGraph) => HTMLDivElement | string | ",paraId:55,tocIndex:22},{value:" | ToolBar 内容，支持 DOM 元素或字符串 |\n| handleClick | (code: string, graph: IGraph) => void | undefined | 点击 ToolBar 中每个图标的回调函数 |\n| position | Point | null | ToolBar 的位置坐标 |",paraId:55,tocIndex:22},{value:"默认的 ToolBar 提供了撤销、重做、放大等功能。",paraId:56,tocIndex:24},{value:"const toolbar = new G6.ToolBar();\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:57,tocIndex:24},{value:"const tc = document.createElement('div');\ntc.id = 'toolbarContainer';\ndocument.body.appendChild(tc);\n\nconst toolbar = new G6.ToolBar({\n  container: tc,\n  getContent: () => {\n    return `\n      <ul>\n        <li code='add'>增加节点</li>\n        <li code='undo'>撤销</li>\n      </ul>\n    `\n  },\n  handleClick: (code, graph) => {\n    if (code === 'add') {\n      graph.addItem('node', {\n        id: 'node2',\n        label: 'node2',\n        x: 300,\n        y: 150\n      })\n    } else if (code === 'undo') {\n      toolbar.undo()\n    }\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:58,tocIndex:25},{value:"const toolbar = new G6.ToolBar({\n  getContent: () => {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `<ul>\n        <li>测试01</li>\n        <li>测试02</li>\n        <li>测试03</li>\n        <li>测试04</li>\n        <li>测试05</li>\n      </ul>`\n    return outDiv\n  },\n  handleClick: (code, graph) => {\n\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [toolbar], // 配置 ToolBar 插件\n});\n",paraId:59,tocIndex:26},{value:"ToolTip 插件主要用于在节点和边上展示一些辅助信息，G6 4.0 以后，Tooltip 插件将会替换 Behavior 中的 tooltip。",paraId:60,tocIndex:27},{value:"名称",paraId:61,tocIndex:28},{value:"类型",paraId:61,tocIndex:28},{value:"默认值",paraId:61,tocIndex:28},{value:"描述",paraId:61,tocIndex:28},{value:"className",paraId:61,tocIndex:28},{value:"string",paraId:61,tocIndex:28},{value:"null",paraId:61,tocIndex:28},{value:"tooltip 容器的 class 类名",paraId:61,tocIndex:28},{value:"container",paraId:61,tocIndex:28},{value:"HTMLDivElement",paraId:61,tocIndex:28},{value:"null",paraId:61,tocIndex:28},{value:"Tooltip 容器，如果不设置，则默认使用 canvas 的 DOM 容器",paraId:61,tocIndex:28},{value:"getContent",paraId:61,tocIndex:28},{value:"(evt?: IG6GraphEvent) => HTMLDivElement / string",paraId:61,tocIndex:28},{value:"tooltip 内容，支持 DOM 元素或字符串",paraId:61,tocIndex:28},{value:"shouldBegin",paraId:61,tocIndex:28},{value:"(evt: G6Event) => boolean",paraId:61,tocIndex:28},{value:"undefined",paraId:61,tocIndex:28},{value:"是否允许 tooltip 出现，可以根据 ",paraId:61,tocIndex:28},{value:"evt.item",paraId:61,tocIndex:28},{value:"（当前鼠标事件中的元素） 或 ",paraId:61,tocIndex:28},{value:"evt.target",paraId:61,tocIndex:28},{value:"（当前鼠标事件中的图形）的内容判断此时是否允许 tooltip 出现",paraId:61,tocIndex:28},{value:"offsetX",paraId:61,tocIndex:28},{value:"number",paraId:61,tocIndex:28},{value:"6",paraId:61,tocIndex:28},{value:"tooltip 的 x 方向偏移值，需要考虑父级容器的 padding",paraId:61,tocIndex:28},{value:"offsetY",paraId:61,tocIndex:28},{value:"number",paraId:61,tocIndex:28},{value:"6",paraId:61,tocIndex:28},{value:"tooltip 的 y 方向偏移值，需要考虑父级容器的 padding",paraId:61,tocIndex:28},{value:"itemTypes",paraId:61,tocIndex:28},{value:"string[]",paraId:61,tocIndex:28},{value:"['node', 'edge', 'combo']",paraId:61,tocIndex:28},{value:"tooltip 作用在哪些类型的元素上，若只想在节点上显示，可将其设置为 ['node']",paraId:61,tocIndex:28},{value:"默认的 Tooltip 只展示元素类型和 ID，一般情况下都需要用户自己定义 Tooltip 上面展示的内容。",paraId:62,tocIndex:29},{value:"const tooltip = new G6.Tooltip({\n  offsetX: 10,\n  offsetY: 20,\n  getContent(e) {\n    const outDiv = document.createElement('div');\n    outDiv.style.width = '180px';\n    outDiv.innerHTML = `\n      <h4>自定义tooltip</h4>\n      <ul>\n        <li>Label: ${e.item.getModel().label || e.item.getModel().id}</li>\n      </ul>`\n    return outDiv\n  },\n  itemTypes: ['node']\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [tooltip], // 配置 Tooltip 插件\n});\n",paraId:63,tocIndex:30},{value:"const tooltip = new G6.Tooltip({\n  getContent(e) {\n    return `<div style='width: 180px;'>\n      <ul id='menu'>\n        <li title='1'>测试02</li>\n        <li title='2'>测试02</li>\n        <li>测试02</li>\n        <li>测试02</li>\n        <li>测试02</li>\n      </ul>\n    </div>`;\n  },\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [tooltip], // 配置 Tooltip 插件\n});\n",paraId:64,tocIndex:31},{value:"Fisheye 鱼眼放大镜是为 focus+context 的探索场景设计的，它能够保证在放大关注区域的同时，保证上下文以及上下文与关注中心的关系不丢失。",paraId:65,tocIndex:32},{value:"| 名称 | 类型 | 默认值 | 描述 |\n| --- | --- | --- | --- | --- |\n| trigger | 'mousemove' / 'click' / 'drag' | 'mousemove' | 放大镜的触发事件 |\n| d | Number | 1.5 | 放大系数，数值越大，放大程度越大 |\n| r | Number | 300 | 放大区域的范围半径 |\n| delegateStyle | Object | { stroke: '#000', strokeOpacity: 0.8, lineWidth: 2, fillOpacity: 0.1, fill: '#ccc' } | 放大镜蒙层样式 |\n| showLabel | Boolean | false | 若 label 默认被隐藏，是否在关注区域内展示 label |\n| maxR | Number | 图的高度 | 滚轮调整缩放范围的最大半径 |\n| minR | Number | 0.05 * 图的高度 | 滚轮调整缩放范围的最小半径 |\n| maxD | Number | 5 | ",paraId:66,tocIndex:33},{value:"trigger",paraId:66,tocIndex:33},{value:" 为 ",paraId:66,tocIndex:33},{value:"'mousemove'",paraId:66,tocIndex:33},{value:" / ",paraId:66,tocIndex:33},{value:"'click'",paraId:66,tocIndex:33},{value:" 时，可以在放大镜上左右拖拽调整缩放系数。maxD 指定了这种调整方式的最大缩放系数，建议取值范围 [0, 5]。若使用 ",paraId:66,tocIndex:33},{value:"minimap.updateParam",paraId:66,tocIndex:33},{value:" 更新参数不受该系数限制 |\n| minD | Number | 0 | ",paraId:66,tocIndex:33},{value:"trigger",paraId:66,tocIndex:33},{value:" 为 ",paraId:66,tocIndex:33},{value:"'mousemove'",paraId:66,tocIndex:33},{value:" / ",paraId:66,tocIndex:33},{value:"'click'",paraId:66,tocIndex:33},{value:" 时，可以在放大镜上左右拖拽调整缩放系数。maxD 指定了这种调整方式的最小缩放系数，建议取值范围 [0, 5]。若使用 ",paraId:66,tocIndex:33},{value:"minimap.updateParam",paraId:66,tocIndex:33},{value:" 更新参数不受该系数限制 |\n| scaleRBy | 'wheel'/'drag'/'unset'/undefined | false | 'unset' | 终端用户调整放大镜范围大小的方式 |\n| scaleDBy | 'wheel'/'drag'/'unset'/undefined | false | 'unset' | 终端用户调整放大镜缩放系数的方式 |\n| showDPercent | Boolean | false | true | 是否在放大镜下方显示当前缩放系数的比例值（与 minD、maxD 相较） |",paraId:66,tocIndex:33},{value:"用于更新该 FishEye 的部分配置项，包括 ",paraId:67,tocIndex:35},{value:"trigger",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"d",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"r",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"maxR",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"minR",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"maxD",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"minD",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"scaleRBy",paraId:67,tocIndex:35},{value:"，",paraId:67,tocIndex:35},{value:"scaleDBy",paraId:67,tocIndex:35},{value:"。例如：",paraId:67,tocIndex:35},{value:"const fisheye = new G6.Fisheye({\n  trigger: 'mousemove'\n});\n\n... // 其他操作\n\nfisheye.updateParams({\n  d: 2,\n  r: 500,\n  // ...\n})\n",paraId:68,tocIndex:35},{value:"const fisheye = new G6.Fisheye({\n  trigger: 'mousemove',\n  d: 1.5,\n  r: 300,\n  delegateStyle: clone(lensDelegateStyle),\n  showLabel: false\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [fisheye], // 配置 fisheye 插件\n});\n",paraId:69,tocIndex:36},{value:"EdgeFilterLens 边过滤镜可以将关注的边保留在过滤镜范围内，其他边将在该范围内不显示。",paraId:70,tocIndex:37},{value:"名称",paraId:71,tocIndex:38},{value:"类型",paraId:71,tocIndex:38},{value:"默认值",paraId:71,tocIndex:38},{value:"描述",paraId:71,tocIndex:38},{value:"trigger",paraId:71,tocIndex:38},{value:"'drag' / 'mousemove' / 'click'",paraId:71,tocIndex:38},{value:"'mousemove'",paraId:71,tocIndex:38},{value:"过滤镜的触发事件",paraId:71,tocIndex:38},{value:"type",paraId:71,tocIndex:38},{value:"'one' / 'both' / 'only-source' / 'only-target'",paraId:71,tocIndex:38},{value:"'both'",paraId:71,tocIndex:38},{value:"根据边两端点作为边过滤的简单条件。",paraId:71,tocIndex:38},{value:"'one'",paraId:71,tocIndex:38},{value:"：边至少有一个端点在过滤镜区域内，则在该区域内显示该边；",paraId:71,tocIndex:38},{value:"'both'",paraId:71,tocIndex:38},{value:"：两个端点都在过滤区域内，则在该区域显示该边；",paraId:71,tocIndex:38},{value:"'only-source'",paraId:71,tocIndex:38},{value:"：只有起始端在过滤镜区域内，则在该区域显示该边；",paraId:71,tocIndex:38},{value:"'only-target'",paraId:71,tocIndex:38},{value:"：只有结束端在过滤区域内，则在该区域显示该边。更复杂的条件可以使用 ",paraId:71,tocIndex:38},{value:"shouldShow",paraId:71,tocIndex:38},{value:" 指定",paraId:71,tocIndex:38},{value:"shouldShow",paraId:71,tocIndex:38},{value:"(d?: unknown) => boolean",paraId:71,tocIndex:38},{value:"undefined",paraId:71,tocIndex:38},{value:"边过滤的自定义条件。参数 ",paraId:71,tocIndex:38},{value:"d",paraId:71,tocIndex:38},{value:" 为边每条边的数据，用户可以根据边的参数返回布尔值。返回 ",paraId:71,tocIndex:38},{value:"true",paraId:71,tocIndex:38},{value:" 代表该边需要在过滤镜区域内显示，",paraId:71,tocIndex:38},{value:"false",paraId:71,tocIndex:38},{value:" 反之。",paraId:71,tocIndex:38},{value:"r",paraId:71,tocIndex:38},{value:"Number",paraId:71,tocIndex:38},{value:"60",paraId:71,tocIndex:38},{value:"过滤镜的范围半径",paraId:71,tocIndex:38},{value:"delegateStyle",paraId:71,tocIndex:38},{value:"Object",paraId:71,tocIndex:38},{value:"{ stroke: '#000', strokeOpacity: 0.8, lineWidth: 2, fillOpacity: 0.1, fill: '#ccc' }",paraId:71,tocIndex:38},{value:"过滤镜蒙层样式",paraId:71,tocIndex:38},{value:"showLabel",paraId:71,tocIndex:38},{value:"'edge' / 'node' / 'both'",paraId:71,tocIndex:38},{value:"'edge'",paraId:71,tocIndex:38},{value:"若 label 默认被隐藏，是否在关注区域内展示对应元素类型的 label。'both' 代表节点和边的 label 都在过滤镜区域显示",paraId:71,tocIndex:38},{value:"maxR",paraId:71,tocIndex:38},{value:"Number",paraId:71,tocIndex:38},{value:"图的高度",paraId:71,tocIndex:38},{value:"滚轮调整过滤镜的最大半径",paraId:71,tocIndex:38},{value:"minR",paraId:71,tocIndex:38},{value:"Number",paraId:71,tocIndex:38},{value:"0.05 * 图的高度",paraId:71,tocIndex:38},{value:"滚轮调整过滤镜的最小半径",paraId:71,tocIndex:38},{value:"scaleRBy",paraId:71,tocIndex:38},{value:"'wheel' / undefined",paraId:71,tocIndex:38},{value:"'wheel'",paraId:71,tocIndex:38},{value:"终端用户调整过滤镜大小的方式，undefined 代表不允许终端用户调整",paraId:71,tocIndex:38},{value:"用于更新该过滤镜的部分配置项，包括 ",paraId:72,tocIndex:40},{value:"trigger",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"type",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"r",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"maxR",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"minR",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"scaleRBy",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"showLabel",paraId:72,tocIndex:40},{value:"，",paraId:72,tocIndex:40},{value:"shouldShow",paraId:72,tocIndex:40},{value:"。例如：",paraId:72,tocIndex:40},{value:"const filterLens = new G6.EdgeFilterLens({\n  trigger: 'drag'\n});\n\n... // 其他操作\n\nfilterLens.updateParams({\n  r: 500,\n  // ...\n})\n",paraId:73,tocIndex:40},{value:"const filterLens = new G6.EdgeFilterLens({\n  trigger: 'mousemove',\n  r: 300,\n  shouldShow: d => {\n    return d.size > 10;\n  }\n});\n\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [filterLens], // 配置 filterLens 插件\n});\n",paraId:74,tocIndex:41},{value:"AntV G6",paraId:75,tocIndex:42},{value:" 内置了三种形态的 TimeBar 组件：",paraId:75,tocIndex:42},{value:"带有趋势图的 TimeBar 组件；",paraId:76,tocIndex:42},{value:"简易版的 TimeBar 组件；",paraId:76,tocIndex:42},{value:"刻度 TimeBar 组件。",paraId:76,tocIndex:42},{value:"并且每种类型的 TimeBar 组件都可以配合播放、快进、后退等控制按钮组使用。",paraId:77,tocIndex:42},{value:"趋势图 TimeBar 组件",paraId:78},{value:"简易版 TimeBar 组件",paraId:78},{value:"刻度 TimeBar 组件",paraId:78},{value:"在趋势图 TimeBar 基础上，我们可以通过配置数据，实现更加复杂的趋势图 TimeBar 组件，如下图所示。",paraId:79,tocIndex:42},{value:"虽然 G6 提供了各种不同类型的 TimeBar 组件，但在使用的方式却非常简单，通过配置字段就可以进行区分。",paraId:80,tocIndex:42},{value:" ",paraId:80,tocIndex:42},{value:"关于 TimeBar 的使用案例，请参考",paraId:80,tocIndex:42},{value:"这里",paraId:80,tocIndex:42},{value:"。",paraId:80,tocIndex:42},{value:"使用 G6 内置的 TimeBar 组件，和使用其他组件的方式完全相同。",paraId:81,tocIndex:43},{value:"import G6 from '@antv/g6';\n\nconst timebar = new G6.TimeBar({\n  width: 500,\n  height: 150,\n  padding: 10,\n  type: 'trend',\n  trend: {\n    data: timeBarData,\n  },\n});\n\nconst graph = new G6.Graph({\n  container: 'container',\n  width,\n  height,\n  plugins: [timebar],\n});\n",paraId:82,tocIndex:43},{value:"通过上面的方式，我们就可以在图中使用 TimeBar 组件了，当实例化 TimeBar 时，type 参数值为 trend，表示我们实例化的是趋势图组件，效果如下图所示。",paraId:83,tocIndex:43},{value:"当设置 type 为 simple 时，就可以使用简易版的 TimeBar。",paraId:84,tocIndex:43},{value:"当设置 type 为 tick 时，表示我们要使用刻度 TimeBar 组件，但此时要注意的是，",paraId:85,tocIndex:43},{value:"刻度时间轴的配置项是通过 tick 对象配置而不是 trend 对象",paraId:85,tocIndex:43},{value:"，这也是刻度时间轴和趋势即简易时间轴不同的地方。",paraId:85,tocIndex:43},{value:"const timebar = new G6.TimeBar({\n  width,\n  height: 150,\n  type: 'tick',\n  tick: {\n    data: timeBarData,\n    width,\n    height: 42,\n    tickLabelFormatter: (d) => {\n      const dateStr = `${d.date}`;\n      if ((count - 1) % 10 === 0) {\n        return `${dateStr.substr(0, 4)}-${dateStr.substr(4, 2)}-${dateStr.substr(6, 2)}`;\n      }\n      return false;\n    },\n    tooltipFomatter: (d) => {\n      const dateStr = `${d}`;\n      return `${dateStr.substr(0, 4)}-${dateStr.substr(4, 2)}-${dateStr.substr(6, 2)}`;\n    },\n  },\n});\n",paraId:86,tocIndex:43},{value:"TimeBar 插件暴露除了几个时机事件，方便用户监听内部状态的变化。以下事件可通过 ",paraId:87,tocIndex:44},{value:"graph.on('eventname', e => {})",paraId:87,tocIndex:44},{value:" 进行监听。",paraId:87,tocIndex:44},{value:"事件名称",paraId:88,tocIndex:44},{value:"描述",paraId:88,tocIndex:44},{value:"valuechange",paraId:88,tocIndex:44},{value:"时间轴的时间范围发生变化时触发",paraId:88,tocIndex:44},{value:"timebarstartplay",paraId:88,tocIndex:44},{value:"时间轴开始播放时触发",paraId:88,tocIndex:44},{value:"timebarendplay",paraId:88,tocIndex:44},{value:"时间轴播放结束时触发",paraId:88,tocIndex:44},{value:"完整的 TimeBar 的接口定义如下：",paraId:89,tocIndex:46},{value:"interface TimeBarConfig extends IPluginBaseConfig {\n  // position size\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  readonly padding?: number;\n\n  readonly type?: 'trend' | 'simple' | 'tick';\n  // 趋势图配置项\n  readonly trend?: TrendConfig;\n  // 滑块、及前后背景的配置\n  readonly slider?: SliderOption;\n\n  // 当 type 是 tick 时，这是 tick 类型时间轴的配置项\n  // 当 type 是 trend 或 simple 时，这是时间轴下方时间刻度文本的配置项\n  readonly tick?: TimeBarSliceOption | TickCfg;\n\n  // 控制按钮\n  readonly controllerCfg?: ControllerCfg;\n\n  // [v4.5.1 起支持] 容器的 CSS 样式\n  readonly containerCSS?: Object;\n\n  // [v4.5.1 起支持] 过滤的类型, ['node', 'edge'], 默认为 ['node']\n  readonly filterItemTypes?: string[];\n\n  // [v4.5.1 起废弃，由 filterItemTypes 代替] 是否过滤边，若为 true，则需要配合边数据上有 date 字段，过滤节点同时将不满足 date 在选中范围内的边也过滤出去；若为 false，则仅过滤节点以及两端节点都被过滤出去的边\n  readonly filterEdge?: boolean;\n\n  // [v4.5.1 起支持] 是否通过 graph.changeData 改变图上数据从而达到筛选目的。若为 false 则将使用 graph.hideItem 和 graph.showItem 以隐藏/展示图上元素从而达到筛选目的\n  readonly changeData?: boolean;\n\n  // TimeBar 时间范围变化时的回调函数，当不定义该函数时，时间范围变化时默认过滤图上的数据\n  rangeChange?: (graph: IGraph, minValue: string, maxValue: string) => void;\n\n  // [v4.5.1 起支持] 用户根据节点/边数据返回对应时间值的方法\n  getDate?: (d: any) => number;\n\n  // [v4.5.1 起支持] 用户根据节点/边数据返回对应 value 的方法。value 用于在 type 为 trend 的时间轴上显示趋势线\n  getValue?: (d: any) => number;\n\n  // [v4.5.1 起支持] 在过滤图元素时是否要忽略某些元素。返回 true，则忽略。否则按照正常过滤逻辑处理\n  shouldIgnore?: (itemType: 'node' | 'edge', model: any, dateRage: { min: number, max: number }) => boolean;\n}\n",paraId:90,tocIndex:46},{value:"名称",paraId:91,tocIndex:47},{value:"类型",paraId:91,tocIndex:47},{value:"默认值",paraId:91,tocIndex:47},{value:"描述",paraId:91,tocIndex:47},{value:"container",paraId:91,tocIndex:47},{value:"HTMLDivElement",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"TimeBar 容器，如果不设置，则默认创建 className 为 g6-component-timebar 的 DOM 容器",paraId:91,tocIndex:47},{value:"x",paraId:91,tocIndex:47},{value:"number",paraId:91,tocIndex:47},{value:"0",paraId:91,tocIndex:47},{value:"TimeBar 开始 x 坐标",paraId:91,tocIndex:47},{value:"y",paraId:91,tocIndex:47},{value:"number",paraId:91,tocIndex:47},{value:"0",paraId:91,tocIndex:47},{value:"TimeBar 开始 y 坐标",paraId:91,tocIndex:47},{value:"width",paraId:91,tocIndex:47},{value:"number",paraId:91,tocIndex:47},{value:"必选",paraId:91,tocIndex:47},{value:"，TimeBar 容器宽度",paraId:91,tocIndex:47},{value:"height",paraId:91,tocIndex:47},{value:"number",paraId:91,tocIndex:47},{value:"必选",paraId:91,tocIndex:47},{value:"，TimeBar 高度",paraId:91,tocIndex:47},{value:"padding",paraId:91,tocIndex:47},{value:"number/number[]",paraId:91,tocIndex:47},{value:"10",paraId:91,tocIndex:47},{value:"TimeBar 距离容器的间距值",paraId:91,tocIndex:47},{value:"type",paraId:91,tocIndex:47},{value:"'trend' / 'simple' / 'tick'",paraId:91,tocIndex:47},{value:"trend",paraId:91,tocIndex:47},{value:"默认的 TimeBar 类型，默认为趋势图样式",paraId:91,tocIndex:47},{value:"trend",paraId:91,tocIndex:47},{value:"TrendConfig",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"Timebar 中趋势图的配置项，当 type 为 trend 或 simple 时，该字段必选",paraId:91,tocIndex:47},{value:"slider",paraId:91,tocIndex:47},{value:"SliderOption",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"TimeBar 组件背景及控制调节范围的滑块的配置项",paraId:91,tocIndex:47},{value:"tick",paraId:91,tocIndex:47},{value:"TimeBarSliceOption / TickCfg",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"当 type 是 tick 时，这是 tick 类型时间轴的配置项，该字段必须按；当 type 是 trend 或 simple 时，这是时间轴下方时间刻度文本的配置项",paraId:91,tocIndex:47},{value:"controllerCfg",paraId:91,tocIndex:47},{value:"ControllerCfg",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"控制按钮组配置项",paraId:91,tocIndex:47},{value:"containerCSS",paraId:91,tocIndex:47},{value:"Object",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"[v4.5.1 起支持] 容器的 CSS 样式",paraId:91,tocIndex:47},{value:"filterItemTypes",paraId:91,tocIndex:47},{value:"string[]",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"[v4.5.1 起支持] 过滤的类型, ['node', 'edge'], 默认为 ['node']",paraId:91,tocIndex:47},{value:"filterEdge",paraId:91,tocIndex:47},{value:"boolean",paraId:91,tocIndex:47},{value:"false",paraId:91,tocIndex:47},{value:"[v4.5.1 起废弃，由 filterItemTypes 代替] 是否过滤边，若为 true，则需要配合边数据上有 date 字段，过滤节点同时将不满足 date 在选中范围内的边也过滤出去；若为 false，则仅过滤节点以及两端节点都被过滤出去的边",paraId:91,tocIndex:47},{value:"changeData",paraId:91,tocIndex:47},{value:"boolean",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"[v4.5.1 起支持] 是否通过 graph.changeData 改变图上数据从而达到筛选目的。若为 false 则将使用 graph.hideItem 和 graph.showItem 以隐藏/展示图上元素从而达到筛选目的",paraId:91,tocIndex:47},{value:"rangeChange",paraId:91,tocIndex:47},{value:"Function",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"TimeBar 时间范围变化时的回调函数，当不定义该函数时，时间范围变化时默认过滤图上的数据",paraId:91,tocIndex:47},{value:"getDate",paraId:91,tocIndex:47},{value:"(d: any) => number",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"[v4.5.1 起支持] 用户根据节点/边数据返回对应时间值的方法",paraId:91,tocIndex:47},{value:"getValue",paraId:91,tocIndex:47},{value:"(d: any) => number",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"[v4.5.1 起支持] 用户根据节点/边数据返回对应 value 的方法。value 用于在 type 为 trend 的时间轴上显示趋势线",paraId:91,tocIndex:47},{value:"shouldIgnore",paraId:91,tocIndex:47},{value:"(itemType: 'node'",paraId:91,tocIndex:47},{value:"'edge', model: any, dateRage: { min: number, max: number }) => boolean",paraId:91,tocIndex:47},{value:"null",paraId:91,tocIndex:47},{value:"暂不支持刻度文本的样式配置",paraId:92,tocIndex:48},{value:"interface TrendConfig {\n  // 数据\n  readonly data: {\n    date: string;\n    value: string;\n  }[];\n  // 位置大小\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  // 样式\n  readonly smooth?: boolean;\n  readonly isArea?: boolean;\n  readonly lineStyle?: ShapeStyle;\n  readonly areaStyle?: ShapeStyle;\n  readonly interval?: Interval;\n}\n",paraId:93,tocIndex:48},{value:"名称",paraId:94,tocIndex:49},{value:"类型",paraId:94,tocIndex:49},{value:"默认值",paraId:94,tocIndex:49},{value:"描述",paraId:94,tocIndex:49},{value:"x",paraId:94,tocIndex:49},{value:"number",paraId:94,tocIndex:49},{value:"0",paraId:94,tocIndex:49},{value:"趋势图开始 x 坐标",paraId:94,tocIndex:49},{value:"y",paraId:94,tocIndex:49},{value:"number",paraId:94,tocIndex:49},{value:"0",paraId:94,tocIndex:49},{value:"趋势图开始 y 坐标",paraId:94,tocIndex:49},{value:"width",paraId:94,tocIndex:49},{value:"number",paraId:94,tocIndex:49},{value:"TimeBar 容器宽度",paraId:94,tocIndex:49},{value:"TimeBar 趋势图宽度，不建议自己设定，如果设定时需要同步设置 slider 中的 width 值",paraId:94,tocIndex:49},{value:"height",paraId:94,tocIndex:49},{value:"number",paraId:94,tocIndex:49},{value:"type=trend：默认为 28",paraId:94,tocIndex:49},{value:"type=simple：默认为 8",paraId:94,tocIndex:49},{value:"TimeBar 趋势图高度，不建议自己设定，如果设定时需要同步设置 slider 中的 height 值",paraId:94,tocIndex:49},{value:"smooth",paraId:94,tocIndex:49},{value:"boolean",paraId:94,tocIndex:49},{value:"false",paraId:94,tocIndex:49},{value:"是否是平滑的曲线",paraId:94,tocIndex:49},{value:"isArea",paraId:94,tocIndex:49},{value:"boolean",paraId:94,tocIndex:49},{value:"false",paraId:94,tocIndex:49},{value:"是否显示面积图",paraId:94,tocIndex:49},{value:"lineStyle",paraId:94,tocIndex:49},{value:"ShapeStyle",paraId:94,tocIndex:49},{value:"null",paraId:94,tocIndex:49},{value:"折线的样式配置",paraId:94,tocIndex:49},{value:"areaStyle",paraId:94,tocIndex:49},{value:"ShapeStyle",paraId:94,tocIndex:49},{value:"null",paraId:94,tocIndex:49},{value:"面积的样式配置项，只有当 isArea 为 true 时生效",paraId:94,tocIndex:49},{value:"interval",paraId:94,tocIndex:49},{value:"Interval",paraId:94,tocIndex:49},{value:"null",paraId:94,tocIndex:49},{value:"柱状图配置项，当配置了该项后，趋势图上会展现为混合图样式。",paraId:94,tocIndex:49},{value:"Interval = { data: number[], style: ShapeStyle }",paraId:94,tocIndex:49},{value:"，",paraId:94,tocIndex:49},{value:"style",paraId:94,tocIndex:49},{value:" 除 ",paraId:94,tocIndex:49},{value:"ShapeStyle",paraId:94,tocIndex:49},{value:" 类型中图形的样式外，还可配置 ",paraId:94,tocIndex:49},{value:"barWidth",paraId:94,tocIndex:49},{value:" 配置柱状图柱子的宽度。",paraId:94,tocIndex:49},{value:"export type SliderOption = Partial<{\n  readonly width?: number;\n  readonly height?: number;\n  readonly backgroundStyle?: ShapeStyle;\n  readonly foregroundStyle?: ShapeStyle;\n  // 滑块样式\n  readonly handlerStyle?: {\n    width?: number;\n    height?: number;\n    style?: ShapeStyle;\n  };\n  readonly textStyle?: ShapeStyle;\n  // 初始位置\n  readonly start: number;\n  readonly end: number;\n  // 滑块文本\n  readonly minText: string;\n  readonly maxText: string;\n}>;\n",paraId:95,tocIndex:50},{value:"名称",paraId:96,tocIndex:51},{value:"类型",paraId:96,tocIndex:51},{value:"默认值",paraId:96,tocIndex:51},{value:"描述",paraId:96,tocIndex:51},{value:"width",paraId:96,tocIndex:51},{value:"number",paraId:96,tocIndex:51},{value:"TimeBar 容器宽度 - 2 * padding",paraId:96,tocIndex:51},{value:"趋势图背景框宽度，不建议自己设定，如果设定时要同步修改 trend 中 width 值",paraId:96,tocIndex:51},{value:"height",paraId:96,tocIndex:51},{value:"number",paraId:96,tocIndex:51},{value:"趋势图默认为 28",paraId:96,tocIndex:51},{value:"简易版默认为 8",paraId:96,tocIndex:51},{value:"TimeBar 趋势图高度，不建议自己设定，如果设定时需要同步设置 trend 中的 height 值",paraId:96,tocIndex:51},{value:"backgroundStyle",paraId:96,tocIndex:51},{value:"ShapeStyle",paraId:96,tocIndex:51},{value:"null",paraId:96,tocIndex:51},{value:"背景样式配置项",paraId:96,tocIndex:51},{value:"foregroundStyle",paraId:96,tocIndex:51},{value:"ShapeStyle",paraId:96,tocIndex:51},{value:"null",paraId:96,tocIndex:51},{value:"前景色样式配置，即选中范围的样式配置项",paraId:96,tocIndex:51},{value:"handlerStyle",paraId:96,tocIndex:51},{value:"ShapeStyle",paraId:96,tocIndex:51},{value:"null",paraId:96,tocIndex:51},{value:"滑块的样式配置项",paraId:96,tocIndex:51},{value:"textStyle",paraId:96,tocIndex:51},{value:"ShapeStyle",paraId:96,tocIndex:51},{value:"null",paraId:96,tocIndex:51},{value:"滑块上文本的样式配置项",paraId:96,tocIndex:51},{value:"start",paraId:96,tocIndex:51},{value:"number",paraId:96,tocIndex:51},{value:"0.1",paraId:96,tocIndex:51},{value:"开始位置",paraId:96,tocIndex:51},{value:"end",paraId:96,tocIndex:51},{value:"number",paraId:96,tocIndex:51},{value:"0.9",paraId:96,tocIndex:51},{value:"结束位置",paraId:96,tocIndex:51},{value:"minText",paraId:96,tocIndex:51},{value:"string",paraId:96,tocIndex:51},{value:"min",paraId:96,tocIndex:51},{value:"最小值文本",paraId:96,tocIndex:51},{value:"maxText",paraId:96,tocIndex:51},{value:"string",paraId:96,tocIndex:51},{value:"max",paraId:96,tocIndex:51},{value:"最大值文本",paraId:96,tocIndex:51},{value:"export interface TimeBarSliceOption {\n  // position size\n  readonly x?: number;\n  readonly y?: number;\n  readonly width?: number;\n  readonly height?: number;\n  readonly padding?: number;\n\n  // styles\n  readonly selectedTickStyle?: TickStyle;\n  readonly unselectedTickStyle?: TickStyle\n  readonly tooltipBackgroundColor?: string;\n\n  readonly start?: number;\n  readonly end?: number;\n\n  // 数据\n  readonly data: {\n    date: string;\n    value: string;\n  }[];\n\n  // 自定义标签格式化函数\n  readonly tickLabelFormatter?: (d: any) => string | boolean;\n  // 自定义 tooltip 内容格式化函数\n  readonly tooltipFomatter?: (d: any) => string;\n}\n",paraId:97,tocIndex:52},{value:"名称",paraId:98,tocIndex:53},{value:"类型",paraId:98,tocIndex:53},{value:"默认值",paraId:98,tocIndex:53},{value:"描述",paraId:98,tocIndex:53},{value:"x",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"0",paraId:98,tocIndex:53},{value:"刻度 TimeBar 开始 x 坐标",paraId:98,tocIndex:53},{value:"y",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"0",paraId:98,tocIndex:53},{value:"刻度 TimeBar 开始 y 坐标",paraId:98,tocIndex:53},{value:"width",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"必选，刻度 TimeBar 宽度",paraId:98,tocIndex:53},{value:"height",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"必选，刻度 TimeBar 高度",paraId:98,tocIndex:53},{value:"padding",paraId:98,tocIndex:53},{value:"number / number[]",paraId:98,tocIndex:53},{value:"0",paraId:98,tocIndex:53},{value:"刻度 TimeBar 距离边界的间距",paraId:98,tocIndex:53},{value:"selectedTickStyle",paraId:98,tocIndex:53},{value:"ShapeStyle",paraId:98,tocIndex:53},{value:"null",paraId:98,tocIndex:53},{value:"选中刻度的样式配置项",paraId:98,tocIndex:53},{value:"unselectedTickStyle",paraId:98,tocIndex:53},{value:"ShapeStyle",paraId:98,tocIndex:53},{value:"null",paraId:98,tocIndex:53},{value:"未选中刻度的样式配置项",paraId:98,tocIndex:53},{value:"tooltipBackgroundColor",paraId:98,tocIndex:53},{value:"ShapeStyle",paraId:98,tocIndex:53},{value:"null",paraId:98,tocIndex:53},{value:"tooltip 背景框配置项",paraId:98,tocIndex:53},{value:"start",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"0.1",paraId:98,tocIndex:53},{value:"开始位置",paraId:98,tocIndex:53},{value:"end",paraId:98,tocIndex:53},{value:"number",paraId:98,tocIndex:53},{value:"0.9",paraId:98,tocIndex:53},{value:"结束位置",paraId:98,tocIndex:53},{value:"data",paraId:98,tocIndex:53},{value:"any[]",paraId:98,tocIndex:53},{value:"[]",paraId:98,tocIndex:53},{value:"必选，刻度时间轴的刻度数据",paraId:98,tocIndex:53},{value:"tickLabelFormatter",paraId:98,tocIndex:53},{value:"Function",paraId:98,tocIndex:53},{value:"null",paraId:98,tocIndex:53},{value:"刻度的格式化回调函数",paraId:98,tocIndex:53},{value:"tooltipFomatter",paraId:98,tocIndex:53},{value:"Function",paraId:98,tocIndex:53},{value:"null",paraId:98,tocIndex:53},{value:"tooltip 上内容格式化的回调函数",paraId:98,tocIndex:53},{value:"export interface TickCfg {\n  // 时间轴下方文本的格式化函数\n  readonly tickLabelFormatter?: (d: any) => string | undefined;\n  // 时间轴下方文本的图形样式。[v4.5.1 起支持] 可配置 tickLabelStyle.rotate 以控制时间轴下方每个文本的旋转角度，可避免文本相互重叠\n  readonly tickLabelStyle?: ShapeStyle;\n  // 时间轴下方文本上的竖线图形样式\n  readonly tickLineStyle?: ShapeStyle;\n}\n",paraId:99,tocIndex:54},{value:"Name",paraId:100,tocIndex:55},{value:"Type",paraId:100,tocIndex:55},{value:"Default Value",paraId:100,tocIndex:55},{value:"Description",paraId:100,tocIndex:55},{value:"tickLabelFormatter",paraId:100,tocIndex:55},{value:"Function",paraId:100,tocIndex:55},{value:"null",paraId:100,tocIndex:55},{value:"时间轴下方文本的格式化函数",paraId:100,tocIndex:55},{value:"tickLabelStyle",paraId:100,tocIndex:55},{value:"ShapeStyle",paraId:100,tocIndex:55},{value:"{}",paraId:100,tocIndex:55},{value:"时间轴下方文本的图形样式。[v4.5.1 起支持] 可配置 tickLabelStyle.rotate 以控制时间轴下方每个文本的旋转角度，可避免文本相互重叠",paraId:100,tocIndex:55},{value:"tickLineStyle",paraId:100,tocIndex:55},{value:"ShapeStyle",paraId:100,tocIndex:55},{value:"{}",paraId:100,tocIndex:55},{value:"时间轴下方文本上方的竖线的图形样式",paraId:100,tocIndex:55},{value:"暂不支持",paraId:101,tocIndex:56},{value:"控制按钮暂不支持配置样式",paraId:102,tocIndex:56},{value:"不支持循环播放",paraId:103,tocIndex:56},{value:"type ControllerCfg = Partial<{\n\n  /** 控制栏的起始位置以及宽高，width height 将不缩放内部子控制器，仅影响它们的位置分布。需要缩放请使用 scale */\n  readonly x?: number;\n  readonly y?: number;\n  readonly width: number;\n  readonly height: number;\n  /** 控制栏缩放比例 */\n  readonly scale?: number;\n  /** 控制器背景的颜色和描边色 */\n  readonly fill?: string;\n  readonly stroke?: string;\n  /** 整个控制栏的字体样式，优先级低于各个子控制器的 text 内的 fontFamily */\n  readonly fontFamily?: string;\n\n  /** 播放速度，1 个 tick 花费时间 */\n  readonly speed?: number;\n  /** 是否循环播放 */\n  readonly loop?: boolean;\n  /** 是否隐藏右下角的 ’播放时间类型切换器‘ */\n  readonly hideTimeTypeController: boolean;\n\n  /** ‘上一帧’按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly preBtnStyle?: ShapeStyle;\n\n  /** ‘下一帧’按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly nextBtnStyle?: ShapeStyle;\n\n  /** ‘播放’ 与 ‘暂停’ 按钮的样式，同时可以为其配置 scale、offsetX、offsetY 单独控制该控制器的缩放以及平移 */\n  readonly playBtnStyle?: ShapeStyle;\n\n  /** ‘速度控制器’ 的样式，包括速度的指针、速度指示滚轮（横线）、文本的样式，同时可以为 speedControllerStyle 及其子图形样式配置 scale、offsetX、offsetY 单独控制该控制器及其子图形的缩放以及平移） */\n  readonly speedControllerStyle?: {\n    offsetX?: number,\n    offsetY?: number;\n    scale?: number\n    pointer?: ShapeStyle,\n    scroller?: ShapeStyle,\n    text?: ShapeStyle\n  };\n\n  /** ‘播放时间类型切换器’ 的样式，包括 checkbox 的框、checkbox 的选中勾、文本的样式，同时可以为 timeTypeControllerStyle 及其子图形样式配置 scale、offsetX、offsetY 单独控制该控制器及其子图形的缩放以及平移  */\n  readonly timeTypeControllerStyle?: {\n    offsetX?: number,\n    offsetY?: number;\n    scale?: number\n    check?: ShapeStyle,\n    box?: ShapeStyle,\n    text?: ShapeStyle\n  };\n  /** [v4.5.1 起支持] 控制栏背景方框的样式 */\n  readonly containerStyle?: ExtendedShapeStyle;\n  /** ‘播放时间类型切换器’单一文本时的文本，默认为‘单一时间’ */\n  readonly timePointControllerText?: string;\n  /** ‘播放时间类型切换器’单一文本时的文本，默认为‘时间范围’ */\n  readonly timeRangeControllerText?: string;\n}>\n",paraId:104,tocIndex:56},{value:"名称",paraId:105,tocIndex:57},{value:"类型",paraId:105,tocIndex:57},{value:"默认值",paraId:105,tocIndex:57},{value:"描述",paraId:105,tocIndex:57},{value:"x",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"0",paraId:105,tocIndex:57},{value:"控制栏开始 x 坐标",paraId:105,tocIndex:57},{value:"y",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"0",paraId:105,tocIndex:57},{value:"控制栏开始 y 坐标",paraId:105,tocIndex:57},{value:"width",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"TimeBar 宽度",paraId:105,tocIndex:57},{value:"控制栏宽度，将不缩放内部子控制器，仅影响它们的位置分布",paraId:105,tocIndex:57},{value:"height",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"40",paraId:105,tocIndex:57},{value:"控制栏高度，将不缩放内部子控制器，仅影响它们的位置分布",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"1",paraId:105,tocIndex:57},{value:"控制栏缩放比例",paraId:105,tocIndex:57},{value:"speed",paraId:105,tocIndex:57},{value:"number",paraId:105,tocIndex:57},{value:"1",paraId:105,tocIndex:57},{value:"播放速度",paraId:105,tocIndex:57},{value:"loop",paraId:105,tocIndex:57},{value:"boolean",paraId:105,tocIndex:57},{value:"false",paraId:105,tocIndex:57},{value:"暂不支持，是否循环播放",paraId:105,tocIndex:57},{value:"hideTimeTypeController",paraId:105,tocIndex:57},{value:"boolean",paraId:105,tocIndex:57},{value:"true",paraId:105,tocIndex:57},{value:"是否隐藏时间类型切换",paraId:105,tocIndex:57},{value:"fill",paraId:105,tocIndex:57},{value:"string",paraId:105,tocIndex:57},{value:"控制栏背景框填充色",paraId:105,tocIndex:57},{value:"stroke",paraId:105,tocIndex:57},{value:"string",paraId:105,tocIndex:57},{value:"整个控制栏的字体样式，优先级低于各个子控制器的 text 内的 fontFamily",paraId:105,tocIndex:57},{value:"preBtnStyle",paraId:105,tocIndex:57},{value:"string",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"控制栏背景框边框色",paraId:105,tocIndex:57},{value:"preBtnStyle",paraId:105,tocIndex:57},{value:"ShapeStyle",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"‘上一帧’按钮的样式，同时可以为其配置 ",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetX",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetY",paraId:105,tocIndex:57},{value:" 单独控制该控制器的缩放以及平移",paraId:105,tocIndex:57},{value:"nextBtnStyle",paraId:105,tocIndex:57},{value:"ShapeStyle",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"‘下一帧’按钮的样式，同时可以为其配置 ",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetX",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetY",paraId:105,tocIndex:57},{value:" 单独控制该控制器的缩放以及平移",paraId:105,tocIndex:57},{value:"playBtnStyle",paraId:105,tocIndex:57},{value:"ShapeStyle",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"‘播放’ 与 ‘暂停’ 按钮的样式，同时可以为其配置 ",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetX",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetY",paraId:105,tocIndex:57},{value:" 单独控制该控制器的缩放以及平移",paraId:105,tocIndex:57},{value:"speedControllerStyle",paraId:105,tocIndex:57},{value:"{ offsetX?: number, offsetY?: number, scale?: number, pointer?: ShapeStyle, text?: ShapeStyle, scroller?: ShapeStyle}",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"‘速度控制器’ 的样式，包括速度的指针、速度指示滚轮（横线）、文本的样式，同时可以为 ",paraId:105,tocIndex:57},{value:"speedControllerStyle",paraId:105,tocIndex:57},{value:" 及其子图形样式配置 ",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetX",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetY",paraId:105,tocIndex:57},{value:" 单独控制该控制器及其子图形的缩放以及平移",paraId:105,tocIndex:57},{value:"timeTypeControllerStyle",paraId:105,tocIndex:57},{value:"{ offsetX?: number, offsetY?: number, scale?: number, box?: ShapeStyle, check?: ShapeStyle, text?: ShapeStyle }",paraId:105,tocIndex:57},{value:"null",paraId:105,tocIndex:57},{value:"‘播放时间类型切换器’ 的样式，包括 checkbox 的框、checkbox 的选中勾、文本的样式，同时可以为 ",paraId:105,tocIndex:57},{value:"timeTypeControllerStyle",paraId:105,tocIndex:57},{value:" 及其子图形样式配置 ",paraId:105,tocIndex:57},{value:"scale",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetX",paraId:105,tocIndex:57},{value:"、",paraId:105,tocIndex:57},{value:"offsetY",paraId:105,tocIndex:57},{value:" 单独控制该控制器及其子图形的缩放以及平移",paraId:105,tocIndex:57},{value:"containerStyle ｜ ShapeStyle",paraId:105,tocIndex:57},{value:"{}",paraId:105,tocIndex:57},{value:"控制栏背景方框的样式",paraId:105,tocIndex:57},{value:"timePointControllerText",paraId:105,tocIndex:57},{value:"string",paraId:105,tocIndex:57},{value:'"单一时间"',paraId:105,tocIndex:57},{value:"右下角“单一时间”文本，默认为”单一时间“",paraId:105,tocIndex:57},{value:"timePointControllerText",paraId:105,tocIndex:57},{value:"string",paraId:105,tocIndex:57},{value:'"时间范围"',paraId:105,tocIndex:57},{value:"右下角“单一时间”文本，默认为”时间范围时间“",paraId:105,tocIndex:57}]},12610:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"当缩放画布的时候，有时候我们希望 Tooltip、ContextMenu 等组件也自动跟随画布缩放，在实际业务需求中，也遇到了这样的诉求：",paraId:0},{value:"https://github.com/antvis/G6/issues/2111",paraId:0},{value:"。",paraId:0},{value:"G6 里面缩放画布是通过 zoom-canvas Behavior 实现的，缩放过程中会触发 wheelzoom 事件，因此，我们只需要监听该事件，就可以让 Tooltip 自动缩放。",paraId:1,tocIndex:0},{value:"graph.on('wheelzoom', (e) => {\n  e.stopPropagation();\n  // 这里的 className 根据实际情况而定，默认是 g6-component-tooltip\n  const tooltips = Array.from(document.getElementsByClassName('g6-component-tooltip'));\n  tooltips.forEach((tooltip) => {\n    if (tooltip && tooltip.style) {\n      tooltip.style.transform = `scale(${graph.getZoom()})`;\n    }\n  });\n});\n",paraId:2,tocIndex:0},{value:"也可以根据我们的实际需要，控制 Tooltip 缩放的最大和最小比例。",paraId:3,tocIndex:0},{value:" ",paraId:3,tocIndex:0},{value:"完整的示例请参考",paraId:3,tocIndex:0},{value:"这里",paraId:3,tocIndex:0},{value:"。",paraId:3,tocIndex:0},{value:"当画布缩放时，ContextMenu 的自动缩放实现方式和 Tooltip 的完全一样，只需要将 Tooltip 容器的 className 名称修改为 ContextMenu 容器的 className 名即可。",paraId:4,tocIndex:1}]},4752:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"除了 ",paraId:0},{value:"内置交互行为  Behavior",paraId:1},{value:" 和 ",paraId:0},{value:"交互模式 Mode",paraId:2},{value:" 搭配的事件管理方式外，G6 提供了直接的单个事件、时机的监听方法，可以监听画布、节点、边、以及各函数被调用的时机等。如果要了解 G6 支持的所有事件，请参考 ",paraId:0},{value:"Event API",paraId:3},{value:"。",paraId:0},{value:"G6 上所有的事件都需要在 graph 上监听",paraId:0},{value:"。这些事件可以分为以下六个层次：",paraId:0},{value:"全局事件",paraId:4},{value:"只要在画布上范围内发生均会被触发，如 ",paraId:5},{value:"mousedown",paraId:5},{value:"，",paraId:5},{value:"mouseup",paraId:5},{value:"，",paraId:5},{value:"click",paraId:5},{value:"，",paraId:5},{value:"mouseenter",paraId:5},{value:"，",paraId:5},{value:"mouseleave",paraId:5},{value:" 等。",paraId:5},{value:"graph.on('click', (ev) => {\n  const shape = ev.target;\n  const item = ev.item;\n  if (item) {\n    const type = item.getType();\n  }\n});\n",paraId:6},{value:"canvas 事件",paraId:7},{value:"只在 canvas 空白处被触发，如 ",paraId:8},{value:"canvas:mousedown",paraId:8},{value:"，",paraId:8},{value:"canvas:click",paraId:8},{value:" 等，以",paraId:8},{value:"canvas:eventName",paraId:8},{value:" 为事件名称。",paraId:8},{value:"graph.on('canvas:click', (ev) => {\n  const shape = ev.target;\n  const item = ev.item;\n  if (item) {\n    const type = item.getType();\n  }\n});\n",paraId:9},{value:"节点/边/combo 上的事件",paraId:10},{value:"例如 ",paraId:11},{value:"node:mousedown",paraId:11},{value:"，",paraId:11},{value:"edge:click",paraId:11},{value:", ",paraId:11},{value:"combo:click",paraId:11},{value:" 等，以 ",paraId:11},{value:"type:eventName",paraId:11},{value:" 为事件名称。",paraId:11},{value:"graph.on('node:click', (ev) => {\n  const node = ev.item; // 被点击的节点元素\n  const shape = ev.target; // 被点击的图形，可根据该信息作出不同响应，以达到局部响应效果\n  // ... do sth\n});\n\ngraph.on('edge:click', (ev) => {\n  const edge = ev.item; // 被点击的边元素\n  const shape = ev.target; // 被点击的图形，可根据该信息作出不同响应，以达到局部响应效果\n  // ... do sth\n});\n\ngraph.on('combo:click', (ev) => {\n  const combo = ev.item; // 被点击 combo 元素\n  const shape = ev.target; // 被点击的图形，可根据该信息作出不同响应，以达到局部响应效果\n  // ... do sth\n});\n",paraId:12},{value:"图形上的事件",paraId:13},{value:"指定图形上的事件，如 ",paraId:14},{value:"circle-shape:mousedown",paraId:14},{value:"，",paraId:14},{value:"circle-shape:click",paraId:14},{value:" 等，以 ",paraId:14},{value:"shapeName:eventName",paraId:14},{value:" 为事件名称。可用于绑定节点/边/combo 中对局部图形做出响应的场景。效果类似上文 ",paraId:14},{value:"graph.on('node:click', fn)",paraId:14},{value:" 中通过 ",paraId:14},{value:"target",paraId:14},{value:" 信息作出不同响应。",paraId:14},{value:"关于图形的 name：",paraId:15},{value:"内置节点/边/combo 上每个图形的名称在开发过程中可以通过 ",paraId:16},{value:"graph.on('node:click', (ev) => console.log(ev.target.get('name')))",paraId:16},{value:" 得知；",paraId:16},{value:"自定义节点/边/combo 中通过 addShape 增加的图形，可添加与 attrs 平级的 name 字段指定任意（",paraId:16},{value:"注意：同元素类型中需要是唯一的",paraId:16},{value:"）字符串作为 name。",paraId:16},{value:"下面例子为图中所有 name 为 circle-shape 的图形绑定了 click 事件监听：",paraId:17},{value:"graph.on('circle-shape:click', (ev) => {\n  const shape = ev.target; // 被点击的图形\n  // ... do sth\n});\n",paraId:18},{value:"时机事件",paraId:19},{value:"时机事件指渲染、视口变换、元素增删改、数据变换等时机。所有时机事件详见 ",paraId:20},{value:"G6 的时机事件列表",paraId:21},{value:"。如：",paraId:20},{value:"beforeadditem",paraId:20},{value:"，",paraId:20},{value:"afteradditem",paraId:20},{value:"  等：",paraId:20},{value:"节点/边/Combo 状态改变时的事件：",paraId:22},{value:"beforerefreshitem",paraId:22},{value:" 与 ",paraId:22},{value:"afterrefreshitem",paraId:22},{value:"；",paraId:22},{value:"布局时机：",paraId:22},{value:"beforelayout",paraId:22},{value:" 与 ",paraId:22},{value:"afterlayout",paraId:22},{value:"。",paraId:22},{value:"下面例子为 graph 绑定了渲染完成时机的监听。时机事件中，afterrender、afterlayout 一类事件必须在 ",paraId:23},{value:"graph.render()",paraId:23},{value:" 或 ",paraId:23},{value:"graph.read()",paraId:23},{value:" 之前绑定，方可监听到首次渲染、布局完成后的相关事件。",paraId:23},{value:"graph.on('afterrender', (ev) => {\n  // ... do sth\n});\n",paraId:24},{value:"自定义事件",paraId:25},{value:"G6 允许用户自定义任意事件，可在任意位置通过 ",paraId:26},{value:"graph.emit(customEventName: string, event: IG6GraphEvent)",paraId:26},{value:" 触发一个事件，第一个参数为自定义事件名称。在触发前，通过 ",paraId:26},{value:"graph.on(customEventName: string, callback: Function)",paraId:26},{value:" 进行监听。例如：",paraId:26},{value:"graph.on('some-custom-event-name', (ev) => {\n  // ... do sth\n});\ngraph.emit('some-custom-event-name', {\n  // some params\n})\n",paraId:27}]},79321:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 除了提供丰富的 ",paraId:0},{value:"内置交互行为 Behavior",paraId:1},{value:" 外，还提供了自定义交互行为的机制，方便用户开发更加定制化的交互行为。",paraId:0},{value:"在交互行为上， G6 主要考虑了三个场景：",paraId:2},{value:"展示关系数据；",paraId:3},{value:"可视化建模；",paraId:3},{value:"图分析。",paraId:3},{value:"在这些场景中只要用户可能无法一眼看清楚所有需要的信息，都需要进行交互，例如：",paraId:4},{value:"图太大，需要缩放；",paraId:5},{value:"单个节点上展示的信息太少，需要通过 tooltip 显示详情；",paraId:5},{value:"对节点进行增删改查。",paraId:5},{value:"我们无法将所有常用的交互全部内置到 G6 中。由于场景不一样，业务不一样，同样的目的需要的交互都不一样：",paraId:6},{value:"有些系统需要从工具栏上点击后添加节点，有些系统需要从面板栏上拖出出新的节点；",paraId:7},{value:"有的业务添加边需要从锚点上拖拽出来，而有些直接点击节点后就可以拖拽出边；",paraId:7},{value:"有些边可以连接到所有节点上，而有些边不能连接到具体某个节点的某个锚点上；",paraId:7},{value:"所有的交互的触发、持续、结束都要允许能够进行个性化的判定；",paraId:7},{value:"……",paraId:7},{value:"我们可以看到在图上的交互是繁杂多变的。各种冲突、各种配置项会让用户和开发者疲于应对。出于这些考虑，G6 提供了一套非常简单而灵活的机制来实现交互。",paraId:8},{value:"为实现交互，首先需要了解交互的生命周期。交互起源于用户在系统上的所有事件，是否允许交互发生同事件密切相关。所以我们看到交互的生命周期，即操作事件的过程如下：",paraId:9,tocIndex:0},{value:"绑定事件；",paraId:10,tocIndex:0},{value:"触发事件；",paraId:10,tocIndex:0},{value:"持续事件；",paraId:10,tocIndex:0},{value:"结束事件；",paraId:10,tocIndex:0},{value:"移除事件。",paraId:10,tocIndex:0},{value:"通过 ",paraId:11,tocIndex:1},{value:"G6.registerBehavior",paraId:11,tocIndex:1},{value:" 自定义 Behavior。下面代码实现了名为  ",paraId:11,tocIndex:1},{value:"'activate-node'",paraId:11,tocIndex:1},{value:" 的交互行为，在终端用户点击节点时，置该节点的 ",paraId:11,tocIndex:1},{value:"active",paraId:11,tocIndex:1},{value:" 状态为 ",paraId:11,tocIndex:1},{value:"true",paraId:11,tocIndex:1},{value:"；再次点击或点击画布时，置该节点的 ",paraId:11,tocIndex:1},{value:"active",paraId:11,tocIndex:1},{value:" 状态为 ",paraId:11,tocIndex:1},{value:"false",paraId:11,tocIndex:1},{value:"。",paraId:11,tocIndex:1},{value:"   ",paraId:12,tocIndex:1},{value:"⚠️ 注意:",paraId:12,tocIndex:1},{value:"下面代码仅设置了不同交互后节点的状态，没有指定这些状态下节点的样式。若需要根据节点状态变化它的样式，参见 ",paraId:13,tocIndex:1},{value:"配置不同 State 下的节点样式",paraId:14,tocIndex:1},{value:"。",paraId:13,tocIndex:1},{value:"自定义 Behavior 时，可选的方法请参数  ",paraId:13,tocIndex:1},{value:"Behavior API",paraId:15,tocIndex:1},{value:"；",paraId:13,tocIndex:1},{value:"getEvent",paraId:13,tocIndex:1},{value:" 返回该 Behavior 所需监听事件的对象，G6 中支持的所有事件，请参考  ",paraId:13,tocIndex:1},{value:"Event API",paraId:16,tocIndex:1},{value:"。",paraId:13,tocIndex:1},{value:"G6.registerBehavior('activate-node', {\n  getDefaultCfg() {\n    return {\n      multiple: true\n    };\n  },\n  getEvents() {\n    return {\n      'node:click': 'onNodeClick',\n      'canvas:click': 'onCanvasClick'\n    };\n  }\n  onNodeClick(e) {\n    const graph = this.graph;\n    const item = e.item;\n    if (item.hasState('active')) {\n      graph.setItemState(item, 'active', false);\n      return;\n    }\n    // this 上即可取到配置，如果不允许多个 'active'，先取消其他节点的 'active' 状态\n    if (!this.multiple) {\n      this.removeNodesState();\n    }\n    // 置点击的节点状态 'active' 为 true\n    graph.setItemState(item, 'active', true);\n  },\n  onCanvasClick(e) {\n    // shouldUpdate 可以由用户复写，返回 true 时取消所有节点的 'active' 状态，即将 'active' 状态置为 false\n    if (this.shouldUpdate(e, self)) {\n      removeNodesState();\n    }\n  },\n  removeNodesState() {\n    graph.findAllByState('node', 'active').forEach(node => {\n        graph.setItemState(node, 'active', false);\n      });\n  }\n});\n",paraId:17,tocIndex:1},{value:"有了上面代码定义的名为 ",paraId:18,tocIndex:2},{value:"'activate-node'",paraId:18,tocIndex:2},{value:" 的 Behavior 以后，在实例化 Graph 时，在 ",paraId:18,tocIndex:2},{value:"modes",paraId:18,tocIndex:2},{value:" 中将其配置到默认或其他",paraId:18,tocIndex:2},{value:"行为模式",paraId:19,tocIndex:2},{value:"中。下面代码将其配置到了默认行为模式中，在默认模式下，该行为将会生效。",paraId:18,tocIndex:2},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  modes: {\n    // 定义的 Behavior 指定到这里，就可以支持 Behavior 中定义的交互\n    default: ['activate-node'],\n  },\n});\n",paraId:20,tocIndex:2}]},44826:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"Behavior 是 G6 提供的定义图上交互事件的机制。它与",paraId:0,tocIndex:0},{value:"交互模式 Mode",paraId:1,tocIndex:0},{value:" 搭配使用，如何将下文所述各种 Behavior 配置到图上，见 ",paraId:0,tocIndex:0},{value:"交互模式",paraId:2,tocIndex:0},{value:"。",paraId:0,tocIndex:0},{value:"理论上， G6 上的所有基础图形、Item（节点/边）都能通过事件来进行操作。考虑到通用性，G6 目前共提供了以下 14 个内置的 Behavior。此外，用户可以注册 ",paraId:3,tocIndex:1},{value:"自定义 Behavior",paraId:4,tocIndex:1},{value:"。",paraId:3,tocIndex:1},{value:"V3.5 以上版本支持。",paraId:5,tocIndex:2},{value:"含义：拖动 Combo；",paraId:6,tocIndex:2},{value:"配置项：\n",paraId:6,tocIndex:2},{value:"type: 'drag-combo'",paraId:7,tocIndex:2},{value:"；",paraId:7,tocIndex:2},{value:"enableDelegate",paraId:7,tocIndex:2},{value:"：拖动 Combo 时候是否开启图形代理 delegate，即拖动 Combo 时候 Combo 不会实时跟随变动，拖动过程中有临时生成一个 delegate 图形，拖动结束后才更新 Combo 位置，默认为 false，不开启；",paraId:7,tocIndex:2},{value:"delegateStyle",paraId:7,tocIndex:2},{value:"：delegate 的样式；",paraId:7,tocIndex:2},{value:"onlyChangeComboSize",paraId:7,tocIndex:2},{value:"：拖动嵌套的 Combo 时，只改变父 Combo 的大小，不改变层级关系，默认为 false；",paraId:7,tocIndex:2},{value:"activeState",paraId:7,tocIndex:2},{value:"：当拖动 Combo 时，父 Combo 或进入到的 Combo 的状态值，需要用户在实例化 Graph 时在 ",paraId:7,tocIndex:2},{value:"comboStateStyles",paraId:7,tocIndex:2},{value:" 里面配置，默认为空；",paraId:7,tocIndex:2},{value:"selectedState",paraId:7,tocIndex:2},{value:"：选中 Combo 的状态，默认为 selected，需要在 ",paraId:7,tocIndex:2},{value:"comboStateStyles",paraId:7,tocIndex:2},{value:" 里面配置；",paraId:7,tocIndex:2},{value:"shouldUpdate(e, self)",paraId:7,tocIndex:2},{value:"：是否允许当前被操作的 combo 被拖拽，参见下面示例。",paraId:7,tocIndex:2},{value:"v4.7.16 起支持",paraId:7,tocIndex:2},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:7,tocIndex:2},{value:"shouldEnd",paraId:7,tocIndex:2},{value:" 中访问该实例；",paraId:7,tocIndex:2},{value:"shouldEnd(e, newParent, self)",paraId:7,tocIndex:2},{value:"：【v4.3.8 后支持】是否允许当前被操作的 combo 完成拖拽。第二个参数为拖拽释放时检测到的新父 combo，若释放在画布上，则 ",paraId:7,tocIndex:2},{value:"newParent",paraId:7,tocIndex:2},{value:" 为 ",paraId:7,tocIndex:2},{value:"undefined",paraId:7,tocIndex:2},{value:"，参见下面示例。",paraId:7,tocIndex:2},{value:"v4.7.16 起支持",paraId:7,tocIndex:2},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:7,tocIndex:2},{value:"shouldEnd",paraId:7,tocIndex:2},{value:" 中访问该实例。",paraId:7,tocIndex:2},{value:"使用默认配置",paraId:8,tocIndex:2},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['drag-combo'],\n  },\n});\n",paraId:9,tocIndex:2},{value:"用户可根据实际需求，为 ",paraId:10,tocIndex:2},{value:"activeState",paraId:10,tocIndex:2},{value:" 或 ",paraId:10,tocIndex:2},{value:"selectedState",paraId:10,tocIndex:2},{value:" 配置样式：",paraId:10,tocIndex:2},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'drag-combo',\n        enableDelegate: true,\n        activeState: 'actived',\n        shouldUpdate: (e, self) => {\n          // 不允许 id 为 'combo1' 的 combo 被拖拽\n          if (e.item && e.item.getModel().id === 'combo1') return false;\n          return true;\n        },\n        // shouldEnd【v4.3.8 后支持】\n        shouldEnd: (e, newParent, self) => {\n          // 不可以将 combo 释放到 combo1 上\n          if (newParent && newParent.getModel().id === 'combo1') return false;\n          return true;\n        }\n      },\n    ],\n  },\n  comboStateStyles: {\n    actived: {\n      stroke: 'red',\n      lineWidth: 3,\n    },\n  },\n});\n",paraId:11,tocIndex:2},{value:"V3.5 以上版本支持。",paraId:12,tocIndex:3},{value:"含义：收起和展开 Combo。若图配置有布局，则该 behavior 被触发后会触发图的重新布局。若希望避免重新布局，可以通过监听 combo 点击事件和 ",paraId:13,tocIndex:3},{value:"graph.collapseExpandCombo API",paraId:14,tocIndex:3},{value:" 控制收缩展开逻辑；",paraId:13,tocIndex:3},{value:"配置项：\n",paraId:13,tocIndex:3},{value:"type: 'collapse-expand-combo'",paraId:15,tocIndex:3},{value:"；",paraId:15,tocIndex:3},{value:"trigger",paraId:15,tocIndex:3},{value:"：触发方式，默认为双击收起或展示，可配置 ",paraId:15,tocIndex:3},{value:"'click'",paraId:15,tocIndex:3},{value:" 和 ",paraId:15,tocIndex:3},{value:"'dblclick'",paraId:15,tocIndex:3},{value:"；",paraId:15,tocIndex:3},{value:"relayout",paraId:15,tocIndex:3},{value:"：收缩或展开后是否触发重新布局，默认为 ",paraId:15,tocIndex:3},{value:"true",paraId:15,tocIndex:3},{value:"。",paraId:15,tocIndex:3},{value:"使用默认配置",paraId:16,tocIndex:3},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['collapse-expand-combo'],\n  },\n});\n",paraId:17,tocIndex:3},{value:"用户可以配置成单击展示或收起：",paraId:18,tocIndex:3},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'collapse-expand-combo',\n        trigger: 'click',\n        relayout: false, // 收缩展开后，不重新布局\n      },\n    ],\n  },\n});\n",paraId:19,tocIndex:3},{value:"含义：拖拽画布；",paraId:20,tocIndex:4},{value:"配置项：",paraId:21,tocIndex:4},{value:"type: 'drag-canvas'",paraId:22,tocIndex:4},{value:"；",paraId:22,tocIndex:4},{value:"direction",paraId:22,tocIndex:4},{value:"：允许拖拽方向，支持",paraId:22,tocIndex:4},{value:"'x'",paraId:22,tocIndex:4},{value:"，",paraId:22,tocIndex:4},{value:"'y'",paraId:22,tocIndex:4},{value:"，",paraId:22,tocIndex:4},{value:"'both'",paraId:22,tocIndex:4},{value:"，默认方向为 ",paraId:22,tocIndex:4},{value:"'both'",paraId:22,tocIndex:4},{value:"；",paraId:22,tocIndex:4},{value:"enableOptimize",paraId:22,tocIndex:4},{value:"：是否开启优化，开启后拖动画布过程中隐藏所有的边及节点上非 keyShape 部分，默认关闭；",paraId:22,tocIndex:4},{value:"shouldBegin(e, self)",paraId:22,tocIndex:4},{value:"：是否允许触发该操作。",paraId:22,tocIndex:4},{value:"v4.7.16 起支持",paraId:22,tocIndex:4},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:22,tocIndex:4},{value:"shouldBegin",paraId:22,tocIndex:4},{value:" 中访问该实例；",paraId:22,tocIndex:4},{value:"allowDragOnItem",paraId:22,tocIndex:4},{value:"：是否允许用户在节点/边/ combo 上拖拽时响应，默认为 false。",paraId:22,tocIndex:4},{value:"v4.8.4 起支持：",paraId:22,tocIndex:4},{value:" 支持配置类型为 ",paraId:22,tocIndex:4},{value:"{ node?: boolean, edge?: boolean, combo?: boolean }",paraId:22,tocIndex:4},{value:" 的对象，以支持控制是否允许响应不同元素类型上的拖拽事件；",paraId:22,tocIndex:4},{value:"scalableRange",paraId:22,tocIndex:4},{value:"：拖动 canvas 可扩展的范围，默认为 0，值为 -1 ～ 1 代表可超出视口的范围的比例值（相对于视口大小）。值小于 -1 或大于 1 时，为正和负数时的效果如下图所示。",paraId:22,tocIndex:4},{value:"相关时机事件：",paraId:23,tocIndex:4},{value:"canvas:dragstart",paraId:24,tocIndex:4},{value:"：画布拖拽开始时触发，使用 ",paraId:24,tocIndex:4},{value:"graph.on('canvas:dragstart', e => {...})",paraId:24,tocIndex:4},{value:" 监听；",paraId:24,tocIndex:4},{value:"canvas:drag",paraId:24,tocIndex:4},{value:"：画布拖拽中触发，使用 ",paraId:24,tocIndex:4},{value:"graph.on('canvas:drag', e => {...})",paraId:24,tocIndex:4},{value:" 监听；",paraId:24,tocIndex:4},{value:"canvas:dragend",paraId:24,tocIndex:4},{value:"：画布拖拽结束后触发，使用 ",paraId:24,tocIndex:4},{value:"graph.on('canvas:dragend', e => {...})",paraId:24,tocIndex:4},{value:" 监听。",paraId:24,tocIndex:4},{value:"使用默认配置",paraId:25,tocIndex:4},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['drag-canvas'],\n  },\n});\n",paraId:26,tocIndex:4},{value:"默认配置下，可以在 x 和 y 两个方向上拖动画布。",paraId:27,tocIndex:4},{value:"使用自定义参数",paraId:28,tocIndex:4},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'drag-canvas',\n        direction: 'x',\n      },\n    ],\n  },\n});\n",paraId:29,tocIndex:4},{value:"此时只能在 x 方向上面拖动，y 方向上不允许拖动。",paraId:30,tocIndex:4},{value:"含义：滚轮滚动画布，",paraId:31,tocIndex:5},{value:"v4.2.6 起支持",paraId:31,tocIndex:5},{value:"；",paraId:31,tocIndex:5},{value:"配置项：",paraId:32,tocIndex:5},{value:"type: 'scroll-canvas'",paraId:33,tocIndex:5},{value:"；",paraId:33,tocIndex:5},{value:"direction",paraId:33,tocIndex:5},{value:"：允许拖拽方向，支持",paraId:33,tocIndex:5},{value:"'x'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'y'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'both'",paraId:33,tocIndex:5},{value:"，默认方向为 ",paraId:33,tocIndex:5},{value:"'both'",paraId:33,tocIndex:5},{value:"；",paraId:33,tocIndex:5},{value:"enableOptimize",paraId:33,tocIndex:5},{value:"：是否开启优化，开启后拖动画布过程中隐藏所有的边及节点上非 keyShape 部分，默认关闭；",paraId:33,tocIndex:5},{value:"zoomKey",paraId:33,tocIndex:5},{value:"：切换为滚动缩放的键盘按钮，按住该键并滚动滚轮，则切换为滚轮缩放画布，可选项为：",paraId:33,tocIndex:5},{value:"'shift'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'ctrl'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'alt'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'control'",paraId:33,tocIndex:5},{value:"，",paraId:33,tocIndex:5},{value:"'meta'",paraId:33,tocIndex:5},{value:", 可使用数组监听多个按键，任意按键按下时都会触发缩放；",paraId:33,tocIndex:5},{value:"scalableRange",paraId:33,tocIndex:5},{value:"：拖动 canvas 可扩展的范围，默认为 0，值为 -1 ～ 1 代表可超出视口的范围的比例值（相对于视口大小）。值小于 -1 或大于 1 时，为正和负数时的效果如下图所示。",paraId:33,tocIndex:5},{value:"allowDragOnItem",paraId:33,tocIndex:5},{value:"：是否允许用户在节点/边/ combo 上拖拽时响应，默认为 false。",paraId:33,tocIndex:5},{value:"v4.8.4 起支持：",paraId:33,tocIndex:5},{value:" 支持配置类型为 ",paraId:33,tocIndex:5},{value:"{ node?: boolean, edge?: boolean, combo?: boolean }",paraId:33,tocIndex:5},{value:" 的对象，以支持控制是否允许响应不同元素类型上的拖拽事件；",paraId:33,tocIndex:5},{value:"相关时机事件：",paraId:34,tocIndex:5},{value:"onWheel",paraId:35,tocIndex:5},{value:"：滚轮滚动时触发，使用 ",paraId:35,tocIndex:5},{value:"graph.on('wheel', e => {...})",paraId:35,tocIndex:5},{value:" 监听。",paraId:35,tocIndex:5},{value:"使用默认配置",paraId:36,tocIndex:5},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['scroll-canvas'],\n  },\n});\n",paraId:37,tocIndex:5},{value:"默认配置下，可以在 x 和 y 两个方向上滚动画布。",paraId:38,tocIndex:5},{value:"使用自定义参数",paraId:39,tocIndex:5},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'scroll-canvas',\n        direction: 'x',\n      },\n    ],\n  },\n});\n",paraId:40,tocIndex:5},{value:"此时只能在 x 方向上面滚动，y 方向上不允许滚动。",paraId:41,tocIndex:5},{value:"含义：缩放画布；",paraId:42,tocIndex:6},{value:"type: 'zoom-canvas'",paraId:42,tocIndex:6},{value:"；",paraId:42,tocIndex:6},{value:"配置项：\n",paraId:42,tocIndex:6},{value:"sensitivity",paraId:43,tocIndex:6},{value:"：缩放灵敏度，支持 1-10 的数值，默认灵敏度为 5；",paraId:43,tocIndex:6},{value:"minZoom",paraId:43,tocIndex:6},{value:"：最小缩放比例；",paraId:43,tocIndex:6},{value:"maxZoom",paraId:43,tocIndex:6},{value:"：最大缩放比例；",paraId:43,tocIndex:6},{value:"enableOptimize",paraId:43,tocIndex:6},{value:"：是否开启性能优化，默认为 false，设置为 true 开启，开启后缩放比例小于 optimizeZoom 时自动隐藏非 keyShape；",paraId:43,tocIndex:6},{value:"optimizeZoom",paraId:43,tocIndex:6},{value:"：当 enableOptimize 为 true 时起作用，默认值为 0.7，表示当缩放到哪个比例时开始隐藏非 keyShape；",paraId:43,tocIndex:6},{value:"shouldUpdate(e, self)",paraId:43,tocIndex:6},{value:"：是否允许发生缩放。",paraId:43,tocIndex:6},{value:"v4.7.16 起支持",paraId:43,tocIndex:6},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:43,tocIndex:6},{value:"shouldBegin",paraId:43,tocIndex:6},{value:" 中访问该实例；",paraId:43,tocIndex:6},{value:"fixSelectedItems",paraId:43,tocIndex:6},{value:"：在缩小画布时是否固定选定元素的描边粗细、文本大小、整体大小等，",paraId:43,tocIndex:6},{value:"fixSelectedItems",paraId:43,tocIndex:6},{value:" 是一个对象，有以下变量：\n",paraId:43,tocIndex:6},{value:"fixSelectedItems.fixState",paraId:44,tocIndex:6},{value:"：将被固定的元素状态，被设置为该状态的节点将会在画布缩小时参与固定大小的计算，默认为 ",paraId:44,tocIndex:6},{value:"'selected'",paraId:44,tocIndex:6},{value:"；",paraId:44,tocIndex:6},{value:"fixSelectedItems.fixAll",paraId:44,tocIndex:6},{value:"：固定元素的整体大小，优先级高于 ",paraId:44,tocIndex:6},{value:"fixSelectedItems.fixLineWidth",paraId:44,tocIndex:6},{value:" 和 ",paraId:44,tocIndex:6},{value:"fixSelectedItems.fixLabel",paraId:44,tocIndex:6},{value:"；",paraId:44,tocIndex:6},{value:"fixSelectedItems.fixLineWidth",paraId:44,tocIndex:6},{value:"：固定元素的 keyShape 的描边粗细；",paraId:44,tocIndex:6},{value:"fixSelectedItems.fixLabel",paraId:44,tocIndex:6},{value:"：固定元素的文本大小。",paraId:44,tocIndex:6},{value:"相关时机事件：\n",paraId:42,tocIndex:6},{value:"wheelzoom(e)",paraId:45,tocIndex:6},{value:"：当缩放发生变化时被触发。使用 ",paraId:45,tocIndex:6},{value:"graph.on('wheelzoom', e => {...})",paraId:45,tocIndex:6},{value:" 监听该时机事件。",paraId:45,tocIndex:6},{value:"提示：若要限定缩放尺寸，请在 graph 上设置  ",paraId:46,tocIndex:6},{value:"minZoom",paraId:46,tocIndex:6},{value:"  和  ",paraId:46,tocIndex:6},{value:"maxZoom",paraId:46,tocIndex:6},{value:"。",paraId:46,tocIndex:6},{value:"说明：",paraId:47,tocIndex:7},{value:" V3.5 以上版本才支持拖动 Combo 中的节点。",paraId:47,tocIndex:7},{value:"含义：拖拽节点，或拖动 Combo 中的节点；",paraId:48,tocIndex:7},{value:"配置项：\n",paraId:48,tocIndex:7},{value:"type: 'drag-node'",paraId:49,tocIndex:7},{value:"；",paraId:49,tocIndex:7},{value:"delegateStyle",paraId:49,tocIndex:7},{value:"：节点拖拽时的绘图属性，默认为 ",paraId:49,tocIndex:7},{value:"{ strokeOpacity: 0.6, fillOpacity: 0.6 }",paraId:49,tocIndex:7},{value:"；",paraId:49,tocIndex:7},{value:"updateEdge",paraId:49,tocIndex:7},{value:"：是否在拖拽节点时更新所有与之相连的边，默认为 ",paraId:49,tocIndex:7},{value:"true",paraId:49,tocIndex:7},{value:" 。",paraId:49,tocIndex:7},{value:"enableDelegate",paraId:49,tocIndex:7},{value:"：拖动节点过程中是否启用 ",paraId:49,tocIndex:7},{value:"delegate",paraId:49,tocIndex:7},{value:"，即在拖动过程中是否使用方框代替元素的直接移动，效果区别见下面两个动图。默认值为  ",paraId:49,tocIndex:7},{value:"false",paraId:49,tocIndex:7},{value:"；",paraId:49,tocIndex:7},{value:"onlyChangeComboSize",paraId:49,tocIndex:7},{value:"：V3.5 及以上版本支持，拖动节点过程中只改变 Combo 大小，不改变 Combo 结构，即不将节点从 Combo 中拖出或将节点拖入到 Combo 中，默认为 false；",paraId:49,tocIndex:7},{value:"enableDebounce",paraId:49,tocIndex:7},{value:"：是否在拖动节点时使用 debounce 来避免频繁的更新计算。这个 boolean 类型的配置项可以为折线边的更新提高性能，减少折线边的频繁重新寻径。默认值为 ",paraId:49,tocIndex:7},{value:"false",paraId:49,tocIndex:7},{value:"；",paraId:49,tocIndex:7},{value:"enableOptimize",paraId:49,tocIndex:7},{value:"：是否在拖拽节点时隐藏相关边，拖拽结束后再显示。这个 boolean 类型的配置项可以完全避免拖拽过程中相关折线边的重新寻径，默认值为 ",paraId:49,tocIndex:7},{value:"false",paraId:49,tocIndex:7},{value:"；",paraId:49,tocIndex:7},{value:"comboActiveState",paraId:49,tocIndex:7},{value:"：V3.5 及以上版本支持，拖动节点过程中，如果存在 Combo，节点所在 Combo 或节点进入的 Combo 的状态，需要在实例化 Graph 时候通过 ",paraId:49,tocIndex:7},{value:"comboStateStyles",paraId:49,tocIndex:7},{value:" 进行配置，默认为空；",paraId:49,tocIndex:7},{value:"selectedState",paraId:49,tocIndex:7},{value:"：V3.5 及以上版本支持，选中 Combo 的样式，需要在实例化 Graph 时候通过 ",paraId:49,tocIndex:7},{value:"comboStateStyles",paraId:49,tocIndex:7},{value:" 进行配置,默认为 selected；",paraId:49,tocIndex:7},{value:"enableStack",paraId:49,tocIndex:7},{value:"：该 behaivor 产生的拖拽节点是否入栈，设置为 false 则不入栈；",paraId:49,tocIndex:7},{value:"shouldBegin(e, self)",paraId:49,tocIndex:7},{value:"：是否允许当前被操作的节点被拖动。",paraId:49,tocIndex:7},{value:"v4.7.16 起支持",paraId:49,tocIndex:7},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:49,tocIndex:7},{value:"shouldBegin",paraId:49,tocIndex:7},{value:" 中访问该实例；",paraId:49,tocIndex:7},{value:"shouldUpdate(e, self)",paraId:49,tocIndex:7},{value:"：是否允许当前被操作的节点在拖动过程中更新自身/ delegate 位置。",paraId:49,tocIndex:7},{value:"v4.7.16 起支持",paraId:49,tocIndex:7},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:49,tocIndex:7},{value:"shouldUpdate",paraId:49,tocIndex:7},{value:" 中访问该实例；",paraId:49,tocIndex:7},{value:"shouldEnd(e, targetItem: Item, self)",paraId:49,tocIndex:7},{value:"：是否允许当前被操作的节点在拖拽结束时更新位置。",paraId:49,tocIndex:7},{value:"v4.7.16 起支持",paraId:49,tocIndex:7},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:49,tocIndex:7},{value:"shouldEnd",paraId:49,tocIndex:7},{value:" 中访问该实例。",paraId:49,tocIndex:7},{value:"使用默认配置",paraId:50,tocIndex:7},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['drag-node'],\n  },\n});\n",paraId:51,tocIndex:7},{value:"启用",paraId:52,tocIndex:7},{value:" ",paraId:52,tocIndex:7},{value:"delegate",paraId:52,tocIndex:7},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'drag-node',\n        enableDelegate: true,\n        shouldBegin: (e, self) => {\n          // 不允许拖拽 id 为 'node1' 的节点\n          if (e.item && e.item.getModel().id === 'node1') return false;\n        },\n      },\n    ],\n  },\n});\n",paraId:53,tocIndex:7},{value:"含义：点击选中节点，再次点击节点或点击 Canvas 取消选中状态；",paraId:54,tocIndex:8},{value:"配置项：\n",paraId:54,tocIndex:8},{value:"type: 'click-select'",paraId:55,tocIndex:8},{value:"；",paraId:55,tocIndex:8},{value:"multiple",paraId:55,tocIndex:8},{value:"：是否允许多选，默认为 ",paraId:55,tocIndex:8},{value:"true",paraId:55,tocIndex:8},{value:"，当设置为 ",paraId:55,tocIndex:8},{value:"false",paraId:55,tocIndex:8},{value:"，表示不允许多选，此时 ",paraId:55,tocIndex:8},{value:"trigger",paraId:55,tocIndex:8},{value:" 参数无效；",paraId:55,tocIndex:8},{value:"trigger",paraId:55,tocIndex:8},{value:"：指定按住哪个键进行多选，默认为 shift，按住 Shift 键多选，用户可配置 shift、ctrl、alt；",paraId:55,tocIndex:8},{value:"selectedState",paraId:55,tocIndex:8},{value:"：被点击选择后设置元素的状态名，默认为 ",paraId:55,tocIndex:8},{value:"'selected'",paraId:55,tocIndex:8},{value:"；",paraId:55,tocIndex:8},{value:"selectNode",paraId:55,tocIndex:8},{value:"：是否允许节点被该交互选中，默认为 ",paraId:55,tocIndex:8},{value:"true",paraId:55,tocIndex:8},{value:"；",paraId:55,tocIndex:8},{value:"selectEdge",paraId:55,tocIndex:8},{value:"：是否允许边被该交互选中，默认为 ",paraId:55,tocIndex:8},{value:"false",paraId:55,tocIndex:8},{value:"；",paraId:55,tocIndex:8},{value:"selectCombo",paraId:55,tocIndex:8},{value:"：是否允许 Combo 被该交互选中，默认为 ",paraId:55,tocIndex:8},{value:"true",paraId:55,tocIndex:8},{value:"；",paraId:55,tocIndex:8},{value:"shouldBegin(e, self)",paraId:55,tocIndex:8},{value:"：是否允许该 behavior 发生，参考下面示例。",paraId:55,tocIndex:8},{value:"v4.7.16 起支持",paraId:55,tocIndex:8},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:55,tocIndex:8},{value:"shouldBegin",paraId:55,tocIndex:8},{value:" 中访问该实例；",paraId:55,tocIndex:8},{value:"shouldUpdate(e, self)",paraId:55,tocIndex:8},{value:"：是否允许对该 behavior 发生状态响应，参考下面示例。",paraId:55,tocIndex:8},{value:"v4.7.16 起支持",paraId:55,tocIndex:8},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:55,tocIndex:8},{value:"shouldUpdate",paraId:55,tocIndex:8},{value:" 中访问该实例。",paraId:55,tocIndex:8},{value:"相关时机事件：\n",paraId:54,tocIndex:8},{value:"'nodeselectchange'",paraId:56,tocIndex:8},{value:"：当选中的元素集合发生变化时将会触发该时机事件。使用 ",paraId:56,tocIndex:8},{value:"graph.on('nodeselectchange', e => {...})",paraId:56,tocIndex:8},{value:" 监听。其参数 ",paraId:56,tocIndex:8},{value:"e",paraId:56,tocIndex:8},{value:" 有以下字段：\n",paraId:56,tocIndex:8},{value:"e.target",paraId:57,tocIndex:8},{value:"：当前操作的 item；",paraId:57,tocIndex:8},{value:"e.selectedItems",paraId:57,tocIndex:8},{value:"：当前操作后，所有被选中的 items 集合；",paraId:57,tocIndex:8},{value:"e.select",paraId:57,tocIndex:8},{value:"：当前操作是选中(true)还是取消选中(false)。",paraId:57,tocIndex:8},{value:"使用默认配置",paraId:58,tocIndex:8},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['click-select'],\n  },\n});\n\n// 当 click-select 选中的元素集合发生变化时将会触发下面时机事件，e 中包含相关信息\ngraph.on('nodeselectchange', (e) => {\n  // 当前操作的 item\n  console.log(e.target);\n  // 当前操作后，所有被选中的 items 集合\n  console.log(e.selectedItems);\n  // 当前操作时选中(true)还是取消选中(false)\n  console.log(e.select);\n});\n",paraId:59,tocIndex:8},{value:"按住 ",paraId:60,tocIndex:8},{value:"Shift",paraId:60,tocIndex:8},{value:" 键可多选。",paraId:60,tocIndex:8},{value:"使用自定义参数",paraId:61,tocIndex:8},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'click-select',\n        trigger: 'ctrl',\n        // 是否允许该 behavior 发生。若返回 false，被操作的 item 不会被选中，也不会触发 'nodeselectchange' 时机事件\n        shouldBegin: (e, self) => {\n          // 当点击的图形名为 'text-shape' 时，不允许该 behavior 发生\n          if (e.target.get('name') === 'text-shape') return false;\n          // 当点击的节点/边/ combo 的 id 为 'id1' 时，不允许该 behavior 发生\n          if (e.item.getModel().id === 'id1') return false;\n          return true;\n        },\n        // 是否允许对该 behavior 发生状态响应。若返回 false，被操作的对象的状态及相关状态样式不会被更新，但是仍然会触发 'nodeselectchange' 时机事件\n        shouldUpdate: (e, self) => {\n          // 当点击的节点/边/ combo 的 id 为 'id2' 时，该 item 不会发生状态的改变\n          if (e.item.getModel().id === 'id2') return false;\n          return true;\n        },\n      },\n    ],\n  },\n});\n\n// 当 click-select 选中的元素集合发生变化时将会触发下面时机事件，evt 中包含相关信息\ngraph.on('nodeselectchange', (e) => {\n  // 当前操作的 item\n  console.log(e.target);\n  // 当前操作后，所有被选中的 items 集合\n  console.log(e.selectedItems);\n  // 当前操作时选中(true)还是取消选中(false)\n  console.log(e.select);\n});\n",paraId:62,tocIndex:8},{value:"以上配置中，用户可按住 ",paraId:63,tocIndex:8},{value:"Ctrl",paraId:63,tocIndex:8},{value:" 键进行多选，也可以配置 ",paraId:63,tocIndex:8},{value:"Alt",paraId:63,tocIndex:8},{value:" 键。当配置了  ",paraId:63,tocIndex:8},{value:"multiple",paraId:63,tocIndex:8},{value:" 参数为 ",paraId:63,tocIndex:8},{value:"false",paraId:63,tocIndex:8},{value:"，则表示不允许多选，此时 ",paraId:63,tocIndex:8},{value:"trigger",paraId:63,tocIndex:8},{value:" 参数无效。",paraId:63,tocIndex:8},{value:"含义：节点文本提示；",paraId:64,tocIndex:9},{value:"配置项：\n",paraId:64,tocIndex:9},{value:"type: 'tooltip'",paraId:65,tocIndex:9},{value:"；",paraId:65,tocIndex:9},{value:"formatText(model)",paraId:65,tocIndex:9},{value:"：格式化函数，可以返回文本或者 HTML；",paraId:65,tocIndex:9},{value:"offset",paraId:65,tocIndex:9},{value:"：tooltip 距离鼠标的偏移量；",paraId:65,tocIndex:9},{value:"shouldBegin(e, self)",paraId:65,tocIndex:9},{value:"：是否允许 toolip 出现。",paraId:65,tocIndex:9},{value:"v4.7.16 起支持",paraId:65,tocIndex:9},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:65,tocIndex:9},{value:"shouldBegin",paraId:65,tocIndex:9},{value:" 中访问该实例；",paraId:65,tocIndex:9},{value:"shouldUpdate(e, self)",paraId:65,tocIndex:9},{value:"：是否允许 toolip 内容更新。",paraId:65,tocIndex:9},{value:"v4.7.16 起支持",paraId:65,tocIndex:9},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:65,tocIndex:9},{value:"shouldUpdate",paraId:65,tocIndex:9},{value:" 中访问该实例。",paraId:65,tocIndex:9},{value:"相关时机事件：\n",paraId:64,tocIndex:9},{value:"tooltipchange",paraId:66,tocIndex:9},{value:"：当 tooltip 发生变化时被触发。使用 ",paraId:66,tocIndex:9},{value:"graph.on('tooltipchange', e => {...})",paraId:66,tocIndex:9},{value:" 监听。",paraId:66,tocIndex:9},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  modes: {\n    default: [\n      {\n        type: 'tooltip',\n        formatText(model) {\n          return model.xxx;\n        },\n        offset: 10,\n      },\n    ],\n  },\n});\n",paraId:67,tocIndex:9},{value:"提示：由于 G6 没有内置任何 tooltip 的样式，用户需要自己定义样式，例如：",paraId:68,tocIndex:9},{value:".g6-tooltip {\n  padding: 10px 6px;\n  color: #444;\n  background-color: rgba(255, 255, 255, 0.9);\n  border: 1px solid #e2e2e2;\n  border-radius: 4px;\n}\n",paraId:69,tocIndex:9},{value:"使用方式基本与 tooltip 相同，但是移到边时触发。主要是为了将两个交互区分开，以满足用户边与节点的提示样式或 HTML 结构不同，以及不需要在事件中去区分是节点事件还是边事件等。",paraId:70,tocIndex:10},{value:"含义：边文本提示；",paraId:71,tocIndex:10},{value:"配置项：\n",paraId:71,tocIndex:10},{value:"type: 'edge-tooltip'",paraId:72,tocIndex:10},{value:"；",paraId:72,tocIndex:10},{value:"formatText(model)",paraId:72,tocIndex:10},{value:"：格式化函数，可以返回文本或者 HTML；",paraId:72,tocIndex:10},{value:"offset",paraId:72,tocIndex:10},{value:"：tooltip 距离鼠标的偏移量；",paraId:72,tocIndex:10},{value:"shouldBegin(e, self)",paraId:72,tocIndex:10},{value:"：是否允许 toolip 出现。",paraId:72,tocIndex:10},{value:"v4.7.16 起支持",paraId:72,tocIndex:10},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:72,tocIndex:10},{value:"shouldBegin",paraId:72,tocIndex:10},{value:" 中访问该实例；",paraId:72,tocIndex:10},{value:"shouldUpdate(e, self)",paraId:72,tocIndex:10},{value:"：是否允许 toolip 内容更新。",paraId:72,tocIndex:10},{value:"v4.7.16 起支持",paraId:72,tocIndex:10},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:72,tocIndex:10},{value:"shouldUpdate",paraId:72,tocIndex:10},{value:" 中访问该实例。",paraId:72,tocIndex:10},{value:"相关时机事件：\n",paraId:71,tocIndex:10},{value:"tooltipchange",paraId:73,tocIndex:10},{value:"：当 tooltip 发生变化时被触发。使用 ",paraId:73,tocIndex:10},{value:"graph.on('tooltipchange', e => {...})",paraId:73,tocIndex:10},{value:" 监听。",paraId:73,tocIndex:10},{value:"含义：当鼠标移到某节点时，突出显示该节点以及与其直接关联的节点和连线；",paraId:74,tocIndex:11},{value:"type: 'activate-relations'",paraId:74,tocIndex:11},{value:"；",paraId:74,tocIndex:11},{value:"参数：\n",paraId:74,tocIndex:11},{value:"trigger: 'mouseenter'",paraId:75,tocIndex:11},{value:"。可以是  ",paraId:75,tocIndex:11},{value:"mousenter",paraId:75,tocIndex:11},{value:"，表示鼠标移入时触发；也可以是  ",paraId:75,tocIndex:11},{value:"click",paraId:75,tocIndex:11},{value:"，鼠标点击时触发；",paraId:75,tocIndex:11},{value:"activeState: 'active'",paraId:75,tocIndex:11},{value:"。活跃节点状态。当行为被触发，需要被突出显示的节点和边都会附带此状态，默认值为  ",paraId:75,tocIndex:11},{value:"active",paraId:75,tocIndex:11},{value:"；可以与 graph 实例的  ",paraId:75,tocIndex:11},{value:"nodeStyle",paraId:75,tocIndex:11},{value:"  和  ",paraId:75,tocIndex:11},{value:"edgeStyle",paraId:75,tocIndex:11},{value:"  结合实现丰富的视觉效果。",paraId:75,tocIndex:11},{value:"inactiveState: 'inactive'",paraId:75,tocIndex:11},{value:"。非活跃节点状态。不需要被突出显示的节点和边都会附带此状态。默认值为  ",paraId:75,tocIndex:11},{value:"inactive",paraId:75,tocIndex:11},{value:"。可以与 graph 实例的  ",paraId:75,tocIndex:11},{value:"nodeStyle",paraId:75,tocIndex:11},{value:"  和  ",paraId:75,tocIndex:11},{value:"edgeStyle",paraId:75,tocIndex:11},{value:"  结合实现丰富的视觉效果；",paraId:75,tocIndex:11},{value:"resetSelected",paraId:75,tocIndex:11},{value:"：高亮相连节点时是否重置已经选中的节点，默认为 ",paraId:75,tocIndex:11},{value:"false",paraId:75,tocIndex:11},{value:"，即选中的节点状态不会被 ",paraId:75,tocIndex:11},{value:"activate-relations",paraId:75,tocIndex:11},{value:" 覆盖；",paraId:75,tocIndex:11},{value:"shouldUpdate(item: Item, { event: G6Event, action: 'deactivate' | 'activate' }, self)",paraId:75,tocIndex:11},{value:"：是否允许该 behavior 发生。",paraId:75,tocIndex:11},{value:"v4.7.16 起支持",paraId:75,tocIndex:11},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:75,tocIndex:11},{value:"shouldUpdate",paraId:75,tocIndex:11},{value:" 中访问该实例。",paraId:75,tocIndex:11},{value:"相关时机事件：\n",paraId:74,tocIndex:11},{value:"'afteractivaterelations'",paraId:76,tocIndex:11},{value:"：当高亮发生改变时触发该时机事件。使用 ",paraId:76,tocIndex:11},{value:"graph.on('afteractivaterelations', evt => {...})",paraId:76,tocIndex:11},{value:" 监听。其参数 ",paraId:76,tocIndex:11},{value:"e",paraId:76,tocIndex:11},{value:" 有以下字段：\n",paraId:76,tocIndex:11},{value:"e.item",paraId:77,tocIndex:11},{value:"：当前操作的节点 item；",paraId:77,tocIndex:11},{value:"e.action",paraId:77,tocIndex:11},{value:"：当前操作是选中(",paraId:77,tocIndex:11},{value:"'activate'",paraId:77,tocIndex:11},{value:")还是取消选中(",paraId:77,tocIndex:11},{value:"'deactivate'",paraId:77,tocIndex:11},{value:")。",paraId:77,tocIndex:11},{value:"使用默认配置",paraId:78,tocIndex:11},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['activate-relations'],\n  },\n});\n\ngraph.on('afteractivaterelations', (e) => {\n  // 当前操作的节点 item\n  console.log(e.item);\n  // 当前操作是选中(`'activate'`)还是取消选中(`'deactivate'`)\n  console.log(e.action);\n});\n",paraId:79,tocIndex:11},{value:"默认情况下，选中的节点状态，在操作完以后仍然会保持选中状态。",paraId:80,tocIndex:11},{value:"使用自定义参数",paraId:81,tocIndex:11},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'activate-relations',\n        resetSelected: true,\n      },\n    ],\n  },\n});\n\ngraph.on('afteractivaterelations', (e) => {\n  // 当前操作的节点 item\n  console.log(e.item);\n  // 当前操作是选中(`'activate'`)还是取消选中(`'deactivate'`)\n  console.log(e.action);\n});\n",paraId:82,tocIndex:11},{value:"配置 ",paraId:83,tocIndex:11},{value:"resetSelected",paraId:83,tocIndex:11},{value:" 参数为 ",paraId:83,tocIndex:11},{value:"true",paraId:83,tocIndex:11},{value:" 后，交互后会重置节点的选择状态。",paraId:83,tocIndex:11},{value:"含义：拖动框选节点；",paraId:84,tocIndex:12},{value:"配置项：\n",paraId:84,tocIndex:12},{value:"type: 'brush-select'",paraId:85,tocIndex:12},{value:"；",paraId:85,tocIndex:12},{value:"brushStyle",paraId:85,tocIndex:12},{value:"：拖动框选框的样式，包括 ",paraId:85,tocIndex:12},{value:"fill",paraId:85,tocIndex:12},{value:"、",paraId:85,tocIndex:12},{value:"fillOpacity",paraId:85,tocIndex:12},{value:"、",paraId:85,tocIndex:12},{value:"stroke",paraId:85,tocIndex:12},{value:" 和 ",paraId:85,tocIndex:12},{value:"lineWidth",paraId:85,tocIndex:12},{value:" 四个属性;",paraId:85,tocIndex:12},{value:"onSelect(nodes)",paraId:85,tocIndex:12},{value:"：选中节点时的回调，参数 ",paraId:85,tocIndex:12},{value:"nodes",paraId:85,tocIndex:12},{value:" 表示选中的节点；",paraId:85,tocIndex:12},{value:"onDeselect(nodes)",paraId:85,tocIndex:12},{value:"：取消选中节点时的回调，参数 ",paraId:85,tocIndex:12},{value:"nodes",paraId:85,tocIndex:12},{value:" 表示取消选中的节点；",paraId:85,tocIndex:12},{value:"selectedState",paraId:85,tocIndex:12},{value:"：选中的状态，默认值为 ",paraId:85,tocIndex:12},{value:"'selected'",paraId:85,tocIndex:12},{value:"；",paraId:85,tocIndex:12},{value:"includeEdges",paraId:85,tocIndex:12},{value:"：框选过程中是否选中边，默认为 ",paraId:85,tocIndex:12},{value:"true",paraId:85,tocIndex:12},{value:"，用户配置为 ",paraId:85,tocIndex:12},{value:"false",paraId:85,tocIndex:12},{value:" 时，则不选中边；",paraId:85,tocIndex:12},{value:"includeCombos",paraId:85,tocIndex:12},{value:"：框选过程中是否选中 Combo，默认为 ",paraId:85,tocIndex:12},{value:"false",paraId:85,tocIndex:12},{value:"，用户配置为 ",paraId:85,tocIndex:12},{value:"true",paraId:85,tocIndex:12},{value:" 时，则可选中 Combo；",paraId:85,tocIndex:12},{value:"trigger",paraId:85,tocIndex:12},{value:"：触发框选的动作，默认为 ",paraId:85,tocIndex:12},{value:"'shift'",paraId:85,tocIndex:12},{value:"，即用户按住 Shift 键拖动就可以进行框选操作，可配置的的选项为: ",paraId:85,tocIndex:12},{value:"'shift'",paraId:85,tocIndex:12},{value:"、",paraId:85,tocIndex:12},{value:"'ctrl' / 'control'",paraId:85,tocIndex:12},{value:"、",paraId:85,tocIndex:12},{value:"'alt'",paraId:85,tocIndex:12},{value:" 和 ",paraId:85,tocIndex:12},{value:"'drag'",paraId:85,tocIndex:12},{value:" ，不区分大小写：\n",paraId:85,tocIndex:12},{value:"'shift'",paraId:86,tocIndex:12},{value:"：按住 Shift 键进行拖动框选；",paraId:86,tocIndex:12},{value:"'ctrl' / 'control'",paraId:86,tocIndex:12},{value:"：按住 Ctrl 键进行拖动框选；",paraId:86,tocIndex:12},{value:"'alt'",paraId:86,tocIndex:12},{value:"：按住 Alt 键进行拖动框选；",paraId:86,tocIndex:12},{value:"风险  ",paraId:86,tocIndex:12},{value:"'drag'",paraId:86,tocIndex:12},{value:"：不需要按任何键，进行拖动框选，如果同时配置了 ",paraId:86,tocIndex:12},{value:"drag-canvas",paraId:86,tocIndex:12},{value:"，则会与该选项冲突。",paraId:86,tocIndex:12},{value:"shouldUpdate(item: Item, action: string, self)",paraId:85,tocIndex:12},{value:"：是否允许对该 behavior 发生，参考下面示例。",paraId:85,tocIndex:12},{value:"v4.7.16 起支持",paraId:85,tocIndex:12},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:85,tocIndex:12},{value:"shouldUpdate",paraId:85,tocIndex:12},{value:" 中访问该实例。",paraId:85,tocIndex:12},{value:"相关时机事件：\n",paraId:84,tocIndex:12},{value:"'nodeselectchange'",paraId:87,tocIndex:12},{value:"：当选中的元素集合发生变化时将会触发该时机事件。使用 ",paraId:87,tocIndex:12},{value:"graph.on('nodeselectchange', e => {...})",paraId:87,tocIndex:12},{value:" 监听。其参数 ",paraId:87,tocIndex:12},{value:"e",paraId:87,tocIndex:12},{value:" 有以下字段：\n",paraId:87,tocIndex:12},{value:"e.selectedItems",paraId:88,tocIndex:12},{value:"：当前操作后，所有被选中的 items 集合；",paraId:88,tocIndex:12},{value:"e.select",paraId:88,tocIndex:12},{value:"：当前操作是选中(true)还是取消选中(false)。",paraId:88,tocIndex:12},{value:"使用默认配置",paraId:89,tocIndex:12},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['brush-select'],\n  },\n});\n\n// 当 click-select 选中的元素集合发生变化时将会触发下面时机事件，e 中包含相关信息\ngraph.on('nodeselectchange', (e) => {\n  // 当前操作后，所有被选中的 items 集合\n  console.log(e.selectedItems);\n  // 当前操作时选中(true)还是取消选中(false)\n  console.log(e.select);\n});\n",paraId:90,tocIndex:12},{value:"默认情况下，按住 Shift 键进行框选，选中节点的同时，也会选中边。 ",paraId:91,tocIndex:12},{value:"使用自定义参数",paraId:92,tocIndex:12},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      {\n        type: 'brush-select',\n        trigger: 'ctrl',\n        includeEdges: false,\n        // 是否允许对该 behavior 发生。若返回 false，被操作的 item 不会被选中，不触发 'nodeselectchange' 时机事件\n        shouldUpdate: (e, self) => {\n          // 当点击的节点/边/ combo 的 id 为 'id2' 时，该 item 不会被选中\n          if (e.item.getModel().id === 'id2') return false;\n          return true;\n        },\n      },\n    ],\n  },\n});\n\n// 当 click-select 选中的元素集合发生变化时将会触发下面时机事件，e 中包含相关信息\ngraph.on('nodeselectchange', (e) => {\n  // 当前操作后，所有被选中的 items 集合\n  console.log(e.selectedItems);\n  // 当前操作时选中(true)还是取消选中(false)\n  console.log(e.select);\n});\n",paraId:93,tocIndex:12},{value:"上面的配置，按住 Ctrl 键，进行框选，框选过程中不会选中边。",paraId:94,tocIndex:12},{value:"冲突的配置：",paraId:95,tocIndex:12},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      'drag-canvas',\n      {\n        type: 'brush-select',\n        trigger: 'drag',\n      },\n    ],\n  },\n});\n",paraId:96,tocIndex:12},{value:"当用户配置 ",paraId:97,tocIndex:12},{value:"brush-select",paraId:97,tocIndex:12},{value:" 的 ",paraId:97,tocIndex:12},{value:"trigger",paraId:97,tocIndex:12},{value:" 为 ",paraId:97,tocIndex:12},{value:"drag",paraId:97,tocIndex:12},{value:"，同时又配置了 ",paraId:97,tocIndex:12},{value:"drag-canvas",paraId:97,tocIndex:12},{value:" 时，在交互上面会出现冲突的情况。",paraId:97,tocIndex:12},{value:"可以看到，在拖动过程中也出现了框选的情况，这种情况很显然不是我们期望的效果，除过使用 ",paraId:98,tocIndex:12},{value:"brush-select",paraId:98,tocIndex:12},{value:" 的 ",paraId:98,tocIndex:12},{value:"trigger",paraId:98,tocIndex:12},{value:" 参数避免这种冲突外，我们还可以通过下面的方式来实现：",paraId:98,tocIndex:12},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['drag-canvas'],\n    brush: [\n      {\n        type: 'brush-select',\n        trigger: 'drag',\n      },\n    ],\n  },\n});\n",paraId:99,tocIndex:12},{value:"上面这种方式是使用不同的 mode 来区分，mode 可以达到使用相同交互动作而产生不同的效果。默认模式中，使用的是拖拽操作由 ",paraId:100,tocIndex:12},{value:"drag-canvas",paraId:100,tocIndex:12},{value:" 响应。当用户通过通过 ",paraId:100,tocIndex:12},{value:"graph.setMode('brush')",paraId:100,tocIndex:12},{value:" 切换到 brush 模式后，此时同样的拖拽操作由 ",paraId:100,tocIndex:12},{value:"brush-select",paraId:100,tocIndex:12},{value:" 响应。更多关于 mode 的内容请参考 ",paraId:100,tocIndex:12},{value:"Mode",paraId:101,tocIndex:12},{value:" 教程。",paraId:100,tocIndex:12},{value:"含义：自由圈选；",paraId:102,tocIndex:13},{value:"配置项：\n",paraId:102,tocIndex:13},{value:"type: 'lasso-select'",paraId:103,tocIndex:13},{value:"；",paraId:103,tocIndex:13},{value:"delegateStyle",paraId:103,tocIndex:13},{value:"：拖动框选框的样式，包括 ",paraId:103,tocIndex:13},{value:"fill",paraId:103,tocIndex:13},{value:"、",paraId:103,tocIndex:13},{value:"fillOpacity",paraId:103,tocIndex:13},{value:"、",paraId:103,tocIndex:13},{value:"stroke",paraId:103,tocIndex:13},{value:" 和 ",paraId:103,tocIndex:13},{value:"lineWidth",paraId:103,tocIndex:13},{value:" 四个属性;",paraId:103,tocIndex:13},{value:"onSelect(nodes, edges)",paraId:103,tocIndex:13},{value:"：选中节点时的回调，参数 ",paraId:103,tocIndex:13},{value:"nodes",paraId:103,tocIndex:13},{value:" 表示选中的节点，",paraId:103,tocIndex:13},{value:"edges",paraId:103,tocIndex:13},{value:" 表示选中的边；",paraId:103,tocIndex:13},{value:"onDeselect(nodes, edges)",paraId:103,tocIndex:13},{value:"：取消选中节点时的回调，参数 ",paraId:103,tocIndex:13},{value:"nodes",paraId:103,tocIndex:13},{value:" 表示取消选中的节点，",paraId:103,tocIndex:13},{value:"edges",paraId:103,tocIndex:13},{value:" 表示取消选中的边；",paraId:103,tocIndex:13},{value:"selectedState",paraId:103,tocIndex:13},{value:"：选中的状态，默认值为 ",paraId:103,tocIndex:13},{value:"'selected'",paraId:103,tocIndex:13},{value:"；",paraId:103,tocIndex:13},{value:"includeEdges",paraId:103,tocIndex:13},{value:"：框选过程中是否选中边，默认为 ",paraId:103,tocIndex:13},{value:"true",paraId:103,tocIndex:13},{value:"，用户配置为 ",paraId:103,tocIndex:13},{value:"false",paraId:103,tocIndex:13},{value:" 时，则不选中边；",paraId:103,tocIndex:13},{value:"trigger",paraId:103,tocIndex:13},{value:"：触发框选的动作，默认为 ",paraId:103,tocIndex:13},{value:"'shift'",paraId:103,tocIndex:13},{value:"，即用户按住 Shift 键拖动就可以进行框选操作，可配置的的选项为: ",paraId:103,tocIndex:13},{value:"'shift'",paraId:103,tocIndex:13},{value:"、",paraId:103,tocIndex:13},{value:"'ctrl' / 'control'",paraId:103,tocIndex:13},{value:"、",paraId:103,tocIndex:13},{value:"'alt'",paraId:103,tocIndex:13},{value:" 和 ",paraId:103,tocIndex:13},{value:"'drag'",paraId:103,tocIndex:13},{value:" ，不区分大小写：\n",paraId:103,tocIndex:13},{value:"'shift'",paraId:104,tocIndex:13},{value:"：按住 Shift 键进行拖动框选；",paraId:104,tocIndex:13},{value:"'ctrl' / 'control'",paraId:104,tocIndex:13},{value:"：按住 Ctrl 键进行拖动框选；",paraId:104,tocIndex:13},{value:"'alt'",paraId:104,tocIndex:13},{value:"：按住 Alt 键进行拖动框选；",paraId:104,tocIndex:13},{value:"风险  ",paraId:104,tocIndex:13},{value:"'drag'",paraId:104,tocIndex:13},{value:"：不需要按任何键，进行拖动框选，如果同时配置了 ",paraId:104,tocIndex:13},{value:"drag-canvas",paraId:104,tocIndex:13},{value:"，则会与该选项冲突。",paraId:104,tocIndex:13},{value:"shouldUpdate(item: Item, action: string, self)",paraId:103,tocIndex:13},{value:"：是否允许对该 behavior 发生，参考下面示例。",paraId:103,tocIndex:13},{value:"v4.7.16 起支持",paraId:103,tocIndex:13},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:103,tocIndex:13},{value:"shouldUpdate",paraId:103,tocIndex:13},{value:" 中访问该实例；",paraId:103,tocIndex:13},{value:"shouldDeselect({ action: string, nodes: INode[], edges: IEdge[] })",paraId:103,tocIndex:13},{value:"：当前条件下是否允许取消选中。",paraId:103,tocIndex:13},{value:"v4.7.16 起支持",paraId:103,tocIndex:13},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:103,tocIndex:13},{value:"shouldDeselect",paraId:103,tocIndex:13},{value:" 中访问该实例。",paraId:103,tocIndex:13},{value:"相关时机事件：\n",paraId:102,tocIndex:13},{value:"'nodeselectchange'",paraId:105,tocIndex:13},{value:"：当选中的元素集合发生变化时将会触发该时机事件。使用 ",paraId:105,tocIndex:13},{value:"graph.on('nodeselectchange', e => {...})",paraId:105,tocIndex:13},{value:" 监听。其参数 ",paraId:105,tocIndex:13},{value:"e",paraId:105,tocIndex:13},{value:" 有以下字段：\n",paraId:105,tocIndex:13},{value:"e.selectedItems",paraId:106,tocIndex:13},{value:"：当前操作后，所有被选中的 items 集合；",paraId:106,tocIndex:13},{value:"e.select",paraId:106,tocIndex:13},{value:"：当前操作是选中(true)还是取消选中(false)。",paraId:106,tocIndex:13},{value:"lasso-select",paraId:107,tocIndex:13},{value:" 的配置和使用方法和 ",paraId:107,tocIndex:13},{value:"brush-select",paraId:107,tocIndex:13},{value:" 一致。",paraId:107,tocIndex:13},{value:"含义：只适用于树图，展开或收起子树；",paraId:108,tocIndex:14},{value:"注意：若希望在首次布局时有默认收起的子树，则可以在数据中设置子树根节点的属性 ",paraId:108,tocIndex:14},{value:"collapsed",paraId:108,tocIndex:14},{value:" 为 ",paraId:108,tocIndex:14},{value:"true",paraId:108,tocIndex:14},{value:"。若希望使用代码控制子树的展开/收起，同样可以在数据中设置子树根节点的 ",paraId:108,tocIndex:14},{value:"collapsed",paraId:108,tocIndex:14},{value:" 属性，并调用 ",paraId:108,tocIndex:14},{value:"treeGraph.layout()",paraId:108,tocIndex:14},{value:" 使之生效；",paraId:108,tocIndex:14},{value:"配置项：\n",paraId:108,tocIndex:14},{value:"type: 'collapse-expand'",paraId:109,tocIndex:14},{value:"；",paraId:109,tocIndex:14},{value:"trigger",paraId:109,tocIndex:14},{value:"：收起和展开树图的方式，支持 ",paraId:109,tocIndex:14},{value:"'click'",paraId:109,tocIndex:14},{value:" 和 ",paraId:109,tocIndex:14},{value:"'dblclick'",paraId:109,tocIndex:14},{value:" 两种方式。默认为 ",paraId:109,tocIndex:14},{value:"'click'",paraId:109,tocIndex:14},{value:"，即单击；",paraId:109,tocIndex:14},{value:"onChange(item: Item, collapsed: boolean, self)",paraId:109,tocIndex:14},{value:"：收起或展开的回调函数。警告：V3.1.2 版本中将移除；",paraId:109,tocIndex:14},{value:"shouldBegin(e, collapsed: boolean, self)",paraId:109,tocIndex:14},{value:"：是否允许该 behavior 在当前操作的 item 上发生。",paraId:109,tocIndex:14},{value:"v4.7.16 起支持",paraId:109,tocIndex:14},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:109,tocIndex:14},{value:"shouldBegin",paraId:109,tocIndex:14},{value:" 中访问该实例；",paraId:109,tocIndex:14},{value:"shouldUpdate(e, collapsed: boolean, self)",paraId:109,tocIndex:14},{value:"：更新节点 ",paraId:109,tocIndex:14},{value:"collapsed",paraId:109,tocIndex:14},{value:" 字段后，是否允许调用 ",paraId:109,tocIndex:14},{value:"onChange",paraId:109,tocIndex:14},{value:" 以及重新布局。",paraId:109,tocIndex:14},{value:"v4.7.16 起支持",paraId:109,tocIndex:14},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:109,tocIndex:14},{value:"shouldUpdate",paraId:109,tocIndex:14},{value:" 中访问该实例；",paraId:109,tocIndex:14},{value:"相关时机事件：\n",paraId:108,tocIndex:14},{value:"itemcollapsed",paraId:110,tocIndex:14},{value:"：当 collapse-expand 发生时被触发。使用 ",paraId:110,tocIndex:14},{value:"graph.on('itemcollapsed', e => {...})",paraId:110,tocIndex:14},{value:" 监听，参数 ",paraId:110,tocIndex:14},{value:"e",paraId:110,tocIndex:14},{value:" 有以下字段：\n",paraId:110,tocIndex:14},{value:"e.item",paraId:111,tocIndex:14},{value:"：当前被操作的节点 item；",paraId:111,tocIndex:14},{value:"e.collapsed",paraId:111,tocIndex:14},{value:"：当前操作是收起（",paraId:111,tocIndex:14},{value:"true",paraId:111,tocIndex:14},{value:"）还是展开（",paraId:111,tocIndex:14},{value:"false",paraId:111,tocIndex:14},{value:"）。",paraId:111,tocIndex:14},{value:"用法",paraId:112,tocIndex:14},{value:"const graph = new G6.TreeGraph({\n  modes: {\n    default: [\n      {\n        type: 'collapse-expand',\n        trigger: 'click',\n        onChange: (item, collapsed) => {\n          const data = item.get('model').data;\n          data.collapsed = collapsed;\n          return true;\n        },\n        shouldBegin: (e, self) => {\n          // 若当前操作的节点 id 为 'node1'，则不发生 collapse-expand\n          if (e.item && e.item.getModel().id === 'node1') return false;\n          return true;\n        },\n      },\n      'drag-canvas',\n      'zoom-canvas',\n    ],\n  },\n});\n\ngraph.on('itemcollapsed', (e) => {\n  // 当前被操作的节点 item\n  console.log(e.item);\n  // 当前操作是收起（`true`）还是展开（`false`）\n  console.log(e.collapsed);\n});\n",paraId:113,tocIndex:14},{value:"含义：通过交互创建边；",paraId:114,tocIndex:15},{value:"配置项：\n",paraId:114,tocIndex:15},{value:"type：'create-edge'",paraId:115,tocIndex:15},{value:"；",paraId:115,tocIndex:15},{value:"trigger",paraId:115,tocIndex:15},{value:"：该交互的触发条件，可选 ",paraId:115,tocIndex:15},{value:"'click'",paraId:115,tocIndex:15},{value:"，",paraId:115,tocIndex:15},{value:"'drag'",paraId:115,tocIndex:15},{value:"。默认为 ",paraId:115,tocIndex:15},{value:"'click'",paraId:115,tocIndex:15},{value:"，即分别点击两个节点为这两个节点创建边。",paraId:115,tocIndex:15},{value:"'drag'",paraId:115,tocIndex:15},{value:" 代表从一个节点“拖拽”出一条边，在另一个节点上松开鼠标完成创建。注意，",paraId:115,tocIndex:15},{value:"trigger: 'drag'",paraId:115,tocIndex:15},{value:" 不能创建一个自环边；",paraId:115,tocIndex:15},{value:"key",paraId:115,tocIndex:15},{value:"：键盘按键作为该交互的辅助触发，若不设置或设置为 undefined 则代表只根据 ",paraId:115,tocIndex:15},{value:"trigger",paraId:115,tocIndex:15},{value:" 决定该交互的触发条件。可选值：",paraId:115,tocIndex:15},{value:"'shift'",paraId:115,tocIndex:15},{value:"，",paraId:115,tocIndex:15},{value:"'ctrl'",paraId:115,tocIndex:15},{value:", 'control'，",paraId:115,tocIndex:15},{value:"'alt'",paraId:115,tocIndex:15},{value:"，",paraId:115,tocIndex:15},{value:"'meta'",paraId:115,tocIndex:15},{value:"，",paraId:115,tocIndex:15},{value:"undefined",paraId:115,tocIndex:15},{value:"；",paraId:115,tocIndex:15},{value:"edgeConfig",paraId:115,tocIndex:15},{value:": 有该交互创建出的边的配置项，可以配置边的类型、样式等，其类型参考",paraId:115,tocIndex:15},{value:"边的配置",paraId:116,tocIndex:15},{value:"。如果需要为不同的被添加边赋予不同样式，请监听 ",paraId:115,tocIndex:15},{value:"'aftercreateedge'",paraId:115,tocIndex:15},{value:" 并更新相对应的边；",paraId:115,tocIndex:15},{value:"shouldBegin(e, self)",paraId:115,tocIndex:15},{value:"：是否允许当前被操作的条件下开始创建边。",paraId:115,tocIndex:15},{value:"v4.7.16 起支持",paraId:115,tocIndex:15},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:115,tocIndex:15},{value:"shouldBegin",paraId:115,tocIndex:15},{value:" 中访问该实例；",paraId:115,tocIndex:15},{value:"shouldEnd(e, self)",paraId:115,tocIndex:15},{value:"：是否允许当前被操作的条件下结束创建边。",paraId:115,tocIndex:15},{value:"v4.7.16 起支持",paraId:115,tocIndex:15},{value:" 最后一个参数为 behavior 实例，方便在箭头函数定义的 ",paraId:115,tocIndex:15},{value:"shouldEnd",paraId:115,tocIndex:15},{value:" 中访问该实例；",paraId:115,tocIndex:15},{value:"相关时机事件：\n",paraId:114,tocIndex:15},{value:"'aftercreateedge'",paraId:117,tocIndex:15},{value:"：当边创建完成时将会触发该时机事件。使用 ",paraId:117,tocIndex:15},{value:"graph.on('aftercreateedge', e => {...})",paraId:117,tocIndex:15},{value:" 监听。其参数 ",paraId:117,tocIndex:15},{value:"e",paraId:117,tocIndex:15},{value:" 中的 ",paraId:117,tocIndex:15},{value:"edge",paraId:117,tocIndex:15},{value:" 字段即为刚刚创建的边。",paraId:117,tocIndex:15},{value:"使用默认配置",paraId:118,tocIndex:15},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['create-edge'],\n  },\n});\ngraph.on('aftercreateedge', (e) => {\n  console.log(e.edge);\n});\n",paraId:119,tocIndex:15},{value:"使用自定义参数",paraId:120,tocIndex:15},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      // 只有当 'shift' 键被按下，才能够通过从一个节点拖拽到另一个节点来创建一条边\n      {\n        type: 'create-edge',\n        trigger: 'drag',\n        key: 'shift',\n        edgeConfig: {\n          type: 'cubic',\n          style: {\n            stroke: '#f00',\n            lineWidth: 2,\n            // ... // 其它边样式配置\n          },\n          // ... // 其它边配置\n        },\n      },\n    ],\n  },\n});\n",paraId:121,tocIndex:15},{value:"含义：允许终端用户使用键盘组合键调用 Graph 的函数，例如按下键盘上的 control 与 1，对图进行适应画布。注意：终端用户使用该功能时焦点必须在画布上才能够正确触发；",paraId:122,tocIndex:16},{value:"配置项：\n",paraId:122,tocIndex:16},{value:"type：'shortcuts-call'",paraId:123,tocIndex:16},{value:"；",paraId:123,tocIndex:16},{value:"trigger",paraId:123,tocIndex:16},{value:"：触发该交互的主键，可选 ",paraId:123,tocIndex:16},{value:"'shift'",paraId:123,tocIndex:16},{value:"，",paraId:123,tocIndex:16},{value:"'alt'",paraId:123,tocIndex:16},{value:"，",paraId:123,tocIndex:16},{value:"'ctrl'",paraId:123,tocIndex:16},{value:"，",paraId:123,tocIndex:16},{value:"'control'",paraId:123,tocIndex:16},{value:"。默认为 ",paraId:123,tocIndex:16},{value:"'control'",paraId:123,tocIndex:16},{value:"。设置时需要注意可能与其他正在别使用的 Behavior 的 trigger 产生冲突；",paraId:123,tocIndex:16},{value:"combinedKey",paraId:123,tocIndex:16},{value:"：触发该交互的副按键，在按住主键 ",paraId:123,tocIndex:16},{value:"trigger",paraId:123,tocIndex:16},{value:" 后，按下该副按键，将会调用 ",paraId:123,tocIndex:16},{value:"functionName",paraId:123,tocIndex:16},{value:" 指定的函数。若不设置或设置为 undefined 则代表只根据 ",paraId:123,tocIndex:16},{value:"trigger",paraId:123,tocIndex:16},{value:" 触发；",paraId:123,tocIndex:16},{value:"functionName",paraId:123,tocIndex:16},{value:": 被调用的 Graph 的一个函数名，若传入一个错误的函数名，将会不产生任何效果；",paraId:123,tocIndex:16},{value:"functionParams",paraId:123,tocIndex:16},{value:": 被调用的函数的参数，请根据各函数的文档传入正确的参数，错误的参数可能导致报错。",paraId:123,tocIndex:16},{value:"使用默认配置",paraId:124,tocIndex:16},{value:"const graph = new G6.Graph({\n  modes: {\n    default: ['shortcuts-call'],\n  },\n});\n",paraId:125,tocIndex:16},{value:"使用自定义参数",paraId:126,tocIndex:16},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      // 当按住 'alt' 键，并按下 'm' 键，将调用 graph.moveTo(10, 10)\n      {\n        type: 'shortcuts-call',\n        // 主健\n        trigger: 'alt',\n        // 副键\n        combinedKey: 'm',\n        // 将图内容的左上角移动到 10,10\n        functionName: 'moveTo',\n        functionParams: [10, 10],\n      },\n    ],\n  },\n});\n",paraId:127,tocIndex:16}]},95166:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"用户在交互一张图时，可能由于意图不同而存在不同的交互模式，例如在编辑模式下点击节点需要弹出窗口让用户编辑，在查看模式下点击节点需要选中节点。",paraId:0,tocIndex:0},{value:"为了解决上述问题，G6 提供了交互模式 Mode，它是图上交互行为 ",paraId:1,tocIndex:0},{value:"Behavior",paraId:2,tocIndex:0},{value:" 的管理机制。一个图上可以有存在多种交互模式，每个交互模式包含多种交互行为 ",paraId:1,tocIndex:0},{value:"Behavior",paraId:3,tocIndex:0},{value:"。",paraId:1,tocIndex:0},{value:"例如，存在 default 和 edit 两种 mode（交互模式）:",paraId:4,tocIndex:0},{value:"default 模式中包含点击选中节点行为和拖拽画布行为;",paraId:5,tocIndex:0},{value:"edit 模式中包含点击节点弹出编辑框行为和拖拽节点行为。",paraId:5,tocIndex:0},{value:"默认情况下，该图对 default 模式中的行为见效，即点击节点时节点被选中而不是弹出编辑框。用户可以通过简单的命令切换该图的行为模式到 edit 模式，则 default 模式中的行为失效，edit 交互模式中的行为起效，即点击节点将弹出编辑框。",paraId:6,tocIndex:0},{value:"在实例化图时配置 ",paraId:7,tocIndex:1},{value:"modes",paraId:7,tocIndex:1},{value:" 属性：",paraId:7,tocIndex:1},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 500,\n  height: 500,\n  modes: {\n    // 支持的 behavior\n    default: ['drag-canvas', 'zoom-canvas'],\n    edit: ['click-select'],\n  },\n});\n",paraId:8,tocIndex:1},{value:"以上是模式定义的一个例子。在图上定义了两个模式，分别是 ",paraId:9,tocIndex:1},{value:"default",paraId:9,tocIndex:1},{value:"，",paraId:9,tocIndex:1},{value:"edit",paraId:9,tocIndex:1},{value:"。其中 ",paraId:9,tocIndex:1},{value:"default",paraId:9,tocIndex:1},{value:" 包含两个  ",paraId:9,tocIndex:1},{value:"Behavior",paraId:10,tocIndex:1},{value:"：",paraId:9,tocIndex:1},{value:"'drag-canvas'",paraId:9,tocIndex:1},{value:" 和 '",paraId:9,tocIndex:1},{value:"zoom-canvas'",paraId:9,tocIndex:1},{value:"，都使用行为的默认参数。",paraId:9,tocIndex:1},{value:"默认时 graph 会使用 ",paraId:11,tocIndex:2},{value:"default",paraId:11,tocIndex:2},{value:" 模式 ，可以拖动和缩放画布，当需要点击选中节点时，可以通过  ",paraId:11,tocIndex:2},{value:"graph.setMode('edit')",paraId:11,tocIndex:2},{value:"  来切换到 ",paraId:11,tocIndex:2},{value:"edit",paraId:11,tocIndex:2},{value:" 的 Mode 。",paraId:11,tocIndex:2},{value:"graph.setMode('edit');\n",paraId:12,tocIndex:2},{value:"此时 graph 便支持了点击选中节点，",paraId:13,tocIndex:2},{value:"default",paraId:13,tocIndex:2},{value:" 模式下的拖拽画布 ",paraId:13,tocIndex:2},{value:"'drag-canvas'",paraId:13,tocIndex:2},{value:"、放缩画布行为 ",paraId:13,tocIndex:2},{value:"'zoom-canvas'",paraId:13,tocIndex:2},{value:" 失效。",paraId:13,tocIndex:2},{value:"在调用了 ",paraId:14,tocIndex:2},{value:"setMode",paraId:14,tocIndex:2},{value:" 方法后，G6 内部进行了以下操作：",paraId:14,tocIndex:2},{value:"解绑目前图模式的所有事件监听；",paraId:15,tocIndex:2},{value:"生成新的 Behavior ，进行事件初始化；",paraId:15,tocIndex:2},{value:"绑定新的行为对应的事件监听。",paraId:15,tocIndex:2},{value:"如果有已经定义好的 Behavior （",paraId:16,tocIndex:3},{value:"内置 Behavior",paraId:17,tocIndex:3},{value:" 或 ",paraId:16,tocIndex:3},{value:"自定义 Behavior",paraId:18,tocIndex:3},{value:"），需要把它添加到某个模式下，可以通过  ",paraId:16,tocIndex:3},{value:"graph.addBehaviors",paraId:16,tocIndex:3},{value:" 方法；需要从某个模式中移除一些 Behavior，可以使用  ",paraId:16,tocIndex:3},{value:"graph.removeBehaviors",paraId:16,tocIndex:3},{value:" 方法。如下示例：",paraId:16,tocIndex:3},{value:"// 向 default 模式中添加名为 drag-canvas 的行为，并使用行为的默认配置\ngraph.addBehaviors('drag-canvas', 'default');\n\n// 从 default 模式中移除名为 drag-canvas 的行为\ngraph.removeBehaviors('drag-canvas', 'default');\n\n// 向 edit 模式中添加名为 drag-canvas 的行为，并定义个性化配置\ngraph.addBehaviors(\n  {\n    type: 'drag-canvas',\n    direction: 'x',\n  },\n  'edit',\n);\n\n// 从 edit 模式中移除名为 drag-canvas 的行为\ngraph.removeBehaviors('drag-canvas', 'edit');\n\n// 一次向 default 模式中添加多个行为\ngraph.addBehaviors(['drag-canvas', 'zoom-canvas'], 'default');\n\n// 一次从 default 模式中移除多个行为\ngraph.removeBehaviors(['drag-canvas', 'zoom-canvas'], 'default');\n\n// --------\n\n// 更新 'default' 模式下的 behavior 'zoom-canvas'\ngraph.updateBehavior('zoom-canvas', { sensitivity: 1.5, enableOptimize: true}, 'default');\n\n// 更新 'select' 模式下的 behavior 'click-select'\ngraph.updateBehavior('click-select', { trigger: 'ctrl' }, 'select');\n",paraId:19,tocIndex:3},{value:"使用多种交互模式",paraId:20,tocIndex:4},{value:"内置交互行为 Behavior",paraId:21,tocIndex:4},{value:"自定义交互行为 Behavior",paraId:22,tocIndex:4}]},39942:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 中的 ",paraId:0,tocIndex:0},{value:"state",paraId:0,tocIndex:0},{value:"，指的是节点或边的状态，包括",paraId:0,tocIndex:0},{value:"交互状态",paraId:0,tocIndex:0},{value:"和",paraId:0,tocIndex:0},{value:"业务状态",paraId:0,tocIndex:0},{value:"两种。",paraId:0,tocIndex:0},{value:"在 G6 中，配置交互状态和业务状态的方式是相同的。对于部分只使用 G6 来完成某个需求的开发，而不想深入理解 G6 的用户，其实不用区分交互状态和业务状态的区别，使用相同的方式定义状态，完全没有理解成本。",paraId:1,tocIndex:0},{value:"交互状态是与具体的交互动作密切相关的，如用户使用鼠标选中某个节点则该节点被选中，hover 到某条边则该边被高亮等。",paraId:2,tocIndex:1},{value:"G6 中默认处理的是交互状态。",paraId:3,tocIndex:1},{value:"指根据用户业务需求自定义的状态。业务状态是与交互动作无关的，与具体业务逻辑强相关的，也可理解为是强数据驱动的。如某个任务的执行状态、某条申请的审批状态等，不同的数据值代表不同的业务状态。业务状态与用户交互动作无关，但在 G6 中的处理方式同交互状态一致。",paraId:4,tocIndex:2},{value:"判断是否该使用 state 的原则很简单，从交互和业务两个层面来看：",paraId:5,tocIndex:3},{value:"某个交互动作要改变节点或边的样式及属性；",paraId:6,tocIndex:3},{value:"呈现给用户的内容会根据数据改变（如 1 代表成功，0 代表失败）。",paraId:6,tocIndex:3},{value:"满足上述条件其一，则应该使用 state。",paraId:7,tocIndex:3},{value:"使用 ",paraId:8,tocIndex:4},{value:"graph.setItemState(item, stateName, stateValue)",paraId:8,tocIndex:4},{value:"  来使定义的状态生效",paraId:8,tocIndex:4},{value:"。",paraId:8,tocIndex:4},{value:"状态可以是二值的，也可以是多值的（G6 3.4 后支持）。",paraId:9,tocIndex:5},{value:"通过 ",paraId:10,tocIndex:6},{value:"graph.setItemState(item, stateName, stateValue)",paraId:10,tocIndex:6},{value:" 设置状态的值。",paraId:10,tocIndex:6},{value:"参数名",paraId:11,tocIndex:6},{value:"类型",paraId:11,tocIndex:6},{value:"描述",paraId:11,tocIndex:6},{value:"item",paraId:11,tocIndex:6},{value:"Number",paraId:11,tocIndex:6},{value:"需要被设置状态的节点/边实例",paraId:11,tocIndex:6},{value:"stateName",paraId:11,tocIndex:6},{value:"String",paraId:11,tocIndex:6},{value:"状态名称，可以是任意字符串",paraId:11,tocIndex:6},{value:"stateValue",paraId:11,tocIndex:6},{value:"Booelean",paraId:11,tocIndex:6},{value:"true 代表该状态是被激活，false 代表该状态被灭活",paraId:11,tocIndex:6},{value:"示例：",paraId:12,tocIndex:6},{value:"graph.setItemState(item, 'stateName', true);\n",paraId:13,tocIndex:6},{value:"多值状态在 G6 3.4 后支持。通过 ",paraId:14,tocIndex:7},{value:"graph.setItemState(item, stateName, stateValue)",paraId:14,tocIndex:7},{value:" 设置状态的值。",paraId:14,tocIndex:7},{value:"参数名",paraId:15,tocIndex:7},{value:"类型",paraId:15,tocIndex:7},{value:"描述",paraId:15,tocIndex:7},{value:"item",paraId:15,tocIndex:7},{value:"Number",paraId:15,tocIndex:7},{value:"需要被设置状态的节点/边实例",paraId:15,tocIndex:7},{value:"stateName",paraId:15,tocIndex:7},{value:"String",paraId:15,tocIndex:7},{value:"状态名称，可以是任意字符串",paraId:15,tocIndex:7},{value:"stateValue",paraId:15,tocIndex:7},{value:"String",paraId:15,tocIndex:7},{value:"状态的值，可以是任意字符串",paraId:15,tocIndex:7},{value:"示例：",paraId:16,tocIndex:7},{value:"graph.setItemState(item, 'stateName', 'stateValue');\n",paraId:17,tocIndex:7},{value:"该函数可以在监听函数 ",paraId:18,tocIndex:8},{value:"graph.on",paraId:18,tocIndex:8},{value:" 中被调用，也可以在自定义 Behavior 中调用，或在其他任意地方用于响应交互/业务的变化。",paraId:18,tocIndex:8},{value:"在回调函数中使定义的交互状态 hover 生效。",paraId:19,tocIndex:9},{value:"graph.on('node:mouseenter', (evt) => {\n  const { item } = evt;\n  graph.setItemState(item, 'hover', true);\n});\n\ngraph.on('node:mouseleave', (evt) => {\n  const { item } = evt;\n  graph.setItemState(item, 'hover', false);\n});\n",paraId:20,tocIndex:9},{value:"在自定义 Behavior 中使定义的交互状态 selected 生效。",paraId:21,tocIndex:10},{value:"G6.registerBehavior('nodeClick', {\n  getEvents() {\n    return {\n      'node:click': 'onClick',\n    };\n  },\n  onClick(e) {\n    e.preventDefault();\n    if (!this.shouldUpdate.call(this, e)) {\n      return;\n    }\n    const { item } = e;\n    const graph = this.graph;\n    graph.setItemState(item, 'selected', true);\n  },\n});\n",paraId:22,tocIndex:10},{value:"上小节使用 ",paraId:23,tocIndex:11},{value:"graph.setItemState",paraId:23,tocIndex:11},{value:" 使某些状态在图元素（节点/边）上被激活/灭活，仅仅是为该元素做了某些状态的标识。为了将这些状态反应到终端用户所见的视觉空间中，我们需要为不同的状态设置不同的图元素样式，以响应该图元素状态的变化。",paraId:23,tocIndex:11},{value:"在 G6 中，有三种方式配置不同状态的样式：",paraId:24,tocIndex:11},{value:"在实例化 Graph 时，通过 ",paraId:25,tocIndex:11},{value:"nodeStateStyles",paraId:25,tocIndex:11},{value:" 和 ",paraId:25,tocIndex:11},{value:"edgeStateStyles",paraId:25,tocIndex:11},{value:" 对象定义；",paraId:25,tocIndex:11},{value:"在节点/边数据中，在 ",paraId:25,tocIndex:11},{value:"stateStyles",paraId:25,tocIndex:11},{value:" 对象中定义状态；",paraId:25,tocIndex:11},{value:"在自定义节点/边时，在 options 配置项的 ",paraId:25,tocIndex:11},{value:"stateStyles",paraId:25,tocIndex:11},{value:" 对象中定义状态。",paraId:25,tocIndex:11},{value:"可为二值/多值状态设置 keyShape 样式以及其他子图形的样式。",paraId:26,tocIndex:11},{value:"⚠️ 注意: ",paraId:27,tocIndex:11},{value:"多值状态和除 keyShape 以外的子图形状态样式设置在 V3.4 后支持。",paraId:28,tocIndex:11},{value:"子图形状态样式仅限于指定节点/边的图形分组下平铺的图形，不支持嵌套图形分组下的图形。内置节点/边的图形分组内的图形均为平铺，在自定义节点时需要注意该规则。",paraId:28,tocIndex:11},{value:"nodeStateStyles",paraId:29,tocIndex:11},{value:" 、 ",paraId:29,tocIndex:11},{value:"edgeStateStyles",paraId:29,tocIndex:11},{value:" 、 ",paraId:29,tocIndex:11},{value:"stateStyles",paraId:29,tocIndex:11},{value:" 对象的格式如下：",paraId:29,tocIndex:11},{value:"{\n  // 二值状态 hover 为 true 时的样式\n  hover: {\n    // keyShape 的状态样式\n    fill: '#d3adf7',\n    // name 为 node-label 的子图形在该状态值下的样式\n    'node-label': {\n      fontSize: 15\n    },\n  },\n  // 二值状态 running 为 true 时的样式\n  running: {\n    // keyShape 的状态样式\n    stroke: 'steelblue',\n  },\n  // 多值状态与子图形样式的设置在 G6 3.4 后支持\n  // 多值状态 bodyState 为 health 时的样式\n  'bodyState:health': {\n    // keyShape 该状态值下的样式\n    fill: 'green',\n    // ... 其他样式\n    // name 为 shape-name1 的子图形在该状态值下的样式\n    'shape-name1': {\n      stroke: '#ccc'\n      // ... 其他样式\n    },\n    // name 为 shape-name2 的子图形在该状态值下的样式\n    'shape-name2': {\n      fill: 'red'\n      // ... 其他样式\n    }\n  },\n  // 多值状态 bodyState 为 suspect 时的样式\n  'bodyState:suspect': {\n    // ...\n  },\n  // 多值状态 bodyState 为 ill 时的样式\n  'bodyState:ill': {\n    // ...\n  }\n  // ... 其他状态\n}\n",paraId:30,tocIndex:11},{value:"使用这种方式可以为图上的所有节点/边配置全局统一的 state 样式。",paraId:31,tocIndex:12},{value:"const graph = new G6.Graph({\n  container: 'mountNode',\n  width: 800,\n  height: 600,\n  defaultNode: {\n    type: 'diamond',\n    style: {\n      // 默认状态样式\n      fill: 'blue',\n      // ... 其他样式\n    },\n  },\n  nodeStateStyles: {\n    // ...见上方例子\n  },\n  defaultEdge: {\n    // ...\n  },\n  edgeStateStyles: {\n    // ...\n  },\n});\n",paraId:32,tocIndex:12},{value:"上面的实例代码中，我们在实例化 Graph 时候，通过 ",paraId:33,tocIndex:12},{value:"nodeStateStyles",paraId:33,tocIndex:12},{value:" 定义了交互状态 ",paraId:33,tocIndex:12},{value:"hover",paraId:33,tocIndex:12},{value:" 和业务状态 ",paraId:33,tocIndex:12},{value:"running",paraId:33,tocIndex:12},{value:" 的样式。当某个任务状态变为正在执行时，二值状态 ",paraId:33,tocIndex:12},{value:"running",paraId:33,tocIndex:12},{value:" 被设置为 ",paraId:33,tocIndex:12},{value:"true",paraId:33,tocIndex:12},{value:" 后，节点的描边色将变为 ",paraId:33,tocIndex:12},{value:"'steelblue'",paraId:33,tocIndex:12},{value:"。当二值状态 ",paraId:33,tocIndex:12},{value:"hover",paraId:33,tocIndex:12},{value:" 被设置为 ",paraId:33,tocIndex:12},{value:"true",paraId:33,tocIndex:12},{value:" 时，节点 ",paraId:33,tocIndex:12},{value:"keyShape",paraId:33,tocIndex:12},{value:" 的填充色会变为 ",paraId:33,tocIndex:12},{value:"'#d3adf7'",paraId:33,tocIndex:12},{value:"；（V3.4 后支持）且该节点中 ",paraId:33,tocIndex:12},{value:"name",paraId:33,tocIndex:12},{value:" 为 ",paraId:33,tocIndex:12},{value:"'node-label'",paraId:33,tocIndex:12},{value:" 的子图形也会发生改变，这里的 ",paraId:33,tocIndex:12},{value:"'node-label'",paraId:33,tocIndex:12},{value:" 即节点上的文本图形，它的 ",paraId:33,tocIndex:12},{value:"fontSize",paraId:33,tocIndex:12},{value:" 将会发生改变。 ",paraId:33,tocIndex:12},{value:"（V3.4 后支持）上面实例还指定了名为 ",paraId:34,tocIndex:12},{value:"'bodyState'",paraId:34,tocIndex:12},{value:" 的多值状态各值下的样式。当一个节点的 ",paraId:34,tocIndex:12},{value:"'bodyState'",paraId:34,tocIndex:12},{value:" 的值被设置为 ",paraId:34,tocIndex:12},{value:"'health'",paraId:34,tocIndex:12},{value:" 时，该节点的 keyShape 样式以及 ",paraId:34,tocIndex:12},{value:"name",paraId:34,tocIndex:12},{value:" 为 ",paraId:34,tocIndex:12},{value:"'shape-name1'",paraId:34,tocIndex:12},{value:" 和 ",paraId:34,tocIndex:12},{value:"'shape-name2'",paraId:34,tocIndex:12},{value:" 的子图形样式都会发生变化。",paraId:34,tocIndex:12},{value:"同理，",paraId:35,tocIndex:12},{value:"defaultEdge",paraId:35,tocIndex:12},{value:" 中的 ",paraId:35,tocIndex:12},{value:"style",paraId:35,tocIndex:12},{value:" 属性定义了默认状态下边的样式，使用 ",paraId:35,tocIndex:12},{value:"edgeStateStyles",paraId:35,tocIndex:12},{value:"  可以定义不同状态下边的样式。",paraId:35,tocIndex:12},{value:"使用这种方式可以为不同的节点/边分别配置不同的 state 样式。",paraId:36,tocIndex:13},{value:"const data = {\n  nodes: [\n    {\n      id: 'node1',\n      styles: {\n        // 默认样式\n      },\n      stateStyles: {\n        //... 见上方例子\n      },\n      // ...\n    },\n    {\n      id: 'node2',\n      styles: {\n        // 默认样式\n      },\n      stateStyles: {\n        //... 见上方例子\n      },\n      // ...其他配置\n    },\n    // ...\n  ],\n  edges: [\n    {\n      source: 'node1',\n      target: 'node2',\n      styles: {\n        // 默认样式\n      },\n      stateStyles: {\n        //... 见上方例子\n      },\n      // ...其他配置\n    },\n    //...\n  ],\n};\n",paraId:37,tocIndex:13},{value:"使用这种方式可以为自定义的节点/边类型配置 state 样式。",paraId:38,tocIndex:14},{value:"G6.registerNode('customShape', {\n  // 自定义节点时的配置\n  options: {\n    size: 60,\n    style: {\n      lineWidth: 1\n    },\n    stateStyles: {\n      // ... 见上方例子\n    }\n  }\n}\n",paraId:39,tocIndex:14},{value:"⚠️ 注意: ",paraId:40,tocIndex:15},{value:" 更新状态样式配置在 V3.4 后支持。",paraId:40,tocIndex:15},{value:"更新状态样式配置是指更改在 ",paraId:41,tocIndex:15},{value:"配置 state 样式",paraId:42,tocIndex:15},{value:" 中设置的某状态下的样式配置。如下代码可以修改节点/边实例的默认样式以及各状态下的样式配置。同样，您也可以使用 ",paraId:41,tocIndex:15},{value:"配置 state 样式",paraId:43,tocIndex:15},{value:" 中的样式格式修改多值状态的样式配置。",paraId:41,tocIndex:15},{value:"graph.updateItem(item, {\n  // 修改默认样式\n  style: {\n    stroke: 'green',\n    // 修改 name 为 'node-label' 的子图形的默认样式\n    'node-label': {\n      stroke: 'yellow',\n    },\n  },\n  stateStyles: {\n    // 修改 hover 状态下的样式\n    hover: {\n      opacity: 0.1,\n      // 修改 name 为 'node-label' 的子图形 hover 状态下的样式\n      'node-text': {\n        stroke: 'blue',\n      },\n    },\n  },\n});\n",paraId:44,tocIndex:15},{value:"使用 ",paraId:45,tocIndex:15},{value:"graph.updateItem",paraId:45,tocIndex:15},{value:" 更新某状态的样式配置时，可能存在两种情况：",paraId:45,tocIndex:15},{value:"item 的该状态为激活状态，即 ",paraId:46,tocIndex:15},{value:"item.hasState('hover') === true",paraId:46,tocIndex:15},{value:"：此时该状态值对应的修改后的样式配置会立即在 item 上生效；",paraId:46,tocIndex:15},{value:"item 的该状态为灭活状态或不存在该状态，即 ",paraId:46,tocIndex:15},{value:"item.hasState('hover') === false",paraId:46,tocIndex:15},{value:"：在用户执行 ",paraId:46,tocIndex:15},{value:"graph.setItemState(item, 'hover', true)",paraId:46,tocIndex:15},{value:" 后，更新后的配置在 item 上的样式。",paraId:46,tocIndex:15},{value:"建议使用 ",paraId:47,tocIndex:16},{value:"graph.clearItemStates",paraId:47,tocIndex:16},{value:" 来取消 ",paraId:47,tocIndex:16},{value:"graph.setItemState",paraId:47,tocIndex:16},{value:" 设置的状态。",paraId:47,tocIndex:16},{value:"graph.clearItemStates",paraId:47,tocIndex:16},{value:" 支持一次取消单个或多个状态。",paraId:47,tocIndex:16},{value:"graph.setItemState(item, 'bodyState', 'health');\ngraph.setItemState(item, 'selected', true);\ngraph.setItemState(item, 'active', true);\n// 取消单个状态\ngraph.clearItemStates(item, 'selected');\ngraph.clearItemStates(item, ['selected']);\n// 取消多个状态\ngraph.clearItemStates(item, ['bodyState:health', 'selected', 'active']);\n",paraId:48,tocIndex:16},{value:"有时候，各个状态的样式之间可能有冲突，需要控制哪一状态的样式优先显示。G6 不提供显式设置状态优先级的方法，所有状态遵循：后设置的状态（通过 ",paraId:49,tocIndex:17},{value:"graph.setItemState",paraId:49,tocIndex:17},{value:"）优先级高于前者。用户可以通过 ",paraId:49,tocIndex:17},{value:"hasState",paraId:49,tocIndex:17},{value:" 方法判断元素的某种状态是否是激活态，从而判断是否应该激活另一个状态。这一逻辑完全由业务用户控制，实现这种控制也非常简单。例如，一般情况下，鼠标 hover 到某个节点后，该节点会高亮，但希望当该节点处于 active 状态时，鼠标 hover 上去后也不要覆盖 active 的状态，即 active 优先级高于 hover。",paraId:49,tocIndex:17},{value:"// 设置节点处于 active 状态\ngraph.setItemState(item, 'active', true);\n// 鼠标 hover\nconst hasActived = item.hasState('active');\n// 当节点没有 active 时才设置 hover 状态\nif (!hasActived) {\n  graph.setItemState(item, 'hover', true);\n}\n",paraId:50,tocIndex:17},{value:"G6 底层提供了状态管理的能力，通过使用 state，简化了状态管理，降低了用户的认知成本。更多关于 G6 中状态的内容请参考  ",paraId:51,tocIndex:18},{value:"G6 状态量思考",paraId:51,tocIndex:18},{value:"。",paraId:51,tocIndex:18}]},63138:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"由于动画机制较为复杂，我们未在 Tutorial-案例 中增加动画。本文简单描述了 G6 中的动画，希望快速上手的用户可以跳过本文，希望深入了解的用户可参见：",paraId:0},{value:"基础动画",paraId:1},{value:"。",paraId:0},{value:"G6 的动画分为两个层次：",paraId:2},{value:"图全局动画：图整体变化时的动画过渡；",paraId:3},{value:"元素动画：节点和边的动画效果。",paraId:3},{value:"G6 的全局动画指通过图实例进行操作时，产生的动画效果。例如：",paraId:4,tocIndex:0},{value:"graph.updateLayout(cfg)",paraId:5,tocIndex:0},{value:"通过实例化图时配置 ",paraId:6,tocIndex:0},{value:"animate: true",paraId:6,tocIndex:0},{value:"，可以达到每次进行上述操作时，动画效果变化的目的。",paraId:6,tocIndex:0},{value:"例子",paraId:7,tocIndex:0},{value:"const graph = new G6.Graph({\n  // ...                      // 其他配置项\n  animate: true, // Boolean，可选，全局变化时否使用动画过渡\n});\n",paraId:8,tocIndex:0},{value:"G6 允许用户通过自定义节点/边的方式，给元素增加动画效果，如下：",paraId:9,tocIndex:1},{value:" ",paraId:9,tocIndex:1},{value:"更多关于动画的案例请参考 ",paraId:10,tocIndex:1},{value:"G6 中的动画案例",paraId:11,tocIndex:1},{value:"。",paraId:10,tocIndex:1}]},18422:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 封装了一系列交互方法，方便用户直接使用。本文将为 ",paraId:0},{value:"Tutorial 案例",paraId:0},{value:" 增加简单的交互：hover 节点、点击节点、点击边、放缩画布、拖拽画布。本节目标效果如下：",paraId:0},{value:"图 1 Tutorial 案例的交互效果。",paraId:1},{value:"G6 中的交互行为。G6 ",paraId:2,tocIndex:1},{value:"内置",paraId:2,tocIndex:1},{value:"了一系列交互行为，用户可以直接使用。简单地理解，就是可以一键开启这些交互行为：",paraId:2,tocIndex:1},{value:"drag-canvas",paraId:3,tocIndex:1},{value:"：拖拽画布；",paraId:3,tocIndex:1},{value:"zoom-canvas",paraId:3,tocIndex:1},{value:"：缩放画布。",paraId:3,tocIndex:1},{value:"更多详见：",paraId:4,tocIndex:1},{value:"交互行为 Behavior",paraId:5,tocIndex:1},{value:"Mode 是 G6 交互行为的管理机制，一个 mode 是多种行为 Behavior 的组合，允许用户通过切换不同的模式进行交互行为的管理。由于该概念较为复杂，在本入门教程中，读者不需要对该机制深入理解。如有需求，参见 ",paraId:6,tocIndex:2},{value:"交互模式 Mode",paraId:7,tocIndex:2},{value:"。",paraId:6,tocIndex:2},{value:"状态 State",paraId:8,tocIndex:3},{value:" 是 G6 中的状态机制。用户可以为图中的元素（节点/边）设置不同的状态及不同状态下的样式。在状态发生变化时，G6 自动更新元素的样式。例如，可以为节点设置状态 ",paraId:9,tocIndex:3},{value:"'click'",paraId:9,tocIndex:3},{value:" 为 ",paraId:9,tocIndex:3},{value:"true",paraId:9,tocIndex:3},{value:" 或 ",paraId:9,tocIndex:3},{value:"false",paraId:9,tocIndex:3},{value:"，并为节点设置 ",paraId:9,tocIndex:3},{value:"'click'",paraId:9,tocIndex:3},{value:" 的样式为加粗节点边框。当 ",paraId:9,tocIndex:3},{value:"'click'",paraId:9,tocIndex:3},{value:" 状态被切换为 ",paraId:9,tocIndex:3},{value:"true",paraId:9,tocIndex:3},{value:" 时，节点的边框将会被加粗，",paraId:9,tocIndex:3},{value:"'click'",paraId:9,tocIndex:3},{value:" 状态被切换为 ",paraId:9,tocIndex:3},{value:"false",paraId:9,tocIndex:3},{value:" 时，节点的样式恢复到默认。在下面的使用方法中，将会有具体例子。",paraId:9,tocIndex:3},{value:"在 G6 中使用内置 Behavior 的方式非常简单，只需要在图实例化时配置 ",paraId:10,tocIndex:5},{value:"modes",paraId:10,tocIndex:5},{value:"。拖拽和缩放属于 G6 内置交互行为，修改代码如下：",paraId:10,tocIndex:5},{value:"const graph = new G6.Graph({\n  // ...                                          // 其他配置项\n  modes: {\n    default: ['drag-canvas', 'zoom-canvas', 'drag-node'], // 允许拖拽画布、放缩画布、拖拽节点\n  },\n});\n",paraId:11,tocIndex:5},{value:"除了直接使用内置交互名称外，也可以为 Behavior 配置参数，例如放缩画布的敏感度、最大/最小放缩程度等，具体用法参见  ",paraId:12,tocIndex:5},{value:"交互行为 Behavior",paraId:13,tocIndex:5},{value:"。",paraId:12,tocIndex:5},{value:"上面代码中的 ",paraId:14,tocIndex:5},{value:"modes",paraId:14,tocIndex:5},{value:" 定义了 G6 的模式，",paraId:14,tocIndex:5},{value:"default",paraId:14,tocIndex:5},{value:" 是默认的模式，还可以允许有其他的模式，比如：编辑模式 ",paraId:14,tocIndex:5},{value:"edit",paraId:14,tocIndex:5},{value:" 等。不同的模式，用户能进行的行为可以不同，比如默认模式能拖拽画布，编辑模式不允许拖拽画布：",paraId:14,tocIndex:5},{value:"// 举例解释不同模式\nmodes: {\n  default: ['drag-canvas'],\n  edit: []\n}\n",paraId:15,tocIndex:5},{value:"更多关于模式、行为可以参考: ",paraId:16,tocIndex:5},{value:"交互模型 Mode",paraId:17,tocIndex:5},{value:" 和 ",paraId:16,tocIndex:5},{value:"交互行为 Behavior",paraId:18,tocIndex:5},{value:" 文档。",paraId:16,tocIndex:5},{value:"有时我们希望通过交互可以将元素样式变成特定样式，如我们看到的图 1 中，鼠标 hover 节点、点击节点、点击边时，样式发生了变化。这里涉及到了 G6 中 ",paraId:19,tocIndex:6},{value:"状态 State",paraId:20,tocIndex:6},{value:" 的概念。简单地说，是否 ",paraId:19,tocIndex:6},{value:"hover",paraId:19,tocIndex:6},{value:" 、",paraId:19,tocIndex:6},{value:"click",paraId:19,tocIndex:6},{value:" 、任何操作（可以是自己起的状态名），都可以称为一种状态（state）。用户可以自由设置不同状态下的元素样式。要达到交互更改元素样式，需要两步：",paraId:19,tocIndex:6},{value:"Step 1: 设置各状态下的元素样式；",paraId:21,tocIndex:6},{value:"Step 2: 监听事件并切换元素状态。",paraId:21,tocIndex:6},{value:"在实例化图时，通过 ",paraId:22,tocIndex:7},{value:"nodeStateStyles",paraId:22,tocIndex:7},{value:" 和 ",paraId:22,tocIndex:7},{value:"edgeStateStyles",paraId:22,tocIndex:7},{value:" 两个配置项可以配置元素在不同状态下的样式。",paraId:22,tocIndex:7},{value:"为达到 ",paraId:22,tocIndex:7},{value:"Tutorial 案例",paraId:22,tocIndex:7},{value:" 中的效果：",paraId:22,tocIndex:7},{value:"鼠标 hover 节点时，该节点颜色变浅；",paraId:23,tocIndex:7},{value:"点击节点时，该节点边框加粗变黑；",paraId:23,tocIndex:7},{value:"点击边时，该边变成蓝色。",paraId:23,tocIndex:7},{value:"下面代码设置了节点分别在 ",paraId:24,tocIndex:7},{value:"hover",paraId:24,tocIndex:7},{value:" 和 ",paraId:24,tocIndex:7},{value:"click",paraId:24,tocIndex:7},{value:" 状态为 ",paraId:24,tocIndex:7},{value:"true",paraId:24,tocIndex:7},{value:" 时的样式，边在 ",paraId:24,tocIndex:7},{value:"click",paraId:24,tocIndex:7},{value:" 状态为 ",paraId:24,tocIndex:7},{value:"true",paraId:24,tocIndex:7},{value:" 时的样式：",paraId:24,tocIndex:7},{value:"const graph = new G6.Graph({\n  // ...                           // 其他配置项\n  // 节点不同状态下的样式集合\n  nodeStateStyles: {\n    // 鼠标 hover 上节点，即 hover 状态为 true 时的样式\n    hover: {\n      fill: 'lightsteelblue',\n    },\n    // 鼠标点击节点，即 click 状态为 true 时的样式\n    click: {\n      stroke: '#000',\n      lineWidth: 3,\n    },\n  },\n  // 边不同状态下的样式集合\n  edgeStateStyles: {\n    // 鼠标点击边，即 click 状态为 true 时的样式\n    click: {\n      stroke: 'steelblue',\n    },\n  },\n});\n",paraId:25,tocIndex:7},{value:"G6 中所有元素监听都挂载在图实例上，如下代码中的 ",paraId:26,tocIndex:8},{value:"graph",paraId:26,tocIndex:8},{value:" 对象是 G6.Graph 的实例，",paraId:26,tocIndex:8},{value:"graph.on()",paraId:26,tocIndex:8},{value:"  函数监听了某元素类型（",paraId:26,tocIndex:8},{value:"node",paraId:26,tocIndex:8},{value:" / ",paraId:26,tocIndex:8},{value:"edge",paraId:26,tocIndex:8},{value:"）的某种事件（",paraId:26,tocIndex:8},{value:"click",paraId:26,tocIndex:8},{value:" / ",paraId:26,tocIndex:8},{value:"mouseenter",paraId:26,tocIndex:8},{value:" / ",paraId:26,tocIndex:8},{value:"mouseleave",paraId:26,tocIndex:8},{value:" / ... 所有事件参见：",paraId:26,tocIndex:8},{value:"Event API",paraId:27,tocIndex:8},{value:"）。",paraId:26,tocIndex:8},{value:"// 在图实例 graph 上监听\ngraph.on('元素类型:事件名', (e) => {\n  // do something\n});\n",paraId:28,tocIndex:8},{value:"现在，我们通过下面代码，为 ",paraId:29,tocIndex:8},{value:"Tutorial 案例",paraId:29,tocIndex:8},{value:" 增加点和边上的监听事件，并在监听函数里使用 ",paraId:29,tocIndex:8},{value:"graph.setItemState()",paraId:29,tocIndex:8},{value:" 改变元素的状态：",paraId:29,tocIndex:8},{value:"// 鼠标进入节点\ngraph.on('node:mouseenter', (e) => {\n  const nodeItem = e.item; // 获取鼠标进入的节点元素对象\n  graph.setItemState(nodeItem, 'hover', true); // 设置当前节点的 hover 状态为 true\n});\n\n// 鼠标离开节点\ngraph.on('node:mouseleave', (e) => {\n  const nodeItem = e.item; // 获取鼠标离开的节点元素对象\n  graph.setItemState(nodeItem, 'hover', false); // 设置当前节点的 hover 状态为 false\n});\n\n// 点击节点\ngraph.on('node:click', (e) => {\n  // 先将所有当前是 click 状态的节点置为非 click 状态\n  const clickNodes = graph.findAllByState('node', 'click');\n  clickNodes.forEach((cn) => {\n    graph.setItemState(cn, 'click', false);\n  });\n  const nodeItem = e.item; // 获取被点击的节点元素对象\n  graph.setItemState(nodeItem, 'click', true); // 设置当前节点的 click 状态为 true\n});\n\n// 点击边\ngraph.on('edge:click', (e) => {\n  // 先将所有当前是 click 状态的边置为非 click 状态\n  const clickEdges = graph.findAllByState('edge', 'click');\n  clickEdges.forEach((ce) => {\n    graph.setItemState(ce, 'click', false);\n  });\n  const edgeItem = e.item; // 获取被点击的边元素对象\n  graph.setItemState(edgeItem, 'click', true); // 设置当前边的 click 状态为 true\n});\n",paraId:30,tocIndex:8},{value:"至此，完整代码如下：",paraId:31,tocIndex:9},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    <div id=\"mountNode\"></div>\n    <script src=\"https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js\"><\/script>\n    \x3c!-- 4.x and later versions --\x3e\n    \x3c!-- <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script> --\x3e\n    <script>\n      const graph = new G6.Graph({\n        container: 'mountNode',\n        width: 800,\n        height: 600,\n        // 节点默认配置\n        defaultNode: {\n          labelCfg: {\n            style: {\n              fill: '#fff',\n            },\n          },\n        },\n        // 边默认配置\n        defaultEdge: {\n          labelCfg: {\n            autoRotate: true,\n          },\n        },\n        // 节点在各状态下的样式\n        nodeStateStyles: {\n          // hover 状态为 true 时的样式\n          hover: {\n            fill: 'lightsteelblue',\n          },\n          // click 状态为 true 时的样式\n          click: {\n            stroke: '#000',\n            lineWidth: 3,\n          },\n        },\n        // 边在各状态下的样式\n        edgeStateStyles: {\n          // click 状态为 true 时的样式\n          click: {\n            stroke: 'steelblue',\n          },\n        },\n        // 布局\n        layout: {\n          type: 'force',\n          linkDistance: 100,\n          preventOverlap: true,\n          nodeStrength: -30,\n          edgeStrength: 0.1,\n        },\n        // 内置交互\n        modes: {\n          default: ['drag-canvas', 'zoom-canvas', 'drag-node'],\n        },\n      });\n\n      const main = async () => {\n        const response = await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json',\n        );\n        const remoteData = await response.json();\n\n        const nodes = remoteData.nodes;\n        const edges = remoteData.edges;\n        nodes.forEach((node) => {\n          if (!node.style) {\n            node.style = {};\n          }\n          node.style.lineWidth = 1;\n          node.style.stroke = '#666';\n          node.style.fill = 'steelblue';\n          switch (node.class) {\n            case 'c0': {\n              node.type = 'circle';\n              node.size = 30;\n              break;\n            }\n            case 'c1': {\n              node.type = 'rect';\n              node.size = [35, 20];\n              break;\n            }\n            case 'c2': {\n              node.type = 'ellipse';\n              node.size = [35, 20];\n              break;\n            }\n          }\n        });\n        edges.forEach((edge) => {\n          if (!edge.style) {\n            edge.style = {};\n          }\n          edge.style.lineWidth = edge.weight;\n          edge.style.opacity = 0.6;\n          edge.style.stroke = 'grey';\n        });\n\n        graph.data(remoteData);\n        graph.render();\n\n        // 监听鼠标进入节点\n        graph.on('node:mouseenter', (e) => {\n          const nodeItem = e.item;\n          // 设置目标节点的 hover 状态 为 true\n          graph.setItemState(nodeItem, 'hover', true);\n        });\n        // 监听鼠标离开节点\n        graph.on('node:mouseleave', (e) => {\n          const nodeItem = e.item;\n          // 设置目标节点的 hover 状态 false\n          graph.setItemState(nodeItem, 'hover', false);\n        });\n        // 监听鼠标点击节点\n        graph.on('node:click', (e) => {\n          // 先将所有当前有 click 状态的节点的 click 状态置为 false\n          const clickNodes = graph.findAllByState('node', 'click');\n          clickNodes.forEach((cn) => {\n            graph.setItemState(cn, 'click', false);\n          });\n          const nodeItem = e.item;\n          // 设置目标节点的 click 状态 为 true\n          graph.setItemState(nodeItem, 'click', true);\n        });\n        // 监听鼠标点击节点\n        graph.on('edge:click', (e) => {\n          // 先将所有当前有 click 状态的边的 click 状态置为 false\n          const clickEdges = graph.findAllByState('edge', 'click');\n          clickEdges.forEach((ce) => {\n            graph.setItemState(ce, 'click', false);\n          });\n          const edgeItem = e.item;\n          // 设置目标边的 click 状态 为 true\n          graph.setItemState(edgeItem, 'click', true);\n        });\n      };\n      main();\n    <\/script>\n  </body>\n</html>\n",paraId:32,tocIndex:9},{value:"⚠️ 注意:",paraId:33,tocIndex:9},{value:" 若需更换数据，请替换  ",paraId:33,tocIndex:9},{value:"'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json'",paraId:33,tocIndex:9},{value:"  为新的数据文件地址。",paraId:33,tocIndex:9}]},78346:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"图的元素特指图上的",paraId:0},{value:"节点",paraId:0},{value:" ",paraId:0},{value:"Node",paraId:0},{value:" 和",paraId:0},{value:"边",paraId:0},{value:" ",paraId:0},{value:"Edge",paraId:0},{value:" 。在上一章节中，我们已经将 ",paraId:0},{value:"Tutorial 案例",paraId:0},{value:"的图绘制了出来，但是各个元素及其 ",paraId:0},{value:"label",paraId:0},{value:"  在视觉上很简陋。本文通过将上一章节中简陋的元素美化成如下效果，介绍元素的属性、配置方法。",paraId:0},{value:"图 1  元素属性配置后的 ",paraId:1},{value:"Tutorial 案例",paraId:1},{value:"。",paraId:1},{value:"图的元素特指图上的",paraId:2,tocIndex:1},{value:"节点",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"Node",paraId:2,tocIndex:1},{value:" 和",paraId:2,tocIndex:1},{value:"边",paraId:2,tocIndex:1},{value:" ",paraId:2,tocIndex:1},{value:"Edge",paraId:2,tocIndex:1},{value:" 。G6 内置了一系列 ",paraId:2,tocIndex:1},{value:"内置的节点",paraId:3,tocIndex:1},{value:" 和 ",paraId:2,tocIndex:1},{value:"内置的边",paraId:4,tocIndex:1},{value:"，供用户自由选择。G6 不同的内置节点或不同的内置边主要区别在于元素的 ",paraId:2,tocIndex:1},{value:"图形 Shape",paraId:5,tocIndex:1},{value:"，例如，节点可以是圆形、矩形、图片等。",paraId:2,tocIndex:1},{value:"不论是节点还是边，它们的属性分为两种：",paraId:6,tocIndex:2},{value:"样式属性 ",paraId:7,tocIndex:2},{value:"style",paraId:7,tocIndex:2},{value:"：对应 Canvas 中的各种样式，在元素",paraId:7,tocIndex:2},{value:"状态 State",paraId:8,tocIndex:2},{value:" 发生变化时，可以被改变；",paraId:7,tocIndex:2},{value:"其他属性",paraId:7,tocIndex:2},{value:"：例如图形类型（ ",paraId:7,tocIndex:2},{value:"type",paraId:7,tocIndex:2},{value:"）、id（",paraId:7,tocIndex:2},{value:"id",paraId:7,tocIndex:2},{value:" ）一类在元素",paraId:7,tocIndex:2},{value:"状态 State",paraId:9,tocIndex:2},{value:" 发生变化时不能被改变的属性。",paraId:7,tocIndex:2},{value:"例如，G6 设定 hover 或 click 节点，造成节点状态的改变，只能自动改变节点的",paraId:10,tocIndex:2},{value:"样式属性",paraId:10,tocIndex:2},{value:"（如 ",paraId:10,tocIndex:2},{value:"fill",paraId:10,tocIndex:2},{value:"、",paraId:10,tocIndex:2},{value:"stroke",paraId:10,tocIndex:2},{value:" 等**）**，",paraId:10,tocIndex:2},{value:"其他属性",paraId:10,tocIndex:2},{value:"（如 ",paraId:10,tocIndex:2},{value:"type",paraId:10,tocIndex:2},{value:"  等）不能被改变。如果需要改变其他属性，要通过  ",paraId:10,tocIndex:2},{value:"graph.updateItem",paraId:11,tocIndex:2},{value:" 手动配置。",paraId:10,tocIndex:2},{value:"样式属性",paraId:10,tocIndex:2},{value:"是一个名为  ",paraId:10,tocIndex:2},{value:"style",paraId:10,tocIndex:2},{value:"  的对象， ",paraId:10,tocIndex:2},{value:"style",paraId:10,tocIndex:2},{value:" 字段与其他属性并行。",paraId:10,tocIndex:2},{value:"以节点元素为例，其属性的数据结构如下：",paraId:12,tocIndex:3},{value:"{\n\tid: 'node0',          // 元素的 id\n  type: 'circle',       // 元素的图形\n  size: 40,             // 元素的大小\n  label: 'node0'        // 标签文字\n  visible: true,        // 控制初次渲染显示与隐藏，若为 false，代表隐藏。默认不隐藏\n  labelCfg: {           // 标签配置属性\n    positions: 'center',// 标签的属性，标签在元素中的位置\n    style: {            // 包裹标签样式属性的字段 style 与标签其他属性在数据结构上并行\n      fontSize: 12      // 标签的样式属性，文字字体大小\n      // ...            // 标签的其他样式属性\n    }\n  }\n  // ...,               // 其他属性\n  style: {              // 包裹样式属性的字段 style 与其他属性在数据结构上并行\n    fill: '#000',       // 样式属性，元素的填充色\n    stroke: '#888',     // 样式属性，元素的描边色\n    // ...              // 其他样式属性\n  }\n}\n",paraId:13,tocIndex:3},{value:"边元素的属性数据结构与节点元素相似，只是其他属性中多了 ",paraId:14,tocIndex:3},{value:"source",paraId:14,tocIndex:3},{value:" 和 ",paraId:14,tocIndex:3},{value:"target",paraId:14,tocIndex:3},{value:" 字段，代表起始和终止节点的 ",paraId:14,tocIndex:3},{value:"id",paraId:14,tocIndex:3},{value:"。",paraId:14,tocIndex:3},{value:"细化在图 1 中 ",paraId:14,tocIndex:3},{value:"Tutorial 案例",paraId:14,tocIndex:3},{value:" 的视觉需求，我们需要完成：",paraId:14,tocIndex:3},{value:"视觉效果：\n",paraId:15,tocIndex:3},{value:"R1: 节点的描边和填充色，对应节点样式属性：",paraId:16,tocIndex:3},{value:"fill",paraId:16,tocIndex:3},{value:"，",paraId:16,tocIndex:3},{value:"stroke",paraId:16,tocIndex:3},{value:"；",paraId:16,tocIndex:3},{value:"R2: 节点上标签文本的颜色，对应节点其他属性：",paraId:16,tocIndex:3},{value:"labelCfg",paraId:16,tocIndex:3},{value:"；",paraId:16,tocIndex:3},{value:"R3: 边的透明度和颜色，对应边样式属性：",paraId:16,tocIndex:3},{value:"opacity",paraId:16,tocIndex:3},{value:"，",paraId:16,tocIndex:3},{value:"stroke",paraId:16,tocIndex:3},{value:"；",paraId:16,tocIndex:3},{value:"R4: 边上标签文本的方向和颜色，对应边其他属性：",paraId:16,tocIndex:3},{value:"labelCfg",paraId:16,tocIndex:3},{value:"；",paraId:16,tocIndex:3},{value:"数据与视觉映射：\n",paraId:15,tocIndex:3},{value:"R5: 根据数据中节点的 ",paraId:17,tocIndex:3},{value:"class",paraId:17,tocIndex:3},{value:" 属性映射节点的形状，对应节点其他属性：",paraId:17,tocIndex:3},{value:"type",paraId:17,tocIndex:3},{value:"；",paraId:17,tocIndex:3},{value:"R6: 根据数据中边的 ",paraId:17,tocIndex:3},{value:"weight",paraId:17,tocIndex:3},{value:" 属性映射边的粗细，对应边样式属性：",paraId:17,tocIndex:3},{value:"lineWidth",paraId:17,tocIndex:3},{value:"。",paraId:17,tocIndex:3},{value:"在 G6 中，根据不同的场景需求，有 7 种配置元素属性的方式。这里，我们简单介绍其中的两种：",paraId:18,tocIndex:4},{value:"实例化图时配置元素的全局属性；",paraId:19,tocIndex:4},{value:"在数据中配置。",paraId:19,tocIndex:4},{value:"**适用场景：**所有节点统一的属性配置，所有边统一的属性配置。",paraId:20,tocIndex:5},{value:"**使用方式：**使用图的两个配置项：",paraId:20,tocIndex:5},{value:"defaultNode",paraId:21,tocIndex:5},{value:"：节点在默认状态下的",paraId:21,tocIndex:5},{value:"样式属性",paraId:21,tocIndex:5},{value:"（",paraId:21,tocIndex:5},{value:"style",paraId:21,tocIndex:5},{value:"）和",paraId:21,tocIndex:5},{value:"其他属性",paraId:21,tocIndex:5},{value:"；",paraId:21,tocIndex:5},{value:"defaultEdge",paraId:21,tocIndex:5},{value:"：边在默认状态下的",paraId:21,tocIndex:5},{value:"样式属性",paraId:21,tocIndex:5},{value:"（",paraId:21,tocIndex:5},{value:"style",paraId:21,tocIndex:5},{value:"）和",paraId:21,tocIndex:5},{value:"其他属性",paraId:21,tocIndex:5},{value:"。",paraId:21,tocIndex:5},{value:"⚠️ 注意:",paraId:22,tocIndex:5},{value:" 由于是统一的配置，不能根据数据中的属性（如 ",paraId:22,tocIndex:5},{value:"class",paraId:22,tocIndex:5},{value:"、",paraId:22,tocIndex:5},{value:"weight",paraId:22,tocIndex:5},{value:"）等值的不同进行个性化设置，因此只能满足 R1、R2、R3、R4 需求。达到如下效果：",paraId:22,tocIndex:5},{value:"图 2  全局配置元素属性后的 ",paraId:23,tocIndex:5},{value:"Tutorial 案例",paraId:23,tocIndex:5},{value:"。",paraId:23,tocIndex:5},{value:"通过如下方式在实例化图时  ",paraId:24,tocIndex:5},{value:"defaultNode",paraId:24,tocIndex:5},{value:" 和  ",paraId:24,tocIndex:5},{value:"defaultEdge",paraId:24,tocIndex:5},{value:" ，可以完成上图效果：",paraId:24,tocIndex:5},{value:"const graph = new G6.Graph({\n  // ...                   // 图的其他配置\n  // 节点在默认状态下的样式配置（style）和其他配置\n  defaultNode: {\n    size: 30, // 节点大小\n    // ...                 // 节点的其他配置\n    // 节点样式配置\n    style: {\n      fill: 'steelblue', // 节点填充色\n      stroke: '#666', // 节点描边色\n      lineWidth: 1, // 节点描边粗细\n    },\n    // 节点上的标签文本配置\n    labelCfg: {\n      // 节点上的标签文本样式配置\n      style: {\n        fill: '#fff', // 节点标签文字颜色\n      },\n    },\n  },\n  // 边在默认状态下的样式配置（style）和其他配置\n  defaultEdge: {\n    // ...                 // 边的其他配置\n    // 边样式配置\n    style: {\n      opacity: 0.6, // 边透明度\n      stroke: 'grey', // 边描边颜色\n    },\n    // 边上的标签文本配置\n    labelCfg: {\n      autoRotate: true, // 边上的标签文本根据边的方向旋转\n    },\n  },\n});\n",paraId:25,tocIndex:5},{value:"**适用场景：**不同节点/边可以有不同的个性化配置。",paraId:26,tocIndex:6},{value:"因此，这种配置方式可以满足 R5、R6 需求。",paraId:26,tocIndex:6},{value:"**使用方式：**可以直接将配置写入数据文件；也可以在读入数据后，通过遍历的方式写入配置。这里展示读入数据后，通过遍历的方式写入配置。下面代码展示了如何遍历数据进行属性的配置：",paraId:26,tocIndex:6},{value:"const nodes = remoteData.nodes;\nnodes.forEach((node) => {\n  if (!node.style) {\n    node.style = {};\n  }\n  switch (\n    node.class // 根据节点数据中的 class 属性配置图形\n  ) {\n    case 'c0': {\n      node.type = 'circle'; // class = 'c0' 时节点图形为 circle\n      break;\n    }\n    case 'c1': {\n      node.type = 'rect'; // class = 'c1' 时节点图形为 rect\n      node.size = [35, 20]; // class = 'c1' 时节点大小\n      break;\n    }\n    case 'c2': {\n      node.type = 'ellipse'; // class = 'c2' 时节点图形为 ellipse\n      node.size = [35, 20]; // class = 'c2' 时节点大小\n      break;\n    }\n  }\n});\n\ngraph.data(remoteData);\n",paraId:27,tocIndex:6},{value:"运行结果如下：",paraId:28,tocIndex:6},{value:"图 3",paraId:29,tocIndex:6},{value:"可以看到，图中有一些节点被渲染成了矩形，还有一些被渲染成了椭圆形。除了设置 ",paraId:30,tocIndex:6},{value:"type",paraId:30,tocIndex:6},{value:" 属性之外，我们还覆盖了上文全局配置的节点的 ",paraId:30,tocIndex:6},{value:"size",paraId:30,tocIndex:6},{value:" 属性，在矩形和椭圆的情况下，",paraId:30,tocIndex:6},{value:"size",paraId:30,tocIndex:6},{value:" 是一个数组；而在默认圆形的情况下，G6 将仍然读取全局配置的 ",paraId:30,tocIndex:6},{value:"size",paraId:30,tocIndex:6},{value:" 属性为数字 ",paraId:30,tocIndex:6},{value:"30",paraId:30,tocIndex:6},{value:"。也就是说，动态配置属性让我们既可以根据数据的不同配置不同的属性值，也可以有能力覆盖全局静态的属性值。",paraId:30,tocIndex:6},{value:"进一步地，我们尝试根据数据的比重不同，配置不一样边的粗细：",paraId:31,tocIndex:6},{value:"// const nodes = ...\n\n// 遍历边数据\nconst edges = remoteData.edges;\nedges.forEach((edge) => {\n  if (!edge.style) {\n    edge.style = {};\n  }\n  edge.style.lineWidth = edge.weight; // 边的粗细映射边数据中的 weight 属性数值\n});\n\ngraph.data(remoteData);\n",paraId:32,tocIndex:6},{value:"结果如下：",paraId:33,tocIndex:6},{value:"如图所示，边的粗细已经按照数据的比重成功渲染了出来，但是边原有的样式（透明度、颜色）却丢失了。这是因为我们提到过动态配置属性会覆盖全局配置属性，这里配置了 ",paraId:34,tocIndex:6},{value:"style.lineWidth",paraId:34,tocIndex:6},{value:"，导致覆盖了全局的 ",paraId:34,tocIndex:6},{value:"style",paraId:34,tocIndex:6},{value:" 对象。解决办法是将被覆盖的边的样式都移到动态配置里面来：",paraId:34,tocIndex:6},{value:"const graph = new G6.Graph({\n  // ...\n  defaultEdge: {\n    // 去掉全局配置的 style\n    labelCfg: {\n      // 边上的标签文本配置\n      autoRotate: true, // 边上的标签文本根据边的方向旋转\n    },\n  },\n});\n\n// 遍历点数据\n// const nodes = ...\n// nodes.forEach ...\n\n// 遍历边数据\nconst edges = remoteData.edges;\nedges.forEach((edge) => {\n  if (!edge.style) {\n    edge.style = {};\n  }\n  edge.style.lineWidth = edge.weight; // 边的粗细映射边数据中的 weight 属性数值\n  // 移到此处\n  edge.style.opacity = 0.6;\n  edge.style.stroke = 'grey';\n});\n\ngraph.data(remoteData);\ngraph.render();\n",paraId:35,tocIndex:6},{value:"至此，完整代码如下：",paraId:36,tocIndex:7},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    <div id=\"mountNode\"></div>\n    <script src=\"https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js\"><\/script>\n    \x3c!-- 4.x and later versions --\x3e\n    \x3c!-- <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script> --\x3e\n    <script>\n      const graph = new G6.Graph({\n        container: 'mountNode',\n        width: 800,\n        height: 600,\n        fitView: true,\n        fitViewPadding: [20, 40, 50, 20],\n        defaultNode: {\n          size: 30,\n          labelCfg: {\n            style: {\n              fill: '#fff',\n            },\n          },\n        },\n        defaultEdge: {\n          labelCfg: {\n            autoRotate: true,\n          },\n        },\n      });\n      const main = async () => {\n        const response = await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json',\n        );\n        const remoteData = await response.json();\n        const nodes = remoteData.nodes;\n        const edges = remoteData.edges;\n        nodes.forEach((node) => {\n          if (!node.style) {\n            node.style = {};\n          }\n          node.style.lineWidth = 1;\n          node.style.stroke = '#666';\n          node.style.fill = 'steelblue';\n          switch (node.class) {\n            case 'c0': {\n              node.type = 'circle';\n              break;\n            }\n            case 'c1': {\n              node.type = 'rect';\n              node.size = [35, 20];\n              break;\n            }\n            case 'c2': {\n              node.type = 'ellipse';\n              node.size = [35, 20];\n              break;\n            }\n          }\n        });\n        edges.forEach((edge) => {\n          if (!edge.style) {\n            edge.style = {};\n          }\n          edge.style.lineWidth = edge.weight;\n          edge.style.opacity = 0.6;\n          edge.style.stroke = 'grey';\n        });\n\n        graph.data(remoteData);\n        graph.render();\n      };\n      main();\n    <\/script>\n  </body>\n</html>\n",paraId:37,tocIndex:7},{value:"⚠️ 注意:",paraId:38,tocIndex:7},{value:" ",paraId:38,tocIndex:7},{value:" 若需更换数据，请替换  ",paraId:38,tocIndex:7},{value:"'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json'",paraId:38,tocIndex:7},{value:"  为新的数据文件地址。",paraId:38,tocIndex:7}]},99465:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"恭喜！你已经成功创建了一个基于 G6 的图可视化应用，并学会了：",paraId:0},{value:"基本绘制方法",paraId:1},{value:"远程数据加载",paraId:1},{value:"属性配置",paraId:1},{value:"布局运用",paraId:1},{value:"增加交互",paraId:1},{value:"添加辅助工具",paraId:1},{value:"完整代码见：",paraId:2},{value:"Tutorial 案例代码",paraId:2},{value:"。",paraId:2},{value:"如果你希望继续学习深入的 G6 知识，请查看 ",paraId:3},{value:"G6 核心概念",paraId:4},{value:"；关于 G6 的扩展内容，请查看 ",paraId:3},{value:"G6 扩展阅读",paraId:5},{value:"。",paraId:3},{value:"开发过程中可通过 ",paraId:6},{value:"G6 API",paraId:7},{value:" 快速查询。",paraId:6}]},25042:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"本文将进行 ",paraId:0},{value:"Tutorial 案例",paraId:0},{value:"的简单绘制和配置。通过本文，你将知道创建一般图时一些常用的配置项及其作用。",paraId:0},{value:"需要在 HTML 中创建一个用于容纳 G6 绘制的图的容器，通常为 ",paraId:1,tocIndex:1},{value:"div",paraId:1,tocIndex:1},{value:"  标签。G6 在绘制时会在该容器下追加 ",paraId:1,tocIndex:1},{value:"canvas",paraId:1,tocIndex:1},{value:" 标签，然后将图绘制在其中。",paraId:1,tocIndex:1},{value:'<body>\n  <div id="mountNode"></div>\n\n  \x3c!-- 引入 G6 --\x3e\n  \x3c!-- ... --\x3e\n</body>\n',paraId:2,tocIndex:1},{value:"引入 G6 的数据源为 JSON 格式的对象。该对象中需要有节点（",paraId:3,tocIndex:2},{value:"nodes",paraId:3,tocIndex:2},{value:"）和边（",paraId:3,tocIndex:2},{value:"edges",paraId:3,tocIndex:2},{value:"）字段，分别用数组表示：",paraId:3,tocIndex:2},{value:"<script>\n  // console.log(G6.Global.version);\n  const initData = {\n    // 点集\n    nodes: [\n      {\n        id: 'node1', // 节点的唯一标识\n        x: 100, // 节点横坐标\n        y: 200, // 节点纵坐标\n        label: '起始点', // 节点文本\n      },\n      {\n        id: 'node2',\n        x: 300,\n        y: 200,\n        label: '目标点',\n      },\n    ],\n    // 边集\n    edges: [\n      // 表示一条从 node1 节点连接到 node2 节点的边\n      {\n        source: 'node1', // 起始点 id\n        target: 'node2', // 目标点 id\n        label: '我是连线', // 边的文本\n      },\n    ],\n  };\n<\/script>\n",paraId:4,tocIndex:2},{value:"⚠️ 注意:",paraId:5,tocIndex:2},{value:"nodes",paraId:6,tocIndex:2},{value:" 数组中包含节点对象，唯一的 ",paraId:6,tocIndex:2},{value:"id",paraId:6,tocIndex:2},{value:" 是每个节点对象中必要的属性，",paraId:6,tocIndex:2},{value:"x",paraId:6,tocIndex:2},{value:"、 ",paraId:6,tocIndex:2},{value:"y",paraId:6,tocIndex:2},{value:" 用于定位；",paraId:6,tocIndex:2},{value:"edges",paraId:6,tocIndex:2},{value:" 数组中包含边对象，",paraId:6,tocIndex:2},{value:"source",paraId:6,tocIndex:2},{value:" 和 ",paraId:6,tocIndex:2},{value:"target",paraId:6,tocIndex:2},{value:" 是每条边的必要属性，分别代表了该边的起始点 ",paraId:6,tocIndex:2},{value:"id",paraId:6,tocIndex:2},{value:" 与 目标点 ",paraId:6,tocIndex:2},{value:"id",paraId:6,tocIndex:2},{value:"。",paraId:6,tocIndex:2},{value:"点和边的更多属性参见：",paraId:6,tocIndex:2},{value:"内置的节点",paraId:7,tocIndex:2},{value:"，",paraId:6,tocIndex:2},{value:"内置的边",paraId:8,tocIndex:2},{value:" 教程。",paraId:6,tocIndex:2},{value:"图实例化时，至少需要为图设置容器、宽、高：",paraId:9,tocIndex:3},{value:"<script>\n  // const initData = { ... }\n  const graph = new G6.Graph({\n    container: 'mountNode', // 指定挂载容器\n    width: 800, // 图的宽度\n    height: 500, // 图的高度\n  });\n<\/script>\n",paraId:10,tocIndex:3},{value:"数据的加载和图的渲染是两个步骤，可以分开进行。",paraId:11,tocIndex:4},{value:"<script>\n  // const initData = { ... }\n  //  const graph = ...\n  graph.data(initData); // 加载数据\n  graph.render(); // 渲染\n<\/script>\n",paraId:12,tocIndex:4},{value:"调用 ",paraId:13,tocIndex:5},{value:"graph.render()",paraId:13,tocIndex:5},{value:" 方法之后，G6 引擎会根据加载的数据进行图的绘制。结果如下：",paraId:13,tocIndex:5},{value:"上文中，我们使用了仅含有两个节点和一条边的数据，直接将数据定义放在了代码中。而真实场景的数据通常是远程接口请求加载的。为了方便，我们已经给读者准备好了一份 JSON 数据文件，地址如下：",paraId:14,tocIndex:6},{value:"https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json",paraId:14,tocIndex:6},{value:"修改 index.html，通过 ",paraId:15,tocIndex:7},{value:"fetch",paraId:15,tocIndex:7},{value:" 函数异步加载远程的数据源，并传入 G6 的图实例中：",paraId:15,tocIndex:7},{value:"<script>\n  //  const graph = ...\n  const main = async () => {\n    const response = await fetch(\n      'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json',\n    );\n    const remoteData = await response.json();\n\n    // ...\n    graph.data(remoteData); // 加载远程数据\n    graph.render(); // 渲染\n  };\n  main();\n<\/script>\n",paraId:16,tocIndex:7},{value:"fetch",paraId:17,tocIndex:7},{value:" 函数允许我们发起网络请求，加载数据，而其异步的过程可以通过 async/await 进行更合理的控制。这里我们为了方便起见，将主要逻辑放在了 ",paraId:17,tocIndex:7},{value:"main",paraId:17,tocIndex:7},{value:" 函数里面。如果读者对 ",paraId:17,tocIndex:7},{value:"fetch",paraId:17,tocIndex:7},{value:" 和 ",paraId:17,tocIndex:7},{value:"async",paraId:17,tocIndex:7},{value:"/",paraId:17,tocIndex:7},{value:"await",paraId:17,tocIndex:7},{value:" 的知识有疑问，可以参考：",paraId:17,tocIndex:7},{value:"async function",paraId:17,tocIndex:7},{value:"，",paraId:17,tocIndex:7},{value:"Fetch API",paraId:17,tocIndex:7},{value:"运行后，我们得到了下图结果：",paraId:18,tocIndex:7},{value:"乍看之下，图像有点奇怪，实际上数据已经正确的加载了进来。由于数据量比较大，节点和边都非常的多，显得内容比较杂乱。另外由于画布大小的限制，实际的图被画布截断了，目前只能看见部分内容，这个问题后文会继续解决。",paraId:19,tocIndex:7},{value:"请看下面摘取自 tutorial-data.json 的部分数据，我们发现数据中节点定义了位置信息 ",paraId:20,tocIndex:7},{value:"x",paraId:20,tocIndex:7},{value:" 与 ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:"，并且很多节点的  ",paraId:20,tocIndex:7},{value:"x",paraId:20,tocIndex:7},{value:" 和 ",paraId:20,tocIndex:7},{value:"y",paraId:20,tocIndex:7},{value:" 不在图的宽高（",paraId:20,tocIndex:7},{value:"width: 800, height: 600",paraId:20,tocIndex:7},{value:"）范围内：",paraId:20,tocIndex:7},{value:'{\n  "nodes": [\n    { "id": "0", "label": "n0", "class": "c0", "x": 1000, "y": -100 },\n    { "id": "1", "label": "n1", "class": "c0", "x": 300, "y": -10 }\n    //...\n  ],\n  "edges": [\n    //...\n  ]\n}\n',paraId:21,tocIndex:7},{value:"由于 G6 在读取数据时，发现了数据中带有位置信息（",paraId:22,tocIndex:7},{value:"x",paraId:22,tocIndex:7},{value:" 和 ",paraId:22,tocIndex:7},{value:"y",paraId:22,tocIndex:7},{value:"），就会按照该位置信息进行绘制，这是为了满足按照原始数据绘制的需求设计的。但为优化超出屏幕到问题，G6 提供了图的两个相关配置项：",paraId:22,tocIndex:7},{value:"fitView",paraId:23,tocIndex:7},{value:"：设置是否将图适配到画布中；",paraId:23,tocIndex:7},{value:"fitViewPadding",paraId:23,tocIndex:7},{value:"：画布上四周的留白宽度。",paraId:23,tocIndex:7},{value:"我们将实例化图的代码更改为如下形式：",paraId:24,tocIndex:7},{value:"const graph = new G6.Graph({\n  // ...\n  fitView: true,\n  fitViewPadding: [20, 40, 50, 20],\n});\n",paraId:25,tocIndex:7},{value:"上述代码将会生成如下图： ",paraId:26,tocIndex:7},{value:"可以看到，图像已经可以自动适配画布的大小，完整的显示了出来。",paraId:27,tocIndex:7},{value:"本文使用到的配置以及后续 Tutorial 将会使用到到常用配置如下：",paraId:28,tocIndex:8},{value:"配置项",paraId:29,tocIndex:8},{value:"类型",paraId:29,tocIndex:8},{value:"选项 / 示例",paraId:29,tocIndex:8},{value:"默认",paraId:29,tocIndex:8},{value:"说明",paraId:29,tocIndex:8},{value:"fitView",paraId:29,tocIndex:8},{value:"Boolean",paraId:29,tocIndex:8},{value:"true / false",paraId:29,tocIndex:8},{value:"false",paraId:29,tocIndex:8},{value:"是否将图适配到画布大小，可以防止超出画布或留白太多。",paraId:29,tocIndex:8},{value:"fitViewPadding",paraId:29,tocIndex:8},{value:"Number / Array",paraId:29,tocIndex:8},{value:"20 / [ 20, 40, 50, 20 ]",paraId:29,tocIndex:8},{value:"0",paraId:29,tocIndex:8},{value:"画布上的四周留白宽度。",paraId:29,tocIndex:8},{value:"animate",paraId:29,tocIndex:8},{value:"Boolean",paraId:29,tocIndex:8},{value:"true / false",paraId:29,tocIndex:8},{value:"false",paraId:29,tocIndex:8},{value:"是否启用图的动画。",paraId:29,tocIndex:8},{value:"modes",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"{",paraId:29,tocIndex:8},{value:"  default: [ 'drag-node', 'drag-canvas' ]",paraId:29,tocIndex:8},{value:"}",paraId:29,tocIndex:8},{value:"null",paraId:29,tocIndex:8},{value:"图上行为模式的集合。由于比较复杂，按需参见：",paraId:29,tocIndex:8},{value:"G6 中的 Mode",paraId:30,tocIndex:8},{value:" 教程。",paraId:29,tocIndex:8},{value:"defaultNode",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"{",paraId:29,tocIndex:8},{value:"  type: 'circle',",paraId:29,tocIndex:8},{value:"  color: '#000',",paraId:29,tocIndex:8},{value:"  style: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  }",paraId:29,tocIndex:8},{value:"}",paraId:29,tocIndex:8},{value:"null",paraId:29,tocIndex:8},{value:"节点默认的属性，包括节点的一般属性和样式属性（style）。",paraId:29,tocIndex:8},{value:"defaultEdge",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"{",paraId:29,tocIndex:8},{value:"  type: 'polyline',",paraId:29,tocIndex:8},{value:"  color: '#000',",paraId:29,tocIndex:8},{value:"  style: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  }",paraId:29,tocIndex:8},{value:"}",paraId:29,tocIndex:8},{value:"null",paraId:29,tocIndex:8},{value:"边默认的属性，包括边的一般属性和样式属性（style）。",paraId:29,tocIndex:8},{value:"nodeStateStyles",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"{",paraId:29,tocIndex:8},{value:"  hover: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  },",paraId:29,tocIndex:8},{value:"  select: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  }",paraId:29,tocIndex:8},{value:"}",paraId:29,tocIndex:8},{value:"null",paraId:29,tocIndex:8},{value:"节点在除默认状态外，其他状态下的样式属性（style）。例如鼠标放置（hover）、选中（select）等状态。",paraId:29,tocIndex:8},{value:"edgeStateStyles",paraId:29,tocIndex:8},{value:"Object",paraId:29,tocIndex:8},{value:"{",paraId:29,tocIndex:8},{value:"  hover: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  },",paraId:29,tocIndex:8},{value:"  select: {",paraId:29,tocIndex:8},{value:"    ......",paraId:29,tocIndex:8},{value:"  }",paraId:29,tocIndex:8},{value:"}",paraId:29,tocIndex:8},{value:"null",paraId:29,tocIndex:8},{value:"边在除默认状态外，其他状态下的样式属性（style）。例如鼠标放置（hover）、选中（select）等状态。",paraId:29,tocIndex:8},{value:"至此，完整代码如下：",paraId:31,tocIndex:9},{value:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    <div id="mountNode"></div>\n    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js"><\/script>\n    \x3c!-- 4.x and later versions --\x3e\n    \x3c!-- <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script> --\x3e\n    <script>\n      const graph = new G6.Graph({\n        container: \'mountNode\',\n        width: 1000,\n        height: 600,\n        fitView: true,\n        fitViewPadding: [20, 40, 50, 20],\n      });\n\n      const main = async () => {\n        const response = await fetch(\n          \'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json\',\n        );\n        const remoteData = await response.json();\n        graph.data(remoteData);\n        graph.render();\n      };\n      main();\n    <\/script>\n  </body>\n</html>\n',paraId:32,tocIndex:9},{value:"⚠️ 注意:",paraId:33,tocIndex:9},{value:"若需更换数据，请替换  ",paraId:33,tocIndex:9},{value:"'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json'",paraId:33,tocIndex:9},{value:"  为新的数据文件地址。",paraId:33,tocIndex:9}]},65162:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"当数据中没有节点位置信息，或者数据中的位置信息不满足需求时，需要借助一些布局算法对图进行布局。G6 提供了 9 种一般图的布局和 4 种树图的布局：",paraId:0},{value:"一般图：",paraId:0},{value:"Random Layout：随机布局；",paraId:1},{value:"Force Layout：经典力导向布局：",paraId:2},{value:"力导向布局：一个布局网络中，粒子与粒子之间具有引力和斥力，从初始的随机无序的布局不断演变，逐渐趋于平衡稳定的布局方式称之为力导向布局。适用于描述事物间关系，比如人物关系、计算机网络关系等。",paraId:3},{value:"Circular Layout：环形布局；",paraId:4},{value:"Radial Layout：辐射状布局；",paraId:5},{value:"MDS Layout：高维数据降维算法布局；",paraId:6},{value:"Fruchterman Layout：Fruchterman 布局，一种力导布局；",paraId:7},{value:"Dagre Layout：层次布局；",paraId:8},{value:"Concentric Layout：同心圆布局，将重要（默认以度数为度量）的节点放置在布局中心；",paraId:9},{value:"Grid Layout：格子布局，将节点有序（默认是数据顺序）排列在格子上。",paraId:10},{value:"树图布局：",paraId:11},{value:"Dendrogram Layout：树状布局（叶子节点布局对齐到同一层）；",paraId:12},{value:"CompactBox Layout：紧凑树布局；",paraId:12},{value:"Mindmap Layout：脑图布局；",paraId:12},{value:"Indented Layout：缩进布局。",paraId:12},{value:"各种布局方法的具体介绍及其配置参见 ",paraId:13},{value:"图布局 API",paraId:14},{value:" 或 ",paraId:13},{value:"树图布局 API",paraId:15},{value:"。本教程中，我们使用的是力导向布局 (Force Layout)。",paraId:13},{value:"我们在之前的教程里面，为了能够将超出画布的图适配到视野中，在实例化图时使用了 ",paraId:16,tocIndex:0},{value:"fitView",paraId:16,tocIndex:0},{value:"  配置项。这节开始我们将会去掉这个特性。因为复杂的布局系统会打破适配的规则，反而会造成更多的困扰。让我们将相关的适配代码变为注释：",paraId:16,tocIndex:0},{value:"const graph = new G6.Graph({\n  // ...\n  // fitView: true,\n  // fitViewPadding: [ 20, 40, 50, 20 ]\n});\n",paraId:17,tocIndex:0},{value:"当实例化图时没有配置布局时：",paraId:18,tocIndex:1},{value:"若数据中节点有位置信息（",paraId:19,tocIndex:1},{value:"x",paraId:19,tocIndex:1},{value:" 和 ",paraId:19,tocIndex:1},{value:"y",paraId:19,tocIndex:1},{value:"），则按照数据的位置信息进行绘制；",paraId:19,tocIndex:1},{value:"若数据中节点没有位置信息，则默认使用 Random Layout 进行布局。",paraId:19,tocIndex:1},{value:"G6 使用布局的方式非常简单，在图实例化的时候，加上 layout 配置即可。下面代码在实例化图时设置了布局方法为 ",paraId:20,tocIndex:2},{value:"type: 'force'",paraId:20,tocIndex:2},{value:"，即经典力导向图布局。并设置了参数 ",paraId:20,tocIndex:2},{value:"preventOverlap: true",paraId:20,tocIndex:2},{value:" ，表示希望节点不重叠。力导向布局的更多配置项参见：",paraId:20,tocIndex:2},{value:"Layout API",paraId:21,tocIndex:2},{value:"。",paraId:20,tocIndex:2},{value:"const graph = new G6.Graph({\n  // ...                      // 其他配置项\n  layout: {\n    // Object，可选，布局的方法及其配置项，默认为 random 布局。\n    type: 'force', // 指定为力导向布局\n    preventOverlap: true, // 防止节点重叠\n    // nodeSize: 30        // 节点大小，用于算法中防止节点重叠时的碰撞检测。由于已经在上一节的元素配置中设置了每个节点的 size 属性，则不需要在此设置 nodeSize。\n  },\n});\n",paraId:22,tocIndex:2},{value:"结果如下：",paraId:23,tocIndex:2},{value:"如图所示，节点按照力导向布局自动平衡。但是图中的节点过于拥挤，边上的文字信息被挤占，无法看清。我们希望布局计算边的距离可以更长一些。G6 的力导向布局提供了  ",paraId:24,tocIndex:2},{value:"linkDistance",paraId:24,tocIndex:2},{value:" 属性用来指定布局的时候边的距离长度：",paraId:24,tocIndex:2},{value:"const graph = new G6.Graph({\n  // ...\n  layout: {\n    type: 'force',\n    preventOverlap: true,\n    linkDistance: 100, // 指定边距离为100\n  },\n});\n",paraId:25,tocIndex:2},{value:"结果如下：",paraId:26,tocIndex:2},{value:"不同布局之间、相同布局不同参数允许动态切换和过渡，具体参见：",paraId:27,tocIndex:2},{value:"布局切换",paraId:28,tocIndex:2},{value:"。",paraId:27,tocIndex:2},{value:"提示：布局将在调用  ",paraId:29,tocIndex:2},{value:"graph.render()",paraId:29,tocIndex:2},{value:" 时执行计算。",paraId:29,tocIndex:2},{value:"至此，完整代码如下：",paraId:30,tocIndex:3},{value:"<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    <div id=\"mountNode\"></div>\n    <script src=\"https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js\"><\/script>\n    \x3c!-- 4.x and later versions --\x3e\n    \x3c!-- <script src=\"https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js\"><\/script> --\x3e\n    <script>\n      const graph = new G6.Graph({\n        container: 'mountNode',\n        width: 800,\n        height: 600,\n        defaultNode: {\n          size: 30,\n          labelCfg: {\n            style: {\n              fill: '#fff',\n            },\n          },\n        },\n        defaultEdge: {\n          labelCfg: {\n            autoRotate: true,\n          },\n        },\n        layout: {\n          type: 'force', // 设置布局算法为 force\n          linkDistance: 100, // 设置边长为 100\n          preventOverlap: true, // 设置防止重叠\n        },\n      });\n      const main = async () => {\n        const response = await fetch(\n          'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json',\n        );\n        const remoteData = await response.json();\n\n        const nodes = remoteData.nodes;\n        const edges = remoteData.edges;\n        nodes.forEach((node) => {\n          if (!node.style) {\n            node.style = {};\n          }\n          node.style.lineWidth = 1;\n          node.style.stroke = '#666';\n          node.style.fill = 'steelblue';\n          switch (node.class) {\n            case 'c0': {\n              node.type = 'circle';\n              break;\n            }\n            case 'c1': {\n              node.type = 'rect';\n              node.size = [35, 20];\n              break;\n            }\n            case 'c2': {\n              node.type = 'ellipse';\n              node.size = [35, 20];\n              break;\n            }\n          }\n        });\n        edges.forEach((edge) => {\n          if (!edge.style) {\n            edge.style = {};\n          }\n          edge.style.lineWidth = edge.weight;\n          edge.style.opacity = 0.6;\n          edge.style.stroke = 'grey';\n        });\n\n        graph.data(remoteData);\n        graph.render();\n      };\n      main();\n    <\/script>\n  </body>\n</html>\n",paraId:31,tocIndex:3},{value:"⚠️ 注意:",paraId:32,tocIndex:3},{value:" 若需更换数据，请替换  ",paraId:32,tocIndex:3},{value:"'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json'",paraId:32,tocIndex:3},{value:"  为新的数据文件地址。",paraId:32,tocIndex:3}]},54954:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"为辅助用户在图上探索，G6 提供了一些辅助工具，其中一部分是插件工具，另一部分是交互工具。",paraId:0},{value:"本文将为 ",paraId:1},{value:"Tutorial 案例",paraId:1},{value:" 添加缩略图插件、网格插件、节点提示框、边提示框。",paraId:1},{value:"使用插件时，有三个步骤：",paraId:2,tocIndex:0},{value:"  Step 1: 引入插件；",paraId:2,tocIndex:0},{value:"  Step 2: 实例化插件；",paraId:2,tocIndex:0},{value:"  Step 3: 在实例化图时将插件的实例配置到图上。",paraId:2,tocIndex:0},{value:"缩略图 (Minimap) 是一种常见的用于快速预览和探索图的工具，可作为导航辅助用户探索大规模图。",paraId:3,tocIndex:1},{value:"现在，我们为 ",paraId:4,tocIndex:1},{value:"Tutorial 案例",paraId:4,tocIndex:1},{value:" 配置一个 Minimap：",paraId:4,tocIndex:1},{value:"预期效果",paraId:5,tocIndex:1},{value:"使用方法",paraId:6,tocIndex:1},{value:"Minimap 是 G6 的插件之一，引入 G6 后可以直接使用。实例化 Minimap 对象，并将其配置到图实例的插件列表里即可：",paraId:7,tocIndex:1},{value:"// 实例化 minimap 插件\nconst minimap = new G6.Minimap({\n  size: [100, 100],\n  className: 'minimap',\n  type: 'delegate',\n});\n\n// 实例化图\nconst graph = new G6.Graph({\n  // ...                           // 其他配置项\n  plugins: [minimap], // 将 minimap 实例配置到图上\n});\n",paraId:8,tocIndex:1},{value:"由于 ",paraId:9,tocIndex:2},{value:"Minimap",paraId:10,tocIndex:2},{value:" 的原理是将主画布内容复制到 minimap 的画布上，在大数据量下可能会造成双倍的绘制效率成本。为缓解该问题，Image Minimap 采用另一种机制，根据提供的图片地址或 base64 字符串 ",paraId:9,tocIndex:2},{value:"graphImg",paraId:9,tocIndex:2},{value:" 绘制 ",paraId:9,tocIndex:2},{value:"<img />",paraId:9,tocIndex:2},{value:" 代替 minimap 上的 canvas。该方法可以大大减轻两倍 canvas 绘制的压力。但 ",paraId:9,tocIndex:2},{value:"graphImg",paraId:9,tocIndex:2},{value:" 完全交由 G6 的用户控制，需要注意主画布更新时需要使用 ",paraId:9,tocIndex:2},{value:"updateGraphImg",paraId:9,tocIndex:2},{value:" 方法替换 ",paraId:9,tocIndex:2},{value:"graphImg",paraId:9,tocIndex:2},{value:"。",paraId:9,tocIndex:2},{value:"预期效果",paraId:11,tocIndex:2},{value:"使用方法",paraId:12,tocIndex:2},{value:"实例化 Image Minimap 插件时，",paraId:13,tocIndex:2},{value:"graphImg",paraId:13,tocIndex:2},{value:" 是必要参数。建议在主画布更新时使用 ",paraId:13,tocIndex:2},{value:"updateGraphImg(img)",paraId:13,tocIndex:2},{value:" 同步更新 minimap 图片，其中参数 ",paraId:13,tocIndex:2},{value:"img",paraId:13,tocIndex:2},{value:" 是图片地址或 base64 文本。",paraId:13,tocIndex:2},{value:"// 实例化 Image Minimap 插件\nconst imageMinimap = new G6.ImageMinimap({\n  width: 200,\n  graphImg: 'https://gw.alipayobjects.com/mdn/rms_f8c6a0/afts/img/A*eD7nT6tmYgAAAAAAAAAAAABkARQnAQ'\n});\nconst graph = new G6.Graph({\n  //... 其他配置项\n  plugins: [imageMinimap], // 配置 imageMinimap 插件\n});\n\ngraph.data(data);\ngraph.render()\n\n... // 一些主画布更新操作\nimageMinimap.updateGraphImg(img); // 使用新的图片（用户自己生成）替换 minimap 图片\n\n",paraId:14,tocIndex:2},{value:"网格可用于辅助用户在拖拽节点时对齐到网格。",paraId:15,tocIndex:3},{value:"预期效果",paraId:16,tocIndex:3},{value:"使用方法",paraId:17,tocIndex:3},{value:" 实例化插件和配置插件到图上：",paraId:17,tocIndex:3},{value:"// const minimap = ...\n\n// 实例化 grid 插件\nconst grid = new G6.Grid();\n\n// 实例化图\nconst graph = new G6.Graph({\n  // ...                        // 其他配置项\n  plugins: [minimap, grid], // 将 grid 实例配置到图上\n});\n",paraId:18,tocIndex:3},{value:"交互工具是指配置到图上交互模式中的工具。使用交互工具时，有两个步骤：",paraId:19,tocIndex:4},{value:"  Step 1: 在实例化图时配置 ",paraId:19,tocIndex:4},{value:"modes",paraId:19,tocIndex:4},{value:"；",paraId:19,tocIndex:4},{value:"  Step 2: 为交互工具定义样式。",paraId:19,tocIndex:4},{value:"节点提示框可以用在节点的详细信息的展示。当鼠标滑过节点时，显示一个浮层告知节点的详细信息。更多配置参见 ",paraId:20,tocIndex:5},{value:"内置交互 tooltip",paraId:21,tocIndex:5},{value:"。",paraId:20,tocIndex:5},{value:"预期效果",paraId:22,tocIndex:5},{value:"使用方法",paraId:23,tocIndex:5},{value:"实例化图时配置 ",paraId:24,tocIndex:5},{value:"'tooltip'",paraId:24,tocIndex:5},{value:" 到 ",paraId:24,tocIndex:5},{value:"modes",paraId:24,tocIndex:5},{value:" 中：",paraId:24,tocIndex:5},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      // ...\n      {\n        type: 'tooltip', // 提示框\n        formatText(model) {\n          // 提示框文本内容\n          const text = 'label: ' + model.label + '<br/> class: ' + model.class;\n          return text;\n        },\n      },\n    ],\n  },\n});\n",paraId:25,tocIndex:5},{value:"由于 tooltip 实际上是一个悬浮的 ",paraId:26,tocIndex:5},{value:"<div>",paraId:26,tocIndex:5},{value:" 标签，因此可在 HTML 的 ",paraId:26,tocIndex:5},{value:"<style>",paraId:26,tocIndex:5},{value:" 标签或 CSS 中设置样式。下面展示在 HTML 中设置样式：",paraId:26,tocIndex:5},{value:'<head>\n  <meta charset="UTF-8" />\n  <title>Tutorial Demo</title>\n\n  <style>\n    /* 提示框的样式 */\n    .g6-tooltip {\n      border: 1px solid #e2e2e2;\n      border-radius: 4px;\n      font-size: 12px;\n      color: #545454;\n      background-color: rgba(255, 255, 255, 0.9);\n      padding: 10px 8px;\n      box-shadow: rgb(174, 174, 174) 0px 0px 10px;\n    }\n  </style>\n</head>\n',paraId:27,tocIndex:5},{value:"边提示框可以用在边的详细信息的展示。当鼠标滑过边时，显示一个浮层告知边的详细信息。更多配置参见 ",paraId:28,tocIndex:6},{value:"内置交互 edge-tooltip",paraId:29,tocIndex:6},{value:"。",paraId:28,tocIndex:6},{value:"预期效果",paraId:30,tocIndex:6},{value:"使用方法",paraId:31,tocIndex:6},{value:"const graph = new G6.Graph({\n  modes: {\n    default: [\n      // ...\n      {\n        type: 'tooltip', // 节点提示框\n        // ...\n      },\n      {\n        type: 'edge-tooltip', // 边提示框\n        formatText(model) {\n          // 边提示框文本内容\n          const text =\n            'source: ' +\n            model.source +\n            '<br/> target: ' +\n            model.target +\n            '<br/> weight: ' +\n            model.weight;\n          return text;\n        },\n      },\n    ],\n  },\n});\n",paraId:32,tocIndex:6},{value:"与 tooltip 相同，edge-tooltip 是一个悬浮的 ",paraId:33,tocIndex:6},{value:"<div>",paraId:33,tocIndex:6},{value:" 标签，可以使用与 tooltip 相同的方法设置其悬浮框的样式。",paraId:33,tocIndex:6},{value:"至此，",paraId:34,tocIndex:7},{value:"Tutorial 案例",paraId:34,tocIndex:7},{value:" 完成，完整代码见：",paraId:34,tocIndex:7},{value:"Tutorial 案例代码",paraId:34,tocIndex:7},{value:"。",paraId:34,tocIndex:7},{value:"⚠️ 注意:",paraId:35,tocIndex:7},{value:" 若需更换数据，请替换  ",paraId:35,tocIndex:7},{value:"'https://gw.alipayobjects.com/os/basement_prod/6cae02ab-4c29-44b2-b1fd-4005688febcb.json'",paraId:35,tocIndex:7},{value:"  为新的数据文件地址。",paraId:35,tocIndex:7}]},40755:function(a,e,d){d.r(e),d.d(e,{texts:function(){return n}});const n=[{value:"G6 是一个图可视化引擎。它提供了图的绘制、布局、分析、交互、动画等基础的图可视化能力。旨在让关系变得透明，简单。让用户获得关系数据的 Insight。",paraId:0,tocIndex:0},{value:"我们在本入门教程中将会完成一个如下图所示简单的图可视化，我们将在后文中称其为 ",paraId:1,tocIndex:1},{value:"Tutorial 案例",paraId:1,tocIndex:1},{value:"，",paraId:1,tocIndex:1},{value:"完整代码",paraId:1,tocIndex:1},{value:"。",paraId:1,tocIndex:1},{value:"Tutorial 案例",paraId:2},{value:" 效果图",paraId:2},{value:"我们将会通过本入门教程完成包含图的创建、渲染、元素的配置、布局、交互、动画、工具的最终的  ",paraId:3,tocIndex:2},{value:"Tutorial 案例",paraId:3,tocIndex:2},{value:"。在这部分教学中，读者将会学习到 G6 中基础和核心的功能。掌握该入门教程内容后，可以帮助读者初步理解 G6 并为深度理解 G6 打好基础。",paraId:3,tocIndex:2},{value:"该入门教程将会划分为以下几个章节：",paraId:4,tocIndex:2},{value:"快速上手",paraId:5,tocIndex:2},{value:"创建图",paraId:5,tocIndex:2},{value:"元素及其配置",paraId:5,tocIndex:2},{value:"使用图布局 Layout",paraId:5,tocIndex:2},{value:"图的交互 Behavior",paraId:5,tocIndex:2},{value:"插件 & 工具",paraId:5,tocIndex:2},{value:"*动画（选读）",paraId:5,tocIndex:2},{value:"提示",paraId:6,tocIndex:2},{value:" ",paraId:6,tocIndex:2},{value:"该入门教程是为希望“边学边做”的读者设计的。如果您更希望从底层概念开始学习 G6，您可以参见：",paraId:6,tocIndex:2},{value:"核心概念",paraId:7,tocIndex:2},{value:"。",paraId:6,tocIndex:2},{value:"本教程展示如何使用 G6 创建一个完整的图可视化应用。在学习之前，我们假设读者对 HTML 和 JavaScript 有所了解，但并不要求对 G6 有任何的基础。如果读者对 G6 的基本内容已经熟知，可以适当跳过部分内容，有针对性地阅读重要的知识点。",paraId:8,tocIndex:3},{value:"建议使用新版的 Chrome 浏览器作为运行环境，用任意的代码编辑器进行代码的编写即可。本教程默认采用 CDN 的方式直接引入 G6 类库，引入的版本是 3.7.1，此版本很多特性会大大简化我们的代码。如果希望在其他环境尝试本教程的学习，读者可以参考 ",paraId:9,tocIndex:4},{value:"快速上手",paraId:10,tocIndex:4},{value:" 中的安装配置部分。",paraId:9,tocIndex:4},{value:"新建 index.html 文件，并添加如下代码：",paraId:11,tocIndex:4},{value:'<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>Tutorial Demo</title>\n  </head>\n  <body>\n    \x3c!-- 引入 G6 --\x3e\n    <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.7.1/dist/g6.min.js"><\/script>\n    \x3c!-- 4.x and later versions --\x3e\n    \x3c!-- <script src="https://gw.alipayobjects.com/os/lib/antv/g6/4.3.11/dist/g6.min.js"><\/script> --\x3e\n\n    <script>\n      console.log(G6.Global.version);\n    <\/script>\n  </body>\n</html>\n',paraId:12,tocIndex:4},{value:"使用浏览器打开 index.html 文件，打开控制台，可以看到 G6 的版本号，说明 G6 已成功引入。",paraId:13,tocIndex:4}]}}]);