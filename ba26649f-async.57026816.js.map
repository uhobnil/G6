{"version":3,"sources":["docs/manual/custom-extension/layout.zh.md?type=text"],"sourcesContent":["\n  import '/home/runner/work/G6/G6/packages/site/docs/manual/custom-extension/layout.zh.md?watch=parent';\n  export const texts = [{\"value\":\"G6 中布局分为\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"迭代布局\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"和\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"非迭代布局\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"两种，迭代布局是指布局算法会迭代多次直到收敛，非迭代布局是指布局算法只执行一次。\",\"paraId\":0,\"tocIndex\":0},{\"value\":\"实现一个非迭代布局相对简单，只需要实现 \",\"paraId\":1,\"tocIndex\":2},{\"value\":\"BaseLayout\",\"paraId\":1,\"tocIndex\":2},{\"value\":\" 中的 \",\"paraId\":1,\"tocIndex\":2},{\"value\":\"execute\",\"paraId\":1,\"tocIndex\":2},{\"value\":\" 方法即可，下面是一个简单的自定义布局实现：\",\"paraId\":1,\"tocIndex\":2},{\"value\":\"import { BaseLayout } from '@antv/g6';\\nimport type { GraphData } from '@antv/g6';\\n\\nclass DiagonalLayout extends BaseLayout {\\n  id = 'diagonal-layout';\\n\\n  async execute(data: GraphData): Promise<GraphData> {\\n    const { nodes = [] } = data;\\n    return {\\n      nodes: nodes.map((node, index) => ({\\n        id: node.id,\\n        style: {\\n          x: 50 * index + 25,\\n          y: 50 * index + 25,\\n        },\\n      })),\\n    };\\n  }\\n}\\n\",\"paraId\":2,\"tocIndex\":2},{\"value\":\"在上面的代码中，我们实现了一个简单的布局算法，将节点从左上角沿对角线排列。\",\"paraId\":3,\"tocIndex\":2},{\"value\":\"(async () => {\\n  const { Graph, BaseLayout, register, ExtensionCategory } = window.g6;\\n\\n  class DiagonalLayout extends BaseLayout {\\n    id = 'diagonal-layout';\\n\\n    async execute(data) {\\n      const { nodes = [] } = data;\\n      return {\\n        nodes: nodes.map((node, index) => ({\\n          id: node.id,\\n          style: {\\n            x: 50 * index + 25,\\n            y: 50 * index + 25,\\n          },\\n        })),\\n      };\\n    }\\n  }\\n\\n  register(ExtensionCategory.LAYOUT, 'diagonal', DiagonalLayout);\\n\\n  const container = createContainer({ width: 200, height: 200 });\\n\\n  const graph = new Graph({\\n    container,\\n    width: 200,\\n    height: 200,\\n    data: {\\n      nodes: [{ id: 'node-1' }, { id: 'node-2' }, { id: 'node-3' }, { id: 'node-4' }],\\n    },\\n    layout: {\\n      type: 'diagonal',\\n    },\\n  });\\n\\n  await graph.render();\\n\\n  return container;\\n})();\\n\",\"paraId\":4,\"tocIndex\":2},{\"value\":\"execute\",\"paraId\":5},{\"value\":\" 方法返回的是一个 GraphData 对象，里面仅需要包含元素的基本信息（如 id、source、target）以及布局新增的属性（如 x、y、边的控制点等），不需要包含其他无用的信息。\\n如果仅需要对节点进行布局，可以只返回节点信息，不需要返回边的信息。\",\"paraId\":5},{\"value\":\"迭代布局的实现同样需要继承 \",\"paraId\":6,\"tocIndex\":3},{\"value\":\"BaseLayout\",\"paraId\":6,\"tocIndex\":3},{\"value\":\"，但是除 \",\"paraId\":6,\"tocIndex\":3},{\"value\":\"execute\",\"paraId\":6,\"tocIndex\":3},{\"value\":\" 外还需要实现 \",\"paraId\":6,\"tocIndex\":3},{\"value\":\"tick\",\"paraId\":6,\"tocIndex\":3},{\"value\":\" 和 \",\"paraId\":6,\"tocIndex\":3},{\"value\":\"stop\",\"paraId\":6,\"tocIndex\":3},{\"value\":\" 方法，\",\"paraId\":6,\"tocIndex\":3},{\"value\":\"tick\",\"paraId\":6,\"tocIndex\":3},{\"value\":\" 方法用于将布局迭代到指定轮次，\",\"paraId\":6,\"tocIndex\":3},{\"value\":\"stop\",\"paraId\":6,\"tocIndex\":3},{\"value\":\" 方法用于停止布局迭代。\",\"paraId\":6,\"tocIndex\":3},{\"value\":\"此外，迭代布局中需要在每次迭代调用 \",\"paraId\":7,\"tocIndex\":3},{\"value\":\"options.onTick\",\"paraId\":7,\"tocIndex\":3},{\"value\":\" 以触发图的更新。\",\"paraId\":7,\"tocIndex\":3},{\"value\":\"type onTick = (data: GraphData) => void;\\n\",\"paraId\":8,\"tocIndex\":3},{\"value\":\"下面是一个简单的迭代布局实现：\",\"paraId\":9,\"tocIndex\":3},{\"value\":\"import { BaseLayout } from '@antv/g6';\\nimport type { GraphData, BaseLayoutOptions } from '@antv/g6';\\n\\ninterface TickTockLayoutOptions extends BaseLayoutOptions {\\n  onTick: (data: GraphData) => void;\\n}\\n\\nclass TickTockLayout extends BaseLayout<TickTockLayoutOptions> {\\n  public id = 'custom-layout';\\n\\n  private tickCount = 0;\\n\\n  private data?: GraphData;\\n\\n  private timer?: number;\\n\\n  private resolve?: () => void;\\n\\n  private promise?: Promise<void>;\\n\\n  async execute(data: GraphData, options: TickTockLayoutOptions): Promise<GraphData> {\\n    const { onTick } = { ...this.options, ...options };\\n\\n    this.tickCount = 0;\\n    this.data = data;\\n\\n    this.promise = new Promise((resolve) => {\\n      this.resolve = resolve;\\n    });\\n\\n    this.timer = window.setInterval(() => {\\n      onTick(this.simulateTick());\\n      if (this.tickCount === 10) this.stop();\\n    }, 200);\\n\\n    await this.promise;\\n\\n    return this.simulateTick();\\n  }\\n\\n  simulateTick = () => {\\n    const x = this.tickCount++ % 2 === 0 ? 50 : 150;\\n\\n    return {\\n      nodes: (this?.data?.nodes || []).map((node, index) => ({\\n        id: node.id,\\n        style: { x, y: (index + 1) * 30 },\\n      })),\\n    };\\n  };\\n\\n  tick = () => {\\n    return this.simulateTick();\\n  };\\n\\n  stop = () => {\\n    clearInterval(this.timer);\\n    this.resolve?.();\\n  };\\n}\\n\",\"paraId\":10,\"tocIndex\":3},{\"value\":\"在这个例子中，我们实现了一个简单的迭代布局算法，每 200ms 将节点的 x 坐标在 50 和 150 之间切换，并按照节点顺序在 y 方向上排列。\",\"paraId\":11,\"tocIndex\":3},{\"value\":\"(async () => {\\n  const { Graph, BaseLayout, register, ExtensionCategory } = window.g6;\\n  class TickTockLayout extends BaseLayout {\\n    id = 'tick-tock-layout';\\n\\n    async execute(data, options) {\\n      const { onTick } = { ...this.options, ...options };\\n\\n      this.tickCount = 0;\\n      this.data = data;\\n\\n      this.promise = new Promise((resolve) => {\\n        this.resolve = resolve;\\n      });\\n\\n      this.timer = window.setInterval(() => {\\n        onTick(this.simulateTick());\\n        if (this.tickCount === 10) this.stop();\\n      }, 200);\\n\\n      await this.promise;\\n\\n      return this.simulateTick();\\n    }\\n\\n    simulateTick = () => {\\n      const x = this.tickCount++ % 2 === 0 ? 50 : 150;\\n\\n      return {\\n        nodes: (this?.data?.nodes || []).map((node, index) => ({\\n          id: node.id,\\n          style: { x, y: (index + 1) * 30 },\\n        })),\\n      };\\n    };\\n\\n    tick = () => {\\n      return this.simulateTick();\\n    };\\n\\n    stop = () => {\\n      clearInterval(this.timer);\\n      this.resolve?.();\\n    };\\n  }\\n\\n  register(ExtensionCategory.LAYOUT, 'tick-tock', TickTockLayout);\\n\\n  const container = createContainer({ width: 200, height: 200 });\\n\\n  const graph = new Graph({\\n    container,\\n    width: 200,\\n    height: 200,\\n    animation: true,\\n    data: {\\n      nodes: [{ id: 'node-1' }, { id: 'node-2' }, { id: 'node-3' }, { id: 'node-4' }, { id: 'node-5' }],\\n    },\\n    layout: {\\n      type: 'tick-tock',\\n    },\\n  });\\n\\n  graph.render();\\n\\n  return container;\\n})();\\n\",\"paraId\":12,\"tocIndex\":3},{\"value\":\"通过 G6 提供的 register 方法注册即可，详见\",\"paraId\":13,\"tocIndex\":4},{\"value\":\"注册布局\",\"paraId\":14,\"tocIndex\":4},{\"value\":\"可在 \",\"paraId\":15,\"tocIndex\":5},{\"value\":\"options.layout\",\"paraId\":15,\"tocIndex\":5},{\"value\":\" 中配置布局的类型和参数，详见\",\"paraId\":15,\"tocIndex\":5},{\"value\":\"配置布局\",\"paraId\":16,\"tocIndex\":5}];\n  "],"names":[],"mappings":"6PAEe,6CAAA,QADN,YACA,IAAM,EAAQ,CAAC,CAAC,MAAQ,oCAAW,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,2BAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,SAAI,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,iCAAQ,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,mPAA2C,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,sHAAuB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,aAAa,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,iBAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,UAAU,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,kIAAyB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,mcAAmc,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,iOAAwC,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,g4BAAg4B,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,UAAU,OAAS,CAAC,EAAE,CAAC,MAAQ,ymBAAoI,OAAS,CAAC,EAAE,CAAC,MAAQ,kFAAiB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,aAAa,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,4BAAQ,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,UAAU,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,yCAAW,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,OAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,WAAM,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,OAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,sBAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,OAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,8FAAmB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,OAAO,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,sEAAe,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,0GAAqB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,iBAAiB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,oDAAY,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,6CAA6C,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,6FAAkB,OAAS,EAAE,SAAW,CAAC,EAAE,CAAC,MAAQ,q1CAAq1C,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,iVAA6E,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,0gDAA0gD,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,qGAA+B,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,2BAAO,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,gBAAM,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,iBAAiB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,wFAAkB,OAAS,GAAG,SAAW,CAAC,EAAE,CAAC,MAAQ,2BAAO,OAAS,GAAG,SAAW,CAAC,EAAE"}