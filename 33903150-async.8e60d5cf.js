(("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@antv/g6-site"]=("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@antv/g6-site"]||[]).push([["33903150"],{33903150:function(e,a,d){"use strict";d.d(a,"__esModule",{value:!0}),d.d(a,"texts",{enumerable:!0,get:function(){return t;}}),d("830ee13c");let t=[{value:"PointTuple",paraId:0,tocIndex:1},{value:"Center position of circular layout, defaults to the center position of the current container",paraId:1,tocIndex:1},{value:"boolean",paraId:2,tocIndex:2},{value:" ",paraId:2,tocIndex:2},{value:"Default:",paraId:2,tocIndex:2},{value:" ",paraId:2,tocIndex:2},{value:"false",paraId:2,tocIndex:2},{value:"Whether to arrange in clockwise order",paraId:3,tocIndex:2},{value:"boolean",paraId:4,tocIndex:3},{value:" ",paraId:4,tocIndex:3},{value:"Default:",paraId:4,tocIndex:3},{value:" ",paraId:4,tocIndex:3},{value:"false",paraId:4,tocIndex:3},{value:"Whether the distance between rings is equal",paraId:5,tocIndex:3},{value:"number",paraId:6,tocIndex:4},{value:"The height of the layout, defaults to the container height",paraId:7,tocIndex:4},{value:"number",paraId:8,tocIndex:5},{value:" ",paraId:8,tocIndex:5},{value:"Default:",paraId:8,tocIndex:5},{value:" ",paraId:8,tocIndex:5},{value:"undefined",paraId:8,tocIndex:5},{value:"The sum of the concentric values of each layer",paraId:9,tocIndex:5},{value:" If undefined, it will be set to maxValue / 4, where maxValue is the largest value of the sortBy attribute. For example, if sortBy is 'degree', maxValue is the degree of the node with the largest degree in all nodes",paraId:10,tocIndex:5},{value:"number |",paraId:11,tocIndex:6},{value:" ",paraId:11,tocIndex:6},{value:"PointTuple",paraId:11,tocIndex:6},{value:" ",paraId:11,tocIndex:6},{value:"| ((nodeData:",paraId:11,tocIndex:6},{value:" ",paraId:11,tocIndex:6},{value:"Node",paraId:11,tocIndex:6},{value:") => number)",paraId:11,tocIndex:6},{value:"Node size (diameter). Used for collision detection when preventing node overlap",paraId:12,tocIndex:6},{value:"number | number[] | ((node?:",paraId:13,tocIndex:7},{value:" ",paraId:13,tocIndex:7},{value:"Node",paraId:13,tocIndex:7},{value:") => number)",paraId:13,tocIndex:7},{value:" ",paraId:13,tocIndex:7},{value:"Default:",paraId:13,tocIndex:7},{value:" ",paraId:13,tocIndex:7},{value:"10",paraId:13,tocIndex:7},{value:"Minimum spacing between rings, used to adjust the radius",paraId:14,tocIndex:7},{value:"boolean",paraId:15,tocIndex:8},{value:" ",paraId:15,tocIndex:8},{value:"Default:",paraId:15,tocIndex:8},{value:" ",paraId:15,tocIndex:8},{value:"false",paraId:15,tocIndex:8},{value:"Whether to prevent overlap",paraId:16,tocIndex:8},{value:" Must be used with the following properties, and only when the data.size property is set in the data or the nodeSize value configured with the same size as the current graph node is configured in the layout, can the node overlap collision detection be performed",paraId:17,tocIndex:8},{value:"string",paraId:18,tocIndex:9},{value:" ",paraId:18,tocIndex:9},{value:"Default:",paraId:18,tocIndex:9},{value:" ",paraId:18,tocIndex:9},{value:"undefined",paraId:18,tocIndex:9},{value:"Specify the basis for sorting (node attribute name)",paraId:19,tocIndex:9},{value:" The higher the value, the more the node will be placed in the center. If undefined, the degree of the node will be calculated, and the higher the degree, the more the node will be placed in the center",paraId:20,tocIndex:9},{value:"number",paraId:21,tocIndex:10},{value:" ",paraId:21,tocIndex:10},{value:"Default:",paraId:21,tocIndex:10},{value:" ",paraId:21,tocIndex:10},{value:"3 / 2 * Math.PI",paraId:21,tocIndex:10},{value:"The starting angle of the layout node",paraId:22,tocIndex:10},{value:"number",paraId:23,tocIndex:11},{value:" ",paraId:23,tocIndex:11},{value:"Default:",paraId:23,tocIndex:11},{value:" ",paraId:23,tocIndex:11},{value:"undefined",paraId:23,tocIndex:11},{value:"The difference in radians between the first and last nodes",paraId:24,tocIndex:11},{value:" If undefined, it will be set to 2 * Math.PI * (1 - 1 / |level.nodes|), where level.nodes is the number of nodes in each layer calculated by this algorithm, and |level.nodes| represents the number of nodes in this layer",paraId:25,tocIndex:11},{value:"number",paraId:26,tocIndex:12},{value:"The width of the layout, defaults to the container width",paraId:27,tocIndex:12},{value:"To directly assign the positions to the nodes.",paraId:28,tocIndex:14},{value:"assign(graph: Graph, options?: ConcentricLayoutOptions): Promise<void>;\n",paraId:29,tocIndex:14},{value:"View Parameters",paraId:30},{value:"Parameter",paraId:31,tocIndex:14},{value:"Type",paraId:32,tocIndex:14},{value:"Description",paraId:33,tocIndex:14},{value:"graph",paraId:34,tocIndex:14},{value:"Graph",paraId:35,tocIndex:14},{value:"options",paraId:36,tocIndex:14},{value:"ConcentricLayoutOptions",paraId:37,tocIndex:14},{value:"Returns",paraId:38,tocIndex:14},{value:":",paraId:38,tocIndex:14},{value:"Type:",paraId:39,tocIndex:14},{value:" Promise<void>",paraId:39,tocIndex:14},{value:"Return the positions of nodes and edges(if needed).",paraId:40,tocIndex:15},{value:"execute(graph: Graph, options?: ConcentricLayoutOptions): Promise<LayoutMapping>;\n",paraId:41,tocIndex:15},{value:"View Parameters",paraId:30},{value:"Parameter",paraId:42,tocIndex:15},{value:"Type",paraId:43,tocIndex:15},{value:"Description",paraId:44,tocIndex:15},{value:"graph",paraId:45,tocIndex:15},{value:"Graph",paraId:46,tocIndex:15},{value:"options",paraId:47,tocIndex:15},{value:"ConcentricLayoutOptions",paraId:48,tocIndex:15},{value:"Returns",paraId:49,tocIndex:15},{value:":",paraId:49,tocIndex:15},{value:"Type:",paraId:50,tocIndex:15},{value:" Promise<LayoutMapping>",paraId:50,tocIndex:15}];}}]);
//# sourceMappingURL=33903150-async.8e60d5cf.js.map